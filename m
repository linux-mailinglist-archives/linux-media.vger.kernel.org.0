Return-Path: <linux-media+bounces-36102-lists+linux-media=lfdr.de@vger.kernel.org>
X-Original-To: lists+linux-media@lfdr.de
Delivered-To: lists+linux-media@lfdr.de
Received: from am.mirrors.kernel.org (am.mirrors.kernel.org [IPv6:2604:1380:4601:e00::3])
	by mail.lfdr.de (Postfix) with ESMTPS id 2EDD6AEBA9B
	for <lists+linux-media@lfdr.de>; Fri, 27 Jun 2025 16:59:17 +0200 (CEST)
Received: from smtp.subspace.kernel.org (relay.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-ECDSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by am.mirrors.kernel.org (Postfix) with ESMTPS id D0C3B189299B
	for <lists+linux-media@lfdr.de>; Fri, 27 Jun 2025 14:59:15 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 226242E7F20;
	Fri, 27 Jun 2025 14:58:37 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=gmail.com header.i=@gmail.com header.b="madtMajK"
X-Original-To: linux-media@vger.kernel.org
Received: from mail-pf1-f179.google.com (mail-pf1-f179.google.com [209.85.210.179])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id B044622577E;
	Fri, 27 Jun 2025 14:57:00 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=209.85.210.179
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1751036313; cv=none; b=r0G/pivIF1r90GHzYnYQJWtW8pdz60huUR4x7MICzNjq0+ltEHkfLIV7CqRQSJzDXvq/d5gaLW+3iW1VhilF1WEKSHqcQBVPIaz8Ocrh8cVbUSgM5F4hkyVjhvQKosJ+w+LPXIeAodpadQLcNSBByXj1Vyzrqx+L5KqEIEgTPJk=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1751036313; c=relaxed/simple;
	bh=40GXoQotmpQtKWFkqpg3CvbdaEucs4SX5aR++yO42hw=;
	h=From:Date:Subject:MIME-Version:Content-Type:Message-Id:To:Cc; b=AqLUffoXWD9nTVzWdsODTNxnlKT6HDhGBaT7YjAHfwyUP5c3xFq2sExmnpIqEddRN+w0P4LnF9TraihFfRCCcWimmWmfRPw2//M/ThAMqAaKw/HpeSNVthA935lZSDavjDY9KRD/+1EPcRFnTs2O8ppaiQ7jTruGMOy2h3DIdAY=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=gmail.com; spf=pass smtp.mailfrom=gmail.com; dkim=pass (2048-bit key) header.d=gmail.com header.i=@gmail.com header.b=madtMajK; arc=none smtp.client-ip=209.85.210.179
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=gmail.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=gmail.com
Received: by mail-pf1-f179.google.com with SMTP id d2e1a72fcca58-749068b9b63so1647847b3a.0;
        Fri, 27 Jun 2025 07:57:00 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20230601; t=1751036220; x=1751641020; darn=vger.kernel.org;
        h=cc:to:message-id:content-transfer-encoding:mime-version:subject
         :date:from:from:to:cc:subject:date:message-id:reply-to;
        bh=ZU8OwT91MbnIjzdp8aFqivSXQydMVi0cbLt1gllnbe8=;
        b=madtMajKSg/268F4AXqZUGgbqx7ecUhuvs5BfuZKUHT0RaDCDcHeHskFnyfJL3a46A
         dJprLphTia1tQGSwj85RInHQp9J8tbjBMBa5vLppMM/A1uTvsTOookUX4v8LC3FEQpQI
         S4n9BSbtP0ROE/7Kd6P9PN5cc/Ypjzpkh2ykuvVAVOx/szlBhe5FREn/i8YfMKv8cghB
         tSUvtLNn8P/fuD4nhA6aVBPmp7Htkjg2mcNM1O432iX/JdppMVJezKPs08zk1D2xztiT
         gFW1nV/Dt/2xepClyJcmw4di+PRuxLgwB4vDILT8/nRjnSZli2olKfz62Inq27e0uuRU
         oTeg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20230601; t=1751036220; x=1751641020;
        h=cc:to:message-id:content-transfer-encoding:mime-version:subject
         :date:from:x-gm-message-state:from:to:cc:subject:date:message-id
         :reply-to;
        bh=ZU8OwT91MbnIjzdp8aFqivSXQydMVi0cbLt1gllnbe8=;
        b=T3Gv0sdaZQdn4n4CrJrUmUd0OTPoc04cRk0hn3O0u52CnrnkA6gHvIXZZDIMgzckXz
         A6kcVjMBOyOF2WUpKaP1Vn/YCaM4wbarGlriwd/18pSCYHRBTAmFgm4NNKVqxDBTuBhF
         73bFjaO70Uau/KNKo6RGcp1VJCt/+2cfpk2w8aE8QClVzEjkwkj6Ye5tbl/+V/PfdBra
         zqGqzA6mx+cb01i8puLcK3OPediEtgmy8GdlVMTL+aTO9uxzL+lQPAW+Y1zl8OMEfJYv
         t2153yuZjQqUFH6klBJxR/XwMiok9G8gDqlKdSOz0WmOcFLAQWpsG2DdrT4w1/fxFcDa
         hUxw==
X-Forwarded-Encrypted: i=1; AJvYcCXNeprc8DCBVDiBqFyvPvatjeubHRcORwzBh8sxTs8zhVIXjT91G1apYWIxx8K+MULy0PGzmwIwsSItVO8=@vger.kernel.org
X-Gm-Message-State: AOJu0YyvnU6ER9WAo52l8R4hNVCwuaLQJSjWIjWuYUjfioeYAdGrap/P
	K1CE/zsas9f91L03WY+rMxwb3CQ0SnGsCuSKaMjBjvDQU64MmpF+yHVC
X-Gm-Gg: ASbGncv0lWUHIDpPG976YmzeSXinIz3XlCOm9a5baVB4Eu+LkGh6UGXiSUbSHx4wcML
	IpY3p6QxdiQCAt7eyEEH6KT3vnSdrIE2C0cMBD30XNWHoS8Z5iYr9Gs1XvdXlrTNYGug6z+UBdw
	4n73HE5rGDlVrPszwJGw3jdE5zDVMQHC98fP8/wnyIpNnQHtqEG2WjQaZCL1lQyzzA+O2B+ub6l
	d2e5r6uFYggvRCYgRJe6n4FQUFu9Me6QVpec6EwEqlCvtBQN/6gc4a1JxqPxUog3jDsooglC5xv
	CIx7HHkF3k3k4DWz+nNJkyA+ReNi/AgmnZjHNuvRzqcT5St0w9hTUtPi52kZ14NOS36mdU2mC+u
	sYprHhFzTNI/3uO3yTb69quQ9qnGEeHMSX9aGXYeo3A9waeQNHQ==
X-Google-Smtp-Source: AGHT+IHOIlKZc4BqJMfu3VSeV5KHDeQbBscOioS+PoF9hXyPyPAsrcOzlx1Aalh7k9+YJmdXJQvMaQ==
X-Received: by 2002:a17:903:1c6:b0:234:b41e:37a2 with SMTP id d9443c01a7336-23ac2d86627mr51473925ad.11.1751036217820;
        Fri, 27 Jun 2025 07:56:57 -0700 (PDT)
Received: from DESKTOP-RD0GVCL.localdomain (124-218-195-161.cm.dynamic.apol.com.tw. [124.218.195.161])
        by smtp.gmail.com with ESMTPSA id d9443c01a7336-23acb39c0b8sm19280285ad.138.2025.06.27.07.56.42
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Fri, 27 Jun 2025 07:56:55 -0700 (PDT)
From: LiangCheng Wang <zaq14760@gmail.com>
Date: Fri, 27 Jun 2025 22:56:09 +0800
Subject: [PATCH v6] staging: media: atomisp: apply clang-format and fix
 checkpatch.pl errors
Precedence: bulk
X-Mailing-List: linux-media@vger.kernel.org
List-Id: <linux-media.vger.kernel.org>
List-Subscribe: <mailto:linux-media+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-media+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20250627-bar-v6-1-b22b5ea3ced0@gmail.com>
X-B4-Tracking: v=1; b=H4sIAAixXmgC/23MTWrDMBAF4KsErasw+htJXfUeIQtJHjmCJi5yM
 QnBd48cb1xTZvWG970nG6kWGtnn4ckqTWUsw60F/DiwdAm3nnjpWmYSpAGUgsdQubEquqghRwe
 sNX8q5XJ/r5zOLV/K+DvUx3t0Esv3r58EF9wERRZAa5Tpq7+G8n1Mw5UtfpL/GNmMJkw5WetR6
 L1RWyNXoxaTkheUQSQV9kZvjV6NbsbndoF8duj2xmyNWY1pposeAcFFBLs18zy/AKO7MfBmAQA
 A
X-Change-ID: 20250621-bar-573b8b40fb80
To: Hans de Goede <hansg@kernel.org>, 
 Mauro Carvalho Chehab <mchehab@kernel.org>, 
 Sakari Ailus <sakari.ailus@linux.intel.com>, 
 Andy Shevchenko <andy@kernel.org>, 
 Greg Kroah-Hartman <gregkh@linuxfoundation.org>, 
 Nathan Chancellor <nathan@kernel.org>, 
 Nick Desaulniers <nick.desaulniers+lkml@gmail.com>, 
 Bill Wendling <morbo@google.com>, Justin Stitt <justinstitt@google.com>
Cc: linux-media@vger.kernel.org, linux-kernel@vger.kernel.org, 
 linux-staging@lists.linux.dev, llvm@lists.linux.dev, 
 LiangCheng Wang <zaq14760@gmail.com>
X-Mailer: b4 0.14.2
X-Developer-Signature: v=1; a=ed25519-sha256; t=1751036202; l=3378941;
 i=zaq14760@gmail.com; h=from:subject:message-id;
 bh=40GXoQotmpQtKWFkqpg3CvbdaEucs4SX5aR++yO42hw=;
 b=WwBcAmmyJpovr5mdCnL8M6EXl5RfTxlhWbkNriQBBqU6lgCmKcxMCfu/6zMe0xjDP5kRclnen
 a9PWMyZZf0+BKk/r2sRAEeLKBTY/BftWWpkPZoLdGqB0OIE0dGBwUsW
X-Developer-Key: i=zaq14760@gmail.com; a=ed25519;
 pk=/x4391DbJ19fFQI7t33HWt3lsHfYPl2I2ax8C+Vxr+M=

Applied clang-format to the entire AtomISP driver to improve code consistency,
readability, and adherence to Linux kernel coding style.

Additionally, manually fixed all checkpatch.pl-reported ERRORs across
the driver, including:

- Macro definitions with complex expressions now wrapped in parentheses
- Removed unnecessary parentheses in return statements
- Avoided initializing globals to zero
- Fixed invalid spacing around unary operators

This patch only includes formatting and stylistic changes with no functional logic modifications.

Suggested-by: Andy Shevchenko <andy@kernel.org>
Link: https://lore.kernel.org/all/aFwSgCtrK7DH3pIw@smile.fi.intel.com/
Signed-off-by: LiangCheng Wang <zaq14760@gmail.com>
---
This patch applies clang-format to the entire AtomISP driver and manually
fixes all checkpatch.pl-reported ERRORs. The intent is to improve code
consistency and align with kernel coding standards.

Formatting and error fixes include:
- Replacing space-based indentation with tabs
- Wrapping complex macros in parentheses
- Removing redundant return parentheses
- Avoiding unnecessary zero-initialized globals

The following tools were used:
  clang-format -i $(find drivers/staging/media/atomisp/ -name "*.[ch]")
  ./scripts/checkpatch.pl -f $(find drivers/staging/media/atomisp/ -name "*.[ch]") | grep '^ERROR:' -B 1 -A 2

WARNINGs (~1500) were intentionally left untouched to keep this patch
focused and reviewable. These may be addressed in future patches.
---
Changes in v6:
- Applied clang-format across the entire AtomISP driver
- Fixed all checkpatch.pl-reported ERRORs
- Added explanation of tooling and scope
- No functional logic modified
- Moved 'Suggested-by' and 'Link' tags above Signed-off-by
- Link to v5: https://lore.kernel.org/r/20250625-bar-v5-1-db960608b607@gmail.com

Changes in v5:
- Replaced space-based indentation with tabs in output_1.0 directory
- Used checkpatch.pl and grep to identify formatting issues
- No functional changes made
- This patch is now focused solely on tab/space issues
- Link to v4: https://lore.kernel.org/r/20250624-bar-v4-1-9f9f9ae9f868@gmail.com

Changes in v4:
- Moved assignment operator '=' to the same line for static struct definitions
- Remove unnecessary line breaks in function definitions
- Update commit message to reflect all the coding style fixes
- Link to v3: https://lore.kernel.org/r/20250622-bar-v3-1-4cc91ef01c3a@gmail.com

Changes in v3:
- Removed extra spaces between type and asterisk (e.g., `*to`) in function
  declarations, as pointed out by Andy Shevchenko
- Update commit message to reflect all the coding style fixes
- Link to v2: https://lore.kernel.org/r/20250621-bar-v2-1-4e6cfc779614@gmail.com

Changes in v2:
- Fix patch subject prefix to "staging: media: atomisp:" to comply with media CI style.
- No other functional changes.

Link to v1: https://lore.kernel.org/r/20250621-bar-v1-1-5a3e7004462c@gmail.com
---
 drivers/staging/media/atomisp/i2c/atomisp-gc0310.c |  144 +-
 drivers/staging/media/atomisp/i2c/atomisp-gc2235.c |   86 +-
 drivers/staging/media/atomisp/i2c/atomisp-ov2722.c |  115 +-
 drivers/staging/media/atomisp/i2c/gc2235.h         |  108 +-
 drivers/staging/media/atomisp/i2c/ov2722.h         |  766 ++--
 drivers/staging/media/atomisp/include/hmm/hmm.h    |    8 +-
 drivers/staging/media/atomisp/include/hmm/hmm_bo.h |  118 +-
 .../staging/media/atomisp/include/hmm/hmm_common.h |   66 +-
 .../staging/media/atomisp/include/linux/atomisp.h  |  376 +-
 .../atomisp/include/linux/atomisp_gmin_platform.h  |   11 +-
 .../media/atomisp/include/linux/atomisp_platform.h |  100 +-
 .../staging/media/atomisp/include/mmu/isp_mmu.h    |   77 +-
 .../media/atomisp/include/mmu/sh_mmu_mrfld.h       |    4 +-
 drivers/staging/media/atomisp/pci/atomisp-regs.h   |  256 +-
 drivers/staging/media/atomisp/pci/atomisp_cmd.c    | 1472 ++++----
 drivers/staging/media/atomisp/pci/atomisp_cmd.h    |   68 +-
 drivers/staging/media/atomisp/pci/atomisp_common.h |   18 +-
 drivers/staging/media/atomisp/pci/atomisp_compat.h |  176 +-
 .../media/atomisp/pci/atomisp_compat_css20.c       | 1086 +++---
 .../media/atomisp/pci/atomisp_compat_css20.h       |   32 +-
 drivers/staging/media/atomisp/pci/atomisp_csi2.c   |   59 +-
 drivers/staging/media/atomisp/pci/atomisp_csi2.h   |   10 +-
 .../media/atomisp/pci/atomisp_csi2_bridge.c        |  162 +-
 .../staging/media/atomisp/pci/atomisp_dfs_tables.h |    4 +-
 drivers/staging/media/atomisp/pci/atomisp_drvfs.c  |   26 +-
 drivers/staging/media/atomisp/pci/atomisp_drvfs.h  |    4 +-
 drivers/staging/media/atomisp/pci/atomisp_fops.c   |  113 +-
 drivers/staging/media/atomisp/pci/atomisp_fops.h   |    4 +-
 .../media/atomisp/pci/atomisp_gmin_platform.c      |  248 +-
 .../staging/media/atomisp/pci/atomisp_internal.h   |   86 +-
 drivers/staging/media/atomisp/pci/atomisp_ioctl.c  |  384 +-
 drivers/staging/media/atomisp/pci/atomisp_ioctl.h  |   12 +-
 drivers/staging/media/atomisp/pci/atomisp_subdev.c |  239 +-
 drivers/staging/media/atomisp/pci/atomisp_subdev.h |  118 +-
 drivers/staging/media/atomisp/pci/atomisp_tables.h |  207 +-
 .../media/atomisp/pci/atomisp_trace_event.h        |  105 +-
 drivers/staging/media/atomisp/pci/atomisp_v4l2.c   |  326 +-
 .../pci/base/circbuf/interface/ia_css_circbuf.h    |   81 +-
 .../base/circbuf/interface/ia_css_circbuf_comm.h   |   27 +-
 .../base/circbuf/interface/ia_css_circbuf_desc.h   |   41 +-
 .../media/atomisp/pci/base/circbuf/src/circbuf.c   |   56 +-
 .../pci/base/refcount/interface/ia_css_refcount.h  |    3 +-
 .../media/atomisp/pci/base/refcount/src/refcount.c |   65 +-
 drivers/staging/media/atomisp/pci/bits.h           |   74 +-
 .../camera/pipe/interface/ia_css_pipe_binarydesc.h |  164 +-
 .../camera/pipe/interface/ia_css_pipe_stagedesc.h  |   27 +-
 .../pci/camera/pipe/interface/ia_css_pipe_util.h   |   14 +-
 .../atomisp/pci/camera/pipe/src/pipe_binarydesc.c  |  366 +-
 .../atomisp/pci/camera/pipe/src/pipe_stagedesc.c   |   32 +-
 .../media/atomisp/pci/camera/pipe/src/pipe_util.c  |   19 +-
 .../pci/camera/util/interface/ia_css_util.h        |   39 +-
 .../media/atomisp/pci/camera/util/src/util.c       |   33 +-
 drivers/staging/media/atomisp/pci/cell_params.h    |   32 +-
 .../atomisp/pci/css_2401_system/csi_rx_global.h    |    8 +-
 .../atomisp/pci/css_2401_system/host/csi_rx.c      |   24 +-
 .../pci/css_2401_system/host/csi_rx_local.h        |   66 +-
 .../pci/css_2401_system/host/csi_rx_private.h      |  222 +-
 .../atomisp/pci/css_2401_system/host/ibuf_ctrl.c   |    6 +-
 .../pci/css_2401_system/host/ibuf_ctrl_local.h     |   10 +-
 .../atomisp/pci/css_2401_system/host/isys_dma.c    |   13 +-
 .../pci/css_2401_system/host/isys_dma_private.h    |   13 +-
 .../atomisp/pci/css_2401_system/host/isys_irq.c    |    6 +-
 .../pci/css_2401_system/host/isys_irq_local.h      |    5 +-
 .../pci/css_2401_system/host/isys_irq_private.h    |   53 +-
 .../pci/css_2401_system/host/isys_stream2mmio.c    |    4 +-
 .../css_2401_system/host/isys_stream2mmio_local.h  |    6 +-
 .../host/isys_stream2mmio_private.h                |   95 +-
 .../pci/css_2401_system/host/pixelgen_local.h      |   56 +-
 .../pci/css_2401_system/host/pixelgen_private.h    |  110 +-
 .../css_2401_system/hrt/PixelGen_SysBlock_defs.h   |  122 +-
 .../pci/css_2401_system/hrt/ibuf_cntrl_defs.h      |  117 +-
 .../css_2401_system/hrt/mipi_backend_common_defs.h |  306 +-
 .../pci/css_2401_system/hrt/mipi_backend_defs.h    |  254 +-
 .../atomisp/pci/css_2401_system/hrt/rx_csi_defs.h  |  200 +-
 .../pci/css_2401_system/hrt/stream2mmio_defs.h     |   69 +-
 .../atomisp/pci/css_2401_system/ibuf_ctrl_global.h |   26 +-
 .../atomisp/pci/css_2401_system/isys_dma_global.h  |   26 +-
 .../atomisp/pci/css_2401_system/isys_irq_global.h  |   22 +-
 .../pci/css_2401_system/isys_stream2mmio_global.h  |    4 +-
 .../atomisp/pci/css_2401_system/pixelgen_global.h  |   32 +-
 .../atomisp/pci/css_receiver_2400_common_defs.h    |  359 +-
 .../media/atomisp/pci/css_receiver_2400_defs.h     |  402 +-
 drivers/staging/media/atomisp/pci/css_trace.h      |  257 +-
 drivers/staging/media/atomisp/pci/dma_v2_defs.h    |  324 +-
 drivers/staging/media/atomisp/pci/gdc_v2_defs.h    |  164 +-
 drivers/staging/media/atomisp/pci/gp_timer_defs.h  |   35 +-
 .../staging/media/atomisp/pci/gpio_block_defs.h    |    8 +-
 .../atomisp/pci/hive_isp_css_common/debug_global.h |   54 +-
 .../atomisp/pci/hive_isp_css_common/dma_global.h   |  344 +-
 .../pci/hive_isp_css_common/fifo_monitor_global.h  |    6 +-
 .../atomisp/pci/hive_isp_css_common/gdc_global.h   |   87 +-
 .../pci/hive_isp_css_common/gp_device_global.h     |  114 +-
 .../pci/hive_isp_css_common/gp_timer_global.h      |   14 +-
 .../atomisp/pci/hive_isp_css_common/gpio_global.h  |    2 +-
 .../atomisp/pci/hive_isp_css_common/hmem_global.h  |   16 +-
 .../atomisp/pci/hive_isp_css_common/host/debug.c   |   25 +-
 .../pci/hive_isp_css_common/host/debug_private.h   |   91 +-
 .../atomisp/pci/hive_isp_css_common/host/dma.c     |    8 +-
 .../pci/hive_isp_css_common/host/dma_local.h       |  149 +-
 .../pci/hive_isp_css_common/host/dma_private.h     |   14 +-
 .../hive_isp_css_common/host/event_fifo_local.h    |   18 +-
 .../hive_isp_css_common/host/event_fifo_private.h  |   20 +-
 .../pci/hive_isp_css_common/host/fifo_monitor.c    |  792 ++--
 .../hive_isp_css_common/host/fifo_monitor_local.h  |   32 +-
 .../host/fifo_monitor_private.h                    |   40 +-
 .../atomisp/pci/hive_isp_css_common/host/gdc.c     |   38 +-
 .../pci/hive_isp_css_common/host/gp_device.c       |  153 +-
 .../pci/hive_isp_css_common/host/gp_device_local.h |   32 +-
 .../hive_isp_css_common/host/gp_device_private.h   |   14 +-
 .../pci/hive_isp_css_common/host/gp_timer.c        |   35 +-
 .../pci/hive_isp_css_common/host/gp_timer_local.h  |   40 +-
 .../pci/hive_isp_css_common/host/gpio_private.h    |   20 +-
 .../pci/hive_isp_css_common/host/hmem_private.h    |    3 +-
 .../pci/hive_isp_css_common/host/input_formatter.c |  266 +-
 .../host/input_formatter_local.h                   |  123 +-
 .../host/input_formatter_private.h                 |   10 +-
 .../pci/hive_isp_css_common/host/input_system.c    | 1021 +++---
 .../atomisp/pci/hive_isp_css_common/host/irq.c     |  199 +-
 .../pci/hive_isp_css_common/host/irq_local.h       |  168 +-
 .../pci/hive_isp_css_common/host/irq_private.h     |   18 +-
 .../atomisp/pci/hive_isp_css_common/host/isp.c     |    7 +-
 .../pci/hive_isp_css_common/host/isp_local.h       |    2 +-
 .../pci/hive_isp_css_common/host/isp_private.h     |   94 +-
 .../atomisp/pci/hive_isp_css_common/host/mmu.c     |   12 +-
 .../atomisp/pci/hive_isp_css_common/host/sp.c      |    4 +-
 .../pci/hive_isp_css_common/host/sp_local.h        |   58 +-
 .../pci/hive_isp_css_common/host/sp_private.h      |   87 +-
 .../pci/hive_isp_css_common/host/timed_ctrl.c      |   37 +-
 .../hive_isp_css_common/host/timed_ctrl_private.h  |   12 +-
 .../atomisp/pci/hive_isp_css_common/host/vmem.c    |  150 +-
 .../pci/hive_isp_css_common/host/vmem_local.h      |   55 +-
 .../hive_isp_css_common/input_formatter_global.h   |  128 +-
 .../atomisp/pci/hive_isp_css_common/irq_global.h   |    2 +-
 .../atomisp/pci/hive_isp_css_common/isp_global.h   |  106 +-
 .../atomisp/pci/hive_isp_css_common/sp_global.h    |  104 +-
 .../pci/hive_isp_css_common/timed_ctrl_global.h    |   48 +-
 .../atomisp/pci/hive_isp_css_common/vamem_global.h |   13 +-
 .../atomisp/pci/hive_isp_css_common/vmem_global.h  |    6 +-
 .../staging/media/atomisp/pci/hive_isp_css_defs.h  |  677 ++--
 .../pci/hive_isp_css_include/assert_support.h      |   11 +-
 .../atomisp/pci/hive_isp_css_include/csi_rx.h      |    2 +-
 .../media/atomisp/pci/hive_isp_css_include/debug.h |    6 +-
 .../device_access/device_access.h                  |   44 +-
 .../media/atomisp/pci/hive_isp_css_include/dma.h   |    6 +-
 .../atomisp/pci/hive_isp_css_include/event_fifo.h  |    6 +-
 .../pci/hive_isp_css_include/fifo_monitor.h        |    6 +-
 .../atomisp/pci/hive_isp_css_include/gdc_device.h  |    6 +-
 .../atomisp/pci/hive_isp_css_include/gp_device.h   |    6 +-
 .../atomisp/pci/hive_isp_css_include/gp_timer.h    |   14 +-
 .../media/atomisp/pci/hive_isp_css_include/hmem.h  |    6 +-
 .../pci/hive_isp_css_include/host/csi_rx_public.h  |   49 +-
 .../pci/hive_isp_css_include/host/debug_public.h   |   19 +-
 .../pci/hive_isp_css_include/host/dma_public.h     |   18 +-
 .../hive_isp_css_include/host/event_fifo_public.h  |   22 +-
 .../host/fifo_monitor_public.h                     |   49 +-
 .../pci/hive_isp_css_include/host/gdc_public.h     |   12 +-
 .../hive_isp_css_include/host/gp_device_public.h   |   18 +-
 .../hive_isp_css_include/host/gp_timer_public.h    |    6 +-
 .../pci/hive_isp_css_include/host/hmem_public.h    |    5 +-
 .../host/input_formatter_public.h                  |   36 +-
 .../pci/hive_isp_css_include/host/irq_public.h     |   42 +-
 .../pci/hive_isp_css_include/host/isp_public.h     |   67 +-
 .../hive_isp_css_include/host/isys_dma_public.h    |   19 +-
 .../hive_isp_css_include/host/isys_irq_public.h    |   19 +-
 .../host/isys_stream2mmio_public.h                 |   36 +-
 .../pci/hive_isp_css_include/host/mmu_public.h     |   28 +-
 .../hive_isp_css_include/host/pixelgen_public.h    |   22 +-
 .../pci/hive_isp_css_include/host/sp_public.h      |   81 +-
 .../pci/hive_isp_css_include/host/tag_public.h     |   12 +-
 .../hive_isp_css_include/host/timed_ctrl_public.h  |   47 +-
 .../pci/hive_isp_css_include/input_formatter.h     |    6 +-
 .../pci/hive_isp_css_include/input_system.h        |    6 +-
 .../media/atomisp/pci/hive_isp_css_include/irq.h   |    6 +-
 .../media/atomisp/pci/hive_isp_css_include/isp.h   |    6 +-
 .../atomisp/pci/hive_isp_css_include/isys_irq.h    |    4 +-
 .../pci/hive_isp_css_include/isys_stream2mmio.h    |    6 +-
 .../pci/hive_isp_css_include/math_support.h        |   10 +-
 .../pci/hive_isp_css_include/misc_support.h        |    3 +-
 .../atomisp/pci/hive_isp_css_include/pixelgen.h    |    6 +-
 .../pci/hive_isp_css_include/platform_support.h    |    4 +-
 .../pci/hive_isp_css_include/print_support.h       |    2 +-
 .../media/atomisp/pci/hive_isp_css_include/queue.h |    6 +-
 .../atomisp/pci/hive_isp_css_include/resource.h    |    6 +-
 .../media/atomisp/pci/hive_isp_css_include/sp.h    |    6 +-
 .../media/atomisp/pci/hive_isp_css_include/tag.h   |    6 +-
 .../atomisp/pci/hive_isp_css_include/timed_ctrl.h  |    6 +-
 .../pci/hive_isp_css_include/type_support.h        |   12 +-
 .../media/atomisp/pci/hive_isp_css_include/vmem.h  |    6 +-
 .../atomisp/pci/hive_isp_css_shared/host/tag.c     |   35 +-
 .../pci/hive_isp_css_shared/sw_event_global.h      |    4 +-
 .../atomisp/pci/hive_isp_css_shared/tag_global.h   |   16 +-
 .../pci/hive_isp_css_streaming_to_mipi_types_hrt.h |    8 +-
 drivers/staging/media/atomisp/pci/hive_types.h     |   34 +-
 drivers/staging/media/atomisp/pci/hmm/hmm.c        |   43 +-
 drivers/staging/media/atomisp/pci/hmm/hmm_bo.c     |  112 +-
 drivers/staging/media/atomisp/pci/ia_css_3a.h      |   76 +-
 .../staging/media/atomisp/pci/ia_css_acc_types.h   |  418 +--
 drivers/staging/media/atomisp/pci/ia_css_buffer.h  |   19 +-
 drivers/staging/media/atomisp/pci/ia_css_control.h |   27 +-
 .../media/atomisp/pci/ia_css_device_access.c       |   40 +-
 .../media/atomisp/pci/ia_css_device_access.h       |   37 +-
 drivers/staging/media/atomisp/pci/ia_css_dvs.h     |   84 +-
 drivers/staging/media/atomisp/pci/ia_css_env.h     |   14 +-
 .../media/atomisp/pci/ia_css_event_public.h        |   87 +-
 .../staging/media/atomisp/pci/ia_css_firmware.h    |   10 +-
 .../media/atomisp/pci/ia_css_frame_format.h        |   48 +-
 .../media/atomisp/pci/ia_css_frame_public.h        |   63 +-
 .../staging/media/atomisp/pci/ia_css_host_data.h   |    5 +-
 .../staging/media/atomisp/pci/ia_css_input_port.h  |   18 +-
 drivers/staging/media/atomisp/pci/ia_css_irq.h     |   96 +-
 .../staging/media/atomisp/pci/ia_css_isp_configs.c |  165 +-
 .../staging/media/atomisp/pci/ia_css_isp_configs.h |   34 +-
 .../staging/media/atomisp/pci/ia_css_isp_params.c  | 2238 ++++++------
 .../staging/media/atomisp/pci/ia_css_isp_params.h  |  214 +-
 .../staging/media/atomisp/pci/ia_css_isp_states.c  |  154 +-
 .../staging/media/atomisp/pci/ia_css_isp_states.h  |    6 +-
 .../staging/media/atomisp/pci/ia_css_metadata.h    |   15 +-
 drivers/staging/media/atomisp/pci/ia_css_mipi.h    |   12 +-
 drivers/staging/media/atomisp/pci/ia_css_mmu.h     |    3 +-
 .../staging/media/atomisp/pci/ia_css_mmu_private.h |    3 +-
 drivers/staging/media/atomisp/pci/ia_css_morph.h   |    7 +-
 drivers/staging/media/atomisp/pci/ia_css_pipe.h    |  149 +-
 .../staging/media/atomisp/pci/ia_css_pipe_public.h |  110 +-
 drivers/staging/media/atomisp/pci/ia_css_prbs.h    |   16 +-
 .../staging/media/atomisp/pci/ia_css_properties.h  |    5 +-
 drivers/staging/media/atomisp/pci/ia_css_shading.h |    8 +-
 drivers/staging/media/atomisp/pci/ia_css_stream.h  |   73 +-
 .../media/atomisp/pci/ia_css_stream_format.h       |    5 +-
 .../media/atomisp/pci/ia_css_stream_public.h       |  154 +-
 drivers/staging/media/atomisp/pci/ia_css_timer.h   |   16 +-
 drivers/staging/media/atomisp/pci/ia_css_types.h   |  166 +-
 drivers/staging/media/atomisp/pci/ia_css_version.h |    5 +-
 .../media/atomisp/pci/ia_css_version_data.h        |    6 +-
 drivers/staging/media/atomisp/pci/if_defs.h        |    6 +-
 .../atomisp/pci/input_formatter_subsystem_defs.h   |   57 +-
 .../media/atomisp/pci/input_selector_defs.h        |  100 +-
 .../media/atomisp/pci/input_switch_2400_defs.h     |   19 +-
 .../media/atomisp/pci/input_system_ctrl_defs.h     |  238 +-
 .../staging/media/atomisp/pci/input_system_defs.h  |  161 +-
 .../media/atomisp/pci/input_system_global.h        |    1 -
 .../staging/media/atomisp/pci/input_system_local.h |   86 +-
 .../media/atomisp/pci/irq_controller_defs.h        |   10 +-
 drivers/staging/media/atomisp/pci/irq_types_hrt.h  |   68 +-
 .../pci/isp/kernels/aa/aa_2/ia_css_aa2_types.h     |    2 +-
 .../pci/isp/kernels/anr/anr_1.0/ia_css_anr.host.c  |   41 +-
 .../pci/isp/kernels/anr/anr_1.0/ia_css_anr.host.h  |   19 +-
 .../pci/isp/kernels/anr/anr_1.0/ia_css_anr_types.h |    4 +-
 .../pci/isp/kernels/anr/anr_2/ia_css_anr2.host.c   |   13 +-
 .../pci/isp/kernels/anr/anr_2/ia_css_anr2.host.h   |   13 +-
 .../pci/isp/kernels/anr/anr_2/ia_css_anr2_param.h  |    2 +-
 .../isp/kernels/anr/anr_2/ia_css_anr2_table.host.c |  143 +-
 .../pci/isp/kernels/anr/anr_2/ia_css_anr2_types.h  |    2 +-
 .../pci/isp/kernels/bh/bh_2/ia_css_bh.host.c       |   21 +-
 .../pci/isp/kernels/bh/bh_2/ia_css_bh.host.h       |   13 +-
 .../pci/isp/kernels/bh/bh_2/ia_css_bh_types.h      |   14 +-
 .../pci/isp/kernels/bnlm/ia_css_bnlm.host.c        |   63 +-
 .../pci/isp/kernels/bnlm/ia_css_bnlm.host.h        |   21 +-
 .../pci/isp/kernels/bnlm/ia_css_bnlm_types.h       |   20 +-
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c    |   79 +-
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h    |   13 +-
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h   |   22 +-
 .../pci/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.c  |   42 +-
 .../pci/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h  |   13 +-
 .../pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.c  |    6 +-
 .../pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.h  |    6 +-
 .../pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr_param.h |    2 +-
 .../pci/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.c   |   50 +-
 .../pci/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h   |   25 +-
 .../pci/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h  |   16 +-
 .../conversion_1.0/ia_css_conversion.host.c        |   10 +-
 .../conversion_1.0/ia_css_conversion.host.h        |    8 +-
 .../conversion_1.0/ia_css_conversion_types.h       |    2 +-
 .../copy_output_1.0/ia_css_copy_output.host.c      |    8 +-
 .../copy_output_1.0/ia_css_copy_output.host.h      |   10 +-
 .../isp/kernels/crop/crop_1.0/ia_css_crop.host.c   |   10 +-
 .../isp/kernels/crop/crop_1.0/ia_css_crop.host.h   |   12 +-
 .../pci/isp/kernels/csc/csc_1.0/ia_css_csc.host.c  |   99 +-
 .../pci/isp/kernels/csc/csc_1.0/ia_css_csc.host.h  |   38 +-
 .../pci/isp/kernels/csc/csc_1.0/ia_css_csc_param.h |   20 +-
 .../pci/isp/kernels/csc/csc_1.0/ia_css_csc_types.h |    2 +-
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c    |   68 +-
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h    |   13 +-
 .../pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c    |   41 +-
 .../pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h    |    3 +-
 .../pci/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h   |    3 +-
 .../pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.c  |   49 +-
 .../pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h  |   14 +-
 .../pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_param.h |    4 +-
 .../kernels/ctc/ctc_1.0/ia_css_ctc_table.host.c    |   67 +-
 .../pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h |   38 +-
 .../pci/isp/kernels/de/de_1.0/ia_css_de.host.c     |   61 +-
 .../pci/isp/kernels/de/de_1.0/ia_css_de.host.h     |   30 +-
 .../pci/isp/kernels/de/de_2/ia_css_de2.host.c      |   37 +-
 .../pci/isp/kernels/de/de_2/ia_css_de2.host.h      |   18 +-
 .../pci/isp/kernels/de/de_2/ia_css_de2_types.h     |    6 +-
 .../pci/isp/kernels/dp/dp_1.0/ia_css_dp.host.c     |  125 +-
 .../pci/isp/kernels/dp/dp_1.0/ia_css_dp.host.h     |   30 +-
 .../pci/isp/kernels/dp/dp_1.0/ia_css_dp_types.h    |   10 +-
 .../pci/isp/kernels/dpc2/ia_css_dpc2.host.c        |   32 +-
 .../pci/isp/kernels/dpc2/ia_css_dpc2.host.h        |   18 +-
 .../pci/isp/kernels/dpc2/ia_css_dpc2_param.h       |   16 +-
 .../pci/isp/kernels/dpc2/ia_css_dpc2_types.h       |    8 +-
 .../pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c  |  152 +-
 .../pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h  |   40 +-
 .../pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs_param.h |    3 +-
 .../pci/isp/kernels/eed1_8/ia_css_eed1_8.host.c    |  203 +-
 .../pci/isp/kernels/eed1_8/ia_css_eed1_8.host.h    |   26 +-
 .../pci/isp/kernels/eed1_8/ia_css_eed1_8_param.h   |   54 +-
 .../pci/isp/kernels/eed1_8/ia_css_eed1_8_types.h   |   88 +-
 .../isp/kernels/fc/fc_1.0/ia_css_formats.host.c    |   34 +-
 .../isp/kernels/fc/fc_1.0/ia_css_formats.host.h    |   20 +-
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h  |    2 +-
 .../pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c  |   39 +-
 .../pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h  |   17 +-
 .../pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn_param.h |    2 +-
 .../pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn_types.h |   10 +-
 .../pci/isp/kernels/gc/gc_1.0/ia_css_gc.host.c     |   88 +-
 .../pci/isp/kernels/gc/gc_1.0/ia_css_gc.host.h     |   54 +-
 .../pci/isp/kernels/gc/gc_1.0/ia_css_gc_param.h    |    8 +-
 .../isp/kernels/gc/gc_1.0/ia_css_gc_table.host.c   |   64 +-
 .../pci/isp/kernels/gc/gc_1.0/ia_css_gc_types.h    |   16 +-
 .../pci/isp/kernels/gc/gc_2/ia_css_gc2.host.c      |   68 +-
 .../pci/isp/kernels/gc/gc_2/ia_css_gc2.host.h      |   58 +-
 .../isp/kernels/gc/gc_2/ia_css_gc2_table.host.c    |   73 +-
 .../pci/isp/kernels/gc/gc_2/ia_css_gc2_types.h     |   10 +-
 .../atomisp/pci/isp/kernels/hdr/ia_css_hdr.host.c  |   24 +-
 .../atomisp/pci/isp/kernels/hdr/ia_css_hdr.host.h  |    8 +-
 .../atomisp/pci/isp/kernels/hdr/ia_css_hdr_param.h |   20 +-
 .../atomisp/pci/isp/kernels/hdr/ia_css_hdr_types.h |   26 +-
 .../ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.c  |   58 +-
 .../ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.h  |    2 +-
 .../yuv444_io_ls/ia_css_yuv444_io.host.c           |   58 +-
 .../yuv444_io_ls/ia_css_yuv444_io.host.h           |    2 +-
 .../iterator/iterator_1.0/ia_css_iterator.host.c   |   32 +-
 .../iterator/iterator_1.0/ia_css_iterator.host.h   |   14 +-
 .../isp/kernels/macc/macc1_5/ia_css_macc1_5.host.c |   37 +-
 .../isp/kernels/macc/macc1_5/ia_css_macc1_5.host.h |   22 +-
 .../kernels/macc/macc1_5/ia_css_macc1_5_param.h    |    2 +-
 .../macc/macc1_5/ia_css_macc1_5_table.host.c       |   16 +-
 .../kernels/macc/macc1_5/ia_css_macc1_5_types.h    |    6 +-
 .../isp/kernels/macc/macc_1.0/ia_css_macc.host.c   |   24 +-
 .../isp/kernels/macc/macc_1.0/ia_css_macc.host.h   |   24 +-
 .../kernels/macc/macc_1.0/ia_css_macc_table.host.c |   32 +-
 .../isp/kernels/macc/macc_1.0/ia_css_macc_types.h  |    4 +-
 .../pci/isp/kernels/ob/ob2/ia_css_ob2.host.c       |   61 +-
 .../pci/isp/kernels/ob/ob2/ia_css_ob2.host.h       |   18 +-
 .../pci/isp/kernels/ob/ob2/ia_css_ob2_types.h      |    8 +-
 .../pci/isp/kernels/ob/ob_1.0/ia_css_ob.host.c     |  113 +-
 .../pci/isp/kernels/ob/ob_1.0/ia_css_ob.host.h     |   47 +-
 .../pci/isp/kernels/ob/ob_1.0/ia_css_ob_param.h    |    2 +-
 .../pci/isp/kernels/ob/ob_1.0/ia_css_ob_types.h    |   16 +-
 .../kernels/output/output_1.0/ia_css_output.host.c |   76 +-
 .../kernels/output/output_1.0/ia_css_output.host.h |   32 +-
 .../output/output_1.0/ia_css_output_types.h        |    4 +-
 .../kernels/qplane/qplane_2/ia_css_qplane.host.c   |    6 +-
 .../kernels/qplane/qplane_2/ia_css_qplane.host.h   |    8 +-
 .../kernels/qplane/qplane_2/ia_css_qplane_types.h  |    2 +-
 .../pci/isp/kernels/raw/raw_1.0/ia_css_raw.host.c  |   47 +-
 .../pci/isp/kernels/raw/raw_1.0/ia_css_raw.host.h  |    7 +-
 .../pci/isp/kernels/raw/raw_1.0/ia_css_raw_types.h |    4 +-
 .../raw_aa_binning_1.0/ia_css_raa.host.c           |    9 +-
 .../raw_aa_binning_1.0/ia_css_raa.host.h           |    7 +-
 .../pci/isp/kernels/ref/ref_1.0/ia_css_ref.host.c  |   25 +-
 .../pci/isp/kernels/ref/ref_1.0/ia_css_ref.host.h  |   14 +-
 .../pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.c  |  257 +-
 .../pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h  |   59 +-
 .../pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h |   78 +-
 .../pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.c     |   53 +-
 .../pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.h     |   22 +-
 .../pci/isp/kernels/sc/sc_1.0/ia_css_sc_param.h    |    2 +-
 .../pci/isp/kernels/sc/sc_1.0/ia_css_sc_types.h    |   12 +-
 .../kernels/sdis/common/ia_css_sdis_common.host.h  |   34 +-
 .../kernels/sdis/common/ia_css_sdis_common_types.h |   50 +-
 .../isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c   |  248 +-
 .../isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.h   |   91 +-
 .../isp/kernels/sdis/sdis_1.0/ia_css_sdis_types.h  |   14 +-
 .../isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c    |  188 +-
 .../isp/kernels/sdis/sdis_2/ia_css_sdis2.host.h    |   69 +-
 .../isp/kernels/sdis/sdis_2/ia_css_sdis2_types.h   |   14 +-
 .../pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c  |   64 +-
 .../pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.h  |   20 +-
 .../pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h |   36 +-
 .../pci/isp/kernels/tnr/tnr3/ia_css_tnr3_types.h   |   34 +-
 .../pci/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.c  |   60 +-
 .../pci/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h  |   37 +-
 .../pci/isp/kernels/vf/vf_1.0/ia_css_vf.host.c     |   49 +-
 .../pci/isp/kernels/vf/vf_1.0/ia_css_vf.host.h     |   18 +-
 .../pci/isp/kernels/vf/vf_1.0/ia_css_vf_param.h    |    2 +-
 .../pci/isp/kernels/wb/wb_1.0/ia_css_wb.host.c     |   79 +-
 .../pci/isp/kernels/wb/wb_1.0/ia_css_wb.host.h     |   18 +-
 .../pci/isp/kernels/wb/wb_1.0/ia_css_wb_types.h    |    8 +-
 .../pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c  |   36 +-
 .../pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.h  |   33 +-
 .../pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_param.h |    4 +-
 .../kernels/xnr/xnr_1.0/ia_css_xnr_table.host.c    |   41 +-
 .../pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_types.h |    8 +-
 .../pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c |   74 +-
 .../pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.h |   22 +-
 .../isp/kernels/xnr/xnr_3.0/ia_css_xnr3_param.h    |   20 +-
 .../isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h    |   31 +-
 .../pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.c  |  212 +-
 .../pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h  |   56 +-
 .../pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr_types.h |   10 +-
 .../pci/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.c   |   93 +-
 .../pci/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.h   |   51 +-
 .../pci/isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h  |   10 +-
 .../pci/isp/modes/interface/input_buf.isp.h        |    9 +-
 .../atomisp/pci/isp/modes/interface/isp_const.h    |  132 +-
 .../atomisp/pci/isp/modes/interface/isp_types.h    |    2 +-
 .../atomisp/pci/isp2400_input_system_global.h      |   77 +-
 .../media/atomisp/pci/isp2400_input_system_local.h |  328 +-
 .../atomisp/pci/isp2400_input_system_private.h     |   80 +-
 .../atomisp/pci/isp2400_input_system_public.h      |  199 +-
 .../staging/media/atomisp/pci/isp2400_support.h    |   17 +-
 .../atomisp/pci/isp2401_input_system_global.h      |  101 +-
 .../media/atomisp/pci/isp2401_input_system_local.h |    4 +-
 .../atomisp/pci/isp2401_input_system_private.h     |  260 +-
 .../media/atomisp/pci/isp_acquisition_defs.h       |  367 +-
 .../staging/media/atomisp/pci/isp_capture_defs.h   |  450 ++-
 .../staging/media/atomisp/pci/mamoiada_params.h    |  308 +-
 drivers/staging/media/atomisp/pci/mmu/isp_mmu.c    |  122 +-
 .../staging/media/atomisp/pci/mmu/sh_mmu_mrfld.c   |   11 +-
 drivers/staging/media/atomisp/pci/mmu_defs.h       |    2 +-
 .../pci/runtime/binary/interface/ia_css_binary.h   |  199 +-
 .../media/atomisp/pci/runtime/binary/src/binary.c  |  818 +++--
 .../pci/runtime/bufq/interface/ia_css_bufq.h       |   46 +-
 .../pci/runtime/bufq/interface/ia_css_bufq_comm.h  |    2 +-
 .../media/atomisp/pci/runtime/bufq/src/bufq.c      |  214 +-
 .../pci/runtime/debug/interface/ia_css_debug.h     |  169 +-
 .../runtime/debug/interface/ia_css_debug_pipe.h    |   10 +-
 .../atomisp/pci/runtime/debug/src/ia_css_debug.c   |  943 ++---
 .../pci/runtime/event/interface/ia_css_event.h     |   11 +-
 .../media/atomisp/pci/runtime/event/src/event.c    |   21 +-
 .../pci/runtime/eventq/interface/ia_css_eventq.h   |   15 +-
 .../media/atomisp/pci/runtime/eventq/src/eventq.c  |   17 +-
 .../pci/runtime/frame/interface/ia_css_frame.h     |   15 +-
 .../runtime/frame/interface/ia_css_frame_comm.h    |   28 +-
 .../media/atomisp/pci/runtime/frame/src/frame.c    |  250 +-
 .../pci/runtime/ifmtr/interface/ia_css_ifmtr.h     |    6 +-
 .../media/atomisp/pci/runtime/ifmtr/src/ifmtr.c    |  165 +-
 .../runtime/inputfifo/interface/ia_css_inputfifo.h |   48 +-
 .../atomisp/pci/runtime/inputfifo/src/inputfifo.c  |  238 +-
 .../runtime/isp_param/interface/ia_css_isp_param.h |  103 +-
 .../isp_param/interface/ia_css_isp_param_types.h   |   24 +-
 .../atomisp/pci/runtime/isp_param/src/isp_param.c  |  153 +-
 .../pci/runtime/isys/interface/ia_css_isys.h       |   96 +-
 .../pci/runtime/isys/interface/ia_css_isys_comm.h  |   20 +-
 .../atomisp/pci/runtime/isys/src/csi_rx_rmgr.c     |   64 +-
 .../atomisp/pci/runtime/isys/src/csi_rx_rmgr.h     |    8 +-
 .../atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.c  |   15 +-
 .../atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.h  |   22 +-
 .../atomisp/pci/runtime/isys/src/isys_dma_rmgr.c   |   24 +-
 .../atomisp/pci/runtime/isys/src/isys_dma_rmgr.h   |    2 +-
 .../media/atomisp/pci/runtime/isys/src/isys_init.c |   56 +-
 .../pci/runtime/isys/src/isys_stream2mmio_rmgr.c   |   18 +-
 .../pci/runtime/isys/src/isys_stream2mmio_rmgr.h   |    4 +-
 .../media/atomisp/pci/runtime/isys/src/rx.c        |  129 +-
 .../atomisp/pci/runtime/isys/src/virtual_isys.c    |  621 ++--
 .../atomisp/pci/runtime/isys/src/virtual_isys.h    |    4 +-
 .../runtime/pipeline/interface/ia_css_pipeline.h   |   62 +-
 .../atomisp/pci/runtime/pipeline/src/pipeline.c    |  257 +-
 .../pci/runtime/queue/interface/ia_css_queue.h     |   46 +-
 .../runtime/queue/interface/ia_css_queue_comm.h    |   12 +-
 .../media/atomisp/pci/runtime/queue/src/queue.c    |   30 +-
 .../atomisp/pci/runtime/queue/src/queue_access.c   |  128 +-
 .../atomisp/pci/runtime/queue/src/queue_access.h   |   75 +-
 .../pci/runtime/rmgr/interface/ia_css_rmgr.h       |   10 +-
 .../pci/runtime/rmgr/interface/ia_css_rmgr_vbuf.h  |   22 +-
 .../media/atomisp/pci/runtime/rmgr/src/rmgr_vbuf.c |   45 +-
 .../pci/runtime/spctrl/interface/ia_css_spctrl.h   |   27 +-
 .../runtime/spctrl/interface/ia_css_spctrl_comm.h  |   22 +-
 .../media/atomisp/pci/runtime/spctrl/src/spctrl.c  |   52 +-
 .../tagger/interface/ia_css_tagger_common.h        |    8 +-
 .../media/atomisp/pci/runtime/timer/src/timer.c    |    2 +-
 drivers/staging/media/atomisp/pci/sh_css.c         | 3863 +++++++++++---------
 drivers/staging/media/atomisp/pci/sh_css_defs.h    |  251 +-
 .../staging/media/atomisp/pci/sh_css_firmware.c    |  125 +-
 .../staging/media/atomisp/pci/sh_css_firmware.h    |   26 +-
 drivers/staging/media/atomisp/pci/sh_css_frac.h    |   16 +-
 .../staging/media/atomisp/pci/sh_css_host_data.c   |    2 +-
 drivers/staging/media/atomisp/pci/sh_css_hrt.c     |    5 +-
 .../staging/media/atomisp/pci/sh_css_internal.h    |  604 ++-
 drivers/staging/media/atomisp/pci/sh_css_legacy.h  |   25 +-
 drivers/staging/media/atomisp/pci/sh_css_metrics.c |   45 +-
 drivers/staging/media/atomisp/pci/sh_css_metrics.h |    2 +-
 drivers/staging/media/atomisp/pci/sh_css_mipi.c    |  289 +-
 drivers/staging/media/atomisp/pci/sh_css_mipi.h    |   17 +-
 drivers/staging/media/atomisp/pci/sh_css_mmu.c     |   12 +-
 .../staging/media/atomisp/pci/sh_css_param_dvs.c   |  115 +-
 .../staging/media/atomisp/pci/sh_css_param_dvs.h   |   51 +-
 .../media/atomisp/pci/sh_css_param_shading.c       |  138 +-
 .../media/atomisp/pci/sh_css_param_shading.h       |   19 +-
 drivers/staging/media/atomisp/pci/sh_css_params.c  | 2873 ++++++++-------
 drivers/staging/media/atomisp/pci/sh_css_params.h  |  142 +-
 .../media/atomisp/pci/sh_css_params_internal.h     |    3 +-
 .../staging/media/atomisp/pci/sh_css_properties.c  |    6 +-
 drivers/staging/media/atomisp/pci/sh_css_sp.c      |  826 ++---
 drivers/staging/media/atomisp/pci/sh_css_sp.h      |  152 +-
 .../media/atomisp/pci/sh_css_stream_format.c       |    4 +-
 .../media/atomisp/pci/sh_css_stream_format.h       |    4 +-
 drivers/staging/media/atomisp/pci/sh_css_struct.h  |   40 +-
 drivers/staging/media/atomisp/pci/sh_css_version.c |    6 +-
 drivers/staging/media/atomisp/pci/str2mem_defs.h   |   34 +-
 .../media/atomisp/pci/streaming_to_mipi_defs.h     |   12 +-
 drivers/staging/media/atomisp/pci/system_global.h  |  176 +-
 drivers/staging/media/atomisp/pci/system_local.c   |  105 +-
 drivers/staging/media/atomisp/pci/system_local.h   |    3 +-
 drivers/staging/media/atomisp/pci/version.h        |    2 +-
 508 files changed, 23302 insertions(+), 24164 deletions(-)

diff --git a/drivers/staging/media/atomisp/i2c/atomisp-gc0310.c b/drivers/staging/media/atomisp/i2c/atomisp-gc0310.c
index d35394f1ddbb848abe71f38de54de841ab2dfe76..6e146c96574ed982de828e4e25f220c77e07d02f 100644
--- a/drivers/staging/media/atomisp/i2c/atomisp-gc0310.c
+++ b/drivers/staging/media/atomisp/i2c/atomisp-gc0310.c
@@ -19,50 +19,50 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 
-#define GC0310_NATIVE_WIDTH			656
-#define GC0310_NATIVE_HEIGHT			496
+#define GC0310_NATIVE_WIDTH 656
+#define GC0310_NATIVE_HEIGHT 496
 
-#define GC0310_FPS				30
-#define GC0310_SKIP_FRAMES			3
+#define GC0310_FPS 30
+#define GC0310_SKIP_FRAMES 3
 
-#define GC0310_FOCAL_LENGTH_NUM			278 /* 2.78mm */
+#define GC0310_FOCAL_LENGTH_NUM 278 /* 2.78mm */
 
-#define GC0310_ID				0xa310
+#define GC0310_ID 0xa310
 
-#define GC0310_RESET_RELATED			0xFE
-#define GC0310_REGISTER_PAGE_0			0x0
-#define GC0310_REGISTER_PAGE_3			0x3
+#define GC0310_RESET_RELATED 0xFE
+#define GC0310_REGISTER_PAGE_0 0x0
+#define GC0310_REGISTER_PAGE_3 0x3
 
 /*
  * GC0310 System control registers
  */
-#define GC0310_SW_STREAM			0x10
-
-#define GC0310_SC_CMMN_CHIP_ID_H		0xf0
-#define GC0310_SC_CMMN_CHIP_ID_L		0xf1
-
-#define GC0310_AEC_PK_EXPO_H			0x03
-#define GC0310_AEC_PK_EXPO_L			0x04
-#define GC0310_AGC_ADJ				0x48
-#define GC0310_DGC_ADJ				0x71
-#define GC0310_GROUP_ACCESS			0x3208
-
-#define GC0310_H_CROP_START_H			0x09
-#define GC0310_H_CROP_START_L			0x0A
-#define GC0310_V_CROP_START_H			0x0B
-#define GC0310_V_CROP_START_L			0x0C
-#define GC0310_H_OUTSIZE_H			0x0F
-#define GC0310_H_OUTSIZE_L			0x10
-#define GC0310_V_OUTSIZE_H			0x0D
-#define GC0310_V_OUTSIZE_L			0x0E
-#define GC0310_H_BLANKING_H			0x05
-#define GC0310_H_BLANKING_L			0x06
-#define GC0310_V_BLANKING_H			0x07
-#define GC0310_V_BLANKING_L			0x08
-#define GC0310_SH_DELAY				0x11
-
-#define GC0310_START_STREAMING			0x94 /* 8-bit enable */
-#define GC0310_STOP_STREAMING			0x0 /* 8-bit disable */
+#define GC0310_SW_STREAM 0x10
+
+#define GC0310_SC_CMMN_CHIP_ID_H 0xf0
+#define GC0310_SC_CMMN_CHIP_ID_L 0xf1
+
+#define GC0310_AEC_PK_EXPO_H 0x03
+#define GC0310_AEC_PK_EXPO_L 0x04
+#define GC0310_AGC_ADJ 0x48
+#define GC0310_DGC_ADJ 0x71
+#define GC0310_GROUP_ACCESS 0x3208
+
+#define GC0310_H_CROP_START_H 0x09
+#define GC0310_H_CROP_START_L 0x0A
+#define GC0310_V_CROP_START_H 0x0B
+#define GC0310_V_CROP_START_L 0x0C
+#define GC0310_H_OUTSIZE_H 0x0F
+#define GC0310_H_OUTSIZE_L 0x10
+#define GC0310_V_OUTSIZE_H 0x0D
+#define GC0310_V_OUTSIZE_L 0x0E
+#define GC0310_H_BLANKING_H 0x05
+#define GC0310_H_BLANKING_L 0x06
+#define GC0310_V_BLANKING_H 0x07
+#define GC0310_V_BLANKING_L 0x08
+#define GC0310_SH_DELAY 0x11
+
+#define GC0310_START_STREAMING 0x94 /* 8-bit enable */
+#define GC0310_STOP_STREAMING 0x0 /* 8-bit disable */
 
 #define to_gc0310_sensor(x) container_of(x, struct gc0310_device, sd)
 
@@ -236,24 +236,18 @@ static const struct gc0310_reg gc0310_reset_register[] = {
 };
 
 static const struct gc0310_reg gc0310_VGA_30fps[] = {
-	{ 0xfe, 0x00 },
-	{ 0x0d, 0x01 }, /* height */
+	{ 0xfe, 0x00 }, { 0x0d, 0x01 }, /* height */
 	{ 0x0e, 0xf2 }, /* 0xf7 //height */
 	{ 0x0f, 0x02 }, /* width */
 	{ 0x10, 0x94 }, /* 0xa0 //height */
 
 	{ 0x50, 0x01 }, /* crop enable */
-	{ 0x51, 0x00 },
-	{ 0x52, 0x00 },
-	{ 0x53, 0x00 },
-	{ 0x54, 0x01 },
-	{ 0x55, 0x01 }, /* crop window height */
-	{ 0x56, 0xf0 },
-	{ 0x57, 0x02 }, /* crop window width */
+	{ 0x51, 0x00 }, { 0x52, 0x00 }, { 0x53, 0x00 },
+	{ 0x54, 0x01 }, { 0x55, 0x01 }, /* crop window height */
+	{ 0x56, 0xf0 }, { 0x57, 0x02 }, /* crop window width */
 	{ 0x58, 0x90 },
 
-	{ 0xfe, 0x03 },
-	{ 0x12, 0x90 }, /* 00 //04 //00 //04//00 //LWC[7:0]  */
+	{ 0xfe, 0x03 }, { 0x12, 0x90 }, /* 00 //04 //00 //04//00 //LWC[7:0]  */
 	{ 0x13, 0x02 }, /* 05 //05 //LWC[15:8] */
 
 	{ 0xfe, 0x00 },
@@ -271,9 +265,11 @@ static int gc0310_write_reg_array(struct i2c_client *client,
 	int i, err;
 
 	for (i = 0; i < count; i++) {
-		err = i2c_smbus_write_byte_data(client, reglist[i].reg, reglist[i].val);
+		err = i2c_smbus_write_byte_data(client, reglist[i].reg,
+						reglist[i].val);
 		if (err) {
-			dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+			dev_err(&client->dev,
+				"write error: wrote 0x%x to offset 0x%x error %d",
 				reglist[i].val, reglist[i].reg, err);
 			return err;
 		}
@@ -317,8 +313,8 @@ static int gc0310_gain_set(struct gc0310_device *dev, u32 gain)
 
 static int gc0310_s_ctrl(struct v4l2_ctrl *ctrl)
 {
-	struct gc0310_device *dev =
-		container_of(ctrl->handler, struct gc0310_device, ctrls.handler);
+	struct gc0310_device *dev = container_of(
+		ctrl->handler, struct gc0310_device, ctrls.handler);
 	int ret;
 
 	/* Only apply changes to the controls if the device is powered up */
@@ -347,8 +343,8 @@ static const struct v4l2_ctrl_ops ctrl_ops = {
 
 static struct v4l2_mbus_framefmt *
 gc0310_get_pad_format(struct gc0310_device *dev,
-		      struct v4l2_subdev_state *state,
-		      unsigned int pad, enum v4l2_subdev_format_whence which)
+		      struct v4l2_subdev_state *state, unsigned int pad,
+		      enum v4l2_subdev_format_whence which)
 {
 	if (which == V4L2_SUBDEV_FORMAT_TRY)
 		return v4l2_subdev_state_get_format(state, pad);
@@ -402,7 +398,8 @@ static int gc0310_detect(struct i2c_client *client)
 
 	ret = pm_runtime_get_sync(&client->dev);
 	if (ret >= 0)
-		ret = i2c_smbus_read_word_swapped(client, GC0310_SC_CMMN_CHIP_ID_H);
+		ret = i2c_smbus_read_word_swapped(client,
+						  GC0310_SC_CMMN_CHIP_ID_H);
 	pm_runtime_put(&client->dev);
 	if (ret < 0) {
 		dev_err(&client->dev, "read sensor_id failed: %d\n", ret);
@@ -412,7 +409,8 @@ static int gc0310_detect(struct i2c_client *client)
 	dev_dbg(&client->dev, "sensor ID = 0x%x\n", ret);
 
 	if (ret != GC0310_ID) {
-		dev_err(&client->dev, "sensor ID error, read id = 0x%x, target id = 0x%x\n",
+		dev_err(&client->dev,
+			"sensor ID error, read id = 0x%x, target id = 0x%x\n",
 			ret, GC0310_ID);
 		return -ENODEV;
 	}
@@ -459,16 +457,19 @@ static int gc0310_s_stream(struct v4l2_subdev *sd, int enable)
 			goto error_power_down;
 	}
 
-	ret = i2c_smbus_write_byte_data(client, GC0310_RESET_RELATED, GC0310_REGISTER_PAGE_3);
+	ret = i2c_smbus_write_byte_data(client, GC0310_RESET_RELATED,
+					GC0310_REGISTER_PAGE_3);
 	if (ret)
 		goto error_power_down;
 
 	ret = i2c_smbus_write_byte_data(client, GC0310_SW_STREAM,
-					enable ? GC0310_START_STREAMING : GC0310_STOP_STREAMING);
+					enable ? GC0310_START_STREAMING :
+						 GC0310_STOP_STREAMING);
 	if (ret)
 		goto error_power_down;
 
-	ret = i2c_smbus_write_byte_data(client, GC0310_RESET_RELATED, GC0310_REGISTER_PAGE_0);
+	ret = i2c_smbus_write_byte_data(client, GC0310_RESET_RELATED,
+					GC0310_REGISTER_PAGE_0);
 	if (ret)
 		goto error_power_down;
 
@@ -486,9 +487,10 @@ static int gc0310_s_stream(struct v4l2_subdev *sd, int enable)
 	return ret;
 }
 
-static int gc0310_get_frame_interval(struct v4l2_subdev *sd,
-				     struct v4l2_subdev_state *sd_state,
-				     struct v4l2_subdev_frame_interval *interval)
+static int
+gc0310_get_frame_interval(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_frame_interval *interval)
 {
 	/*
 	 * FIXME: Implement support for V4L2_SUBDEV_FORMAT_TRY, using the V4L2
@@ -538,7 +540,7 @@ static int gc0310_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
 }
 
 static const struct v4l2_subdev_sensor_ops gc0310_sensor_ops = {
-	.g_skip_frames	= gc0310_g_skip_frames,
+	.g_skip_frames = gc0310_g_skip_frames,
 };
 
 static const struct v4l2_subdev_video_ops gc0310_video_ops = {
@@ -569,8 +571,8 @@ static int gc0310_init_controls(struct gc0310_device *dev)
 	hdl->lock = &dev->input_lock;
 	dev->sd.ctrl_handler = hdl;
 
-	dev->ctrls.exposure =
-		v4l2_ctrl_new_std(hdl, &ctrl_ops, V4L2_CID_EXPOSURE, 0, 4095, 1, 1023);
+	dev->ctrls.exposure = v4l2_ctrl_new_std(
+		hdl, &ctrl_ops, V4L2_CID_EXPOSURE, 0, 4095, 1, 1023);
 
 	/* 32 steps at base gain 1 + 64 half steps at base gain 2 */
 	dev->ctrls.gain =
@@ -603,9 +605,11 @@ static int gc0310_probe(struct i2c_client *client)
 	 * Sometimes the fwnode graph is initialized by the bridge driver.
 	 * Bridge drivers doing this may also add GPIO mappings, wait for this.
 	 */
-	ep_fwnode = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	ep_fwnode =
+		fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
 	if (!ep_fwnode)
-		return dev_err_probe(&client->dev, -EPROBE_DEFER, "waiting for fwnode graph endpoint\n");
+		return dev_err_probe(&client->dev, -EPROBE_DEFER,
+				     "waiting for fwnode graph endpoint\n");
 
 	fwnode_handle_put(ep_fwnode);
 
@@ -619,7 +623,8 @@ static int gc0310_probe(struct i2c_client *client)
 				     "getting reset GPIO\n");
 	}
 
-	dev->powerdown = devm_gpiod_get(&client->dev, "powerdown", GPIOD_OUT_HIGH);
+	dev->powerdown =
+		devm_gpiod_get(&client->dev, "powerdown", GPIOD_OUT_HIGH);
 	if (IS_ERR(dev->powerdown)) {
 		return dev_err_probe(&client->dev, PTR_ERR(dev->powerdown),
 				     "getting powerdown GPIO\n");
@@ -688,10 +693,11 @@ static int gc0310_resume(struct device *dev)
 	return 0;
 }
 
-static DEFINE_RUNTIME_DEV_PM_OPS(gc0310_pm_ops, gc0310_suspend, gc0310_resume, NULL);
+static DEFINE_RUNTIME_DEV_PM_OPS(gc0310_pm_ops, gc0310_suspend, gc0310_resume,
+				 NULL);
 
 static const struct acpi_device_id gc0310_acpi_match[] = {
-	{"INT0310"},
+	{ "INT0310" },
 	{},
 };
 MODULE_DEVICE_TABLE(acpi, gc0310_acpi_match);
diff --git a/drivers/staging/media/atomisp/i2c/atomisp-gc2235.c b/drivers/staging/media/atomisp/i2c/atomisp-gc2235.c
index 857d7175942cd8ab25612bc819edfcc83ac1c184..8b971ac152a978c99d490defc3cacd1462500362 100644
--- a/drivers/staging/media/atomisp/i2c/atomisp-gc2235.c
+++ b/drivers/staging/media/atomisp/i2c/atomisp-gc2235.c
@@ -26,8 +26,8 @@
 #include "gc2235.h"
 
 /* i2c read/write stuff */
-static int gc2235_read_reg(struct i2c_client *client,
-			   u16 data_length, u16 reg, u16 *val)
+static int gc2235_read_reg(struct i2c_client *client, u16 data_length, u16 reg,
+			   u16 *val)
 {
 	int err;
 	struct i2c_msg msg[2];
@@ -64,8 +64,8 @@ static int gc2235_read_reg(struct i2c_client *client,
 	if (err != 2) {
 		if (err >= 0)
 			err = -EIO;
-		dev_err(&client->dev,
-			"read from offset 0x%x error %d", reg, err);
+		dev_err(&client->dev, "read from offset 0x%x error %d", reg,
+			err);
 		return err;
 	}
 
@@ -92,16 +92,16 @@ static int gc2235_i2c_write(struct i2c_client *client, u16 len, u8 *data)
 	return ret == num_msg ? 0 : -EIO;
 }
 
-static int gc2235_write_reg(struct i2c_client *client, u16 data_length,
-			    u8 reg, u8 val)
+static int gc2235_write_reg(struct i2c_client *client, u16 data_length, u8 reg,
+			    u8 val)
 {
 	int ret;
-	unsigned char data[4] = {0};
+	unsigned char data[4] = { 0 };
 	const u16 len = data_length + sizeof(u8); /* 16-bit address + data */
 
 	if (data_length != GC2235_8BIT) {
-		dev_err(&client->dev,
-			"%s error, invalid data_length\n", __func__);
+		dev_err(&client->dev, "%s error, invalid data_length\n",
+			__func__);
 		return -EINVAL;
 	}
 
@@ -112,8 +112,8 @@ static int gc2235_write_reg(struct i2c_client *client, u16 data_length,
 	ret = gc2235_i2c_write(client, len, data);
 	if (ret)
 		dev_err(&client->dev,
-			"write error: wrote 0x%x to offset 0x%x error %d",
-			val, reg, ret);
+			"write error: wrote 0x%x to offset 0x%x error %d", val,
+			reg, ret);
 
 	return ret;
 }
@@ -199,8 +199,8 @@ static int gc2235_write_reg_array(struct i2c_client *client,
 			}
 			err = __gc2235_buf_reg_array(client, &ctrl, next);
 			if (err) {
-				dev_err(&client->dev, "%s: write error, aborted\n",
-					__func__);
+				dev_err(&client->dev,
+					"%s: write error, aborted\n", __func__);
 				return err;
 			}
 			break;
@@ -222,10 +222,10 @@ static long __gc2235_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
 	expo_coarse_h = coarse_integration >> 8;
 	expo_coarse_l = coarse_integration & 0xff;
 
-	ret = gc2235_write_reg(client, GC2235_8BIT,
-			       GC2235_EXPOSURE_H, expo_coarse_h);
-	ret = gc2235_write_reg(client, GC2235_8BIT,
-			       GC2235_EXPOSURE_L, expo_coarse_l);
+	ret = gc2235_write_reg(client, GC2235_8BIT, GC2235_EXPOSURE_H,
+			       expo_coarse_h);
+	ret = gc2235_write_reg(client, GC2235_8BIT, GC2235_EXPOSURE_L,
+			       expo_coarse_l);
 
 	if (gain <= 0x58) {
 		gain_val = 0x40;
@@ -238,16 +238,16 @@ static long __gc2235_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
 		gain_val = 0xff;
 	}
 
-	ret = gc2235_write_reg(client, GC2235_8BIT,
-			       GC2235_GLOBAL_GAIN, (u8)gain_val);
-	ret = gc2235_write_reg(client, GC2235_8BIT,
-			       GC2235_PRE_GAIN, (u8)gain_val2);
+	ret = gc2235_write_reg(client, GC2235_8BIT, GC2235_GLOBAL_GAIN,
+			       (u8)gain_val);
+	ret = gc2235_write_reg(client, GC2235_8BIT, GC2235_PRE_GAIN,
+			       (u8)gain_val2);
 
 	return ret;
 }
 
-static int gc2235_set_exposure(struct v4l2_subdev *sd, int exposure,
-			       int gain, int digitgain)
+static int gc2235_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
+			       int digitgain)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 	int ret;
@@ -299,15 +299,11 @@ static int gc2235_q_exposure(struct v4l2_subdev *sd, s32 *value)
 	int ret;
 
 	/* get exposure */
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-			      GC2235_EXPOSURE_L,
-			      &reg_v);
+	ret = gc2235_read_reg(client, GC2235_8BIT, GC2235_EXPOSURE_L, &reg_v);
 	if (ret)
 		goto err;
 
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-			      GC2235_EXPOSURE_H,
-			      &reg_v2);
+	ret = gc2235_read_reg(client, GC2235_8BIT, GC2235_EXPOSURE_H, &reg_v2);
 	if (ret)
 		goto err;
 
@@ -321,7 +317,7 @@ static int gc2235_q_exposure(struct v4l2_subdev *sd, s32 *value)
 static int gc2235_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct gc2235_device *dev =
-	    container_of(ctrl->handler, struct gc2235_device, ctrl_handler);
+		container_of(ctrl->handler, struct gc2235_device, ctrl_handler);
 	int ret = 0;
 
 	switch (ctrl->id) {
@@ -335,9 +331,8 @@ static int gc2235_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 	return ret;
 }
 
-static const struct v4l2_ctrl_ops ctrl_ops = {
-	.g_volatile_ctrl = gc2235_g_volatile_ctrl
-};
+static const struct v4l2_ctrl_ops ctrl_ops = { .g_volatile_ctrl =
+						       gc2235_g_volatile_ctrl };
 
 static struct v4l2_ctrl_config gc2235_controls[] = {
 	{
@@ -408,8 +403,7 @@ static int power_up(struct v4l2_subdev *sd)
 	int ret;
 
 	if (!dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
+		dev_err(&client->dev, "no camera_sensor_platform_data");
 		return -ENODEV;
 	}
 	/* power control */
@@ -452,8 +446,7 @@ static int power_down(struct v4l2_subdev *sd)
 	int ret = 0;
 
 	if (!dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
+		dev_err(&client->dev, "no camera_sensor_platform_data");
 		return -ENODEV;
 	}
 	/* gpio ctrl */
@@ -626,8 +619,7 @@ static int gc2235_s_stream(struct v4l2_subdev *sd, int enable)
 	return ret;
 }
 
-static int gc2235_s_config(struct v4l2_subdev *sd,
-			   int irq, void *platform_data)
+static int gc2235_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
@@ -637,7 +629,7 @@ static int gc2235_s_config(struct v4l2_subdev *sd,
 		return -ENODEV;
 
 	dev->platform_data =
-	    (struct camera_sensor_platform_data *)platform_data;
+		(struct camera_sensor_platform_data *)platform_data;
 
 	mutex_lock(&dev->input_lock);
 	/*
@@ -688,9 +680,10 @@ static int gc2235_s_config(struct v4l2_subdev *sd,
 	return ret;
 }
 
-static int gc2235_get_frame_interval(struct v4l2_subdev *sd,
-				     struct v4l2_subdev_state *sd_state,
-				     struct v4l2_subdev_frame_interval *interval)
+static int
+gc2235_get_frame_interval(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_frame_interval *interval)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
@@ -747,7 +740,7 @@ static int gc2235_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
 }
 
 static const struct v4l2_subdev_sensor_ops gc2235_sensor_ops = {
-	.g_skip_frames	= gc2235_g_skip_frames,
+	.g_skip_frames = gc2235_g_skip_frames,
 };
 
 static const struct v4l2_subdev_video_ops gc2235_video_ops = {
@@ -817,9 +810,8 @@ static int gc2235_probe(struct i2c_client *client)
 	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
 	dev->format.code = MEDIA_BUS_FMT_SBGGR10_1X10;
 	dev->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
-	ret =
-	    v4l2_ctrl_handler_init(&dev->ctrl_handler,
-				   ARRAY_SIZE(gc2235_controls));
+	ret = v4l2_ctrl_handler_init(&dev->ctrl_handler,
+				     ARRAY_SIZE(gc2235_controls));
 	if (ret) {
 		gc2235_remove(client);
 		return ret;
diff --git a/drivers/staging/media/atomisp/i2c/atomisp-ov2722.c b/drivers/staging/media/atomisp/i2c/atomisp-ov2722.c
index c7de7800799aad455ca1f291ab00c42ccb49f1aa..63e5cdf50b4c2524a6768758f8c8434c8fb84dce 100644
--- a/drivers/staging/media/atomisp/i2c/atomisp-ov2722.c
+++ b/drivers/staging/media/atomisp/i2c/atomisp-ov2722.c
@@ -26,8 +26,8 @@
 #include "ov2722.h"
 
 /* i2c read/write stuff */
-static int ov2722_read_reg(struct i2c_client *client,
-			   u16 data_length, u16 reg, u16 *val)
+static int ov2722_read_reg(struct i2c_client *client, u16 data_length, u16 reg,
+			   u16 *val)
 {
 	int err;
 	struct i2c_msg msg[2];
@@ -66,8 +66,8 @@ static int ov2722_read_reg(struct i2c_client *client,
 	if (err != 2) {
 		if (err >= 0)
 			err = -EIO;
-		dev_err(&client->dev,
-			"read from offset 0x%x error %d", reg, err);
+		dev_err(&client->dev, "read from offset 0x%x error %d", reg,
+			err);
 		return err;
 	}
 
@@ -98,17 +98,17 @@ static int ov2722_i2c_write(struct i2c_client *client, u16 len, u8 *data)
 	return ret == num_msg ? 0 : -EIO;
 }
 
-static int ov2722_write_reg(struct i2c_client *client, u16 data_length,
-			    u16 reg, u16 val)
+static int ov2722_write_reg(struct i2c_client *client, u16 data_length, u16 reg,
+			    u16 val)
 {
 	int ret;
-	unsigned char data[4] = {0};
+	unsigned char data[4] = { 0 };
 	__be16 *wreg = (__be16 *)data;
 	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
 
 	if (data_length != OV2722_8BIT && data_length != OV2722_16BIT) {
-		dev_err(&client->dev,
-			"%s error, invalid data_length\n", __func__);
+		dev_err(&client->dev, "%s error, invalid data_length\n",
+			__func__);
 		return -EINVAL;
 	}
 
@@ -127,8 +127,8 @@ static int ov2722_write_reg(struct i2c_client *client, u16 data_length,
 	ret = ov2722_i2c_write(client, len, data);
 	if (ret)
 		dev_err(&client->dev,
-			"write error: wrote 0x%x to offset 0x%x error %d",
-			val, reg, ret);
+			"write error: wrote 0x%x to offset 0x%x error %d", val,
+			reg, ret);
 
 	return ret;
 }
@@ -240,8 +240,8 @@ static int ov2722_write_reg_array(struct i2c_client *client,
 			}
 			err = __ov2722_buf_reg_array(client, &ctrl, next);
 			if (err) {
-				dev_err(&client->dev, "%s: write error, aborted\n",
-					__func__);
+				dev_err(&client->dev,
+					"%s: write error, aborted\n", __func__);
 				return err;
 			}
 			break;
@@ -276,54 +276,49 @@ static long __ov2722_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
 	coarse_itg <<= 4;
 	digitgain <<= 2;
 
-	ret = ov2722_write_reg(client, OV2722_16BIT,
-			       OV2722_VTS_H, vts);
+	ret = ov2722_write_reg(client, OV2722_16BIT, OV2722_VTS_H, vts);
 	if (ret)
 		return ret;
 
-	ret = ov2722_write_reg(client, OV2722_16BIT,
-			       OV2722_HTS_H, hts);
+	ret = ov2722_write_reg(client, OV2722_16BIT, OV2722_HTS_H, hts);
 	if (ret)
 		return ret;
 
 	/* set exposure */
-	ret = ov2722_write_reg(client, OV2722_8BIT,
-			       OV2722_AEC_PK_EXPO_L,
+	ret = ov2722_write_reg(client, OV2722_8BIT, OV2722_AEC_PK_EXPO_L,
 			       coarse_itg & 0xff);
 	if (ret)
 		return ret;
 
-	ret = ov2722_write_reg(client, OV2722_16BIT,
-			       OV2722_AEC_PK_EXPO_H,
+	ret = ov2722_write_reg(client, OV2722_16BIT, OV2722_AEC_PK_EXPO_H,
 			       (coarse_itg >> 8) & 0xfff);
 	if (ret)
 		return ret;
 
 	/* set analog gain */
-	ret = ov2722_write_reg(client, OV2722_16BIT,
-			       OV2722_AGC_ADJ_H, gain);
+	ret = ov2722_write_reg(client, OV2722_16BIT, OV2722_AGC_ADJ_H, gain);
 	if (ret)
 		return ret;
 
 	/* set digital gain */
-	ret = ov2722_write_reg(client, OV2722_16BIT,
-			       OV2722_MWB_GAIN_R_H, digitgain);
+	ret = ov2722_write_reg(client, OV2722_16BIT, OV2722_MWB_GAIN_R_H,
+			       digitgain);
 	if (ret)
 		return ret;
 
-	ret = ov2722_write_reg(client, OV2722_16BIT,
-			       OV2722_MWB_GAIN_G_H, digitgain);
+	ret = ov2722_write_reg(client, OV2722_16BIT, OV2722_MWB_GAIN_G_H,
+			       digitgain);
 	if (ret)
 		return ret;
 
-	ret = ov2722_write_reg(client, OV2722_16BIT,
-			       OV2722_MWB_GAIN_B_H, digitgain);
+	ret = ov2722_write_reg(client, OV2722_16BIT, OV2722_MWB_GAIN_B_H,
+			       digitgain);
 
 	return ret;
 }
 
-static int ov2722_set_exposure(struct v4l2_subdev *sd, int exposure,
-			       int gain, int digitgain)
+static int ov2722_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
+			       int digitgain)
 {
 	struct ov2722_device *dev = to_ov2722_sensor(sd);
 	int ret;
@@ -374,21 +369,18 @@ static int ov2722_q_exposure(struct v4l2_subdev *sd, s32 *value)
 	int ret;
 
 	/* get exposure */
-	ret = ov2722_read_reg(client, OV2722_8BIT,
-			      OV2722_AEC_PK_EXPO_L,
+	ret = ov2722_read_reg(client, OV2722_8BIT, OV2722_AEC_PK_EXPO_L,
 			      &reg_v);
 	if (ret)
 		goto err;
 
-	ret = ov2722_read_reg(client, OV2722_8BIT,
-			      OV2722_AEC_PK_EXPO_M,
+	ret = ov2722_read_reg(client, OV2722_8BIT, OV2722_AEC_PK_EXPO_M,
 			      &reg_v2);
 	if (ret)
 		goto err;
 
 	reg_v += reg_v2 << 8;
-	ret = ov2722_read_reg(client, OV2722_8BIT,
-			      OV2722_AEC_PK_EXPO_H,
+	ret = ov2722_read_reg(client, OV2722_8BIT, OV2722_AEC_PK_EXPO_H,
 			      &reg_v2);
 	if (ret)
 		goto err;
@@ -401,7 +393,7 @@ static int ov2722_q_exposure(struct v4l2_subdev *sd, s32 *value)
 static int ov2722_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct ov2722_device *dev =
-	    container_of(ctrl->handler, struct ov2722_device, ctrl_handler);
+		container_of(ctrl->handler, struct ov2722_device, ctrl_handler);
 	int ret = 0;
 	unsigned int val;
 
@@ -414,7 +406,7 @@ static int ov2722_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 		if (val == 0)
 			return -EINVAL;
 
-		ctrl->val = val * 1000;	/* To Hz */
+		ctrl->val = val * 1000; /* To Hz */
 		break;
 	default:
 		ret = -EINVAL;
@@ -423,9 +415,8 @@ static int ov2722_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 	return ret;
 }
 
-static const struct v4l2_ctrl_ops ctrl_ops = {
-	.g_volatile_ctrl = ov2722_g_volatile_ctrl
-};
+static const struct v4l2_ctrl_ops ctrl_ops = { .g_volatile_ctrl =
+						       ov2722_g_volatile_ctrl };
 
 static const struct v4l2_ctrl_config ov2722_controls[] = {
 	{
@@ -513,8 +504,7 @@ static int power_up(struct v4l2_subdev *sd)
 	int ret;
 
 	if (!dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
+		dev_err(&client->dev, "no camera_sensor_platform_data");
 		return -ENODEV;
 	}
 
@@ -560,8 +550,7 @@ static int power_down(struct v4l2_subdev *sd)
 	int ret = 0;
 
 	if (!dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
+		dev_err(&client->dev, "no camera_sensor_platform_data");
 		return -ENODEV;
 	}
 
@@ -606,8 +595,7 @@ static int startup(struct v4l2_subdev *sd)
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret = 0;
 
-	ret = ov2722_write_reg(client, OV2722_8BIT,
-			       OV2722_SW_RESET, 0x01);
+	ret = ov2722_write_reg(client, OV2722_8BIT, OV2722_SW_RESET, 0x01);
 	if (ret) {
 		dev_err(&client->dev, "ov2722 reset err.\n");
 		return ret;
@@ -666,7 +654,8 @@ static int ov2722_set_fmt(struct v4l2_subdev *sd,
 	if (ret) {
 		int i = 0;
 
-		dev_err(&client->dev, "ov2722 startup err, retry to power up\n");
+		dev_err(&client->dev,
+			"ov2722 startup err, retry to power up\n");
 		for (i = 0; i < OV2722_POWER_UP_RETRY_NUM; i++) {
 			dev_err(&client->dev,
 				"ov2722 retry to power up %d/%d times, result: ",
@@ -674,7 +663,8 @@ static int ov2722_set_fmt(struct v4l2_subdev *sd,
 			power_down(sd);
 			ret = power_up(sd);
 			if (ret) {
-				dev_err(&client->dev, "power up failed, continue\n");
+				dev_err(&client->dev,
+					"power up failed, continue\n");
 				continue;
 			}
 			ret = startup(sd);
@@ -725,10 +715,8 @@ static int ov2722_detect(struct i2c_client *client)
 	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
 		return -ENODEV;
 
-	ov2722_read_reg(client, OV2722_8BIT,
-			OV2722_SC_CMMN_CHIP_ID_H, &high);
-	ov2722_read_reg(client, OV2722_8BIT,
-			OV2722_SC_CMMN_CHIP_ID_L, &low);
+	ov2722_read_reg(client, OV2722_8BIT, OV2722_SC_CMMN_CHIP_ID_H, &high);
+	ov2722_read_reg(client, OV2722_8BIT, OV2722_SC_CMMN_CHIP_ID_L, &low);
 	id = (high << 8) | low;
 
 	if ((id != OV2722_ID) && (id != OV2720_ID)) {
@@ -737,8 +725,7 @@ static int ov2722_detect(struct i2c_client *client)
 	}
 
 	high = 0;
-	ov2722_read_reg(client, OV2722_8BIT,
-			OV2722_SC_CMMN_SUB_ID, &high);
+	ov2722_read_reg(client, OV2722_8BIT, OV2722_SC_CMMN_SUB_ID, &high);
 	revision = (u8)high & 0x0f;
 
 	dev_dbg(&client->dev, "sensor_revision = 0x%x\n", revision);
@@ -756,14 +743,13 @@ static int ov2722_s_stream(struct v4l2_subdev *sd, int enable)
 
 	ret = ov2722_write_reg(client, OV2722_8BIT, OV2722_SW_STREAM,
 			       enable ? OV2722_START_STREAMING :
-			       OV2722_STOP_STREAMING);
+					OV2722_STOP_STREAMING);
 
 	mutex_unlock(&dev->input_lock);
 	return ret;
 }
 
-static int ov2722_s_config(struct v4l2_subdev *sd,
-			   int irq, void *platform_data)
+static int ov2722_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
 {
 	struct ov2722_device *dev = to_ov2722_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
@@ -773,7 +759,7 @@ static int ov2722_s_config(struct v4l2_subdev *sd,
 		return -ENODEV;
 
 	dev->platform_data =
-	    (struct camera_sensor_platform_data *)platform_data;
+		(struct camera_sensor_platform_data *)platform_data;
 
 	mutex_lock(&dev->input_lock);
 
@@ -824,9 +810,10 @@ static int ov2722_s_config(struct v4l2_subdev *sd,
 	return ret;
 }
 
-static int ov2722_get_frame_interval(struct v4l2_subdev *sd,
-				     struct v4l2_subdev_state *sd_state,
-				     struct v4l2_subdev_frame_interval *interval)
+static int
+ov2722_get_frame_interval(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_frame_interval *interval)
 {
 	struct ov2722_device *dev = to_ov2722_sensor(sd);
 
@@ -883,7 +870,7 @@ static int ov2722_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
 }
 
 static const struct v4l2_subdev_sensor_ops ov2722_sensor_ops = {
-	.g_skip_frames	= ov2722_g_skip_frames,
+	.g_skip_frames = ov2722_g_skip_frames,
 };
 
 static const struct v4l2_subdev_video_ops ov2722_video_ops = {
diff --git a/drivers/staging/media/atomisp/i2c/gc2235.h b/drivers/staging/media/atomisp/i2c/gc2235.h
index 6c743a17f198be5f87e4088b8f92f73627ad5e47..62f55382730b26ab8e5faf4b82bedf03ec51ee51 100644
--- a/drivers/staging/media/atomisp/i2c/gc2235.h
+++ b/drivers/staging/media/atomisp/i2c/gc2235.h
@@ -24,15 +24,15 @@
 /*
  * FIXME: non-preview resolutions are currently broken
  */
-#define ENABLE_NON_PREVIEW     0
+#define ENABLE_NON_PREVIEW 0
 
 /* Defines for register writes and register array processing */
-#define I2C_MSG_LENGTH		0x2
-#define I2C_RETRY_COUNT		5
+#define I2C_MSG_LENGTH 0x2
+#define I2C_RETRY_COUNT 5
 
-#define GC2235_FOCAL_LENGTH_NUM	278	/*2.78mm*/
+#define GC2235_FOCAL_LENGTH_NUM 278 /*2.78mm*/
 
-#define MAX_FMTS		1
+#define MAX_FMTS 1
 
 /*
  * focal length bits definition:
@@ -54,7 +54,7 @@
  * bits 7-0: min f-number denominator
  */
 #define GC2235_F_NUMBER_RANGE 0x1a0a1a0a
-#define GC2235_ID	0x2235
+#define GC2235_ID 0x2235
 
 #define GC2235_FINE_INTG_TIME_MIN 0
 #define GC2235_FINE_INTG_TIME_MAX_MARGIN 0
@@ -64,43 +64,43 @@
 /*
  * GC2235 System control registers
  */
-#define GC2235_SENSOR_ID_H		0xF0
-#define GC2235_SENSOR_ID_L		0xF1
-#define GC2235_RESET_RELATED		0xFE
-#define GC2235_SW_RESET			0x8
-#define GC2235_MIPI_RESET		0x3
-#define GC2235_RESET_BIT		0x4
-#define GC2235_REGISTER_PAGE_0		0x0
-#define GC2235_REGISTER_PAGE_3		0x3
-
-#define GC2235_V_CROP_START_H		0x91
-#define GC2235_V_CROP_START_L		0x92
-#define GC2235_H_CROP_START_H		0x93
-#define GC2235_H_CROP_START_L		0x94
-#define GC2235_V_OUTSIZE_H		0x95
-#define GC2235_V_OUTSIZE_L		0x96
-#define GC2235_H_OUTSIZE_H		0x97
-#define GC2235_H_OUTSIZE_L		0x98
-
-#define GC2235_HB_H			0x5
-#define GC2235_HB_L			0x6
-#define GC2235_VB_H			0x7
-#define GC2235_VB_L			0x8
-#define GC2235_SH_DELAY_H		0x11
-#define GC2235_SH_DELAY_L		0x12
-
-#define GC2235_CSI2_MODE		0x10
-
-#define GC2235_EXPOSURE_H		0x3
-#define GC2235_EXPOSURE_L		0x4
-#define GC2235_GLOBAL_GAIN		0xB0
-#define GC2235_PRE_GAIN			0xB1
-#define GC2235_AWB_R_GAIN		0xB3
-#define GC2235_AWB_G_GAIN		0xB4
-#define GC2235_AWB_B_GAIN		0xB5
-
-#define GC2235_START_STREAMING		0x91
-#define GC2235_STOP_STREAMING		0x0
+#define GC2235_SENSOR_ID_H 0xF0
+#define GC2235_SENSOR_ID_L 0xF1
+#define GC2235_RESET_RELATED 0xFE
+#define GC2235_SW_RESET 0x8
+#define GC2235_MIPI_RESET 0x3
+#define GC2235_RESET_BIT 0x4
+#define GC2235_REGISTER_PAGE_0 0x0
+#define GC2235_REGISTER_PAGE_3 0x3
+
+#define GC2235_V_CROP_START_H 0x91
+#define GC2235_V_CROP_START_L 0x92
+#define GC2235_H_CROP_START_H 0x93
+#define GC2235_H_CROP_START_L 0x94
+#define GC2235_V_OUTSIZE_H 0x95
+#define GC2235_V_OUTSIZE_L 0x96
+#define GC2235_H_OUTSIZE_H 0x97
+#define GC2235_H_OUTSIZE_L 0x98
+
+#define GC2235_HB_H 0x5
+#define GC2235_HB_L 0x6
+#define GC2235_VB_H 0x7
+#define GC2235_VB_L 0x8
+#define GC2235_SH_DELAY_H 0x11
+#define GC2235_SH_DELAY_L 0x12
+
+#define GC2235_CSI2_MODE 0x10
+
+#define GC2235_EXPOSURE_H 0x3
+#define GC2235_EXPOSURE_L 0x4
+#define GC2235_GLOBAL_GAIN 0xB0
+#define GC2235_PRE_GAIN 0xB1
+#define GC2235_AWB_R_GAIN 0xB3
+#define GC2235_AWB_G_GAIN 0xB4
+#define GC2235_AWB_B_GAIN 0xB5
+
+#define GC2235_START_STREAMING 0x91
+#define GC2235_STOP_STREAMING 0x0
 
 struct regval_list {
 	u16 reg_num;
@@ -143,11 +143,11 @@ struct gc2235_device {
 };
 
 enum gc2235_tok_type {
-	GC2235_8BIT  = 0x0001,
+	GC2235_8BIT = 0x0001,
 	GC2235_16BIT = 0x0002,
 	GC2235_32BIT = 0x0004,
-	GC2235_TOK_TERM   = 0xf000,	/* terminating token for reg list */
-	GC2235_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	GC2235_TOK_TERM = 0xf000, /* terminating token for reg list */
+	GC2235_TOK_DELAY = 0xfe00, /* delay token for reg list */
 	GC2235_TOK_MASK = 0xfff0
 };
 
@@ -162,12 +162,12 @@ enum gc2235_tok_type {
 struct gc2235_reg {
 	enum gc2235_tok_type type;
 	u8 reg;
-	u32 val;	/* @set value for read/mod/write, @mask */
+	u32 val; /* @set value for read/mod/write, @mask */
 };
 
 #define to_gc2235_sensor(x) container_of(x, struct gc2235_device, sd)
 
-#define GC2235_MAX_WRITE_BUF_SIZE	30
+#define GC2235_MAX_WRITE_BUF_SIZE 30
 
 struct gc2235_write_buffer {
 	u8 addr;
@@ -180,16 +180,16 @@ struct gc2235_write_ctrl {
 };
 
 static struct gc2235_reg const gc2235_stream_on[] = {
-	{ GC2235_8BIT, 0xfe, 0x03}, /* switch to P3 */
-	{ GC2235_8BIT, 0x10, 0x91}, /* start mipi */
-	{ GC2235_8BIT, 0xfe, 0x00}, /* switch to P0 */
+	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
+	{ GC2235_8BIT, 0x10, 0x91 }, /* start mipi */
+	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
 	{ GC2235_TOK_TERM, 0, 0 }
 };
 
 static struct gc2235_reg const gc2235_stream_off[] = {
-	{ GC2235_8BIT, 0xfe, 0x03}, /* switch to P3 */
-	{ GC2235_8BIT, 0x10, 0x01}, /* stop mipi */
-	{ GC2235_8BIT, 0xfe, 0x00}, /* switch to P0 */
+	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
+	{ GC2235_8BIT, 0x10, 0x01 }, /* stop mipi */
+	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
 	{ GC2235_TOK_TERM, 0, 0 }
 };
 
diff --git a/drivers/staging/media/atomisp/i2c/ov2722.h b/drivers/staging/media/atomisp/i2c/ov2722.h
index bc36133f3722229da9a31c769ad5199a6cd5195a..6a1c1754aa096ccf4e21f88881d825683ed2eb5d 100644
--- a/drivers/staging/media/atomisp/i2c/ov2722.h
+++ b/drivers/staging/media/atomisp/i2c/ov2722.h
@@ -24,12 +24,12 @@
 #define OV2722_POWER_UP_RETRY_NUM 5
 
 /* Defines for register writes and register array processing */
-#define I2C_MSG_LENGTH		0x2
-#define I2C_RETRY_COUNT		5
+#define I2C_MSG_LENGTH 0x2
+#define I2C_RETRY_COUNT 5
 
-#define OV2722_FOCAL_LENGTH_NUM	278	/*2.78mm*/
+#define OV2722_FOCAL_LENGTH_NUM 278 /*2.78mm*/
 
-#define MAX_FMTS		1
+#define MAX_FMTS 1
 
 /*
  * focal length bits definition:
@@ -51,8 +51,8 @@
  * bits 7-0: min f-number denominator
  */
 #define OV2722_F_NUMBER_RANGE 0x1a0a1a0a
-#define OV2720_ID	0x2720
-#define OV2722_ID	0x2722
+#define OV2720_ID 0x2720
+#define OV2722_ID 0x2722
 
 #define OV2722_FINE_INTG_TIME_MIN 0
 #define OV2722_FINE_INTG_TIME_MAX_MARGIN 0
@@ -62,93 +62,93 @@
 /*
  * OV2722 System control registers
  */
-#define OV2722_SW_SLEEP				0x0100
-#define OV2722_SW_RESET				0x0103
-#define OV2722_SW_STREAM			0x0100
+#define OV2722_SW_SLEEP 0x0100
+#define OV2722_SW_RESET 0x0103
+#define OV2722_SW_STREAM 0x0100
 
-#define OV2722_SC_CMMN_CHIP_ID_H		0x300A
-#define OV2722_SC_CMMN_CHIP_ID_L		0x300B
-#define OV2722_SC_CMMN_SCCB_ID			0x300C
-#define OV2722_SC_CMMN_SUB_ID			0x302A /* process, version*/
+#define OV2722_SC_CMMN_CHIP_ID_H 0x300A
+#define OV2722_SC_CMMN_CHIP_ID_L 0x300B
+#define OV2722_SC_CMMN_SCCB_ID 0x300C
+#define OV2722_SC_CMMN_SUB_ID 0x302A /* process, version*/
 
-#define OV2722_SC_CMMN_PAD_OEN0			0x3000
-#define OV2722_SC_CMMN_PAD_OEN1			0x3001
-#define OV2722_SC_CMMN_PAD_OEN2			0x3002
-#define OV2722_SC_CMMN_PAD_OUT0			0x3008
-#define OV2722_SC_CMMN_PAD_OUT1			0x3009
-#define OV2722_SC_CMMN_PAD_OUT2			0x300D
-#define OV2722_SC_CMMN_PAD_SEL0			0x300E
-#define OV2722_SC_CMMN_PAD_SEL1			0x300F
-#define OV2722_SC_CMMN_PAD_SEL2			0x3010
+#define OV2722_SC_CMMN_PAD_OEN0 0x3000
+#define OV2722_SC_CMMN_PAD_OEN1 0x3001
+#define OV2722_SC_CMMN_PAD_OEN2 0x3002
+#define OV2722_SC_CMMN_PAD_OUT0 0x3008
+#define OV2722_SC_CMMN_PAD_OUT1 0x3009
+#define OV2722_SC_CMMN_PAD_OUT2 0x300D
+#define OV2722_SC_CMMN_PAD_SEL0 0x300E
+#define OV2722_SC_CMMN_PAD_SEL1 0x300F
+#define OV2722_SC_CMMN_PAD_SEL2 0x3010
 
-#define OV2722_SC_CMMN_PAD_PK			0x3011
-#define OV2722_SC_CMMN_A_PWC_PK_O_13		0x3013
-#define OV2722_SC_CMMN_A_PWC_PK_O_14		0x3014
+#define OV2722_SC_CMMN_PAD_PK 0x3011
+#define OV2722_SC_CMMN_A_PWC_PK_O_13 0x3013
+#define OV2722_SC_CMMN_A_PWC_PK_O_14 0x3014
 
-#define OV2722_SC_CMMN_CLKRST0			0x301A
-#define OV2722_SC_CMMN_CLKRST1			0x301B
-#define OV2722_SC_CMMN_CLKRST2			0x301C
-#define OV2722_SC_CMMN_CLKRST3			0x301D
-#define OV2722_SC_CMMN_CLKRST4			0x301E
-#define OV2722_SC_CMMN_CLKRST5			0x3005
-#define OV2722_SC_CMMN_PCLK_DIV_CTRL		0x3007
-#define OV2722_SC_CMMN_CLOCK_SEL		0x3020
-#define OV2722_SC_SOC_CLKRST5			0x3040
+#define OV2722_SC_CMMN_CLKRST0 0x301A
+#define OV2722_SC_CMMN_CLKRST1 0x301B
+#define OV2722_SC_CMMN_CLKRST2 0x301C
+#define OV2722_SC_CMMN_CLKRST3 0x301D
+#define OV2722_SC_CMMN_CLKRST4 0x301E
+#define OV2722_SC_CMMN_CLKRST5 0x3005
+#define OV2722_SC_CMMN_PCLK_DIV_CTRL 0x3007
+#define OV2722_SC_CMMN_CLOCK_SEL 0x3020
+#define OV2722_SC_SOC_CLKRST5 0x3040
 
-#define OV2722_SC_CMMN_PLL_CTRL0		0x3034
-#define OV2722_SC_CMMN_PLL_CTRL1		0x3035
-#define OV2722_SC_CMMN_PLL_CTRL2		0x3039
-#define OV2722_SC_CMMN_PLL_CTRL3		0x3037
-#define OV2722_SC_CMMN_PLL_MULTIPLIER		0x3036
-#define OV2722_SC_CMMN_PLL_DEBUG_OPT		0x3038
-#define OV2722_SC_CMMN_PLLS_CTRL0		0x303A
-#define OV2722_SC_CMMN_PLLS_CTRL1		0x303B
-#define OV2722_SC_CMMN_PLLS_CTRL2		0x303C
-#define OV2722_SC_CMMN_PLLS_CTRL3		0x303D
+#define OV2722_SC_CMMN_PLL_CTRL0 0x3034
+#define OV2722_SC_CMMN_PLL_CTRL1 0x3035
+#define OV2722_SC_CMMN_PLL_CTRL2 0x3039
+#define OV2722_SC_CMMN_PLL_CTRL3 0x3037
+#define OV2722_SC_CMMN_PLL_MULTIPLIER 0x3036
+#define OV2722_SC_CMMN_PLL_DEBUG_OPT 0x3038
+#define OV2722_SC_CMMN_PLLS_CTRL0 0x303A
+#define OV2722_SC_CMMN_PLLS_CTRL1 0x303B
+#define OV2722_SC_CMMN_PLLS_CTRL2 0x303C
+#define OV2722_SC_CMMN_PLLS_CTRL3 0x303D
 
-#define OV2722_SC_CMMN_MIPI_PHY_16		0x3016
-#define OV2722_SC_CMMN_MIPI_PHY_17		0x3017
-#define OV2722_SC_CMMN_MIPI_SC_CTRL_18		0x3018
-#define OV2722_SC_CMMN_MIPI_SC_CTRL_19		0x3019
-#define OV2722_SC_CMMN_MIPI_SC_CTRL_21		0x3021
-#define OV2722_SC_CMMN_MIPI_SC_CTRL_22		0x3022
+#define OV2722_SC_CMMN_MIPI_PHY_16 0x3016
+#define OV2722_SC_CMMN_MIPI_PHY_17 0x3017
+#define OV2722_SC_CMMN_MIPI_SC_CTRL_18 0x3018
+#define OV2722_SC_CMMN_MIPI_SC_CTRL_19 0x3019
+#define OV2722_SC_CMMN_MIPI_SC_CTRL_21 0x3021
+#define OV2722_SC_CMMN_MIPI_SC_CTRL_22 0x3022
 
-#define OV2722_AEC_PK_EXPO_H			0x3500
-#define OV2722_AEC_PK_EXPO_M			0x3501
-#define OV2722_AEC_PK_EXPO_L			0x3502
-#define OV2722_AEC_MANUAL_CTRL			0x3503
-#define OV2722_AGC_ADJ_H			0x3508
-#define OV2722_AGC_ADJ_L			0x3509
-#define OV2722_VTS_DIFF_H			0x350c
-#define OV2722_VTS_DIFF_L			0x350d
-#define OV2722_GROUP_ACCESS			0x3208
-#define OV2722_HTS_H				0x380c
-#define OV2722_HTS_L				0x380d
-#define OV2722_VTS_H				0x380e
-#define OV2722_VTS_L				0x380f
+#define OV2722_AEC_PK_EXPO_H 0x3500
+#define OV2722_AEC_PK_EXPO_M 0x3501
+#define OV2722_AEC_PK_EXPO_L 0x3502
+#define OV2722_AEC_MANUAL_CTRL 0x3503
+#define OV2722_AGC_ADJ_H 0x3508
+#define OV2722_AGC_ADJ_L 0x3509
+#define OV2722_VTS_DIFF_H 0x350c
+#define OV2722_VTS_DIFF_L 0x350d
+#define OV2722_GROUP_ACCESS 0x3208
+#define OV2722_HTS_H 0x380c
+#define OV2722_HTS_L 0x380d
+#define OV2722_VTS_H 0x380e
+#define OV2722_VTS_L 0x380f
 
-#define OV2722_MWB_GAIN_R_H			0x5186
-#define OV2722_MWB_GAIN_R_L			0x5187
-#define OV2722_MWB_GAIN_G_H			0x5188
-#define OV2722_MWB_GAIN_G_L			0x5189
-#define OV2722_MWB_GAIN_B_H			0x518a
-#define OV2722_MWB_GAIN_B_L			0x518b
+#define OV2722_MWB_GAIN_R_H 0x5186
+#define OV2722_MWB_GAIN_R_L 0x5187
+#define OV2722_MWB_GAIN_G_H 0x5188
+#define OV2722_MWB_GAIN_G_L 0x5189
+#define OV2722_MWB_GAIN_B_H 0x518a
+#define OV2722_MWB_GAIN_B_L 0x518b
 
-#define OV2722_H_CROP_START_H			0x3800
-#define OV2722_H_CROP_START_L			0x3801
-#define OV2722_V_CROP_START_H			0x3802
-#define OV2722_V_CROP_START_L			0x3803
-#define OV2722_H_CROP_END_H			0x3804
-#define OV2722_H_CROP_END_L			0x3805
-#define OV2722_V_CROP_END_H			0x3806
-#define OV2722_V_CROP_END_L			0x3807
-#define OV2722_H_OUTSIZE_H			0x3808
-#define OV2722_H_OUTSIZE_L			0x3809
-#define OV2722_V_OUTSIZE_H			0x380a
-#define OV2722_V_OUTSIZE_L			0x380b
+#define OV2722_H_CROP_START_H 0x3800
+#define OV2722_H_CROP_START_L 0x3801
+#define OV2722_V_CROP_START_H 0x3802
+#define OV2722_V_CROP_START_L 0x3803
+#define OV2722_H_CROP_END_H 0x3804
+#define OV2722_H_CROP_END_L 0x3805
+#define OV2722_V_CROP_END_H 0x3806
+#define OV2722_V_CROP_END_L 0x3807
+#define OV2722_H_OUTSIZE_H 0x3808
+#define OV2722_H_OUTSIZE_L 0x3809
+#define OV2722_V_OUTSIZE_H 0x380a
+#define OV2722_V_OUTSIZE_L 0x380b
 
-#define OV2722_START_STREAMING			0x01
-#define OV2722_STOP_STREAMING			0x00
+#define OV2722_START_STREAMING 0x01
+#define OV2722_STOP_STREAMING 0x00
 
 struct regval_list {
 	u16 reg_num;
@@ -196,11 +196,11 @@ struct ov2722_device {
 };
 
 enum ov2722_tok_type {
-	OV2722_8BIT  = 0x0001,
+	OV2722_8BIT = 0x0001,
 	OV2722_16BIT = 0x0002,
 	OV2722_32BIT = 0x0004,
-	OV2722_TOK_TERM   = 0xf000,	/* terminating token for reg list */
-	OV2722_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	OV2722_TOK_TERM = 0xf000, /* terminating token for reg list */
+	OV2722_TOK_DELAY = 0xfe00, /* delay token for reg list */
 	OV2722_TOK_MASK = 0xfff0
 };
 
@@ -215,12 +215,12 @@ enum ov2722_tok_type {
 struct ov2722_reg {
 	enum ov2722_tok_type type;
 	u16 reg;
-	u32 val;	/* @set value for read/mod/write, @mask */
+	u32 val; /* @set value for read/mod/write, @mask */
 };
 
 #define to_ov2722_sensor(x) container_of(x, struct ov2722_device, sd)
 
-#define OV2722_MAX_WRITE_BUF_SIZE	30
+#define OV2722_MAX_WRITE_BUF_SIZE 30
 
 struct ov2722_write_buffer {
 	u16 addr;
@@ -566,206 +566,206 @@ static struct ov2722_reg const ov2722_VGA_30fps[] = {
 #endif
 
 static struct ov2722_reg const ov2722_1632_1092_30fps[] = {
-	{OV2722_8BIT, 0x3021, 0x03}, /* For stand wait for
+	{ OV2722_8BIT, 0x3021, 0x03 }, /* For stand wait for
 				a whole frame complete.(vblank) */
-	{OV2722_8BIT, 0x3718, 0x10},
-	{OV2722_8BIT, 0x3702, 0x24},
-	{OV2722_8BIT, 0x373a, 0x60},
-	{OV2722_8BIT, 0x3715, 0x01},
-	{OV2722_8BIT, 0x3703, 0x2e},
-	{OV2722_8BIT, 0x3705, 0x10},
-	{OV2722_8BIT, 0x3730, 0x30},
-	{OV2722_8BIT, 0x3704, 0x62},
-	{OV2722_8BIT, 0x3f06, 0x3a},
-	{OV2722_8BIT, 0x371c, 0x00},
-	{OV2722_8BIT, 0x371d, 0xc4},
-	{OV2722_8BIT, 0x371e, 0x01},
-	{OV2722_8BIT, 0x371f, 0x0d},
-	{OV2722_8BIT, 0x3708, 0x61},
-	{OV2722_8BIT, 0x3709, 0x12},
-	{OV2722_8BIT, 0x3800, 0x00},
-	{OV2722_8BIT, 0x3801, 0x9E}, /* H crop start: 158 */
-	{OV2722_8BIT, 0x3802, 0x00},
-	{OV2722_8BIT, 0x3803, 0x01}, /* V crop start: 1 */
-	{OV2722_8BIT, 0x3804, 0x07},
-	{OV2722_8BIT, 0x3805, 0x05}, /* H crop end: 1797 */
-	{OV2722_8BIT, 0x3806, 0x04},
-	{OV2722_8BIT, 0x3807, 0x45}, /* V crop end: 1093 */
+	{ OV2722_8BIT, 0x3718, 0x10 },
+	{ OV2722_8BIT, 0x3702, 0x24 },
+	{ OV2722_8BIT, 0x373a, 0x60 },
+	{ OV2722_8BIT, 0x3715, 0x01 },
+	{ OV2722_8BIT, 0x3703, 0x2e },
+	{ OV2722_8BIT, 0x3705, 0x10 },
+	{ OV2722_8BIT, 0x3730, 0x30 },
+	{ OV2722_8BIT, 0x3704, 0x62 },
+	{ OV2722_8BIT, 0x3f06, 0x3a },
+	{ OV2722_8BIT, 0x371c, 0x00 },
+	{ OV2722_8BIT, 0x371d, 0xc4 },
+	{ OV2722_8BIT, 0x371e, 0x01 },
+	{ OV2722_8BIT, 0x371f, 0x0d },
+	{ OV2722_8BIT, 0x3708, 0x61 },
+	{ OV2722_8BIT, 0x3709, 0x12 },
+	{ OV2722_8BIT, 0x3800, 0x00 },
+	{ OV2722_8BIT, 0x3801, 0x9E }, /* H crop start: 158 */
+	{ OV2722_8BIT, 0x3802, 0x00 },
+	{ OV2722_8BIT, 0x3803, 0x01 }, /* V crop start: 1 */
+	{ OV2722_8BIT, 0x3804, 0x07 },
+	{ OV2722_8BIT, 0x3805, 0x05 }, /* H crop end: 1797 */
+	{ OV2722_8BIT, 0x3806, 0x04 },
+	{ OV2722_8BIT, 0x3807, 0x45 }, /* V crop end: 1093 */
 
-	{OV2722_8BIT, 0x3808, 0x06},
-	{OV2722_8BIT, 0x3809, 0x60}, /* H output size: 1632 */
-	{OV2722_8BIT, 0x380a, 0x04},
-	{OV2722_8BIT, 0x380b, 0x44}, /* V output size: 1092 */
-	{OV2722_8BIT, 0x380c, 0x08},
-	{OV2722_8BIT, 0x380d, 0xd4}, /* H timing: 2260 */
-	{OV2722_8BIT, 0x380e, 0x04},
-	{OV2722_8BIT, 0x380f, 0xdc}, /* V timing: 1244 */
-	{OV2722_8BIT, 0x3810, 0x00},
-	{OV2722_8BIT, 0x3811, 0x03}, /* H window offset: 3 */
-	{OV2722_8BIT, 0x3812, 0x00},
-	{OV2722_8BIT, 0x3813, 0x02}, /* V window offset: 2 */
-	{OV2722_8BIT, 0x3820, 0x80},
-	{OV2722_8BIT, 0x3821, 0x06}, /*  mirror */
-	{OV2722_8BIT, 0x3814, 0x11},
-	{OV2722_8BIT, 0x3815, 0x11},
-	{OV2722_8BIT, 0x3612, 0x0b},
-	{OV2722_8BIT, 0x3618, 0x04},
-	{OV2722_8BIT, 0x3a08, 0x01},
-	{OV2722_8BIT, 0x3a09, 0x50},
-	{OV2722_8BIT, 0x3a0a, 0x01},
-	{OV2722_8BIT, 0x3a0b, 0x18},
-	{OV2722_8BIT, 0x3a0d, 0x03},
-	{OV2722_8BIT, 0x3a0e, 0x03},
-	{OV2722_8BIT, 0x4520, 0x00},
-	{OV2722_8BIT, 0x4837, 0x1b},
-	{OV2722_8BIT, 0x3600, 0x08},
-	{OV2722_8BIT, 0x3621, 0xc0},
-	{OV2722_8BIT, 0x3632, 0xd2}, /* added for power opt */
-	{OV2722_8BIT, 0x3633, 0x23},
-	{OV2722_8BIT, 0x3634, 0x54},
-	{OV2722_8BIT, 0x3f01, 0x0c},
-	{OV2722_8BIT, 0x5001, 0xc1},
-	{OV2722_8BIT, 0x3614, 0xf0},
-	{OV2722_8BIT, 0x3630, 0x2d},
-	{OV2722_8BIT, 0x370b, 0x62},
-	{OV2722_8BIT, 0x3706, 0x61},
-	{OV2722_8BIT, 0x4000, 0x02},
-	{OV2722_8BIT, 0x4002, 0xc5},
-	{OV2722_8BIT, 0x4005, 0x08},
-	{OV2722_8BIT, 0x404f, 0x84},
-	{OV2722_8BIT, 0x4051, 0x00},
-	{OV2722_8BIT, 0x5000, 0xcf}, /* manual 3a */
-	{OV2722_8BIT, 0x301d, 0xf0}, /* enable group hold */
-	{OV2722_8BIT, 0x3a18, 0x00},
-	{OV2722_8BIT, 0x3a19, 0x80},
-	{OV2722_8BIT, 0x4521, 0x00},
-	{OV2722_8BIT, 0x5183, 0xb0},
-	{OV2722_8BIT, 0x5184, 0xb0},
-	{OV2722_8BIT, 0x5185, 0xb0},
-	{OV2722_8BIT, 0x370c, 0x0c},
-	{OV2722_8BIT, 0x3035, 0x00},
-	{OV2722_8BIT, 0x3036, 0x2c}, /* 422.4 MHz */
-	{OV2722_8BIT, 0x3037, 0xa1},
-	{OV2722_8BIT, 0x303e, 0x19},
-	{OV2722_8BIT, 0x3038, 0x06},
-	{OV2722_8BIT, 0x3018, 0x04},
-	{OV2722_8BIT, 0x3000, 0x00}, /* added for power optimization */
-	{OV2722_8BIT, 0x3001, 0x00},
-	{OV2722_8BIT, 0x3002, 0x00},
-	{OV2722_8BIT, 0x3a0f, 0x40},
-	{OV2722_8BIT, 0x3a10, 0x38},
-	{OV2722_8BIT, 0x3a1b, 0x48},
-	{OV2722_8BIT, 0x3a1e, 0x30},
-	{OV2722_8BIT, 0x3a11, 0x90},
-	{OV2722_8BIT, 0x3a1f, 0x10},
-	{OV2722_8BIT, 0x3503, 0x17}, /* manual 3a */
-	{OV2722_8BIT, 0x3500, 0x00},
-	{OV2722_8BIT, 0x3501, 0x3F},
-	{OV2722_8BIT, 0x3502, 0x00},
-	{OV2722_8BIT, 0x3508, 0x00},
-	{OV2722_8BIT, 0x3509, 0x00},
-	{OV2722_TOK_TERM, 0, 0}
+	{ OV2722_8BIT, 0x3808, 0x06 },
+	{ OV2722_8BIT, 0x3809, 0x60 }, /* H output size: 1632 */
+	{ OV2722_8BIT, 0x380a, 0x04 },
+	{ OV2722_8BIT, 0x380b, 0x44 }, /* V output size: 1092 */
+	{ OV2722_8BIT, 0x380c, 0x08 },
+	{ OV2722_8BIT, 0x380d, 0xd4 }, /* H timing: 2260 */
+	{ OV2722_8BIT, 0x380e, 0x04 },
+	{ OV2722_8BIT, 0x380f, 0xdc }, /* V timing: 1244 */
+	{ OV2722_8BIT, 0x3810, 0x00 },
+	{ OV2722_8BIT, 0x3811, 0x03 }, /* H window offset: 3 */
+	{ OV2722_8BIT, 0x3812, 0x00 },
+	{ OV2722_8BIT, 0x3813, 0x02 }, /* V window offset: 2 */
+	{ OV2722_8BIT, 0x3820, 0x80 },
+	{ OV2722_8BIT, 0x3821, 0x06 }, /*  mirror */
+	{ OV2722_8BIT, 0x3814, 0x11 },
+	{ OV2722_8BIT, 0x3815, 0x11 },
+	{ OV2722_8BIT, 0x3612, 0x0b },
+	{ OV2722_8BIT, 0x3618, 0x04 },
+	{ OV2722_8BIT, 0x3a08, 0x01 },
+	{ OV2722_8BIT, 0x3a09, 0x50 },
+	{ OV2722_8BIT, 0x3a0a, 0x01 },
+	{ OV2722_8BIT, 0x3a0b, 0x18 },
+	{ OV2722_8BIT, 0x3a0d, 0x03 },
+	{ OV2722_8BIT, 0x3a0e, 0x03 },
+	{ OV2722_8BIT, 0x4520, 0x00 },
+	{ OV2722_8BIT, 0x4837, 0x1b },
+	{ OV2722_8BIT, 0x3600, 0x08 },
+	{ OV2722_8BIT, 0x3621, 0xc0 },
+	{ OV2722_8BIT, 0x3632, 0xd2 }, /* added for power opt */
+	{ OV2722_8BIT, 0x3633, 0x23 },
+	{ OV2722_8BIT, 0x3634, 0x54 },
+	{ OV2722_8BIT, 0x3f01, 0x0c },
+	{ OV2722_8BIT, 0x5001, 0xc1 },
+	{ OV2722_8BIT, 0x3614, 0xf0 },
+	{ OV2722_8BIT, 0x3630, 0x2d },
+	{ OV2722_8BIT, 0x370b, 0x62 },
+	{ OV2722_8BIT, 0x3706, 0x61 },
+	{ OV2722_8BIT, 0x4000, 0x02 },
+	{ OV2722_8BIT, 0x4002, 0xc5 },
+	{ OV2722_8BIT, 0x4005, 0x08 },
+	{ OV2722_8BIT, 0x404f, 0x84 },
+	{ OV2722_8BIT, 0x4051, 0x00 },
+	{ OV2722_8BIT, 0x5000, 0xcf }, /* manual 3a */
+	{ OV2722_8BIT, 0x301d, 0xf0 }, /* enable group hold */
+	{ OV2722_8BIT, 0x3a18, 0x00 },
+	{ OV2722_8BIT, 0x3a19, 0x80 },
+	{ OV2722_8BIT, 0x4521, 0x00 },
+	{ OV2722_8BIT, 0x5183, 0xb0 },
+	{ OV2722_8BIT, 0x5184, 0xb0 },
+	{ OV2722_8BIT, 0x5185, 0xb0 },
+	{ OV2722_8BIT, 0x370c, 0x0c },
+	{ OV2722_8BIT, 0x3035, 0x00 },
+	{ OV2722_8BIT, 0x3036, 0x2c }, /* 422.4 MHz */
+	{ OV2722_8BIT, 0x3037, 0xa1 },
+	{ OV2722_8BIT, 0x303e, 0x19 },
+	{ OV2722_8BIT, 0x3038, 0x06 },
+	{ OV2722_8BIT, 0x3018, 0x04 },
+	{ OV2722_8BIT, 0x3000, 0x00 }, /* added for power optimization */
+	{ OV2722_8BIT, 0x3001, 0x00 },
+	{ OV2722_8BIT, 0x3002, 0x00 },
+	{ OV2722_8BIT, 0x3a0f, 0x40 },
+	{ OV2722_8BIT, 0x3a10, 0x38 },
+	{ OV2722_8BIT, 0x3a1b, 0x48 },
+	{ OV2722_8BIT, 0x3a1e, 0x30 },
+	{ OV2722_8BIT, 0x3a11, 0x90 },
+	{ OV2722_8BIT, 0x3a1f, 0x10 },
+	{ OV2722_8BIT, 0x3503, 0x17 }, /* manual 3a */
+	{ OV2722_8BIT, 0x3500, 0x00 },
+	{ OV2722_8BIT, 0x3501, 0x3F },
+	{ OV2722_8BIT, 0x3502, 0x00 },
+	{ OV2722_8BIT, 0x3508, 0x00 },
+	{ OV2722_8BIT, 0x3509, 0x00 },
+	{ OV2722_TOK_TERM, 0, 0 }
 };
 
 static struct ov2722_reg const ov2722_1452_1092_30fps[] = {
-	{OV2722_8BIT, 0x3021, 0x03}, /* For stand wait for
+	{ OV2722_8BIT, 0x3021, 0x03 }, /* For stand wait for
 				a whole frame complete.(vblank) */
-	{OV2722_8BIT, 0x3718, 0x10},
-	{OV2722_8BIT, 0x3702, 0x24},
-	{OV2722_8BIT, 0x373a, 0x60},
-	{OV2722_8BIT, 0x3715, 0x01},
-	{OV2722_8BIT, 0x3703, 0x2e},
-	{OV2722_8BIT, 0x3705, 0x10},
-	{OV2722_8BIT, 0x3730, 0x30},
-	{OV2722_8BIT, 0x3704, 0x62},
-	{OV2722_8BIT, 0x3f06, 0x3a},
-	{OV2722_8BIT, 0x371c, 0x00},
-	{OV2722_8BIT, 0x371d, 0xc4},
-	{OV2722_8BIT, 0x371e, 0x01},
-	{OV2722_8BIT, 0x371f, 0x0d},
-	{OV2722_8BIT, 0x3708, 0x61},
-	{OV2722_8BIT, 0x3709, 0x12},
-	{OV2722_8BIT, 0x3800, 0x00},
-	{OV2722_8BIT, 0x3801, 0xF8}, /* H crop start: 248 */
-	{OV2722_8BIT, 0x3802, 0x00},
-	{OV2722_8BIT, 0x3803, 0x01}, /* V crop start: 1 */
-	{OV2722_8BIT, 0x3804, 0x06},
-	{OV2722_8BIT, 0x3805, 0xab}, /* H crop end: 1707 */
-	{OV2722_8BIT, 0x3806, 0x04},
-	{OV2722_8BIT, 0x3807, 0x45}, /* V crop end: 1093 */
-	{OV2722_8BIT, 0x3808, 0x05},
-	{OV2722_8BIT, 0x3809, 0xac}, /* H output size: 1452 */
-	{OV2722_8BIT, 0x380a, 0x04},
-	{OV2722_8BIT, 0x380b, 0x44}, /* V output size: 1092 */
-	{OV2722_8BIT, 0x380c, 0x08},
-	{OV2722_8BIT, 0x380d, 0xd4}, /* H timing: 2260 */
-	{OV2722_8BIT, 0x380e, 0x04},
-	{OV2722_8BIT, 0x380f, 0xdc}, /* V timing: 1244 */
-	{OV2722_8BIT, 0x3810, 0x00},
-	{OV2722_8BIT, 0x3811, 0x03}, /* H window offset: 3 */
-	{OV2722_8BIT, 0x3812, 0x00},
-	{OV2722_8BIT, 0x3813, 0x02}, /* V window offset: 2 */
-	{OV2722_8BIT, 0x3820, 0x80},
-	{OV2722_8BIT, 0x3821, 0x06}, /*  mirror */
-	{OV2722_8BIT, 0x3814, 0x11},
-	{OV2722_8BIT, 0x3815, 0x11},
-	{OV2722_8BIT, 0x3612, 0x0b},
-	{OV2722_8BIT, 0x3618, 0x04},
-	{OV2722_8BIT, 0x3a08, 0x01},
-	{OV2722_8BIT, 0x3a09, 0x50},
-	{OV2722_8BIT, 0x3a0a, 0x01},
-	{OV2722_8BIT, 0x3a0b, 0x18},
-	{OV2722_8BIT, 0x3a0d, 0x03},
-	{OV2722_8BIT, 0x3a0e, 0x03},
-	{OV2722_8BIT, 0x4520, 0x00},
-	{OV2722_8BIT, 0x4837, 0x1b},
-	{OV2722_8BIT, 0x3600, 0x08},
-	{OV2722_8BIT, 0x3621, 0xc0},
-	{OV2722_8BIT, 0x3632, 0xd2}, /* added for power opt */
-	{OV2722_8BIT, 0x3633, 0x23},
-	{OV2722_8BIT, 0x3634, 0x54},
-	{OV2722_8BIT, 0x3f01, 0x0c},
-	{OV2722_8BIT, 0x5001, 0xc1},
-	{OV2722_8BIT, 0x3614, 0xf0},
-	{OV2722_8BIT, 0x3630, 0x2d},
-	{OV2722_8BIT, 0x370b, 0x62},
-	{OV2722_8BIT, 0x3706, 0x61},
-	{OV2722_8BIT, 0x4000, 0x02},
-	{OV2722_8BIT, 0x4002, 0xc5},
-	{OV2722_8BIT, 0x4005, 0x08},
-	{OV2722_8BIT, 0x404f, 0x84},
-	{OV2722_8BIT, 0x4051, 0x00},
-	{OV2722_8BIT, 0x5000, 0xcf}, /* manual 3a */
-	{OV2722_8BIT, 0x301d, 0xf0}, /* enable group hold */
-	{OV2722_8BIT, 0x3a18, 0x00},
-	{OV2722_8BIT, 0x3a19, 0x80},
-	{OV2722_8BIT, 0x4521, 0x00},
-	{OV2722_8BIT, 0x5183, 0xb0},
-	{OV2722_8BIT, 0x5184, 0xb0},
-	{OV2722_8BIT, 0x5185, 0xb0},
-	{OV2722_8BIT, 0x370c, 0x0c},
-	{OV2722_8BIT, 0x3035, 0x00},
-	{OV2722_8BIT, 0x3036, 0x2c}, /* 422.4 MHz */
-	{OV2722_8BIT, 0x3037, 0xa1},
-	{OV2722_8BIT, 0x303e, 0x19},
-	{OV2722_8BIT, 0x3038, 0x06},
-	{OV2722_8BIT, 0x3018, 0x04},
-	{OV2722_8BIT, 0x3000, 0x00}, /* added for power optimization */
-	{OV2722_8BIT, 0x3001, 0x00},
-	{OV2722_8BIT, 0x3002, 0x00},
-	{OV2722_8BIT, 0x3a0f, 0x40},
-	{OV2722_8BIT, 0x3a10, 0x38},
-	{OV2722_8BIT, 0x3a1b, 0x48},
-	{OV2722_8BIT, 0x3a1e, 0x30},
-	{OV2722_8BIT, 0x3a11, 0x90},
-	{OV2722_8BIT, 0x3a1f, 0x10},
-	{OV2722_8BIT, 0x3503, 0x17}, /* manual 3a */
-	{OV2722_8BIT, 0x3500, 0x00},
-	{OV2722_8BIT, 0x3501, 0x3F},
-	{OV2722_8BIT, 0x3502, 0x00},
-	{OV2722_8BIT, 0x3508, 0x00},
-	{OV2722_8BIT, 0x3509, 0x00},
-	{OV2722_TOK_TERM, 0, 0}
+	{ OV2722_8BIT, 0x3718, 0x10 },
+	{ OV2722_8BIT, 0x3702, 0x24 },
+	{ OV2722_8BIT, 0x373a, 0x60 },
+	{ OV2722_8BIT, 0x3715, 0x01 },
+	{ OV2722_8BIT, 0x3703, 0x2e },
+	{ OV2722_8BIT, 0x3705, 0x10 },
+	{ OV2722_8BIT, 0x3730, 0x30 },
+	{ OV2722_8BIT, 0x3704, 0x62 },
+	{ OV2722_8BIT, 0x3f06, 0x3a },
+	{ OV2722_8BIT, 0x371c, 0x00 },
+	{ OV2722_8BIT, 0x371d, 0xc4 },
+	{ OV2722_8BIT, 0x371e, 0x01 },
+	{ OV2722_8BIT, 0x371f, 0x0d },
+	{ OV2722_8BIT, 0x3708, 0x61 },
+	{ OV2722_8BIT, 0x3709, 0x12 },
+	{ OV2722_8BIT, 0x3800, 0x00 },
+	{ OV2722_8BIT, 0x3801, 0xF8 }, /* H crop start: 248 */
+	{ OV2722_8BIT, 0x3802, 0x00 },
+	{ OV2722_8BIT, 0x3803, 0x01 }, /* V crop start: 1 */
+	{ OV2722_8BIT, 0x3804, 0x06 },
+	{ OV2722_8BIT, 0x3805, 0xab }, /* H crop end: 1707 */
+	{ OV2722_8BIT, 0x3806, 0x04 },
+	{ OV2722_8BIT, 0x3807, 0x45 }, /* V crop end: 1093 */
+	{ OV2722_8BIT, 0x3808, 0x05 },
+	{ OV2722_8BIT, 0x3809, 0xac }, /* H output size: 1452 */
+	{ OV2722_8BIT, 0x380a, 0x04 },
+	{ OV2722_8BIT, 0x380b, 0x44 }, /* V output size: 1092 */
+	{ OV2722_8BIT, 0x380c, 0x08 },
+	{ OV2722_8BIT, 0x380d, 0xd4 }, /* H timing: 2260 */
+	{ OV2722_8BIT, 0x380e, 0x04 },
+	{ OV2722_8BIT, 0x380f, 0xdc }, /* V timing: 1244 */
+	{ OV2722_8BIT, 0x3810, 0x00 },
+	{ OV2722_8BIT, 0x3811, 0x03 }, /* H window offset: 3 */
+	{ OV2722_8BIT, 0x3812, 0x00 },
+	{ OV2722_8BIT, 0x3813, 0x02 }, /* V window offset: 2 */
+	{ OV2722_8BIT, 0x3820, 0x80 },
+	{ OV2722_8BIT, 0x3821, 0x06 }, /*  mirror */
+	{ OV2722_8BIT, 0x3814, 0x11 },
+	{ OV2722_8BIT, 0x3815, 0x11 },
+	{ OV2722_8BIT, 0x3612, 0x0b },
+	{ OV2722_8BIT, 0x3618, 0x04 },
+	{ OV2722_8BIT, 0x3a08, 0x01 },
+	{ OV2722_8BIT, 0x3a09, 0x50 },
+	{ OV2722_8BIT, 0x3a0a, 0x01 },
+	{ OV2722_8BIT, 0x3a0b, 0x18 },
+	{ OV2722_8BIT, 0x3a0d, 0x03 },
+	{ OV2722_8BIT, 0x3a0e, 0x03 },
+	{ OV2722_8BIT, 0x4520, 0x00 },
+	{ OV2722_8BIT, 0x4837, 0x1b },
+	{ OV2722_8BIT, 0x3600, 0x08 },
+	{ OV2722_8BIT, 0x3621, 0xc0 },
+	{ OV2722_8BIT, 0x3632, 0xd2 }, /* added for power opt */
+	{ OV2722_8BIT, 0x3633, 0x23 },
+	{ OV2722_8BIT, 0x3634, 0x54 },
+	{ OV2722_8BIT, 0x3f01, 0x0c },
+	{ OV2722_8BIT, 0x5001, 0xc1 },
+	{ OV2722_8BIT, 0x3614, 0xf0 },
+	{ OV2722_8BIT, 0x3630, 0x2d },
+	{ OV2722_8BIT, 0x370b, 0x62 },
+	{ OV2722_8BIT, 0x3706, 0x61 },
+	{ OV2722_8BIT, 0x4000, 0x02 },
+	{ OV2722_8BIT, 0x4002, 0xc5 },
+	{ OV2722_8BIT, 0x4005, 0x08 },
+	{ OV2722_8BIT, 0x404f, 0x84 },
+	{ OV2722_8BIT, 0x4051, 0x00 },
+	{ OV2722_8BIT, 0x5000, 0xcf }, /* manual 3a */
+	{ OV2722_8BIT, 0x301d, 0xf0 }, /* enable group hold */
+	{ OV2722_8BIT, 0x3a18, 0x00 },
+	{ OV2722_8BIT, 0x3a19, 0x80 },
+	{ OV2722_8BIT, 0x4521, 0x00 },
+	{ OV2722_8BIT, 0x5183, 0xb0 },
+	{ OV2722_8BIT, 0x5184, 0xb0 },
+	{ OV2722_8BIT, 0x5185, 0xb0 },
+	{ OV2722_8BIT, 0x370c, 0x0c },
+	{ OV2722_8BIT, 0x3035, 0x00 },
+	{ OV2722_8BIT, 0x3036, 0x2c }, /* 422.4 MHz */
+	{ OV2722_8BIT, 0x3037, 0xa1 },
+	{ OV2722_8BIT, 0x303e, 0x19 },
+	{ OV2722_8BIT, 0x3038, 0x06 },
+	{ OV2722_8BIT, 0x3018, 0x04 },
+	{ OV2722_8BIT, 0x3000, 0x00 }, /* added for power optimization */
+	{ OV2722_8BIT, 0x3001, 0x00 },
+	{ OV2722_8BIT, 0x3002, 0x00 },
+	{ OV2722_8BIT, 0x3a0f, 0x40 },
+	{ OV2722_8BIT, 0x3a10, 0x38 },
+	{ OV2722_8BIT, 0x3a1b, 0x48 },
+	{ OV2722_8BIT, 0x3a1e, 0x30 },
+	{ OV2722_8BIT, 0x3a11, 0x90 },
+	{ OV2722_8BIT, 0x3a1f, 0x10 },
+	{ OV2722_8BIT, 0x3503, 0x17 }, /* manual 3a */
+	{ OV2722_8BIT, 0x3500, 0x00 },
+	{ OV2722_8BIT, 0x3501, 0x3F },
+	{ OV2722_8BIT, 0x3502, 0x00 },
+	{ OV2722_8BIT, 0x3508, 0x00 },
+	{ OV2722_8BIT, 0x3509, 0x00 },
+	{ OV2722_TOK_TERM, 0, 0 }
 };
 
 #if 0
@@ -878,108 +878,108 @@ static struct ov2722_reg const ov2722_1M3_30fps[] = {
 #endif
 
 static struct ov2722_reg const ov2722_1080p_30fps[] = {
-	{OV2722_8BIT, 0x3021, 0x03}, /* For stand wait for a whole
+	{ OV2722_8BIT, 0x3021, 0x03 }, /* For stand wait for a whole
 					frame complete.(vblank) */
-	{OV2722_8BIT, 0x3718, 0x10},
-	{OV2722_8BIT, 0x3702, 0x24},
-	{OV2722_8BIT, 0x373a, 0x60},
-	{OV2722_8BIT, 0x3715, 0x01},
-	{OV2722_8BIT, 0x3703, 0x2e},
-	{OV2722_8BIT, 0x3705, 0x2b},
-	{OV2722_8BIT, 0x3730, 0x30},
-	{OV2722_8BIT, 0x3704, 0x62},
-	{OV2722_8BIT, 0x3f06, 0x3a},
-	{OV2722_8BIT, 0x371c, 0x00},
-	{OV2722_8BIT, 0x371d, 0xc4},
-	{OV2722_8BIT, 0x371e, 0x01},
-	{OV2722_8BIT, 0x371f, 0x28},
-	{OV2722_8BIT, 0x3708, 0x61},
-	{OV2722_8BIT, 0x3709, 0x12},
-	{OV2722_8BIT, 0x3800, 0x00},
-	{OV2722_8BIT, 0x3801, 0x08}, /* H crop start: 8 */
-	{OV2722_8BIT, 0x3802, 0x00},
-	{OV2722_8BIT, 0x3803, 0x01}, /* V crop start: 1 */
-	{OV2722_8BIT, 0x3804, 0x07},
-	{OV2722_8BIT, 0x3805, 0x9b}, /* H crop end: 1947 */
-	{OV2722_8BIT, 0x3806, 0x04},
-	{OV2722_8BIT, 0x3807, 0x45}, /* V crop end: 1093 */
-	{OV2722_8BIT, 0x3808, 0x07},
-	{OV2722_8BIT, 0x3809, 0x8c}, /* H output size: 1932 */
-	{OV2722_8BIT, 0x380a, 0x04},
-	{OV2722_8BIT, 0x380b, 0x44}, /* V output size: 1092 */
-	{OV2722_8BIT, 0x380c, 0x08},
-	{OV2722_8BIT, 0x380d, 0x14}, /* H timing: 2068 */
-	{OV2722_8BIT, 0x380e, 0x04},
-	{OV2722_8BIT, 0x380f, 0x5a}, /* V timing: 1114 */
-	{OV2722_8BIT, 0x3810, 0x00},
-	{OV2722_8BIT, 0x3811, 0x03}, /* H window offset: 3 */
-	{OV2722_8BIT, 0x3812, 0x00},
-	{OV2722_8BIT, 0x3813, 0x02}, /* V window offset: 2 */
-	{OV2722_8BIT, 0x3820, 0x80},
-	{OV2722_8BIT, 0x3821, 0x06}, /*  mirror */
-	{OV2722_8BIT, 0x3814, 0x11},
-	{OV2722_8BIT, 0x3815, 0x11},
-	{OV2722_8BIT, 0x3612, 0x4b},
-	{OV2722_8BIT, 0x3618, 0x04},
-	{OV2722_8BIT, 0x3a08, 0x01},
-	{OV2722_8BIT, 0x3a09, 0x50},
-	{OV2722_8BIT, 0x3a0a, 0x01},
-	{OV2722_8BIT, 0x3a0b, 0x18},
-	{OV2722_8BIT, 0x3a0d, 0x03},
-	{OV2722_8BIT, 0x3a0e, 0x03},
-	{OV2722_8BIT, 0x4520, 0x00},
-	{OV2722_8BIT, 0x4837, 0x1b},
-	{OV2722_8BIT, 0x3000, 0xff},
-	{OV2722_8BIT, 0x3001, 0xff},
-	{OV2722_8BIT, 0x3002, 0xf0},
-	{OV2722_8BIT, 0x3600, 0x08},
-	{OV2722_8BIT, 0x3621, 0xc0},
-	{OV2722_8BIT, 0x3632, 0x53}, /* added for power opt */
-	{OV2722_8BIT, 0x3633, 0x63},
-	{OV2722_8BIT, 0x3634, 0x24},
-	{OV2722_8BIT, 0x3f01, 0x0c},
-	{OV2722_8BIT, 0x5001, 0xc1},
-	{OV2722_8BIT, 0x3614, 0xf0},
-	{OV2722_8BIT, 0x3630, 0x2d},
-	{OV2722_8BIT, 0x370b, 0x62},
-	{OV2722_8BIT, 0x3706, 0x61},
-	{OV2722_8BIT, 0x4000, 0x02},
-	{OV2722_8BIT, 0x4002, 0xc5},
-	{OV2722_8BIT, 0x4005, 0x08},
-	{OV2722_8BIT, 0x404f, 0x84},
-	{OV2722_8BIT, 0x4051, 0x00},
-	{OV2722_8BIT, 0x5000, 0xcd}, /* manual 3a */
-	{OV2722_8BIT, 0x301d, 0xf0}, /* enable group hold */
-	{OV2722_8BIT, 0x3a18, 0x00},
-	{OV2722_8BIT, 0x3a19, 0x80},
-	{OV2722_8BIT, 0x3503, 0x17},
-	{OV2722_8BIT, 0x4521, 0x00},
-	{OV2722_8BIT, 0x5183, 0xb0},
-	{OV2722_8BIT, 0x5184, 0xb0},
-	{OV2722_8BIT, 0x5185, 0xb0},
-	{OV2722_8BIT, 0x370c, 0x0c},
-	{OV2722_8BIT, 0x3035, 0x00},
-	{OV2722_8BIT, 0x3036, 0x24}, /* 345.6 MHz */
-	{OV2722_8BIT, 0x3037, 0xa1},
-	{OV2722_8BIT, 0x303e, 0x19},
-	{OV2722_8BIT, 0x3038, 0x06},
-	{OV2722_8BIT, 0x3018, 0x04},
-	{OV2722_8BIT, 0x3000, 0x00}, /* added for power optimization */
-	{OV2722_8BIT, 0x3001, 0x00},
-	{OV2722_8BIT, 0x3002, 0x00},
-	{OV2722_8BIT, 0x3a0f, 0x40},
-	{OV2722_8BIT, 0x3a10, 0x38},
-	{OV2722_8BIT, 0x3a1b, 0x48},
-	{OV2722_8BIT, 0x3a1e, 0x30},
-	{OV2722_8BIT, 0x3a11, 0x90},
-	{OV2722_8BIT, 0x3a1f, 0x10},
-	{OV2722_8BIT, 0x3011, 0x22},
-	{OV2722_8BIT, 0x3500, 0x00},
-	{OV2722_8BIT, 0x3501, 0x3F},
-	{OV2722_8BIT, 0x3502, 0x00},
-	{OV2722_8BIT, 0x3508, 0x00},
-	{OV2722_8BIT, 0x3509, 0x00},
-	{OV2722_TOK_TERM, 0, 0}
+	{ OV2722_8BIT, 0x3718, 0x10 },
+	{ OV2722_8BIT, 0x3702, 0x24 },
+	{ OV2722_8BIT, 0x373a, 0x60 },
+	{ OV2722_8BIT, 0x3715, 0x01 },
+	{ OV2722_8BIT, 0x3703, 0x2e },
+	{ OV2722_8BIT, 0x3705, 0x2b },
+	{ OV2722_8BIT, 0x3730, 0x30 },
+	{ OV2722_8BIT, 0x3704, 0x62 },
+	{ OV2722_8BIT, 0x3f06, 0x3a },
+	{ OV2722_8BIT, 0x371c, 0x00 },
+	{ OV2722_8BIT, 0x371d, 0xc4 },
+	{ OV2722_8BIT, 0x371e, 0x01 },
+	{ OV2722_8BIT, 0x371f, 0x28 },
+	{ OV2722_8BIT, 0x3708, 0x61 },
+	{ OV2722_8BIT, 0x3709, 0x12 },
+	{ OV2722_8BIT, 0x3800, 0x00 },
+	{ OV2722_8BIT, 0x3801, 0x08 }, /* H crop start: 8 */
+	{ OV2722_8BIT, 0x3802, 0x00 },
+	{ OV2722_8BIT, 0x3803, 0x01 }, /* V crop start: 1 */
+	{ OV2722_8BIT, 0x3804, 0x07 },
+	{ OV2722_8BIT, 0x3805, 0x9b }, /* H crop end: 1947 */
+	{ OV2722_8BIT, 0x3806, 0x04 },
+	{ OV2722_8BIT, 0x3807, 0x45 }, /* V crop end: 1093 */
+	{ OV2722_8BIT, 0x3808, 0x07 },
+	{ OV2722_8BIT, 0x3809, 0x8c }, /* H output size: 1932 */
+	{ OV2722_8BIT, 0x380a, 0x04 },
+	{ OV2722_8BIT, 0x380b, 0x44 }, /* V output size: 1092 */
+	{ OV2722_8BIT, 0x380c, 0x08 },
+	{ OV2722_8BIT, 0x380d, 0x14 }, /* H timing: 2068 */
+	{ OV2722_8BIT, 0x380e, 0x04 },
+	{ OV2722_8BIT, 0x380f, 0x5a }, /* V timing: 1114 */
+	{ OV2722_8BIT, 0x3810, 0x00 },
+	{ OV2722_8BIT, 0x3811, 0x03 }, /* H window offset: 3 */
+	{ OV2722_8BIT, 0x3812, 0x00 },
+	{ OV2722_8BIT, 0x3813, 0x02 }, /* V window offset: 2 */
+	{ OV2722_8BIT, 0x3820, 0x80 },
+	{ OV2722_8BIT, 0x3821, 0x06 }, /*  mirror */
+	{ OV2722_8BIT, 0x3814, 0x11 },
+	{ OV2722_8BIT, 0x3815, 0x11 },
+	{ OV2722_8BIT, 0x3612, 0x4b },
+	{ OV2722_8BIT, 0x3618, 0x04 },
+	{ OV2722_8BIT, 0x3a08, 0x01 },
+	{ OV2722_8BIT, 0x3a09, 0x50 },
+	{ OV2722_8BIT, 0x3a0a, 0x01 },
+	{ OV2722_8BIT, 0x3a0b, 0x18 },
+	{ OV2722_8BIT, 0x3a0d, 0x03 },
+	{ OV2722_8BIT, 0x3a0e, 0x03 },
+	{ OV2722_8BIT, 0x4520, 0x00 },
+	{ OV2722_8BIT, 0x4837, 0x1b },
+	{ OV2722_8BIT, 0x3000, 0xff },
+	{ OV2722_8BIT, 0x3001, 0xff },
+	{ OV2722_8BIT, 0x3002, 0xf0 },
+	{ OV2722_8BIT, 0x3600, 0x08 },
+	{ OV2722_8BIT, 0x3621, 0xc0 },
+	{ OV2722_8BIT, 0x3632, 0x53 }, /* added for power opt */
+	{ OV2722_8BIT, 0x3633, 0x63 },
+	{ OV2722_8BIT, 0x3634, 0x24 },
+	{ OV2722_8BIT, 0x3f01, 0x0c },
+	{ OV2722_8BIT, 0x5001, 0xc1 },
+	{ OV2722_8BIT, 0x3614, 0xf0 },
+	{ OV2722_8BIT, 0x3630, 0x2d },
+	{ OV2722_8BIT, 0x370b, 0x62 },
+	{ OV2722_8BIT, 0x3706, 0x61 },
+	{ OV2722_8BIT, 0x4000, 0x02 },
+	{ OV2722_8BIT, 0x4002, 0xc5 },
+	{ OV2722_8BIT, 0x4005, 0x08 },
+	{ OV2722_8BIT, 0x404f, 0x84 },
+	{ OV2722_8BIT, 0x4051, 0x00 },
+	{ OV2722_8BIT, 0x5000, 0xcd }, /* manual 3a */
+	{ OV2722_8BIT, 0x301d, 0xf0 }, /* enable group hold */
+	{ OV2722_8BIT, 0x3a18, 0x00 },
+	{ OV2722_8BIT, 0x3a19, 0x80 },
+	{ OV2722_8BIT, 0x3503, 0x17 },
+	{ OV2722_8BIT, 0x4521, 0x00 },
+	{ OV2722_8BIT, 0x5183, 0xb0 },
+	{ OV2722_8BIT, 0x5184, 0xb0 },
+	{ OV2722_8BIT, 0x5185, 0xb0 },
+	{ OV2722_8BIT, 0x370c, 0x0c },
+	{ OV2722_8BIT, 0x3035, 0x00 },
+	{ OV2722_8BIT, 0x3036, 0x24 }, /* 345.6 MHz */
+	{ OV2722_8BIT, 0x3037, 0xa1 },
+	{ OV2722_8BIT, 0x303e, 0x19 },
+	{ OV2722_8BIT, 0x3038, 0x06 },
+	{ OV2722_8BIT, 0x3018, 0x04 },
+	{ OV2722_8BIT, 0x3000, 0x00 }, /* added for power optimization */
+	{ OV2722_8BIT, 0x3001, 0x00 },
+	{ OV2722_8BIT, 0x3002, 0x00 },
+	{ OV2722_8BIT, 0x3a0f, 0x40 },
+	{ OV2722_8BIT, 0x3a10, 0x38 },
+	{ OV2722_8BIT, 0x3a1b, 0x48 },
+	{ OV2722_8BIT, 0x3a1e, 0x30 },
+	{ OV2722_8BIT, 0x3a11, 0x90 },
+	{ OV2722_8BIT, 0x3a1f, 0x10 },
+	{ OV2722_8BIT, 0x3011, 0x22 },
+	{ OV2722_8BIT, 0x3500, 0x00 },
+	{ OV2722_8BIT, 0x3501, 0x3F },
+	{ OV2722_8BIT, 0x3502, 0x00 },
+	{ OV2722_8BIT, 0x3508, 0x00 },
+	{ OV2722_8BIT, 0x3509, 0x00 },
+	{ OV2722_TOK_TERM, 0, 0 }
 };
 
 #if 0 /* Currently unused */
diff --git a/drivers/staging/media/atomisp/include/hmm/hmm.h b/drivers/staging/media/atomisp/include/hmm/hmm.h
index a7aef27f54de83c3d4a1a8e3ea78a50c83887131..285ec2db6ab896ebe50faff3668b1490b1613bfe 100644
--- a/drivers/staging/media/atomisp/include/hmm/hmm.h
+++ b/drivers/staging/media/atomisp/include/hmm/hmm.h
@@ -7,8 +7,8 @@
  * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  */
 
-#ifndef	__HMM_H__
-#define	__HMM_H__
+#ifndef __HMM_H__
+#define __HMM_H__
 
 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -19,8 +19,8 @@
 #include "hmm/hmm_bo.h"
 #include "ia_css_types.h"
 
-#define mmgr_NULL              ((ia_css_ptr)0)
-#define mmgr_EXCEPTION         ((ia_css_ptr) - 1)
+#define mmgr_NULL ((ia_css_ptr)0)
+#define mmgr_EXCEPTION ((ia_css_ptr)-1)
 
 int hmm_init(void);
 void hmm_cleanup(void);
diff --git a/drivers/staging/media/atomisp/include/hmm/hmm_bo.h b/drivers/staging/media/atomisp/include/hmm/hmm_bo.h
index e09ac29ac43d4ad689fe56a05c7a605df5097077..17fbc246303c42e1b0138d7b2e6d39aba01f0766 100644
--- a/drivers/staging/media/atomisp/include/hmm/hmm_bo.h
+++ b/drivers/staging/media/atomisp/include/hmm/hmm_bo.h
@@ -7,8 +7,8 @@
  * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  */
 
-#ifndef	__HMM_BO_H__
-#define	__HMM_BO_H__
+#ifndef __HMM_BO_H__
+#define __HMM_BO_H__
 
 #include <linux/kernel.h>
 #include <linux/slab.h>
@@ -19,46 +19,40 @@
 #include "hmm/hmm_common.h"
 #include "ia_css_types.h"
 
-#define	check_bodev_null_return(bdev, exp)	\
-		check_null_return(bdev, exp, \
-			"NULL hmm_bo_device.\n")
+#define check_bodev_null_return(bdev, exp) \
+	check_null_return(bdev, exp, "NULL hmm_bo_device.\n")
 
-#define	check_bodev_null_return_void(bdev)	\
-		check_null_return_void(bdev, \
-			"NULL hmm_bo_device.\n")
+#define check_bodev_null_return_void(bdev) \
+	check_null_return_void(bdev, "NULL hmm_bo_device.\n")
 
-#define	check_bo_status_yes_goto(bo, _status, label) \
-	var_not_equal_goto((bo->status & (_status)), (_status), \
-			label, \
-			"HMM buffer status not contain %s.\n", \
-			#_status)
+#define check_bo_status_yes_goto(bo, _status, label)                   \
+	var_not_equal_goto((bo->status & (_status)), (_status), label, \
+			   "HMM buffer status not contain %s.\n", #_status)
 
-#define	check_bo_status_no_goto(bo, _status, label) \
-	var_equal_goto((bo->status & (_status)), (_status), \
-			label, \
-			"HMM buffer status contains %s.\n", \
-			#_status)
+#define check_bo_status_no_goto(bo, _status, label)                \
+	var_equal_goto((bo->status & (_status)), (_status), label, \
+		       "HMM buffer status contains %s.\n", #_status)
 
-#define rbtree_node_to_hmm_bo(root_node)	\
+#define rbtree_node_to_hmm_bo(root_node) \
 	container_of((root_node), struct hmm_buffer_object, node)
 
-#define	list_to_hmm_bo(list_ptr)	\
+#define list_to_hmm_bo(list_ptr) \
 	list_entry((list_ptr), struct hmm_buffer_object, list)
 
-#define	kref_to_hmm_bo(kref_ptr)	\
+#define kref_to_hmm_bo(kref_ptr) \
 	list_entry((kref_ptr), struct hmm_buffer_object, kref)
 
-#define	check_bo_null_return(bo, exp)	\
+#define check_bo_null_return(bo, exp) \
 	check_null_return(bo, exp, "NULL hmm buffer object.\n")
 
-#define	check_bo_null_return_void(bo)	\
+#define check_bo_null_return_void(bo) \
 	check_null_return_void(bo, "NULL hmm buffer object.\n")
 
-#define	ISP_VM_START	0x0
-#define	ISP_VM_SIZE	(0x7FFFFFFF)	/* 2G address space */
-#define	ISP_PTR_NULL	NULL
+#define ISP_VM_START 0x0
+#define ISP_VM_SIZE (0x7FFFFFFF) /* 2G address space */
+#define ISP_PTR_NULL NULL
 
-#define	HMM_BO_DEVICE_INITED	0x1
+#define HMM_BO_DEVICE_INITED 0x1
 
 enum hmm_bo_type {
 	HMM_BO_PRIVATE,
@@ -66,18 +60,18 @@ enum hmm_bo_type {
 	HMM_BO_LAST,
 };
 
-#define	HMM_BO_MASK		0x1
-#define	HMM_BO_FREE		0x0
-#define	HMM_BO_ALLOCED	0x1
-#define	HMM_BO_PAGE_ALLOCED	0x2
-#define	HMM_BO_BINDED		0x4
-#define	HMM_BO_MMAPED		0x8
-#define	HMM_BO_VMAPED		0x10
-#define	HMM_BO_VMAPED_CACHED	0x20
-#define	HMM_BO_ACTIVE		0x1000
+#define HMM_BO_MASK 0x1
+#define HMM_BO_FREE 0x0
+#define HMM_BO_ALLOCED 0x1
+#define HMM_BO_PAGE_ALLOCED 0x2
+#define HMM_BO_BINDED 0x4
+#define HMM_BO_MMAPED 0x8
+#define HMM_BO_VMAPED 0x10
+#define HMM_BO_VMAPED_CACHED 0x20
+#define HMM_BO_ACTIVE 0x1000
 
 struct hmm_bo_device {
-	struct isp_mmu		mmu;
+	struct isp_mmu mmu;
 
 	/* start/pgnr/size is used to record the virtual memory of this bo */
 	unsigned int start;
@@ -85,7 +79,7 @@ struct hmm_bo_device {
 	unsigned int size;
 
 	/* list lock is used to protect the entire_bo_list */
-	spinlock_t	list_lock;
+	spinlock_t list_lock;
 	int flag;
 
 	/* linked list for entire buffer object */
@@ -99,23 +93,23 @@ struct hmm_bo_device {
 };
 
 struct hmm_buffer_object {
-	struct hmm_bo_device	*bdev;
-	struct list_head	list;
-	struct kref	kref;
+	struct hmm_bo_device *bdev;
+	struct list_head list;
+	struct kref kref;
 
 	struct page **pages;
 
 	/* mutex protecting this BO */
-	struct mutex		mutex;
-	enum hmm_bo_type	type;
-	int		mmap_count;
-	int		status;
-	void		*vmap_addr; /* kernel virtual address by vmap */
-
-	struct rb_node	node;
-	unsigned int	start;
-	unsigned int	end;
-	unsigned int	pgnr;
+	struct mutex mutex;
+	enum hmm_bo_type type;
+	int mmap_count;
+	int status;
+	void *vmap_addr; /* kernel virtual address by vmap */
+
+	struct rb_node node;
+	unsigned int start;
+	unsigned int end;
+	unsigned int pgnr;
 	/*
 	 * When insert a bo which has the same pgnr with an existed
 	 * bo node in the free_rbtree, using "prev & next" pointer
@@ -124,8 +118,8 @@ struct hmm_buffer_object {
 	 * in free_rbtree has different pgnr.
 	 * "prev & next" default is NULL.
 	 */
-	struct hmm_buffer_object	*prev;
-	struct hmm_buffer_object	*next;
+	struct hmm_buffer_object *prev;
+	struct hmm_buffer_object *next;
 };
 
 struct hmm_buffer_object *hmm_bo_alloc(struct hmm_bo_device *bdev,
@@ -194,8 +188,7 @@ int hmm_bo_allocated(struct hmm_buffer_object *bo);
  * pages will be allocated by using video driver (for share buffer)
  * or by ISP driver itself.
  */
-int hmm_bo_alloc_pages(struct hmm_buffer_object *bo,
-		       enum hmm_bo_type type,
+int hmm_bo_alloc_pages(struct hmm_buffer_object *bo, enum hmm_bo_type type,
 		       void *vmalloc_addr);
 void hmm_bo_free_pages(struct hmm_buffer_object *bo);
 int hmm_bo_page_allocated(struct hmm_buffer_object *bo);
@@ -232,15 +225,14 @@ void hmm_bo_vunmap(struct hmm_buffer_object *bo);
  *
  * vma->vm_flags will be set to (VM_RESERVED | VM_IO).
  */
-int hmm_bo_mmap(struct vm_area_struct *vma,
-		struct hmm_buffer_object *bo);
+int hmm_bo_mmap(struct vm_area_struct *vma, struct hmm_buffer_object *bo);
 
 /*
  * find the buffer object by its virtual address vaddr.
  * return NULL if no such buffer object found.
  */
-struct hmm_buffer_object *hmm_bo_device_search_start(
-    struct hmm_bo_device *bdev, ia_css_ptr vaddr);
+struct hmm_buffer_object *hmm_bo_device_search_start(struct hmm_bo_device *bdev,
+						     ia_css_ptr vaddr);
 
 /*
  * find the buffer object by its virtual address.
@@ -248,14 +240,14 @@ struct hmm_buffer_object *hmm_bo_device_search_start(
  * it can be an address within the range of one bo.
  * return NULL if no such buffer object found.
  */
-struct hmm_buffer_object *hmm_bo_device_search_in_range(
-    struct hmm_bo_device *bdev, ia_css_ptr vaddr);
+struct hmm_buffer_object *
+hmm_bo_device_search_in_range(struct hmm_bo_device *bdev, ia_css_ptr vaddr);
 
 /*
  * find the buffer object with kernel virtual address vaddr.
  * return NULL if no such buffer object found.
  */
-struct hmm_buffer_object *hmm_bo_device_search_vmap_start(
-    struct hmm_bo_device *bdev, const void *vaddr);
+struct hmm_buffer_object *
+hmm_bo_device_search_vmap_start(struct hmm_bo_device *bdev, const void *vaddr);
 
 #endif
diff --git a/drivers/staging/media/atomisp/include/hmm/hmm_common.h b/drivers/staging/media/atomisp/include/hmm/hmm_common.h
index b251e96cc19d75273425cccebb929286b5a3ac3d..30d6cb1aaaca4a7a11c82483e7a3deab69eb2450 100644
--- a/drivers/staging/media/atomisp/include/hmm/hmm_common.h
+++ b/drivers/staging/media/atomisp/include/hmm/hmm_common.h
@@ -7,54 +7,50 @@
  * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  */
 
-#ifndef	__HMM_BO_COMMON_H__
-#define	__HMM_BO_COMMON_H__
+#ifndef __HMM_BO_COMMON_H__
+#define __HMM_BO_COMMON_H__
 
-#define	HMM_BO_NAME	"HMM"
+#define HMM_BO_NAME "HMM"
 
 /*
  * some common use micros
  */
-#define	var_equal_return(var1, var2, exp, fmt, arg ...)	\
-	do { \
-		if ((var1) == (var2)) { \
-			dev_err(atomisp_dev, \
-			fmt, ## arg); \
-			return exp;\
-		} \
+#define var_equal_return(var1, var2, exp, fmt, arg...)    \
+	do {                                              \
+		if ((var1) == (var2)) {                   \
+			dev_err(atomisp_dev, fmt, ##arg); \
+			return exp;                       \
+		}                                         \
 	} while (0)
 
-#define	var_equal_return_void(var1, var2, fmt, arg ...)	\
-	do { \
-		if ((var1) == (var2)) { \
-			dev_err(atomisp_dev, \
-			fmt, ## arg); \
-			return;\
-		} \
+#define var_equal_return_void(var1, var2, fmt, arg...)    \
+	do {                                              \
+		if ((var1) == (var2)) {                   \
+			dev_err(atomisp_dev, fmt, ##arg); \
+			return;                           \
+		}                                         \
 	} while (0)
 
-#define	var_equal_goto(var1, var2, label, fmt, arg ...)	\
-	do { \
-		if ((var1) == (var2)) { \
-			dev_err(atomisp_dev, \
-			fmt, ## arg); \
-			goto label;\
-		} \
+#define var_equal_goto(var1, var2, label, fmt, arg...)    \
+	do {                                              \
+		if ((var1) == (var2)) {                   \
+			dev_err(atomisp_dev, fmt, ##arg); \
+			goto label;                       \
+		}                                         \
 	} while (0)
 
-#define	var_not_equal_goto(var1, var2, label, fmt, arg ...)	\
-	do { \
-		if ((var1) != (var2)) { \
-			dev_err(atomisp_dev, \
-			fmt, ## arg); \
-			goto label;\
-		} \
+#define var_not_equal_goto(var1, var2, label, fmt, arg...) \
+	do {                                               \
+		if ((var1) != (var2)) {                    \
+			dev_err(atomisp_dev, fmt, ##arg);  \
+			goto label;                        \
+		}                                          \
 	} while (0)
 
-#define	check_null_return(ptr, exp, fmt, arg ...)	\
-		var_equal_return(ptr, NULL, exp, fmt, ## arg)
+#define check_null_return(ptr, exp, fmt, arg...) \
+	var_equal_return(ptr, NULL, exp, fmt, ##arg)
 
-#define	check_null_return_void(ptr, fmt, arg ...)	\
-		var_equal_return_void(ptr, NULL, fmt, ## arg)
+#define check_null_return_void(ptr, fmt, arg...) \
+	var_equal_return_void(ptr, NULL, fmt, ##arg)
 
 #endif
diff --git a/drivers/staging/media/atomisp/include/linux/atomisp.h b/drivers/staging/media/atomisp/include/linux/atomisp.h
index 3c8fa3f5808d0b7e80fb6562cea302c6c2b840ba..a02780aacd580b2a9e471002b1a1ae14bea21430 100644
--- a/drivers/staging/media/atomisp/include/linux/atomisp.h
+++ b/drivers/staging/media/atomisp/include/linux/atomisp.h
@@ -11,22 +11,22 @@
 #include <linux/types.h>
 
 /* struct media_device_info.hw_revision */
-#define ATOMISP_HW_REVISION_MASK	0x0000ff00
-#define ATOMISP_HW_REVISION_SHIFT	8
-#define ATOMISP_HW_REVISION_ISP2300	0x00
-#define ATOMISP_HW_REVISION_ISP2400	0x10
+#define ATOMISP_HW_REVISION_MASK 0x0000ff00
+#define ATOMISP_HW_REVISION_SHIFT 8
+#define ATOMISP_HW_REVISION_ISP2300 0x00
+#define ATOMISP_HW_REVISION_ISP2400 0x10
 #define ATOMISP_HW_REVISION_ISP2401_LEGACY 0x11
-#define ATOMISP_HW_REVISION_ISP2401	0x20
+#define ATOMISP_HW_REVISION_ISP2401 0x20
 
-#define ATOMISP_HW_STEPPING_MASK	0x000000ff
-#define ATOMISP_HW_STEPPING_A0		0x00
-#define ATOMISP_HW_STEPPING_B0		0x10
+#define ATOMISP_HW_STEPPING_MASK 0x000000ff
+#define ATOMISP_HW_STEPPING_A0 0x00
+#define ATOMISP_HW_STEPPING_B0 0x10
 
 /*ISP binary running mode*/
-#define CI_MODE_PREVIEW		0x8000
-#define CI_MODE_VIDEO		0x4000
-#define CI_MODE_STILL_CAPTURE	0x2000
-#define CI_MODE_NONE		0x0000
+#define CI_MODE_PREVIEW 0x8000
+#define CI_MODE_VIDEO 0x4000
+#define CI_MODE_STILL_CAPTURE 0x2000
+#define CI_MODE_NONE 0x0000
 
 #define OUTPUT_MODE_FILE 0x0100
 #define OUTPUT_MODE_TEXT 0x0200
@@ -35,26 +35,26 @@
  * Camera HAL sets this flag in v4l2_buffer reserved2 to indicate this
  * buffer has a per-frame parameter.
  */
-#define ATOMISP_BUFFER_HAS_PER_FRAME_SETTING	0x80000000
+#define ATOMISP_BUFFER_HAS_PER_FRAME_SETTING 0x80000000
 
 /* Custom format for RAW capture from M10MO 0x3130314d */
-#define V4L2_PIX_FMT_CUSTOM_M10MO_RAW	v4l2_fourcc('M', '1', '0', '1')
+#define V4L2_PIX_FMT_CUSTOM_M10MO_RAW v4l2_fourcc('M', '1', '0', '1')
 
 /* Custom media bus formats being used in atomisp */
-#define V4L2_MBUS_FMT_CUSTOM_YUV420	0x8001
-#define V4L2_MBUS_FMT_CUSTOM_YVU420	0x8002
-#define V4L2_MBUS_FMT_CUSTOM_YUV422P	0x8003
-#define V4L2_MBUS_FMT_CUSTOM_YUV444	0x8004
-#define V4L2_MBUS_FMT_CUSTOM_NV12	0x8005
-#define V4L2_MBUS_FMT_CUSTOM_NV21	0x8006
-#define V4L2_MBUS_FMT_CUSTOM_NV16	0x8007
-#define V4L2_MBUS_FMT_CUSTOM_YUYV	0x8008
-#define V4L2_MBUS_FMT_CUSTOM_SBGGR16	0x8009
-#define V4L2_MBUS_FMT_CUSTOM_RGB32	0x800a
+#define V4L2_MBUS_FMT_CUSTOM_YUV420 0x8001
+#define V4L2_MBUS_FMT_CUSTOM_YVU420 0x8002
+#define V4L2_MBUS_FMT_CUSTOM_YUV422P 0x8003
+#define V4L2_MBUS_FMT_CUSTOM_YUV444 0x8004
+#define V4L2_MBUS_FMT_CUSTOM_NV12 0x8005
+#define V4L2_MBUS_FMT_CUSTOM_NV21 0x8006
+#define V4L2_MBUS_FMT_CUSTOM_NV16 0x8007
+#define V4L2_MBUS_FMT_CUSTOM_YUYV 0x8008
+#define V4L2_MBUS_FMT_CUSTOM_SBGGR16 0x8009
+#define V4L2_MBUS_FMT_CUSTOM_RGB32 0x800a
 
 /* Custom media bus format for M10MO RAW capture */
 #if 0
-#define V4L2_MBUS_FMT_CUSTOM_M10MO_RAW	0x800b
+#define V4L2_MBUS_FMT_CUSTOM_M10MO_RAW 0x800b
 #endif
 
 /* Configuration used by Bayer noise reduction and YCC noise reduction */
@@ -73,9 +73,9 @@ struct atomisp_nr_config {
 
 /* Temporal noise reduction configuration */
 struct atomisp_tnr_config {
-	unsigned int gain;	 /* [gain] Strength of NR */
-	unsigned int threshold_y;/* [intensity] Motion sensitivity for Y */
-	unsigned int threshold_uv;/* [intensity] Motion sensitivity for U/V */
+	unsigned int gain; /* [gain] Strength of NR */
+	unsigned int threshold_y; /* [intensity] Motion sensitivity for Y */
+	unsigned int threshold_uv; /* [intensity] Motion sensitivity for U/V */
 };
 
 /* Histogram. This contains num_elements values of type unsigned int.
@@ -143,15 +143,15 @@ struct atomisp_gc_config {
 };
 
 struct atomisp_3a_config {
-	unsigned int ae_y_coef_r;	/* [gain] Weight of R for Y */
-	unsigned int ae_y_coef_g;	/* [gain] Weight of G for Y */
-	unsigned int ae_y_coef_b;	/* [gain] Weight of B for Y */
-	unsigned int awb_lg_high_raw;	/* [intensity]
+	unsigned int ae_y_coef_r; /* [gain] Weight of R for Y */
+	unsigned int ae_y_coef_g; /* [gain] Weight of G for Y */
+	unsigned int ae_y_coef_b; /* [gain] Weight of B for Y */
+	unsigned int awb_lg_high_raw; /* [intensity]
 					   AWB level gate high for raw */
-	unsigned int awb_lg_low;	/* [intensity] AWB level gate low */
-	unsigned int awb_lg_high;	/* [intensity] AWB level gate high */
-	int af_fir1_coef[7];	/* [factor] AF FIR coefficients of fir1 */
-	int af_fir2_coef[7];	/* [factor] AF FIR coefficients of fir2 */
+	unsigned int awb_lg_low; /* [intensity] AWB level gate low */
+	unsigned int awb_lg_high; /* [intensity] AWB level gate high */
+	int af_fir1_coef[7]; /* [factor] AF FIR coefficients of fir1 */
+	int af_fir2_coef[7]; /* [factor] AF FIR coefficients of fir2 */
 };
 
 struct atomisp_dvs_grid_info {
@@ -194,8 +194,8 @@ struct atomisp_dis_vector {
 struct atomisp_dvs2_coef_types {
 	short __user *odd_real; /** real part of the odd coefficients*/
 	short __user *odd_imag; /** imaginary part of the odd coefficients*/
-	short __user *even_real;/** real part of the even coefficients*/
-	short __user *even_imag;/** imaginary part of the even coefficients*/
+	short __user *even_real; /** real part of the even coefficients*/
+	short __user *even_imag; /** imaginary part of the even coefficients*/
 };
 
 /*
@@ -205,8 +205,8 @@ struct atomisp_dvs2_coef_types {
 struct atomisp_dvs2_stat_types {
 	int __user *odd_real; /** real part of the odd statistics*/
 	int __user *odd_imag; /** imaginary part of the odd statistics*/
-	int __user *even_real;/** real part of the even statistics*/
-	int __user *even_imag;/** imaginary part of the even statistics*/
+	int __user *even_real; /** real part of the even statistics*/
+	int __user *even_imag; /** imaginary part of the even statistics*/
 };
 
 struct atomisp_dis_coefficients {
@@ -253,7 +253,7 @@ struct atomisp_ext_isp_ctrl {
 };
 
 struct atomisp_3a_statistics {
-	struct atomisp_grid_info  grid_info;
+	struct atomisp_grid_info grid_info;
 	struct atomisp_3a_output __user *data;
 	struct atomisp_3a_rgby_output __user *rgby_data;
 	u32 exp_id; /* exposure ID */
@@ -263,16 +263,16 @@ struct atomisp_3a_statistics {
 /* White Balance (Gain Adjust) */
 struct atomisp_wb_config {
 	unsigned int integer_bits;
-	unsigned int gr;	/* unsigned <integer_bits>.<16-integer_bits> */
-	unsigned int r;		/* unsigned <integer_bits>.<16-integer_bits> */
-	unsigned int b;		/* unsigned <integer_bits>.<16-integer_bits> */
-	unsigned int gb;	/* unsigned <integer_bits>.<16-integer_bits> */
+	unsigned int gr; /* unsigned <integer_bits>.<16-integer_bits> */
+	unsigned int r; /* unsigned <integer_bits>.<16-integer_bits> */
+	unsigned int b; /* unsigned <integer_bits>.<16-integer_bits> */
+	unsigned int gb; /* unsigned <integer_bits>.<16-integer_bits> */
 };
 
 /* Color Space Conversion settings */
 struct atomisp_cc_config {
 	unsigned int fraction_bits;
-	int matrix[3 * 3];	/* RGB2YUV Color matrix, signed
+	int matrix[3 * 3]; /* RGB2YUV Color matrix, signed
 				   <13-fraction_bits>.<fraction_bits> */
 };
 
@@ -322,7 +322,7 @@ struct atomisp_metadata_config {
  * Generic resolution structure.
  */
 struct atomisp_resolution {
-	u32 width;  /** Width */
+	u32 width; /** Width */
 	u32 height; /** Height */
 };
 
@@ -367,8 +367,8 @@ struct atomisp_parm {
 };
 
 struct dvs2_bq_resolution {
-	int width_bq;         /* width [BQ] */
-	int height_bq;        /* height [BQ] */
+	int width_bq; /* width [BQ] */
+	int height_bq; /* height [BQ] */
 };
 
 struct atomisp_dvs2_bq_resolutions {
@@ -401,80 +401,80 @@ struct atomisp_formats_config {
 };
 
 struct atomisp_parameters {
-	struct atomisp_wb_config   *wb_config;  /* White Balance config */
-	struct atomisp_cc_config   *cc_config;  /* Color Correction config */
-	struct atomisp_tnr_config  *tnr_config; /* Temporal Noise Reduction */
-	struct atomisp_ecd_config  *ecd_config; /* Eigen Color Demosaicing */
-	struct atomisp_ynr_config  *ynr_config; /* Y(Luma) Noise Reduction */
-	struct atomisp_fc_config   *fc_config;  /* Fringe Control */
+	struct atomisp_wb_config *wb_config; /* White Balance config */
+	struct atomisp_cc_config *cc_config; /* Color Correction config */
+	struct atomisp_tnr_config *tnr_config; /* Temporal Noise Reduction */
+	struct atomisp_ecd_config *ecd_config; /* Eigen Color Demosaicing */
+	struct atomisp_ynr_config *ynr_config; /* Y(Luma) Noise Reduction */
+	struct atomisp_fc_config *fc_config; /* Fringe Control */
 	struct atomisp_formats_config *formats_config; /* Formats Control */
-	struct atomisp_cnr_config  *cnr_config; /* Chroma Noise Reduction */
-	struct atomisp_macc_config *macc_config;  /* MACC */
-	struct atomisp_ctc_config  *ctc_config; /* Chroma Tone Control */
-	struct atomisp_aa_config   *aa_config;  /* Anti-Aliasing */
-	struct atomisp_aa_config   *baa_config;  /* Anti-Aliasing */
-	struct atomisp_ce_config   *ce_config;
+	struct atomisp_cnr_config *cnr_config; /* Chroma Noise Reduction */
+	struct atomisp_macc_config *macc_config; /* MACC */
+	struct atomisp_ctc_config *ctc_config; /* Chroma Tone Control */
+	struct atomisp_aa_config *aa_config; /* Anti-Aliasing */
+	struct atomisp_aa_config *baa_config; /* Anti-Aliasing */
+	struct atomisp_ce_config *ce_config;
 	struct atomisp_dvs_6axis_config *dvs_6axis_config;
-	struct atomisp_ob_config   *ob_config;  /* Objective Black config */
-	struct atomisp_dp_config   *dp_config;  /* Dead Pixel config */
-	struct atomisp_nr_config   *nr_config;  /* Noise Reduction config */
-	struct atomisp_ee_config   *ee_config;  /* Edge Enhancement config */
-	struct atomisp_de_config   *de_config;  /* Demosaic config */
-	struct atomisp_gc_config   *gc_config;  /* Gamma Correction config */
-	struct atomisp_anr_config  *anr_config; /* Advanced Noise Reduction */
-	struct atomisp_3a_config   *a3a_config; /* 3A Statistics config */
-	struct atomisp_xnr_config  *xnr_config; /* eXtra Noise Reduction */
-	struct atomisp_dz_config   *dz_config;  /* Digital Zoom */
+	struct atomisp_ob_config *ob_config; /* Objective Black config */
+	struct atomisp_dp_config *dp_config; /* Dead Pixel config */
+	struct atomisp_nr_config *nr_config; /* Noise Reduction config */
+	struct atomisp_ee_config *ee_config; /* Edge Enhancement config */
+	struct atomisp_de_config *de_config; /* Demosaic config */
+	struct atomisp_gc_config *gc_config; /* Gamma Correction config */
+	struct atomisp_anr_config *anr_config; /* Advanced Noise Reduction */
+	struct atomisp_3a_config *a3a_config; /* 3A Statistics config */
+	struct atomisp_xnr_config *xnr_config; /* eXtra Noise Reduction */
+	struct atomisp_dz_config *dz_config; /* Digital Zoom */
 	struct atomisp_cc_config *yuv2rgb_cc_config; /* Color
 							Correction config */
 	struct atomisp_cc_config *rgb2yuv_cc_config; /* Color
 							Correction config */
-	struct atomisp_macc_table  *macc_table;
+	struct atomisp_macc_table *macc_table;
 	struct atomisp_gamma_table *gamma_table;
-	struct atomisp_ctc_table   *ctc_table;
-	struct atomisp_xnr_table   *xnr_table;
+	struct atomisp_ctc_table *ctc_table;
+	struct atomisp_xnr_table *xnr_table;
 	struct atomisp_rgb_gamma_table *r_gamma_table;
 	struct atomisp_rgb_gamma_table *g_gamma_table;
 	struct atomisp_rgb_gamma_table *b_gamma_table;
-	struct atomisp_vector      *motion_vector; /* For 2-axis DVS */
+	struct atomisp_vector *motion_vector; /* For 2-axis DVS */
 	struct atomisp_shading_table *shading_table;
-	struct atomisp_morph_table   *morph_table;
+	struct atomisp_morph_table *morph_table;
 	struct atomisp_dvs_coefficients *dvs_coefs; /* DVS 1.0 coefficients */
 	struct atomisp_dis_coefficients *dvs2_coefs; /* DVS 2.0 coefficients */
-	struct atomisp_capture_config   *capture_config;
-	struct atomisp_anr_thres   *anr_thres;
-
-	void	*lin_2500_config;       /* Skylake: Linearization config */
-	void	*obgrid_2500_config;    /* Skylake: OBGRID config */
-	void	*bnr_2500_config;       /* Skylake: bayer denoise config */
-	void	*shd_2500_config;       /* Skylake: shading config */
-	void	*dm_2500_config;        /* Skylake: demosaic config */
-	void	*rgbpp_2500_config;     /* Skylake: RGBPP config */
-	void	*dvs_stat_2500_config;  /* Skylake: DVS STAT config */
-	void	*lace_stat_2500_config; /* Skylake: LACE STAT config */
-	void	*yuvp1_2500_config;     /* Skylake: yuvp1 config */
-	void	*yuvp2_2500_config;     /* Skylake: yuvp2 config */
-	void	*tnr_2500_config;       /* Skylake: TNR config */
-	void	*dpc_2500_config;       /* Skylake: DPC config */
-	void	*awb_2500_config;       /* Skylake: auto white balance config */
-	void	*awb_fr_2500_config;    /* Skylake: auto white balance filter response config */
-	void	*anr_2500_config;       /* Skylake: ANR config */
-	void	*af_2500_config;        /* Skylake: auto focus config */
-	void	*ae_2500_config;        /* Skylake: auto exposure config */
-	void	*bds_2500_config;       /* Skylake: bayer downscaler config */
-	void	*dvs_2500_config;       /* Skylake: digital video stabilization config */
-	void	*res_mgr_2500_config;
+	struct atomisp_capture_config *capture_config;
+	struct atomisp_anr_thres *anr_thres;
+
+	void *lin_2500_config; /* Skylake: Linearization config */
+	void *obgrid_2500_config; /* Skylake: OBGRID config */
+	void *bnr_2500_config; /* Skylake: bayer denoise config */
+	void *shd_2500_config; /* Skylake: shading config */
+	void *dm_2500_config; /* Skylake: demosaic config */
+	void *rgbpp_2500_config; /* Skylake: RGBPP config */
+	void *dvs_stat_2500_config; /* Skylake: DVS STAT config */
+	void *lace_stat_2500_config; /* Skylake: LACE STAT config */
+	void *yuvp1_2500_config; /* Skylake: yuvp1 config */
+	void *yuvp2_2500_config; /* Skylake: yuvp2 config */
+	void *tnr_2500_config; /* Skylake: TNR config */
+	void *dpc_2500_config; /* Skylake: DPC config */
+	void *awb_2500_config; /* Skylake: auto white balance config */
+	void *awb_fr_2500_config; /* Skylake: auto white balance filter response config */
+	void *anr_2500_config; /* Skylake: ANR config */
+	void *af_2500_config; /* Skylake: auto focus config */
+	void *ae_2500_config; /* Skylake: auto exposure config */
+	void *bds_2500_config; /* Skylake: bayer downscaler config */
+	void *dvs_2500_config; /* Skylake: digital video stabilization config */
+	void *res_mgr_2500_config;
 
 	/*
 	 * Output frame pointer the config is to be applied to (optional),
 	 * set to NULL to make this config is applied as global.
 	 */
-	void	*output_frame;
+	void *output_frame;
 	/*
 	 * Unique ID to track which config was actually applied to a particular
 	 * frame, driver will send this id back with output frame together.
 	 */
-	u32	isp_config_id;
+	u32 isp_config_id;
 
 	/*
 	 * Switch to control per_frame setting:
@@ -482,10 +482,10 @@ struct atomisp_parameters {
 	 * 1: this is a per_frame setting
 	 * PLEASE KEEP THIS AT THE END OF THE STRUCTURE!!
 	 */
-	u32	per_frame_setting;
+	u32 per_frame_setting;
 };
 
-#define ATOMISP_GAMMA_TABLE_SIZE        1024
+#define ATOMISP_GAMMA_TABLE_SIZE 1024
 struct atomisp_gamma_table {
 	unsigned short data[ATOMISP_GAMMA_TABLE_SIZE];
 };
@@ -494,18 +494,18 @@ struct atomisp_gamma_table {
  * Each line of width elements takes up COORD_TABLE_EXT_WIDTH elements
  * in memory.
  */
-#define ATOMISP_MORPH_TABLE_NUM_PLANES  6
+#define ATOMISP_MORPH_TABLE_NUM_PLANES 6
 struct atomisp_morph_table {
 	unsigned int enabled;
 
 	unsigned int height;
-	unsigned int width;	/* number of valid elements per line */
+	unsigned int width; /* number of valid elements per line */
 	unsigned short __user *coordinates_x[ATOMISP_MORPH_TABLE_NUM_PLANES];
 	unsigned short __user *coordinates_y[ATOMISP_MORPH_TABLE_NUM_PLANES];
 };
 
-#define ATOMISP_NUM_SC_COLORS	4
-#define ATOMISP_SC_FLAG_QUERY	BIT(0)
+#define ATOMISP_NUM_SC_COLORS 4
+#define ATOMISP_SC_FLAG_QUERY BIT(0)
 
 struct atomisp_shading_table {
 	__u32 enable;
@@ -520,7 +520,7 @@ struct atomisp_shading_table {
 };
 
 /* parameter for MACC */
-#define ATOMISP_NUM_MACC_AXES           16
+#define ATOMISP_NUM_MACC_AXES 16
 struct atomisp_macc_table {
 	short data[4 * ATOMISP_NUM_MACC_AXES];
 };
@@ -531,7 +531,7 @@ struct atomisp_macc_config {
 };
 
 /* Parameter for ctc parameter control */
-#define ATOMISP_CTC_TABLE_SIZE          1024
+#define ATOMISP_CTC_TABLE_SIZE 1024
 struct atomisp_ctc_table {
 	unsigned short data[ATOMISP_CTC_TABLE_SIZE];
 };
@@ -586,14 +586,14 @@ struct atomisp_bc_video_package {
 
 enum atomisp_focus_hp {
 	ATOMISP_FOCUS_HP_IN_PROGRESS = (1U << 2),
-	ATOMISP_FOCUS_HP_COMPLETE    = (2U << 2),
-	ATOMISP_FOCUS_HP_FAILED      = (3U << 2)
+	ATOMISP_FOCUS_HP_COMPLETE = (2U << 2),
+	ATOMISP_FOCUS_HP_FAILED = (3U << 2)
 };
 
 /* Masks */
-#define ATOMISP_FOCUS_STATUS_MOVING           BIT(0)
+#define ATOMISP_FOCUS_STATUS_MOVING BIT(0)
 #define ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE BIT(1)
-#define ATOMISP_FOCUS_STATUS_HOME_POSITION    (3U << 2)
+#define ATOMISP_FOCUS_STATUS_HOME_POSITION (3U << 2)
 
 enum atomisp_camera_port {
 	ATOMISP_CAMERA_PORT_SECONDARY,
@@ -618,52 +618,50 @@ enum atomisp_ext_isp_id {
 	EXT_ISP_CID_SHOT_MODE
 };
 
-#define EXT_ISP_FOCUS_MODE_NORMAL	0
-#define EXT_ISP_FOCUS_MODE_MACRO	1
-#define EXT_ISP_FOCUS_MODE_TOUCH_AF	2
-#define EXT_ISP_FOCUS_MODE_PREVIEW_CAF	3
-#define EXT_ISP_FOCUS_MODE_MOVIE_CAF	4
-#define EXT_ISP_FOCUS_MODE_FACE_CAF	5
-#define EXT_ISP_FOCUS_MODE_TOUCH_MACRO	6
-#define EXT_ISP_FOCUS_MODE_TOUCH_CAF	7
+#define EXT_ISP_FOCUS_MODE_NORMAL 0
+#define EXT_ISP_FOCUS_MODE_MACRO 1
+#define EXT_ISP_FOCUS_MODE_TOUCH_AF 2
+#define EXT_ISP_FOCUS_MODE_PREVIEW_CAF 3
+#define EXT_ISP_FOCUS_MODE_MOVIE_CAF 4
+#define EXT_ISP_FOCUS_MODE_FACE_CAF 5
+#define EXT_ISP_FOCUS_MODE_TOUCH_MACRO 6
+#define EXT_ISP_FOCUS_MODE_TOUCH_CAF 7
 
-#define EXT_ISP_FOCUS_STOP		0
-#define EXT_ISP_FOCUS_SEARCH		1
-#define EXT_ISP_PAN_FOCUSING		2
+#define EXT_ISP_FOCUS_STOP 0
+#define EXT_ISP_FOCUS_SEARCH 1
+#define EXT_ISP_PAN_FOCUSING 2
 
-#define EXT_ISP_CAF_RESTART_CHECK	1
-#define EXT_ISP_CAF_STATUS_FOCUSING	2
-#define EXT_ISP_CAF_STATUS_SUCCESS	3
-#define EXT_ISP_CAF_STATUS_FAIL         4
+#define EXT_ISP_CAF_RESTART_CHECK 1
+#define EXT_ISP_CAF_STATUS_FOCUSING 2
+#define EXT_ISP_CAF_STATUS_SUCCESS 3
+#define EXT_ISP_CAF_STATUS_FAIL 4
 
-#define EXT_ISP_AF_STATUS_INVALID	1
-#define EXT_ISP_AF_STATUS_FOCUSING	2
-#define EXT_ISP_AF_STATUS_SUCCESS	3
-#define EXT_ISP_AF_STATUS_FAIL		4
+#define EXT_ISP_AF_STATUS_INVALID 1
+#define EXT_ISP_AF_STATUS_FOCUSING 2
+#define EXT_ISP_AF_STATUS_SUCCESS 3
+#define EXT_ISP_AF_STATUS_FAIL 4
 
 enum atomisp_burst_capture_options {
 	EXT_ISP_BURST_CAPTURE_CTRL_START = 0,
 	EXT_ISP_BURST_CAPTURE_CTRL_STOP
 };
 
-#define EXT_ISP_SHOT_MODE_AUTO		0
-#define EXT_ISP_SHOT_MODE_BEAUTY_FACE	1
-#define EXT_ISP_SHOT_MODE_BEST_PHOTO	2
-#define EXT_ISP_SHOT_MODE_DRAMA		3
-#define EXT_ISP_SHOT_MODE_BEST_FACE	4
-#define EXT_ISP_SHOT_MODE_ERASER	5
-#define EXT_ISP_SHOT_MODE_PANORAMA	6
-#define EXT_ISP_SHOT_MODE_RICH_TONE_HDR	7
-#define EXT_ISP_SHOT_MODE_NIGHT		8
-#define EXT_ISP_SHOT_MODE_SOUND_SHOT	9
-#define EXT_ISP_SHOT_MODE_ANIMATED_PHOTO	10
-#define EXT_ISP_SHOT_MODE_SPORTS	11
+#define EXT_ISP_SHOT_MODE_AUTO 0
+#define EXT_ISP_SHOT_MODE_BEAUTY_FACE 1
+#define EXT_ISP_SHOT_MODE_BEST_PHOTO 2
+#define EXT_ISP_SHOT_MODE_DRAMA 3
+#define EXT_ISP_SHOT_MODE_BEST_FACE 4
+#define EXT_ISP_SHOT_MODE_ERASER 5
+#define EXT_ISP_SHOT_MODE_PANORAMA 6
+#define EXT_ISP_SHOT_MODE_RICH_TONE_HDR 7
+#define EXT_ISP_SHOT_MODE_NIGHT 8
+#define EXT_ISP_SHOT_MODE_SOUND_SHOT 9
+#define EXT_ISP_SHOT_MODE_ANIMATED_PHOTO 10
+#define EXT_ISP_SHOT_MODE_SPORTS 11
 
 /*Private IOCTLs for ISP */
-#define ATOMISP_IOC_G_XNR \
-	_IOR('v', BASE_VIDIOC_PRIVATE + 0, int)
-#define ATOMISP_IOC_S_XNR \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 0, int)
+#define ATOMISP_IOC_G_XNR _IOR('v', BASE_VIDIOC_PRIVATE + 0, int)
+#define ATOMISP_IOC_S_XNR _IOW('v', BASE_VIDIOC_PRIVATE + 0, int)
 #define ATOMISP_IOC_G_NR \
 	_IOR('v', BASE_VIDIOC_PRIVATE + 1, struct atomisp_nr_config)
 #define ATOMISP_IOC_S_NR \
@@ -783,11 +781,9 @@ enum atomisp_burst_capture_options {
 #define ATOMISP_IOC_S_PARAMETERS \
 	_IOW('v', BASE_VIDIOC_PRIVATE + 32, struct atomisp_parameters)
 
-#define ATOMISP_IOC_EXP_ID_UNLOCK \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 36, int)
+#define ATOMISP_IOC_EXP_ID_UNLOCK _IOW('v', BASE_VIDIOC_PRIVATE + 36, int)
 
-#define ATOMISP_IOC_EXP_ID_CAPTURE \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 37, int)
+#define ATOMISP_IOC_EXP_ID_CAPTURE _IOW('v', BASE_VIDIOC_PRIVATE + 37, int)
 
 #define ATOMISP_IOC_S_ENABLE_DZ_CAPT_PIPE \
 	_IOWR('v', BASE_VIDIOC_PRIVATE + 38, unsigned int)
@@ -798,8 +794,7 @@ enum atomisp_burst_capture_options {
 #define ATOMISP_IOC_S_FORMATS_CONFIG \
 	_IOW('v', BASE_VIDIOC_PRIVATE + 39, struct atomisp_formats_config)
 
-#define ATOMISP_IOC_INJECT_A_FAKE_EVENT \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 42, int)
+#define ATOMISP_IOC_INJECT_A_FAKE_EVENT _IOW('v', BASE_VIDIOC_PRIVATE + 42, int)
 
 #define ATOMISP_IOC_S_ARRAY_RESOLUTION \
 	_IOW('v', BASE_VIDIOC_PRIVATE + 45, struct atomisp_resolution)
@@ -823,62 +818,55 @@ enum atomisp_burst_capture_options {
  */
 
 /*  ISP Private control IDs */
-#define V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION \
-	(V4L2_CID_PRIVATE_BASE + 0)
-#define V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC \
-	(V4L2_CID_PRIVATE_BASE + 1)
-#define V4L2_CID_ATOMISP_VIDEO_STABLIZATION \
-	(V4L2_CID_PRIVATE_BASE + 2)
-#define V4L2_CID_ATOMISP_FIXED_PATTERN_NR \
-	(V4L2_CID_PRIVATE_BASE + 3)
-#define V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION \
-	(V4L2_CID_PRIVATE_BASE + 4)
-#define V4L2_CID_ATOMISP_LOW_LIGHT \
-	(V4L2_CID_PRIVATE_BASE + 5)
+#define V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION (V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC (V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_CID_ATOMISP_VIDEO_STABLIZATION (V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_CID_ATOMISP_FIXED_PATTERN_NR (V4L2_CID_PRIVATE_BASE + 3)
+#define V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION (V4L2_CID_PRIVATE_BASE + 4)
+#define V4L2_CID_ATOMISP_LOW_LIGHT (V4L2_CID_PRIVATE_BASE + 5)
 
 /* Camera class:
  * Exposure, Flash and privacy (indicator) light controls, to be upstreamed */
-#define V4L2_CID_CAMERA_LASTP1             (V4L2_CID_CAMERA_CLASS_BASE + 1024)
+#define V4L2_CID_CAMERA_LASTP1 (V4L2_CID_CAMERA_CLASS_BASE + 1024)
 
-#define V4L2_CID_RUN_MODE			(V4L2_CID_CAMERA_LASTP1 + 20)
-#define ATOMISP_RUN_MODE_VIDEO			1
-#define ATOMISP_RUN_MODE_STILL_CAPTURE		2
-#define ATOMISP_RUN_MODE_PREVIEW		3
-#define ATOMISP_RUN_MODE_MIN			1
-#define ATOMISP_RUN_MODE_MAX			3
+#define V4L2_CID_RUN_MODE (V4L2_CID_CAMERA_LASTP1 + 20)
+#define ATOMISP_RUN_MODE_VIDEO 1
+#define ATOMISP_RUN_MODE_STILL_CAPTURE 2
+#define ATOMISP_RUN_MODE_PREVIEW 3
+#define ATOMISP_RUN_MODE_MIN 1
+#define ATOMISP_RUN_MODE_MAX 3
 
-#define V4L2_CID_ENABLE_VFPP			(V4L2_CID_CAMERA_LASTP1 + 21)
-#define V4L2_CID_ATOMISP_CONTINUOUS_MODE	(V4L2_CID_CAMERA_LASTP1 + 22)
+#define V4L2_CID_ENABLE_VFPP (V4L2_CID_CAMERA_LASTP1 + 21)
+#define V4L2_CID_ATOMISP_CONTINUOUS_MODE (V4L2_CID_CAMERA_LASTP1 + 22)
 #define V4L2_CID_ATOMISP_CONTINUOUS_RAW_BUFFER_SIZE \
-						(V4L2_CID_CAMERA_LASTP1 + 23)
-#define V4L2_CID_ATOMISP_CONTINUOUS_VIEWFINDER \
-						(V4L2_CID_CAMERA_LASTP1 + 24)
+	(V4L2_CID_CAMERA_LASTP1 + 23)
+#define V4L2_CID_ATOMISP_CONTINUOUS_VIEWFINDER (V4L2_CID_CAMERA_LASTP1 + 24)
 
-#define V4L2_CID_VFPP				(V4L2_CID_CAMERA_LASTP1 + 25)
-#define ATOMISP_VFPP_ENABLE			0
-#define ATOMISP_VFPP_DISABLE_SCALER		1
-#define ATOMISP_VFPP_DISABLE_LOWLAT		2
+#define V4L2_CID_VFPP (V4L2_CID_CAMERA_LASTP1 + 25)
+#define ATOMISP_VFPP_ENABLE 0
+#define ATOMISP_VFPP_DISABLE_SCALER 1
+#define ATOMISP_VFPP_DISABLE_LOWLAT 2
 
-#define V4L2_CID_START_ZSL_CAPTURE	(V4L2_CID_CAMERA_LASTP1 + 28)
+#define V4L2_CID_START_ZSL_CAPTURE (V4L2_CID_CAMERA_LASTP1 + 28)
 /* Lock and unlock raw buffer */
 #define V4L2_CID_ENABLE_RAW_BUFFER_LOCK (V4L2_CID_CAMERA_LASTP1 + 29)
 
-#define V4L2_CID_EXPOSURE_ZONE_NUM	(V4L2_CID_CAMERA_LASTP1 + 31)
+#define V4L2_CID_EXPOSURE_ZONE_NUM (V4L2_CID_CAMERA_LASTP1 + 31)
 /* Disable digital zoom */
-#define V4L2_CID_DISABLE_DZ		(V4L2_CID_CAMERA_LASTP1 + 32)
+#define V4L2_CID_DISABLE_DZ (V4L2_CID_CAMERA_LASTP1 + 32)
 
-#define V4L2_CID_ATOMISP_SELECT_ISP_VERSION	(V4L2_CID_CAMERA_LASTP1 + 38)
+#define V4L2_CID_ATOMISP_SELECT_ISP_VERSION (V4L2_CID_CAMERA_LASTP1 + 38)
 
-#define V4L2_BUF_FLAG_BUFFER_INVALID       0x0400
-#define V4L2_BUF_FLAG_BUFFER_VALID         0x0800
+#define V4L2_BUF_FLAG_BUFFER_INVALID 0x0400
+#define V4L2_BUF_FLAG_BUFFER_VALID 0x0800
 
-#define V4L2_BUF_TYPE_VIDEO_CAPTURE_ION  (V4L2_BUF_TYPE_PRIVATE + 1024)
+#define V4L2_BUF_TYPE_VIDEO_CAPTURE_ION (V4L2_BUF_TYPE_PRIVATE + 1024)
 
-#define V4L2_EVENT_ATOMISP_3A_STATS_READY   (V4L2_EVENT_PRIVATE_START + 1)
-#define V4L2_EVENT_ATOMISP_METADATA_READY   (V4L2_EVENT_PRIVATE_START + 2)
-#define V4L2_EVENT_ATOMISP_ACC_COMPLETE     (V4L2_EVENT_PRIVATE_START + 4)
-#define V4L2_EVENT_ATOMISP_PAUSE_BUFFER	    (V4L2_EVENT_PRIVATE_START + 5)
-#define V4L2_EVENT_ATOMISP_CSS_RESET	    (V4L2_EVENT_PRIVATE_START + 6)
+#define V4L2_EVENT_ATOMISP_3A_STATS_READY (V4L2_EVENT_PRIVATE_START + 1)
+#define V4L2_EVENT_ATOMISP_METADATA_READY (V4L2_EVENT_PRIVATE_START + 2)
+#define V4L2_EVENT_ATOMISP_ACC_COMPLETE (V4L2_EVENT_PRIVATE_START + 4)
+#define V4L2_EVENT_ATOMISP_PAUSE_BUFFER (V4L2_EVENT_PRIVATE_START + 5)
+#define V4L2_EVENT_ATOMISP_CSS_RESET (V4L2_EVENT_PRIVATE_START + 6)
 /* Nonstandard color effects for V4L2_CID_COLORFX */
 enum {
 	V4L2_COLORFX_SKIN_WHITEN_LOW = 1001,
diff --git a/drivers/staging/media/atomisp/include/linux/atomisp_gmin_platform.h b/drivers/staging/media/atomisp/include/linux/atomisp_gmin_platform.h
index 426c5ee4ec188210a93642f4c044220fe10af447..794d62f39d2929489bf2d2823d10c66c715e0599 100644
--- a/drivers/staging/media/atomisp/include/linux/atomisp_gmin_platform.h
+++ b/drivers/staging/media/atomisp/include/linux/atomisp_gmin_platform.h
@@ -12,11 +12,10 @@
 int atomisp_register_i2c_module(struct v4l2_subdev *subdev,
 				struct camera_sensor_platform_data *plat_data);
 int atomisp_gmin_remove_subdev(struct v4l2_subdev *sd);
-int gmin_get_var_int(struct device *dev, bool is_gmin,
-		     const char *var, int def);
+int gmin_get_var_int(struct device *dev, bool is_gmin, const char *var,
+		     int def);
 struct camera_sensor_platform_data *
-gmin_camera_platform_data(
-    struct v4l2_subdev *subdev,
-    enum atomisp_input_format csi_format,
-    enum atomisp_bayer_order csi_bayer);
+gmin_camera_platform_data(struct v4l2_subdev *subdev,
+			  enum atomisp_input_format csi_format,
+			  enum atomisp_bayer_order csi_bayer);
 #endif
diff --git a/drivers/staging/media/atomisp/include/linux/atomisp_platform.h b/drivers/staging/media/atomisp/include/linux/atomisp_platform.h
index 6146555fe9cfd859ef0541b79ab04b3a0d08454f..9a643c9003a3eeeff3e610d8c0718d6e4b33fb48 100644
--- a/drivers/staging/media/atomisp/include/linux/atomisp_platform.h
+++ b/drivers/staging/media/atomisp/include/linux/atomisp_platform.h
@@ -36,43 +36,43 @@ enum atomisp_input_stream_id {
 };
 
 enum atomisp_input_format {
-	ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY,/* 8 bits per subpixel (legacy) */
+	ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY, /* 8 bits per subpixel (legacy) */
 	ATOMISP_INPUT_FORMAT_YUV420_8, /* 8 bits per subpixel */
-	ATOMISP_INPUT_FORMAT_YUV420_10,/* 10 bits per subpixel */
-	ATOMISP_INPUT_FORMAT_YUV420_16,/* 16 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_YUV420_10, /* 10 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_YUV420_16, /* 16 bits per subpixel */
 	ATOMISP_INPUT_FORMAT_YUV422_8, /* UYVY..UVYV, 8 bits per subpixel */
-	ATOMISP_INPUT_FORMAT_YUV422_10,/* UYVY..UVYV, 10 bits per subpixel */
-	ATOMISP_INPUT_FORMAT_YUV422_16,/* UYVY..UVYV, 16 bits per subpixel */
-	ATOMISP_INPUT_FORMAT_RGB_444,  /* BGR..BGR, 4 bits per subpixel */
-	ATOMISP_INPUT_FORMAT_RGB_555,  /* BGR..BGR, 5 bits per subpixel */
-	ATOMISP_INPUT_FORMAT_RGB_565,  /* BGR..BGR, 5 bits B and R, 6 bits G */
-	ATOMISP_INPUT_FORMAT_RGB_666,  /* BGR..BGR, 6 bits per subpixel */
-	ATOMISP_INPUT_FORMAT_RGB_888,  /* BGR..BGR, 8 bits per subpixel */
-	ATOMISP_INPUT_FORMAT_RAW_6,    /* RAW data, 6 bits per pixel */
-	ATOMISP_INPUT_FORMAT_RAW_7,    /* RAW data, 7 bits per pixel */
-	ATOMISP_INPUT_FORMAT_RAW_8,    /* RAW data, 8 bits per pixel */
-	ATOMISP_INPUT_FORMAT_RAW_10,   /* RAW data, 10 bits per pixel */
-	ATOMISP_INPUT_FORMAT_RAW_12,   /* RAW data, 12 bits per pixel */
-	ATOMISP_INPUT_FORMAT_RAW_14,   /* RAW data, 14 bits per pixel */
-	ATOMISP_INPUT_FORMAT_RAW_16,   /* RAW data, 16 bits per pixel */
+	ATOMISP_INPUT_FORMAT_YUV422_10, /* UYVY..UVYV, 10 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_YUV422_16, /* UYVY..UVYV, 16 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_444, /* BGR..BGR, 4 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_555, /* BGR..BGR, 5 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_565, /* BGR..BGR, 5 bits B and R, 6 bits G */
+	ATOMISP_INPUT_FORMAT_RGB_666, /* BGR..BGR, 6 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_888, /* BGR..BGR, 8 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RAW_6, /* RAW data, 6 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_7, /* RAW data, 7 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_8, /* RAW data, 8 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_10, /* RAW data, 10 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_12, /* RAW data, 12 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_14, /* RAW data, 14 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_16, /* RAW data, 16 bits per pixel */
 	ATOMISP_INPUT_FORMAT_BINARY_8, /* Binary byte stream. */
 
 	/* CSI2-MIPI specific format: Generic short packet data. It is used to
 	 * keep the timing information for the opening/closing of shutters,
 	 * triggering of flashes and etc.
 	 */
-	ATOMISP_INPUT_FORMAT_GENERIC_SHORT1,  /* Generic Short Packet Code 1 */
-	ATOMISP_INPUT_FORMAT_GENERIC_SHORT2,  /* Generic Short Packet Code 2 */
-	ATOMISP_INPUT_FORMAT_GENERIC_SHORT3,  /* Generic Short Packet Code 3 */
-	ATOMISP_INPUT_FORMAT_GENERIC_SHORT4,  /* Generic Short Packet Code 4 */
-	ATOMISP_INPUT_FORMAT_GENERIC_SHORT5,  /* Generic Short Packet Code 5 */
-	ATOMISP_INPUT_FORMAT_GENERIC_SHORT6,  /* Generic Short Packet Code 6 */
-	ATOMISP_INPUT_FORMAT_GENERIC_SHORT7,  /* Generic Short Packet Code 7 */
-	ATOMISP_INPUT_FORMAT_GENERIC_SHORT8,  /* Generic Short Packet Code 8 */
+	ATOMISP_INPUT_FORMAT_GENERIC_SHORT1, /* Generic Short Packet Code 1 */
+	ATOMISP_INPUT_FORMAT_GENERIC_SHORT2, /* Generic Short Packet Code 2 */
+	ATOMISP_INPUT_FORMAT_GENERIC_SHORT3, /* Generic Short Packet Code 3 */
+	ATOMISP_INPUT_FORMAT_GENERIC_SHORT4, /* Generic Short Packet Code 4 */
+	ATOMISP_INPUT_FORMAT_GENERIC_SHORT5, /* Generic Short Packet Code 5 */
+	ATOMISP_INPUT_FORMAT_GENERIC_SHORT6, /* Generic Short Packet Code 6 */
+	ATOMISP_INPUT_FORMAT_GENERIC_SHORT7, /* Generic Short Packet Code 7 */
+	ATOMISP_INPUT_FORMAT_GENERIC_SHORT8, /* Generic Short Packet Code 8 */
 
 	/* CSI2-MIPI specific format: YUV data.
 	 */
-	ATOMISP_INPUT_FORMAT_YUV420_8_SHIFT,  /* YUV420 8-bit (Chroma Shifted
+	ATOMISP_INPUT_FORMAT_YUV420_8_SHIFT, /* YUV420 8-bit (Chroma Shifted
 						 Pixel Sampling) */
 	ATOMISP_INPUT_FORMAT_YUV420_10_SHIFT, /* YUV420 8-bit (Chroma Shifted
 						 Pixel Sampling) */
@@ -86,14 +86,14 @@ enum atomisp_input_format {
 	 * the User Defined Data Type 4 and the MPEG data as the
 	 * User Defined Data Type 7.
 	 */
-	ATOMISP_INPUT_FORMAT_USER_DEF1,  /* User defined 8-bit data type 1 */
-	ATOMISP_INPUT_FORMAT_USER_DEF2,  /* User defined 8-bit data type 2 */
-	ATOMISP_INPUT_FORMAT_USER_DEF3,  /* User defined 8-bit data type 3 */
-	ATOMISP_INPUT_FORMAT_USER_DEF4,  /* User defined 8-bit data type 4 */
-	ATOMISP_INPUT_FORMAT_USER_DEF5,  /* User defined 8-bit data type 5 */
-	ATOMISP_INPUT_FORMAT_USER_DEF6,  /* User defined 8-bit data type 6 */
-	ATOMISP_INPUT_FORMAT_USER_DEF7,  /* User defined 8-bit data type 7 */
-	ATOMISP_INPUT_FORMAT_USER_DEF8,  /* User defined 8-bit data type 8 */
+	ATOMISP_INPUT_FORMAT_USER_DEF1, /* User defined 8-bit data type 1 */
+	ATOMISP_INPUT_FORMAT_USER_DEF2, /* User defined 8-bit data type 2 */
+	ATOMISP_INPUT_FORMAT_USER_DEF3, /* User defined 8-bit data type 3 */
+	ATOMISP_INPUT_FORMAT_USER_DEF4, /* User defined 8-bit data type 4 */
+	ATOMISP_INPUT_FORMAT_USER_DEF5, /* User defined 8-bit data type 5 */
+	ATOMISP_INPUT_FORMAT_USER_DEF6, /* User defined 8-bit data type 6 */
+	ATOMISP_INPUT_FORMAT_USER_DEF7, /* User defined 8-bit data type 7 */
+	ATOMISP_INPUT_FORMAT_USER_DEF8, /* User defined 8-bit data type 8 */
 };
 
 #define N_ATOMISP_INPUT_FORMAT (ATOMISP_INPUT_FORMAT_USER_DEF8 + 1)
@@ -148,14 +148,14 @@ struct camera_sensor_platform_data {
 };
 
 struct camera_mipi_info {
-	enum atomisp_camera_port        port;
-	unsigned int                    num_lanes;
-	enum atomisp_input_format       input_format;
-	enum atomisp_bayer_order        raw_bayer_order;
-	enum atomisp_input_format       metadata_format;
-	u32                             metadata_width;
-	u32                             metadata_height;
-	const u32                       *metadata_effective_width;
+	enum atomisp_camera_port port;
+	unsigned int num_lanes;
+	enum atomisp_input_format input_format;
+	enum atomisp_bayer_order raw_bayer_order;
+	enum atomisp_input_format metadata_format;
+	u32 metadata_width;
+	u32 metadata_height;
+	const u32 *metadata_effective_width;
 };
 
 const struct intel_v4l2_subdev_table *atomisp_platform_get_subdevs(void);
@@ -166,16 +166,16 @@ void atomisp_unregister_subdev(struct v4l2_subdev *subdev);
 
 /* API from old platform_camera.h, new CPUID implementation */
 #define __IS_SOC(x) (boot_cpu_data.x86_vfm == x)
-#define __IS_SOCS(x, y) (boot_cpu_data.x86_vfm == x || boot_cpu_data.x86_vfm == y)
+#define __IS_SOCS(x, y) \
+	(boot_cpu_data.x86_vfm == x || boot_cpu_data.x86_vfm == y)
 
-#define IS_MFLD	__IS_SOC(INTEL_ATOM_SALTWELL_MID)
-#define IS_BYT	__IS_SOC(INTEL_ATOM_SILVERMONT)
-#define IS_CHT	__IS_SOC(INTEL_ATOM_AIRMONT)
-#define IS_MRFD	__IS_SOC(INTEL_ATOM_SILVERMONT_MID)
-#define IS_MOFD	__IS_SOC(INTEL_ATOM_SILVERMONT_MID2)
+#define IS_MFLD __IS_SOC(INTEL_ATOM_SALTWELL_MID)
+#define IS_BYT __IS_SOC(INTEL_ATOM_SILVERMONT)
+#define IS_CHT __IS_SOC(INTEL_ATOM_AIRMONT)
+#define IS_MRFD __IS_SOC(INTEL_ATOM_SILVERMONT_MID)
+#define IS_MOFD __IS_SOC(INTEL_ATOM_SILVERMONT_MID2)
 
 /* Both CHT and MOFD come with ISP2401 */
-#define IS_ISP2401 __IS_SOCS(INTEL_ATOM_AIRMONT, \
-			     INTEL_ATOM_SILVERMONT_MID2)
+#define IS_ISP2401 __IS_SOCS(INTEL_ATOM_AIRMONT, INTEL_ATOM_SILVERMONT_MID2)
 
 #endif /* ATOMISP_PLATFORM_H_ */
diff --git a/drivers/staging/media/atomisp/include/mmu/isp_mmu.h b/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
index ee9839b080a6f3d279269eb03ed2d8274625a807..77ef919e1fceea1186792e013407044bf524548e 100644
--- a/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
+++ b/drivers/staging/media/atomisp/include/mmu/isp_mmu.h
@@ -9,8 +9,8 @@
 /*
  * ISP MMU driver for classic two-level page tables
  */
-#ifndef	__ISP_MMU_H__
-#define	__ISP_MMU_H__
+#ifndef __ISP_MMU_H__
+#define __ISP_MMU_H__
 
 #include <linux/types.h>
 #include <linux/mutex.h>
@@ -20,38 +20,35 @@
  * do not change these values, the page size for ISP must be the
  * same as kernel's page size.
  */
-#define	ISP_PAGE_OFFSET		12
-#define	ISP_PAGE_SIZE		BIT(ISP_PAGE_OFFSET)
-#define	ISP_PAGE_MASK		(~(phys_addr_t)(ISP_PAGE_SIZE - 1))
+#define ISP_PAGE_OFFSET 12
+#define ISP_PAGE_SIZE BIT(ISP_PAGE_OFFSET)
+#define ISP_PAGE_MASK (~(phys_addr_t)(ISP_PAGE_SIZE - 1))
 
-#define	ISP_L1PT_OFFSET		22
-#define	ISP_L1PT_MASK		(~((1U << ISP_L1PT_OFFSET) - 1))
+#define ISP_L1PT_OFFSET 22
+#define ISP_L1PT_MASK (~((1U << ISP_L1PT_OFFSET) - 1))
 
-#define	ISP_L2PT_OFFSET		12
-#define	ISP_L2PT_MASK		(~(ISP_L1PT_MASK | (~(ISP_PAGE_MASK))))
+#define ISP_L2PT_OFFSET 12
+#define ISP_L2PT_MASK (~(ISP_L1PT_MASK | (~(ISP_PAGE_MASK))))
 
-#define	ISP_L1PT_PTES		1024
-#define	ISP_L2PT_PTES		1024
+#define ISP_L1PT_PTES 1024
+#define ISP_L2PT_PTES 1024
 
-#define	ISP_PTR_TO_L1_IDX(x)	((((x) & ISP_L1PT_MASK)) \
-					>> ISP_L1PT_OFFSET)
+#define ISP_PTR_TO_L1_IDX(x) ((((x)&ISP_L1PT_MASK)) >> ISP_L1PT_OFFSET)
 
-#define	ISP_PTR_TO_L2_IDX(x)	((((x) & ISP_L2PT_MASK)) \
-					>> ISP_L2PT_OFFSET)
+#define ISP_PTR_TO_L2_IDX(x) ((((x)&ISP_L2PT_MASK)) >> ISP_L2PT_OFFSET)
 
-#define	ISP_PAGE_ALIGN(x)	(((x) + (ISP_PAGE_SIZE - 1)) \
-					& ISP_PAGE_MASK)
+#define ISP_PAGE_ALIGN(x) (((x) + (ISP_PAGE_SIZE - 1)) & ISP_PAGE_MASK)
 
-#define	ISP_PT_TO_VIRT(l1_idx, l2_idx, offset) do {\
-		((l1_idx) << ISP_L1PT_OFFSET) | \
-		((l2_idx) << ISP_L2PT_OFFSET) | \
-		(offset)\
-} while (0)
+#define ISP_PT_TO_VIRT(l1_idx, l2_idx, offset)                   \
+	do {                                                     \
+		((l1_idx) << ISP_L1PT_OFFSET) |                  \
+			((l2_idx) << ISP_L2PT_OFFSET) | (offset) \
+	} while (0)
 
-#define	pgnr_to_size(pgnr)	((pgnr) << ISP_PAGE_OFFSET)
-#define	size_to_pgnr_ceil(size)	(((size) + (1 << ISP_PAGE_OFFSET) - 1)\
-						>> ISP_PAGE_OFFSET)
-#define	size_to_pgnr_bottom(size)	((size) >> ISP_PAGE_OFFSET)
+#define pgnr_to_size(pgnr) ((pgnr) << ISP_PAGE_OFFSET)
+#define size_to_pgnr_ceil(size) \
+	(((size) + (1 << ISP_PAGE_OFFSET) - 1) >> ISP_PAGE_OFFSET)
+#define size_to_pgnr_bottom(size) ((size) >> ISP_PAGE_OFFSET)
 
 struct isp_mmu;
 
@@ -86,14 +83,11 @@ struct isp_mmu_client {
 	 * tlb_flush_all is must be provided. if tlb_flush_range is
 	 * not valid, it will set to tlb_flush_all by default.
 	 */
-	void (*tlb_flush_range)(struct isp_mmu *mmu,
-				unsigned int addr, unsigned int size);
+	void (*tlb_flush_range)(struct isp_mmu *mmu, unsigned int addr,
+				unsigned int size);
 	void (*tlb_flush_all)(struct isp_mmu *mmu);
-	unsigned int (*phys_to_pte)(struct isp_mmu *mmu,
-				    phys_addr_t phys);
-	phys_addr_t (*pte_to_phys)(struct isp_mmu *mmu,
-				   unsigned int pte);
-
+	unsigned int (*phys_to_pte)(struct isp_mmu *mmu, phys_addr_t phys);
+	phys_addr_t (*pte_to_phys)(struct isp_mmu *mmu, unsigned int pte);
 };
 
 struct isp_mmu {
@@ -106,14 +100,12 @@ struct isp_mmu {
 };
 
 /* flags for PDE and PTE */
-#define	ISP_PTE_VALID_MASK(mmu)	\
-	((mmu)->driver->pte_valid_mask)
+#define ISP_PTE_VALID_MASK(mmu) ((mmu)->driver->pte_valid_mask)
 
-#define	ISP_PTE_VALID(mmu, pte)	\
-	((pte) & ISP_PTE_VALID_MASK(mmu))
+#define ISP_PTE_VALID(mmu, pte) ((pte)&ISP_PTE_VALID_MASK(mmu))
 
-#define	NULL_PAGE	((phys_addr_t)(-1) & ISP_PAGE_MASK)
-#define	PAGE_VALID(page)	((page) != NULL_PAGE)
+#define NULL_PAGE ((phys_addr_t)(-1) & ISP_PAGE_MASK)
+#define PAGE_VALID(page) ((page) != NULL_PAGE)
 
 /*
  * init mmu with specific mmu driver.
@@ -134,8 +126,8 @@ void isp_mmu_exit(struct isp_mmu *mmu);
  * map/unmap will not flush tlb, and caller needs to deal with
  * this itself.
  */
-int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
-		phys_addr_t phys, unsigned int pgnr);
+int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt, phys_addr_t phys,
+		unsigned int pgnr);
 
 void isp_mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
 		   unsigned int pgnr);
@@ -149,7 +141,8 @@ static inline void isp_mmu_flush_tlb_all(struct isp_mmu *mmu)
 #define isp_mmu_flush_tlb isp_mmu_flush_tlb_all
 
 static inline void isp_mmu_flush_tlb_range(struct isp_mmu *mmu,
-	unsigned int start, unsigned int size)
+					   unsigned int start,
+					   unsigned int size)
 {
 	if (mmu->driver && mmu->driver->tlb_flush_range)
 		mmu->driver->tlb_flush_range(mmu, start, size);
diff --git a/drivers/staging/media/atomisp/include/mmu/sh_mmu_mrfld.h b/drivers/staging/media/atomisp/include/mmu/sh_mmu_mrfld.h
index bdec30ff8309d872678c524b621b385fbf359668..de673ba03c456af292ce24395634727deedc2412 100644
--- a/drivers/staging/media/atomisp/include/mmu/sh_mmu_mrfld.h
+++ b/drivers/staging/media/atomisp/include/mmu/sh_mmu_mrfld.h
@@ -7,8 +7,8 @@
  * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  */
 
-#ifndef	__SH_MMU_MRFLD_H__
-#define	__SH_MMU_MRFLD_H__
+#ifndef __SH_MMU_MRFLD_H__
+#define __SH_MMU_MRFLD_H__
 
 extern struct isp_mmu_client sh_mmu_mrfld;
 #endif
diff --git a/drivers/staging/media/atomisp/pci/atomisp-regs.h b/drivers/staging/media/atomisp/pci/atomisp-regs.h
index 15e61098a675625fb08af82a969ee8ecdacfae43..ed625c9c5d0210bf287932fdeda680beb129d9c4 100644
--- a/drivers/staging/media/atomisp/pci/atomisp-regs.h
+++ b/drivers/staging/media/atomisp/pci/atomisp-regs.h
@@ -9,44 +9,44 @@
 #define ATOMISP_REGS_H
 
 /* common register definitions */
-#define PCICMDSTS		0x01
-#define INTR			0x0f
-#define MSI_CAPID		0x24
-#define MSI_ADDRESS		0x25
-#define MSI_DATA		0x26
-#define INTR_CTL		0x27
-
-#define PCI_MSI_CAPID		0x90
-#define PCI_MSI_ADDR		0x94
-#define PCI_MSI_DATA		0x98
-#define PCI_INTERRUPT_CTRL	0x9C
-#define PCI_I_CONTROL		0xfc
+#define PCICMDSTS 0x01
+#define INTR 0x0f
+#define MSI_CAPID 0x24
+#define MSI_ADDRESS 0x25
+#define MSI_DATA 0x26
+#define INTR_CTL 0x27
+
+#define PCI_MSI_CAPID 0x90
+#define PCI_MSI_ADDR 0x94
+#define PCI_MSI_DATA 0x98
+#define PCI_INTERRUPT_CTRL 0x9C
+#define PCI_I_CONTROL 0xfc
 
 /* MRFLD specific register definitions */
-#define MRFLD_CSI_AFE		0x39
-#define MRFLD_CSI_CONTROL	0x3a
-#define MRFLD_CSI_RCOMP		0x3d
-
-#define MRFLD_PCI_PMCS		0x84
-#define MRFLD_PCI_CSI_ACCESS_CTRL_VIOL	0xd4
-#define MRFLD_PCI_CSI_AFE_HS_CONTROL	0xdc
-#define MRFLD_PCI_CSI_AFE_RCOMP_CONTROL	0xe0
-#define MRFLD_PCI_CSI_CONTROL		0xe8
-#define MRFLD_PCI_CSI_AFE_TRIM_CONTROL	0xe4
-#define MRFLD_PCI_CSI_DEADLINE_CONTROL	0xec
-#define MRFLD_PCI_CSI_RCOMP_CONTROL	0xf4
+#define MRFLD_CSI_AFE 0x39
+#define MRFLD_CSI_CONTROL 0x3a
+#define MRFLD_CSI_RCOMP 0x3d
+
+#define MRFLD_PCI_PMCS 0x84
+#define MRFLD_PCI_CSI_ACCESS_CTRL_VIOL 0xd4
+#define MRFLD_PCI_CSI_AFE_HS_CONTROL 0xdc
+#define MRFLD_PCI_CSI_AFE_RCOMP_CONTROL 0xe0
+#define MRFLD_PCI_CSI_CONTROL 0xe8
+#define MRFLD_PCI_CSI_AFE_TRIM_CONTROL 0xe4
+#define MRFLD_PCI_CSI_DEADLINE_CONTROL 0xec
+#define MRFLD_PCI_CSI_RCOMP_CONTROL 0xf4
 
 /* Select Arasan (legacy)/Intel input system */
-#define MRFLD_PCI_CSI_CONTROL_PARPATHEN	BIT(24)
+#define MRFLD_PCI_CSI_CONTROL_PARPATHEN BIT(24)
 /* Enable CSI interface (ANN B0/K0) */
-#define MRFLD_PCI_CSI_CONTROL_CSI_READY	BIT(25)
+#define MRFLD_PCI_CSI_CONTROL_CSI_READY BIT(25)
 
 /*
  * Enables the combining of adjacent 32-byte read requests to the same
  * cache line. When cleared, each 32-byte read request is sent as a
  * separate request on the IB interface.
  */
-#define MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING	0x1
+#define MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING 0x1
 
 /*
  * Register: MRFLD_PCI_CSI_RCOMP_CONTROL
@@ -55,24 +55,24 @@
  * If this bit is set, then the high speed clock is not gated during the
  * update cycle.
  */
-#define MRFLD_PCI_CSI_HS_OVR_CLK_GATE_ON_UPDATE		0x800000
+#define MRFLD_PCI_CSI_HS_OVR_CLK_GATE_ON_UPDATE 0x800000
 
 /*
  * Enables the combining of adjacent 32-byte write requests to the same
  * cache line. When cleared, each 32-byte write request is sent as a
  * separate request on the IB interface.
  */
-#define MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING	0x2
+#define MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING 0x2
 
-#define MRFLD_PCI_I_CONTROL_SRSE_RESET_MASK		0xc
+#define MRFLD_PCI_I_CONTROL_SRSE_RESET_MASK 0xc
 
-#define MRFLD_PCI_CSI1_HSRXCLKTRIM		0x2
-#define MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT	16
-#define MRFLD_PCI_CSI2_HSRXCLKTRIM		0x3
-#define MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT	24
-#define MRFLD_PCI_CSI3_HSRXCLKTRIM		0x2
-#define MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT	28
-#define MRFLD_PCI_CSI_HSRXCLKTRIM_MASK		0xf
+#define MRFLD_PCI_CSI1_HSRXCLKTRIM 0x2
+#define MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT 16
+#define MRFLD_PCI_CSI2_HSRXCLKTRIM 0x3
+#define MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT 24
+#define MRFLD_PCI_CSI3_HSRXCLKTRIM 0x2
+#define MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT 28
+#define MRFLD_PCI_CSI_HSRXCLKTRIM_MASK 0xf
 
 /*
  * This register is IUINT MMIO register, it is used to select the CSI
@@ -80,106 +80,106 @@
  * 1: SH CSI backend
  * 0: Arasan CSI backend
  */
-#define MRFLD_CSI_RECEIVER_SELECTION_REG       0x8081c
+#define MRFLD_CSI_RECEIVER_SELECTION_REG 0x8081c
 
-#define MRFLD_INTR_CLEAR_REG		       0x50c
-#define MRFLD_INTR_STATUS_REG		       0x508
-#define MRFLD_INTR_ENABLE_REG		       0x510
+#define MRFLD_INTR_CLEAR_REG 0x50c
+#define MRFLD_INTR_STATUS_REG 0x508
+#define MRFLD_INTR_ENABLE_REG 0x510
 
-#define MRFLD_MAX_ZOOM_FACTOR	1024
+#define MRFLD_MAX_ZOOM_FACTOR 1024
 
 /* MRFLD ISP POWER related */
-#define MRFLD_ISPSSPM0         0x39
-#define MRFLD_ISPSSPM0_ISPSSC_OFFSET   0
-#define MRFLD_ISPSSPM0_ISPSSS_OFFSET   24
-#define MRFLD_ISPSSPM0_ISPSSC_MASK     0x3
-#define MRFLD_ISPSSPM0_IUNIT_POWER_ON  0
+#define MRFLD_ISPSSPM0 0x39
+#define MRFLD_ISPSSPM0_ISPSSC_OFFSET 0
+#define MRFLD_ISPSSPM0_ISPSSS_OFFSET 24
+#define MRFLD_ISPSSPM0_ISPSSC_MASK 0x3
+#define MRFLD_ISPSSPM0_IUNIT_POWER_ON 0
 #define MRFLD_ISPSSPM0_IUNIT_POWER_OFF 0x3
-#define MRFLD_ISPSSDVFS			0x13F
-#define MRFLD_BIT0			0x0001
-#define MRFLD_BIT1			0x0002
+#define MRFLD_ISPSSDVFS 0x13F
+#define MRFLD_BIT0 0x0001
+#define MRFLD_BIT1 0x0002
 
 /* MRFLD CSI lane configuration related */
-#define MRFLD_PORT_CONFIG_NUM  8
-#define MRFLD_PORT1_ENABLE_SHIFT       0
-#define MRFLD_PORT2_ENABLE_SHIFT       1
-#define MRFLD_PORT3_ENABLE_SHIFT       2
-#define MRFLD_PORT1_LANES_SHIFT        3
-#define MRFLD_PORT2_LANES_SHIFT        7
-#define MRFLD_PORT3_LANES_SHIFT        8
+#define MRFLD_PORT_CONFIG_NUM 8
+#define MRFLD_PORT1_ENABLE_SHIFT 0
+#define MRFLD_PORT2_ENABLE_SHIFT 1
+#define MRFLD_PORT3_ENABLE_SHIFT 2
+#define MRFLD_PORT1_LANES_SHIFT 3
+#define MRFLD_PORT2_LANES_SHIFT 7
+#define MRFLD_PORT3_LANES_SHIFT 8
 #define MRFLD_PORT_CONFIG_MASK 0x000f03ff
-#define MRFLD_PORT_CONFIGCODE_SHIFT    16
-#define MRFLD_ALL_CSI_PORTS_OFF_MASK   0x7
-
-#define CHV_PORT3_LANES_SHIFT		9
-#define CHV_PORT_CONFIG_MASK		0x1f07ff
-
-#define ISPSSPM1				0x3a
-#define ISP_FREQ_STAT_MASK			(0x1f << ISP_FREQ_STAT_OFFSET)
-#define ISP_REQ_FREQ_MASK			0x1f
-#define ISP_FREQ_VALID_MASK			(0x1 << ISP_FREQ_VALID_OFFSET)
-#define ISP_FREQ_STAT_OFFSET			0x18
-#define ISP_REQ_GUAR_FREQ_OFFSET		0x8
-#define ISP_REQ_FREQ_OFFSET			0x0
-#define ISP_FREQ_VALID_OFFSET			0x7
-#define ISP_FREQ_RULE_ANY			0x0
-
-#define ISP_FREQ_457MHZ				0x1C9
-#define ISP_FREQ_400MHZ				0x190
-#define ISP_FREQ_356MHZ				0x164
-#define ISP_FREQ_320MHZ				0x140
-#define ISP_FREQ_266MHZ				0x10a
-#define ISP_FREQ_200MHZ				0xc8
-#define ISP_FREQ_100MHZ				0x64
-
-#define HPLL_FREQ_800MHZ			0x320
-#define HPLL_FREQ_1600MHZ			0x640
-#define HPLL_FREQ_2000MHZ			0x7D0
-
-#define CCK_FUSE_REG_0			0x08
-#define CCK_FUSE_HPLL_FREQ_MASK		0x03
+#define MRFLD_PORT_CONFIGCODE_SHIFT 16
+#define MRFLD_ALL_CSI_PORTS_OFF_MASK 0x7
+
+#define CHV_PORT3_LANES_SHIFT 9
+#define CHV_PORT_CONFIG_MASK 0x1f07ff
+
+#define ISPSSPM1 0x3a
+#define ISP_FREQ_STAT_MASK (0x1f << ISP_FREQ_STAT_OFFSET)
+#define ISP_REQ_FREQ_MASK 0x1f
+#define ISP_FREQ_VALID_MASK (0x1 << ISP_FREQ_VALID_OFFSET)
+#define ISP_FREQ_STAT_OFFSET 0x18
+#define ISP_REQ_GUAR_FREQ_OFFSET 0x8
+#define ISP_REQ_FREQ_OFFSET 0x0
+#define ISP_FREQ_VALID_OFFSET 0x7
+#define ISP_FREQ_RULE_ANY 0x0
+
+#define ISP_FREQ_457MHZ 0x1C9
+#define ISP_FREQ_400MHZ 0x190
+#define ISP_FREQ_356MHZ 0x164
+#define ISP_FREQ_320MHZ 0x140
+#define ISP_FREQ_266MHZ 0x10a
+#define ISP_FREQ_200MHZ 0xc8
+#define ISP_FREQ_100MHZ 0x64
+
+#define HPLL_FREQ_800MHZ 0x320
+#define HPLL_FREQ_1600MHZ 0x640
+#define HPLL_FREQ_2000MHZ 0x7D0
+
+#define CCK_FUSE_REG_0 0x08
+#define CCK_FUSE_HPLL_FREQ_MASK 0x03
 
 /* ISP2401 CSI2+ receiver delay settings */
-#define CSI2_PORT_A_BASE					0xC0000
-#define CSI2_PORT_B_BASE					0xC2000
-#define CSI2_PORT_C_BASE					0xC4000
-
-#define CSI2_LANE_CL_BASE					0x418
-#define CSI2_LANE_D0_BASE					0x420
-#define CSI2_LANE_D1_BASE					0x428
-#define CSI2_LANE_D2_BASE					0x430
-#define CSI2_LANE_D3_BASE					0x438
-
-#define CSI2_REG_RX_CSI_DLY_CNT_TERMEN				0
-#define CSI2_REG_RX_CSI_DLY_CNT_SETTLE				0x4
-
-#define CSI2_PORT_A_RX_CSI_DLY_CNT_TERMEN_CLANE			0xC0418
-#define CSI2_PORT_A_RX_CSI_DLY_CNT_SETTLE_CLANE			0xC041C
-#define CSI2_PORT_A_RX_CSI_DLY_CNT_TERMEN_DLANE0		0xC0420
-#define CSI2_PORT_A_RX_CSI_DLY_CNT_SETTLE_DLANE0		0xC0424
-#define CSI2_PORT_A_RX_CSI_DLY_CNT_TERMEN_DLANE1		0xC0428
-#define CSI2_PORT_A_RX_CSI_DLY_CNT_SETTLE_DLANE1		0xC042C
-#define CSI2_PORT_A_RX_CSI_DLY_CNT_TERMEN_DLANE2		0xC0430
-#define CSI2_PORT_A_RX_CSI_DLY_CNT_SETTLE_DLANE2		0xC0434
-#define CSI2_PORT_A_RX_CSI_DLY_CNT_TERMEN_DLANE3		0xC0438
-#define CSI2_PORT_A_RX_CSI_DLY_CNT_SETTLE_DLANE3		0xC043C
-
-#define CSI2_PORT_B_RX_CSI_DLY_CNT_TERMEN_CLANE			0xC2418
-#define CSI2_PORT_B_RX_CSI_DLY_CNT_SETTLE_CLANE			0xC241C
-#define CSI2_PORT_B_RX_CSI_DLY_CNT_TERMEN_DLANE0		0xC2420
-#define CSI2_PORT_B_RX_CSI_DLY_CNT_SETTLE_DLANE0		0xC2424
-#define CSI2_PORT_B_RX_CSI_DLY_CNT_TERMEN_DLANE1		0xC2428
-#define CSI2_PORT_B_RX_CSI_DLY_CNT_SETTLE_DLANE1		0xC242C
-
-#define CSI2_PORT_C_RX_CSI_DLY_CNT_TERMEN_CLANE			0xC4418
-#define CSI2_PORT_C_RX_CSI_DLY_CNT_SETTLE_CLANE			0xC441C
-#define CSI2_PORT_C_RX_CSI_DLY_CNT_TERMEN_DLANE0		0xC4420
-#define CSI2_PORT_C_RX_CSI_DLY_CNT_SETTLE_DLANE0		0xC4424
-#define CSI2_PORT_C_RX_CSI_DLY_CNT_TERMEN_DLANE1		0xC4428
-#define CSI2_PORT_C_RX_CSI_DLY_CNT_SETTLE_DLANE1		0xC442C
-
-#define DMA_BURST_SIZE_REG					0xCD408
-
-#define ISP_DFS_TRY_TIMES	2
+#define CSI2_PORT_A_BASE 0xC0000
+#define CSI2_PORT_B_BASE 0xC2000
+#define CSI2_PORT_C_BASE 0xC4000
+
+#define CSI2_LANE_CL_BASE 0x418
+#define CSI2_LANE_D0_BASE 0x420
+#define CSI2_LANE_D1_BASE 0x428
+#define CSI2_LANE_D2_BASE 0x430
+#define CSI2_LANE_D3_BASE 0x438
+
+#define CSI2_REG_RX_CSI_DLY_CNT_TERMEN 0
+#define CSI2_REG_RX_CSI_DLY_CNT_SETTLE 0x4
+
+#define CSI2_PORT_A_RX_CSI_DLY_CNT_TERMEN_CLANE 0xC0418
+#define CSI2_PORT_A_RX_CSI_DLY_CNT_SETTLE_CLANE 0xC041C
+#define CSI2_PORT_A_RX_CSI_DLY_CNT_TERMEN_DLANE0 0xC0420
+#define CSI2_PORT_A_RX_CSI_DLY_CNT_SETTLE_DLANE0 0xC0424
+#define CSI2_PORT_A_RX_CSI_DLY_CNT_TERMEN_DLANE1 0xC0428
+#define CSI2_PORT_A_RX_CSI_DLY_CNT_SETTLE_DLANE1 0xC042C
+#define CSI2_PORT_A_RX_CSI_DLY_CNT_TERMEN_DLANE2 0xC0430
+#define CSI2_PORT_A_RX_CSI_DLY_CNT_SETTLE_DLANE2 0xC0434
+#define CSI2_PORT_A_RX_CSI_DLY_CNT_TERMEN_DLANE3 0xC0438
+#define CSI2_PORT_A_RX_CSI_DLY_CNT_SETTLE_DLANE3 0xC043C
+
+#define CSI2_PORT_B_RX_CSI_DLY_CNT_TERMEN_CLANE 0xC2418
+#define CSI2_PORT_B_RX_CSI_DLY_CNT_SETTLE_CLANE 0xC241C
+#define CSI2_PORT_B_RX_CSI_DLY_CNT_TERMEN_DLANE0 0xC2420
+#define CSI2_PORT_B_RX_CSI_DLY_CNT_SETTLE_DLANE0 0xC2424
+#define CSI2_PORT_B_RX_CSI_DLY_CNT_TERMEN_DLANE1 0xC2428
+#define CSI2_PORT_B_RX_CSI_DLY_CNT_SETTLE_DLANE1 0xC242C
+
+#define CSI2_PORT_C_RX_CSI_DLY_CNT_TERMEN_CLANE 0xC4418
+#define CSI2_PORT_C_RX_CSI_DLY_CNT_SETTLE_CLANE 0xC441C
+#define CSI2_PORT_C_RX_CSI_DLY_CNT_TERMEN_DLANE0 0xC4420
+#define CSI2_PORT_C_RX_CSI_DLY_CNT_SETTLE_DLANE0 0xC4424
+#define CSI2_PORT_C_RX_CSI_DLY_CNT_TERMEN_DLANE1 0xC4428
+#define CSI2_PORT_C_RX_CSI_DLY_CNT_SETTLE_DLANE1 0xC442C
+
+#define DMA_BURST_SIZE_REG 0xCD408
+
+#define ISP_DFS_TRY_TIMES 2
 
 #endif /* ATOMISP_REGS_H */
diff --git a/drivers/staging/media/atomisp/pci/atomisp_cmd.c b/drivers/staging/media/atomisp/pci/atomisp_cmd.c
index 3a4eb4f6d3be5df9be7292fd42e5c3809a1c7dac..9d7aaa91c4f6b49c93fa0526b6ce84ae663309a6 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_cmd.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_cmd.c
@@ -75,8 +75,8 @@ struct camera_mipi_info *atomisp_to_sensor_mipi_info(struct v4l2_subdev *sd)
  */
 struct atomisp_video_pipe *atomisp_to_video_pipe(struct video_device *dev)
 {
-	return (struct atomisp_video_pipe *)
-	       container_of(dev, struct atomisp_video_pipe, vdev);
+	return (struct atomisp_video_pipe *)container_of(
+		dev, struct atomisp_video_pipe, vdev);
 }
 
 static unsigned short atomisp_get_sensor_fps(struct atomisp_sub_device *asd)
@@ -115,7 +115,8 @@ static int write_target_freq_to_hw(struct atomisp_device *isp,
 	int i;
 
 	if (!isp->hpll_freq) {
-		dev_err(isp->dev, "failed to get hpll_freq. no change to freq\n");
+		dev_err(isp->dev,
+			"failed to get hpll_freq. no change to freq\n");
 		return -EINVAL;
 	}
 
@@ -134,16 +135,18 @@ static int write_target_freq_to_hw(struct atomisp_device *isp,
 
 	for (i = 0; i < ISP_DFS_TRY_TIMES; i++) {
 		iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE, ISPSSPM1,
-			       isp_sspm1
-			       | ratio << ISP_REQ_FREQ_OFFSET
-			       | 1 << ISP_FREQ_VALID_OFFSET
-			       | guar_ratio << ISP_REQ_GUAR_FREQ_OFFSET);
+			       isp_sspm1 | ratio << ISP_REQ_FREQ_OFFSET |
+				       1 << ISP_FREQ_VALID_OFFSET |
+				       guar_ratio << ISP_REQ_GUAR_FREQ_OFFSET);
 
-		iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1, &isp_sspm1);
+		iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1,
+			      &isp_sspm1);
 		timeout = 20;
 		while ((isp_sspm1 & ISP_FREQ_VALID_MASK) && timeout) {
-			iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1, &isp_sspm1);
-			dev_dbg(isp->dev, "waiting for ISPSSPM1 valid bit to be 0.\n");
+			iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1,
+				      &isp_sspm1);
+			dev_dbg(isp->dev,
+				"waiting for ISPSSPM1 valid bit to be 0.\n");
 			udelay(100);
 			timeout--;
 		}
@@ -160,8 +163,10 @@ static int write_target_freq_to_hw(struct atomisp_device *isp,
 	iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1, &isp_sspm1);
 	timeout = 10;
 	while (((isp_sspm1 >> ISP_FREQ_STAT_OFFSET) != ratio) && timeout) {
-		iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1, &isp_sspm1);
-		dev_dbg(isp->dev, "waiting for ISPSSPM1 status bit to be 0x%x.\n",
+		iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM1,
+			      &isp_sspm1);
+		dev_dbg(isp->dev,
+			"waiting for ISPSSPM1 status bit to be 0x%x.\n",
 			new_freq);
 		udelay(100);
 		timeout--;
@@ -174,8 +179,7 @@ static int write_target_freq_to_hw(struct atomisp_device *isp,
 	return 0;
 }
 
-int atomisp_freq_scaling(struct atomisp_device *isp,
-			 enum atomisp_dfs_mode mode,
+int atomisp_freq_scaling(struct atomisp_device *isp, enum atomisp_dfs_mode mode,
 			 bool force)
 {
 	const struct atomisp_dfs_config *dfs;
@@ -324,7 +328,7 @@ void atomisp_msi_irq_uninit(struct atomisp_device *isp)
 	u16 msg16;
 
 	pci_read_config_dword(pdev, PCI_MSI_CAPID, &msg32);
-	msg32 &=  ~(1 << MSI_ENABLE_BIT);
+	msg32 &= ~(1 << MSI_ENABLE_BIT);
 	pci_write_config_dword(pdev, PCI_MSI_CAPID, msg32);
 
 	msg32 = 0x0;
@@ -337,7 +341,7 @@ void atomisp_msi_irq_uninit(struct atomisp_device *isp)
 
 static void atomisp_sof_event(struct atomisp_sub_device *asd)
 {
-	struct v4l2_event event = {0};
+	struct v4l2_event event = { 0 };
 
 	event.type = V4L2_EVENT_FRAME_SYNC;
 	event.u.frame_sync.frame_sequence = atomic_read(&asd->sof_count);
@@ -347,7 +351,7 @@ static void atomisp_sof_event(struct atomisp_sub_device *asd)
 
 void atomisp_eof_event(struct atomisp_sub_device *asd, uint8_t exp_id)
 {
-	struct v4l2_event event = {0};
+	struct v4l2_event event = { 0 };
 
 	event.type = V4L2_EVENT_FRAME_END;
 	event.u.frame_sync.frame_sequence = exp_id;
@@ -356,9 +360,9 @@ void atomisp_eof_event(struct atomisp_sub_device *asd, uint8_t exp_id)
 }
 
 static void atomisp_3a_stats_ready_event(struct atomisp_sub_device *asd,
-	uint8_t exp_id)
+					 uint8_t exp_id)
 {
-	struct v4l2_event event = {0};
+	struct v4l2_event event = { 0 };
 
 	event.type = V4L2_EVENT_ATOMISP_3A_STATS_READY;
 	event.u.frame_sync.frame_sequence = exp_id;
@@ -367,9 +371,9 @@ static void atomisp_3a_stats_ready_event(struct atomisp_sub_device *asd,
 }
 
 static void atomisp_metadata_ready_event(struct atomisp_sub_device *asd,
-	enum atomisp_metadata_type md_type)
+					 enum atomisp_metadata_type md_type)
 {
-	struct v4l2_event event = {0};
+	struct v4l2_event event = { 0 };
 
 	event.type = V4L2_EVENT_ATOMISP_METADATA_READY;
 	event.u.data[0] = md_type;
@@ -379,7 +383,7 @@ static void atomisp_metadata_ready_event(struct atomisp_sub_device *asd,
 
 static void atomisp_reset_event(struct atomisp_sub_device *asd)
 {
-	struct v4l2_event event = {0};
+	struct v4l2_event event = { 0 };
 
 	event.type = V4L2_EVENT_ATOMISP_CSS_RESET;
 
@@ -469,15 +473,18 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 		 * NOTE: There is assumption here that ISP will not start processing
 		 * next frame from sensor before old one is completely done.
 		 */
-		if (atomic_read(&isp->asd.sequence) == atomic_read(&isp->asd.sequence_temp))
-			atomic_set(&isp->asd.sequence_temp, atomic_read(&isp->asd.sof_count));
+		if (atomic_read(&isp->asd.sequence) ==
+		    atomic_read(&isp->asd.sequence_temp))
+			atomic_set(&isp->asd.sequence_temp,
+				   atomic_read(&isp->asd.sof_count));
 
 		dev_dbg_ratelimited(isp->dev, "irq:0x%x (SOF)\n", irq_infos);
 		irq_infos &= ~IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF;
 	}
 
 	if (irq_infos & IA_CSS_IRQ_INFO_EVENTS_READY)
-		atomic_set(&isp->asd.sequence, atomic_read(&isp->asd.sequence_temp));
+		atomic_set(&isp->asd.sequence,
+			   atomic_read(&isp->asd.sequence_temp));
 
 	if ((irq_infos & IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR) ||
 	    (irq_infos & IA_CSS_IRQ_INFO_IF_ERROR)) {
@@ -485,8 +492,7 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 		u32 rx_infos;
 		enum mipi_port_id port;
 
-		for (port = MIPI_PORT0_ID; port <= MIPI_PORT2_ID;
-		     port++) {
+		for (port = MIPI_PORT0_ID; port <= MIPI_PORT2_ID; port++) {
 			print_csi_rx_errors(port, isp);
 			atomisp_css_rx_get_irq_info(port, &rx_infos);
 			atomisp_css_rx_clear_irq_info(port, rx_infos);
@@ -496,7 +502,8 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 	if (irq_infos & IA_CSS_IRQ_INFO_ISYS_EVENTS_READY) {
 		while (ia_css_dequeue_isys_event(&eof_event.event) == 0) {
 			atomisp_eof_event(&isp->asd, eof_event.event.exp_id);
-			dev_dbg_ratelimited(isp->dev, "ISYS event: EOF exp_id %d\n",
+			dev_dbg_ratelimited(isp->dev,
+					    "ISYS event: EOF exp_id %d\n",
 					    eof_event.event.exp_id);
 		}
 
@@ -515,8 +522,10 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 	spin_unlock_irqrestore(&isp->lock, flags);
 
 	if (irq_infos)
-		dev_dbg_ratelimited(isp->dev, "irq:0x%x (ignored, as not streaming anymore)\n",
-				    irq_infos);
+		dev_dbg_ratelimited(
+			isp->dev,
+			"irq:0x%x (ignored, as not streaming anymore)\n",
+			irq_infos);
 
 	return IRQ_HANDLED;
 }
@@ -533,7 +542,7 @@ void atomisp_clear_css_buffer_counters(struct atomisp_sub_device *asd)
 }
 
 /* 0x100000 is the start of dmem inside SP */
-#define SP_DMEM_BASE	0x100000
+#define SP_DMEM_BASE 0x100000
 
 void dump_sp_dmem(struct atomisp_device *isp, unsigned int addr,
 		  unsigned int size)
@@ -545,8 +554,8 @@ void dump_sp_dmem(struct atomisp_device *isp, unsigned int addr,
 	dev_dbg(isp->dev, "%s, addr:0x%x, size: %d, size32: %d\n", __func__,
 		addr, size, size32);
 	if (size32 * 4 + addr > 0x4000) {
-		dev_err(isp->dev, "illegal size (%d) or addr (0x%x)\n",
-			size32, addr);
+		dev_err(isp->dev, "illegal size (%d) or addr (0x%x)\n", size32,
+			addr);
 		return;
 	}
 	addr += SP_DMEM_BASE;
@@ -574,7 +583,8 @@ int atomisp_buffers_in_css(struct atomisp_video_pipe *pipe)
 	return buffers_in_css;
 }
 
-void atomisp_buffer_done(struct ia_css_frame *frame, enum vb2_buffer_state state)
+void atomisp_buffer_done(struct ia_css_frame *frame,
+			 enum vb2_buffer_state state)
 {
 	struct atomisp_video_pipe *pipe = vb_to_pipe(&frame->vb.vb2_buf);
 
@@ -585,11 +595,13 @@ void atomisp_buffer_done(struct ia_css_frame *frame, enum vb2_buffer_state state
 	frame->vb.sequence = atomic_read(&pipe->asd->sequence);
 	list_del(&frame->queue);
 	if (state == VB2_BUF_STATE_DONE)
-		vb2_set_plane_payload(&frame->vb.vb2_buf, 0, pipe->pix.sizeimage);
+		vb2_set_plane_payload(&frame->vb.vb2_buf, 0,
+				      pipe->pix.sizeimage);
 	vb2_buffer_done(&frame->vb.vb2_buf, state);
 }
 
-void atomisp_flush_video_pipe(struct atomisp_video_pipe *pipe, enum vb2_buffer_state state,
+void atomisp_flush_video_pipe(struct atomisp_video_pipe *pipe,
+			      enum vb2_buffer_state state,
 			      bool warn_on_css_frames)
 {
 	struct ia_css_frame *frame, *_frame;
@@ -599,14 +611,16 @@ void atomisp_flush_video_pipe(struct atomisp_video_pipe *pipe, enum vb2_buffer_s
 
 	list_for_each_entry_safe(frame, _frame, &pipe->buffers_in_css, queue) {
 		if (warn_on_css_frames)
-			dev_warn(pipe->isp->dev, "Warning: CSS frames queued on flush\n");
+			dev_warn(pipe->isp->dev,
+				 "Warning: CSS frames queued on flush\n");
 		atomisp_buffer_done(frame, state);
 	}
 
 	list_for_each_entry_safe(frame, _frame, &pipe->activeq, queue)
 		atomisp_buffer_done(frame, state);
 
-	list_for_each_entry_safe(frame, _frame, &pipe->buffers_waiting_for_param, queue) {
+	list_for_each_entry_safe(frame, _frame,
+				 &pipe->buffers_waiting_for_param, queue) {
 		pipe->frame_request_config_id[frame->vb.vb2_buf.index] = 0;
 		atomisp_buffer_done(frame, state);
 	}
@@ -645,8 +659,8 @@ static void atomisp_recover_params_queue(struct atomisp_video_pipe *pipe)
 
 void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 		      enum ia_css_buffer_type buf_type,
-		      enum ia_css_pipe_id css_pipe_id,
-		      bool q_buffers, enum atomisp_input_stream_id stream_id)
+		      enum ia_css_pipe_id css_pipe_id, bool q_buffers,
+		      enum atomisp_input_stream_id stream_id)
 {
 	struct atomisp_video_pipe *pipe = NULL;
 	struct atomisp_css_buffer buffer;
@@ -662,8 +676,7 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 
 	lockdep_assert_held(&isp->mutex);
 
-	if (
-	    buf_type != IA_CSS_BUFFER_TYPE_METADATA &&
+	if (buf_type != IA_CSS_BUFFER_TYPE_METADATA &&
 	    buf_type != IA_CSS_BUFFER_TYPE_3A_STATISTICS &&
 	    buf_type != IA_CSS_BUFFER_TYPE_DIS_STATISTICS &&
 	    buf_type != IA_CSS_BUFFER_TYPE_OUTPUT_FRAME &&
@@ -671,18 +684,18 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 	    buf_type != IA_CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME &&
 	    buf_type != IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME &&
 	    buf_type != IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME) {
-		dev_err(isp->dev, "%s, unsupported buffer type: %d\n",
-			__func__, buf_type);
+		dev_err(isp->dev, "%s, unsupported buffer type: %d\n", __func__,
+			buf_type);
 		return;
 	}
 
 	memset(&buffer, 0, sizeof(struct atomisp_css_buffer));
 	buffer.css_buffer.type = buf_type;
-	err = atomisp_css_dequeue_buffer(asd, stream_id, css_pipe_id,
-					 buf_type, &buffer);
+	err = atomisp_css_dequeue_buffer(asd, stream_id, css_pipe_id, buf_type,
+					 &buffer);
 	if (err) {
-		dev_err(isp->dev,
-			"atomisp_css_dequeue_buffer failed: 0x%x\n", err);
+		dev_err(isp->dev, "atomisp_css_dequeue_buffer failed: 0x%x\n",
+			err);
 		return;
 	}
 
@@ -703,10 +716,12 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 		asd->s3a_bufs_in_css[css_pipe_id]--;
 		atomisp_3a_stats_ready_event(asd, buffer.css_buffer.exp_id);
 		if (s3a_buf)
-			dev_dbg(isp->dev, "%s: s3a stat with exp_id %d is ready\n",
+			dev_dbg(isp->dev,
+				"%s: s3a stat with exp_id %d is ready\n",
 				__func__, s3a_buf->s3a_data->exp_id);
 		else
-			dev_dbg(isp->dev, "%s: s3a stat is ready with no exp_id found\n",
+			dev_dbg(isp->dev,
+				"%s: s3a stat is ready with no exp_id found\n",
 				__func__);
 		break;
 	case IA_CSS_BUFFER_TYPE_METADATA:
@@ -728,10 +743,12 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 		asd->metadata_bufs_in_css[stream_id][css_pipe_id]--;
 		atomisp_metadata_ready_event(asd, md_type);
 		if (md_buf)
-			dev_dbg(isp->dev, "%s: metadata with exp_id %d is ready\n",
+			dev_dbg(isp->dev,
+				"%s: metadata with exp_id %d is ready\n",
 				__func__, md_buf->metadata->exp_id);
 		else
-			dev_dbg(isp->dev, "%s: metadata is ready with no exp_id found\n",
+			dev_dbg(isp->dev,
+				"%s: metadata is ready with no exp_id found\n",
 				__func__);
 		break;
 	case IA_CSS_BUFFER_TYPE_DIS_STATISTICS:
@@ -752,10 +769,12 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 		}
 		asd->dis_bufs_in_css--;
 		if (dis_buf)
-			dev_dbg(isp->dev, "%s: dis stat with exp_id %d is ready\n",
+			dev_dbg(isp->dev,
+				"%s: dis stat with exp_id %d is ready\n",
 				__func__, dis_buf->dis_data->exp_id);
 		else
-			dev_dbg(isp->dev, "%s: dis stat is ready with no exp_id found\n",
+			dev_dbg(isp->dev,
+				"%s: dis stat is ready with no exp_id found\n",
 				__func__);
 		break;
 	case IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
@@ -772,7 +791,8 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 
 		dev_dbg(isp->dev, "%s: vf frame with exp_id %d is ready\n",
 			__func__, frame->exp_id);
-		pipe->frame_config_id[frame->vb.vb2_buf.index] = frame->isp_config_id;
+		pipe->frame_config_id[frame->vb.vb2_buf.index] =
+			frame->isp_config_id;
 		break;
 	case IA_CSS_BUFFER_TYPE_OUTPUT_FRAME:
 	case IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME:
@@ -794,9 +814,11 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 
 		/* free the parameters */
 		if (pipe->frame_params[i]) {
-			if (asd->params.dvs_6axis == pipe->frame_params[i]->params.dvs_6axis)
+			if (asd->params.dvs_6axis ==
+			    pipe->frame_params[i]->params.dvs_6axis)
 				asd->params.dvs_6axis = NULL;
-			atomisp_free_css_parameters(&pipe->frame_params[i]->params);
+			atomisp_free_css_parameters(
+				&pipe->frame_params[i]->params);
 			kvfree(pipe->frame_params[i]);
 			pipe->frame_params[i] = NULL;
 		}
@@ -807,7 +829,8 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 			atomisp_apply_css_parameters(asd,
 						     &asd->params.css_param);
 			if (asd->params.css_param.update_flag.dz_config)
-				asd->params.config.dz_config = &asd->params.css_param.dz_config;
+				asd->params.config.dz_config =
+					&asd->params.css_param.dz_config;
 			/* New global dvs 6axis config should be blocked
 			 * here if there's a buffer with per-frame parameters
 			 * pending in CSS frame buffer queue.
@@ -817,8 +840,8 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 			 * buffers in CSS got processed.
 			 */
 			if (asd->params.dvs_6axis)
-				atomisp_css_set_dvs_6axis(asd,
-							  asd->params.dvs_6axis);
+				atomisp_css_set_dvs_6axis(
+					asd, asd->params.dvs_6axis);
 			else
 				asd->params.css_update_params_needed = false;
 			/* The update flag should not be cleaned here
@@ -840,7 +863,8 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 	}
 	if (frame) {
 		spin_lock_irqsave(&pipe->irq_lock, irqflags);
-		atomisp_buffer_done(frame, error ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+		atomisp_buffer_done(frame, error ? VB2_BUF_STATE_ERROR :
+						   VB2_BUF_STATE_DONE);
 		spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
 	}
 
@@ -849,12 +873,11 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 	 * Queue/dequeue order will change if driver recycles image buffers.
 	 */
 	if (requeue) {
-		err = atomisp_css_queue_buffer(asd,
-					       stream_id, css_pipe_id,
+		err = atomisp_css_queue_buffer(asd, stream_id, css_pipe_id,
 					       buf_type, &buffer);
 		if (err)
-			dev_err(isp->dev, "%s, q to css fails: %d\n",
-				__func__, err);
+			dev_err(isp->dev, "%s, q to css fails: %d\n", __func__,
+				err);
 		return;
 	}
 	if (!error && q_buffers)
@@ -863,8 +886,8 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 
 void atomisp_assert_recovery_work(struct work_struct *work)
 {
-	struct atomisp_device *isp = container_of(work, struct atomisp_device,
-						  assert_recovery_work);
+	struct atomisp_device *isp =
+		container_of(work, struct atomisp_device, assert_recovery_work);
 	struct pci_dev *pdev = to_pci_dev(isp->dev);
 	unsigned long flags;
 	int ret;
@@ -881,8 +904,9 @@ void atomisp_assert_recovery_work(struct work_struct *work)
 	spin_unlock_irqrestore(&isp->lock, flags);
 
 	/* stream off sensor */
-	ret = v4l2_subdev_call(isp->inputs[isp->asd.input_curr].csi_remote_source,
-			       video, s_stream, 0);
+	ret = v4l2_subdev_call(
+		isp->inputs[isp->asd.input_curr].csi_remote_source, video,
+		s_stream, 0);
 	if (ret)
 		dev_warn(isp->dev, "Stopping sensor stream failed: %d\n", ret);
 
@@ -893,7 +917,8 @@ void atomisp_assert_recovery_work(struct work_struct *work)
 	isp->asd.preview_exp_id = 1;
 	isp->asd.postview_exp_id = 1;
 	/* notify HAL the CSS reset */
-	dev_dbg(isp->dev, "send reset event to %s\n", isp->asd.subdev.devnode->name);
+	dev_dbg(isp->dev, "send reset event to %s\n",
+		isp->asd.subdev.devnode->name);
 	atomisp_reset_event(&isp->asd);
 
 	/* clear irq */
@@ -902,12 +927,14 @@ void atomisp_assert_recovery_work(struct work_struct *work)
 
 	/* Set the SRSE to 3 before resetting */
 	pci_write_config_dword(pdev, PCI_I_CONTROL,
-			       isp->saved_regs.i_control | MRFLD_PCI_I_CONTROL_SRSE_RESET_MASK);
+			       isp->saved_regs.i_control |
+				       MRFLD_PCI_I_CONTROL_SRSE_RESET_MASK);
 
 	/* reset ISP and restore its state */
 	atomisp_reset(isp);
 
-	atomisp_css_input_set_mode(&isp->asd, IA_CSS_INPUT_MODE_BUFFERED_SENSOR);
+	atomisp_css_input_set_mode(&isp->asd,
+				   IA_CSS_INPUT_MODE_BUFFERED_SENSOR);
 
 	/* Recreate streams destroyed by atomisp_css_stop() */
 	atomisp_create_pipes_stream(&isp->asd);
@@ -916,7 +943,9 @@ void atomisp_assert_recovery_work(struct work_struct *work)
 	wbinvd();
 
 	if (atomisp_css_start(&isp->asd)) {
-		dev_warn(isp->dev, "start SP failed, so do not set streaming to be enable!\n");
+		dev_warn(
+			isp->dev,
+			"start SP failed, so do not set streaming to be enable!\n");
 	} else {
 		spin_lock_irqsave(&isp->lock, flags);
 		isp->asd.streaming = true;
@@ -932,13 +961,15 @@ void atomisp_assert_recovery_work(struct work_struct *work)
 		dev_dbg(isp->dev, "DFS auto failed while recovering!\n");
 
 	/* Dequeueing buffers is not needed, CSS will recycle buffers that it has */
-	atomisp_flush_video_pipe(&isp->asd.video_out, VB2_BUF_STATE_ERROR, false);
+	atomisp_flush_video_pipe(&isp->asd.video_out, VB2_BUF_STATE_ERROR,
+				 false);
 
 	/* Requeue unprocessed per-frame parameters. */
 	atomisp_recover_params_queue(&isp->asd.video_out);
 
-	ret = v4l2_subdev_call(isp->inputs[isp->asd.input_curr].csi_remote_source,
-			       video, s_stream, 1);
+	ret = v4l2_subdev_call(
+		isp->inputs[isp->asd.input_curr].csi_remote_source, video,
+		s_stream, 1);
 	if (ret)
 		dev_err(isp->dev, "Starting sensor stream failed: %d\n", ret);
 
@@ -994,12 +1025,11 @@ irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr)
 /*
  * Get internal fmt according to V4L2 fmt
  */
-static enum ia_css_frame_format
-v4l2_fmt_to_sh_fmt(u32 fmt)
+static enum ia_css_frame_format v4l2_fmt_to_sh_fmt(u32 fmt)
 {
 	switch (fmt) {
 	case V4L2_PIX_FMT_YUV420:
-				return IA_CSS_FRAME_FORMAT_YUV420;
+		return IA_CSS_FRAME_FORMAT_YUV420;
 	case V4L2_PIX_FMT_YVU420:
 		return IA_CSS_FRAME_FORMAT_YV12;
 	case V4L2_PIX_FMT_YUV422P:
@@ -1074,7 +1104,8 @@ static int raw_output_format_match_input(u32 input, u32 output)
 	     (output == V4L2_PIX_FMT_SGBRG8)))
 		return 0;
 
-	if ((input == ATOMISP_INPUT_FORMAT_RAW_16) && (output == V4L2_PIX_FMT_SBGGR16))
+	if ((input == ATOMISP_INPUT_FORMAT_RAW_16) &&
+	    (output == V4L2_PIX_FMT_SBGGR16))
 		return 0;
 
 	return -EINVAL;
@@ -1117,7 +1148,7 @@ u32 atomisp_get_pixel_depth(u32 pixelformat)
 	case V4L2_PIX_FMT_SRGGB8:
 		return 8;
 	default:
-		return 8 * 2;	/* raw type now */
+		return 8 * 2; /* raw type now */
 	}
 }
 
@@ -1138,7 +1169,8 @@ static void atomisp_update_capture_mode(struct atomisp_sub_device *asd)
 	if (asd->params.gdc_cac_en)
 		atomisp_css_capture_set_mode(asd, IA_CSS_CAPTURE_MODE_ADVANCED);
 	else if (asd->params.low_light)
-		atomisp_css_capture_set_mode(asd, IA_CSS_CAPTURE_MODE_LOW_LIGHT);
+		atomisp_css_capture_set_mode(asd,
+					     IA_CSS_CAPTURE_MODE_LOW_LIGHT);
 	else if (asd->video_out.sh_fmt == IA_CSS_FRAME_FORMAT_RAW)
 		atomisp_css_capture_set_mode(asd, IA_CSS_CAPTURE_MODE_RAW);
 	else
@@ -1149,8 +1181,7 @@ static void atomisp_update_capture_mode(struct atomisp_sub_device *asd)
  * Function to enable/disable lens geometry distortion correction (GDC) and
  * chromatic aberration correction (CAC)
  */
-int atomisp_gdc_cac(struct atomisp_sub_device *asd, int flag,
-		    __s32 *value)
+int atomisp_gdc_cac(struct atomisp_sub_device *asd, int flag, __s32 *value)
 {
 	if (flag == 0) {
 		*value = asd->params.gdc_cac_en;
@@ -1159,7 +1190,8 @@ int atomisp_gdc_cac(struct atomisp_sub_device *asd, int flag,
 
 	asd->params.gdc_cac_en = !!*value;
 	if (asd->params.gdc_cac_en)
-		asd->params.config.morph_table = asd->params.css_param.morph_table;
+		asd->params.config.morph_table =
+			asd->params.css_param.morph_table;
 	else
 		asd->params.config.morph_table = NULL;
 
@@ -1171,8 +1203,7 @@ int atomisp_gdc_cac(struct atomisp_sub_device *asd, int flag,
 /*
  * Function to enable/disable low light mode including ANR
  */
-int atomisp_low_light(struct atomisp_sub_device *asd, int flag,
-		      __s32 *value)
+int atomisp_low_light(struct atomisp_sub_device *asd, int flag, __s32 *value)
 {
 	if (flag == 0) {
 		*value = asd->params.low_light;
@@ -1188,8 +1219,7 @@ int atomisp_low_light(struct atomisp_sub_device *asd, int flag,
  * Function to enable/disable extra noise reduction (XNR) in low light
  * condition
  */
-int atomisp_xnr(struct atomisp_sub_device *asd, int flag,
-		int *xnr_enable)
+int atomisp_xnr(struct atomisp_sub_device *asd, int flag, int *xnr_enable)
 {
 	if (flag == 0) {
 		*xnr_enable = asd->params.xnr_en;
@@ -1236,7 +1266,8 @@ int atomisp_tnr(struct atomisp_sub_device *asd, int flag,
 		/* Set tnr config to isp parameters */
 		memcpy(&asd->params.css_param.tnr_config, config,
 		       sizeof(struct ia_css_tnr_config));
-		asd->params.config.tnr_config = &asd->params.css_param.tnr_config;
+		asd->params.config.tnr_config =
+			&asd->params.css_param.tnr_config;
 		asd->params.css_update_params_needed = true;
 	}
 
@@ -1299,7 +1330,8 @@ int atomisp_gamma(struct atomisp_sub_device *asd, int flag,
 		/* Set gamma table to isp parameters */
 		memcpy(&asd->params.css_param.gamma_table, config,
 		       sizeof(asd->params.css_param.gamma_table));
-		asd->params.config.gamma_table = &asd->params.css_param.gamma_table;
+		asd->params.config.gamma_table =
+			&asd->params.css_param.gamma_table;
 	}
 
 	return 0;
@@ -1319,7 +1351,8 @@ int atomisp_ctc(struct atomisp_sub_device *asd, int flag,
 		/* Set ctc table to isp parameters */
 		memcpy(&asd->params.css_param.ctc_table, config,
 		       sizeof(asd->params.css_param.ctc_table));
-		atomisp_css_set_ctc_table(asd, &asd->params.css_param.ctc_table);
+		atomisp_css_set_ctc_table(asd,
+					  &asd->params.css_param.ctc_table);
 	}
 
 	return 0;
@@ -1360,7 +1393,8 @@ int atomisp_formats(struct atomisp_sub_device *asd, int flag,
 		/* Set narrow gamma flag to isp parameters */
 		memcpy(&asd->params.css_param.formats_config, config,
 		       sizeof(asd->params.css_param.formats_config));
-		asd->params.config.formats_config = &asd->params.css_param.formats_config;
+		asd->params.config.formats_config =
+			&asd->params.css_param.formats_config;
 	}
 
 	return 0;
@@ -1395,7 +1429,8 @@ static void atomisp_update_grid_info(struct atomisp_sub_device *asd,
 		if (asd->params.s3a_output_bytes != 0) {
 			/* For SOC sensor happens s3a_output_bytes == 0,
 			 * using if condition to exclude false error log */
-			dev_err(isp->dev, "Failed to allocate memory for 3A statistics\n");
+			dev_err(isp->dev,
+				"Failed to allocate memory for 3A statistics\n");
 		}
 		goto err;
 	}
@@ -1428,7 +1463,7 @@ static void atomisp_curr_user_grid_info(struct atomisp_sub_device *asd,
 int atomisp_compare_grid(struct atomisp_sub_device *asd,
 			 struct atomisp_grid_info *atomgrid)
 {
-	struct atomisp_grid_info tmp = {0};
+	struct atomisp_grid_info tmp = { 0 };
 
 	atomisp_curr_user_grid_info(asd, &tmp);
 	return memcmp(atomgrid, &tmp, sizeof(tmp));
@@ -1446,7 +1481,7 @@ int atomisp_gdc_cac_table(struct atomisp_sub_device *asd, int flag,
 
 	if (flag == 0) {
 		/* Get gdc table from current setup */
-		struct ia_css_morph_table tab = {0};
+		struct ia_css_morph_table tab = { 0 };
 
 		atomisp_css_get_morph_table(asd, &tab);
 
@@ -1454,17 +1489,19 @@ int atomisp_gdc_cac_table(struct atomisp_sub_device *asd, int flag,
 		config->height = tab.height;
 
 		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-			ret = copy_to_user(config->coordinates_x[i],
-					   tab.coordinates_x[i], tab.height *
-					   tab.width * sizeof(*tab.coordinates_x[i]));
+			ret = copy_to_user(
+				config->coordinates_x[i], tab.coordinates_x[i],
+				tab.height * tab.width *
+					sizeof(*tab.coordinates_x[i]));
 			if (ret) {
 				dev_err(isp->dev,
 					"Failed to copy to User for x\n");
 				return -EFAULT;
 			}
-			ret = copy_to_user(config->coordinates_y[i],
-					   tab.coordinates_y[i], tab.height *
-					   tab.width * sizeof(*tab.coordinates_y[i]));
+			ret = copy_to_user(
+				config->coordinates_y[i], tab.coordinates_y[i],
+				tab.height * tab.width *
+					sizeof(*tab.coordinates_y[i]));
 			if (ret) {
 				dev_err(isp->dev,
 					"Failed to copy to User for y\n");
@@ -1473,7 +1510,7 @@ int atomisp_gdc_cac_table(struct atomisp_sub_device *asd, int flag,
 		}
 	} else {
 		struct ia_css_morph_table *tab =
-			    asd->params.css_param.morph_table;
+			asd->params.css_param.morph_table;
 
 		/* free first if we have one */
 		if (tab) {
@@ -1491,10 +1528,10 @@ int atomisp_gdc_cac_table(struct atomisp_sub_device *asd, int flag,
 		}
 
 		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-			ret = copy_from_user(tab->coordinates_x[i],
-					     config->coordinates_x[i],
-					     config->height * config->width *
-					     sizeof(*config->coordinates_x[i]));
+			ret = copy_from_user(
+				tab->coordinates_x[i], config->coordinates_x[i],
+				config->height * config->width *
+					sizeof(*config->coordinates_x[i]));
 			if (ret) {
 				dev_err(isp->dev,
 					"Failed to copy from User for x, ret %d\n",
@@ -1502,10 +1539,10 @@ int atomisp_gdc_cac_table(struct atomisp_sub_device *asd, int flag,
 				atomisp_css_morph_table_free(tab);
 				return -EFAULT;
 			}
-			ret = copy_from_user(tab->coordinates_y[i],
-					     config->coordinates_y[i],
-					     config->height * config->width *
-					     sizeof(*config->coordinates_y[i]));
+			ret = copy_from_user(
+				tab->coordinates_y[i], config->coordinates_y[i],
+				config->height * config->width *
+					sizeof(*config->coordinates_y[i]));
 			if (ret) {
 				dev_err(isp->dev,
 					"Failed to copy from User for y, ret is %d\n",
@@ -1587,7 +1624,7 @@ int atomisp_get_dis_stat(struct atomisp_sub_device *asd,
  * Function  set camrea_prefiles.xml current sensor pixel array size
  */
 int atomisp_set_array_res(struct atomisp_sub_device *asd,
-			  struct atomisp_resolution  *config)
+			  struct atomisp_resolution *config)
 {
 	dev_dbg(asd->isp->dev, ">%s start\n", __func__);
 	if (!config) {
@@ -1609,14 +1646,14 @@ int atomisp_get_dvs2_bq_resolutions(struct atomisp_sub_device *asd,
 	struct ia_css_pipe_config *pipe_cfg = NULL;
 
 	struct ia_css_stream *stream =
-		    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream;
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream;
 	if (!stream) {
 		dev_warn(asd->isp->dev, "stream is not created");
 		return -EAGAIN;
 	}
 
 	pipe_cfg = &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		   .pipe_configs[IA_CSS_PIPE_ID_VIDEO];
+			    .pipe_configs[IA_CSS_PIPE_ID_VIDEO];
 
 	if (!bq_res)
 		return -EINVAL;
@@ -1628,10 +1665,10 @@ int atomisp_get_dvs2_bq_resolutions(struct atomisp_sub_device *asd,
 	bq_res->envelope_bq.width_bq = 0;
 	bq_res->envelope_bq.height_bq = 0;
 	/* the GDC input resolution */
-	bq_res->source_bq.width_bq = bq_res->output_bq.width_bq +
-				     pipe_cfg->dvs_envelope.width / 2;
-	bq_res->source_bq.height_bq = bq_res->output_bq.height_bq +
-				      pipe_cfg->dvs_envelope.height / 2;
+	bq_res->source_bq.width_bq =
+		bq_res->output_bq.width_bq + pipe_cfg->dvs_envelope.width / 2;
+	bq_res->source_bq.height_bq =
+		bq_res->output_bq.height_bq + pipe_cfg->dvs_envelope.height / 2;
 	/*
 	 * Bad pixels caused by spatial filter processing
 	 * ISP filter resolution should be given by CSS/FW, but for now
@@ -1645,10 +1682,12 @@ int atomisp_get_dvs2_bq_resolutions(struct atomisp_sub_device *asd,
 	bq_res->gdc_shift_bq.height_bq = 4 / 2;
 
 	if (asd->params.video_dis_en) {
-		bq_res->envelope_bq.width_bq = pipe_cfg->dvs_envelope.width / 2 -
-					       bq_res->ispfilter_bq.width_bq;
-		bq_res->envelope_bq.height_bq = pipe_cfg->dvs_envelope.height / 2 -
-						bq_res->ispfilter_bq.height_bq;
+		bq_res->envelope_bq.width_bq =
+			pipe_cfg->dvs_envelope.width / 2 -
+			bq_res->ispfilter_bq.width_bq;
+		bq_res->envelope_bq.height_bq =
+			pipe_cfg->dvs_envelope.height / 2 -
+			bq_res->ispfilter_bq.height_bq;
 	}
 
 	dev_dbg(asd->isp->dev,
@@ -1697,11 +1736,11 @@ int atomisp_3a_stat(struct atomisp_sub_device *asd, int flag,
 		return -EAGAIN;
 	}
 
-	s3a_buf = list_entry(asd->s3a_stats_ready.next,
-			     struct atomisp_s3a_buf, list);
+	s3a_buf = list_entry(asd->s3a_stats_ready.next, struct atomisp_s3a_buf,
+			     list);
 	if (s3a_buf->s3a_map)
-		ia_css_translate_3a_statistics(
-		    asd->params.s3a_user_stat, s3a_buf->s3a_map);
+		ia_css_translate_3a_statistics(asd->params.s3a_user_stat,
+					       s3a_buf->s3a_map);
 	else
 		ia_css_get_3a_statistics(asd->params.s3a_user_stat,
 					 s3a_buf->s3a_data);
@@ -1720,9 +1759,9 @@ int atomisp_3a_stat(struct atomisp_sub_device *asd, int flag,
 	/* Move to free buffer list */
 	list_del_init(&s3a_buf->list);
 	list_add_tail(&s3a_buf->list, &asd->s3a_stats);
-	dev_dbg(isp->dev, "%s: finish getting exp_id %d 3a stat, isp_config_id %d\n",
-		__func__,
-		config->exp_id, config->isp_config_id);
+	dev_dbg(isp->dev,
+		"%s: finish getting exp_id %d 3a stat, isp_config_id %d\n",
+		__func__, config->exp_id, config->isp_config_id);
 	return 0;
 }
 
@@ -1730,13 +1769,13 @@ int atomisp_3a_stat(struct atomisp_sub_device *asd, int flag,
  * Function to calculate real zoom region for every pipe
  */
 int atomisp_calculate_real_zoom_region(struct atomisp_sub_device *asd,
-				       struct ia_css_dz_config   *dz_config,
+				       struct ia_css_dz_config *dz_config,
 				       enum ia_css_pipe_id css_pipe_id)
 
 {
 	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	struct atomisp_resolution  eff_res, out_res;
+		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
+	struct atomisp_resolution eff_res, out_res;
 	int w_offset, h_offset;
 
 	memset(&eff_res, 0, sizeof(eff_res));
@@ -1745,27 +1784,26 @@ int atomisp_calculate_real_zoom_region(struct atomisp_sub_device *asd,
 	if (dz_config->dx || dz_config->dy)
 		return 0;
 
-	if (css_pipe_id != IA_CSS_PIPE_ID_PREVIEW
-	    && css_pipe_id != IA_CSS_PIPE_ID_CAPTURE) {
-		dev_err(asd->isp->dev, "%s the set pipe no support crop region"
-			, __func__);
+	if (css_pipe_id != IA_CSS_PIPE_ID_PREVIEW &&
+	    css_pipe_id != IA_CSS_PIPE_ID_CAPTURE) {
+		dev_err(asd->isp->dev, "%s the set pipe no support crop region",
+			__func__);
 		return -EINVAL;
 	}
 
 	eff_res.width =
-	    stream_env->stream_config.input_config.effective_res.width;
+		stream_env->stream_config.input_config.effective_res.width;
 	eff_res.height =
-	    stream_env->stream_config.input_config.effective_res.height;
+		stream_env->stream_config.input_config.effective_res.height;
 	if (eff_res.width == 0 || eff_res.height == 0) {
-		dev_err(asd->isp->dev, "%s err effective resolution"
-			, __func__);
+		dev_err(asd->isp->dev, "%s err effective resolution", __func__);
 		return -EINVAL;
 	}
 
-	if (dz_config->zoom_region.resolution.width
-	    == asd->sensor_array_res.width
-	    || dz_config->zoom_region.resolution.height
-	    == asd->sensor_array_res.height) {
+	if (dz_config->zoom_region.resolution.width ==
+		    asd->sensor_array_res.width ||
+	    dz_config->zoom_region.resolution.height ==
+		    asd->sensor_array_res.height) {
 		/*no need crop region*/
 		dz_config->zoom_region.origin.x = 0;
 		dz_config->zoom_region.origin.y = 0;
@@ -1781,101 +1819,115 @@ int atomisp_calculate_real_zoom_region(struct atomisp_sub_device *asd,
 	 */
 
 	if (!IS_ISP2401) {
-		dz_config->zoom_region.origin.x = dz_config->zoom_region.origin.x
-						  * eff_res.width
-						  / asd->sensor_array_res.width;
-		dz_config->zoom_region.origin.y = dz_config->zoom_region.origin.y
-						  * eff_res.height
-						  / asd->sensor_array_res.height;
-		dz_config->zoom_region.resolution.width = dz_config->zoom_region.resolution.width
-							  * eff_res.width
-							  / asd->sensor_array_res.width;
-		dz_config->zoom_region.resolution.height = dz_config->zoom_region.resolution.height
-							  * eff_res.height
-							  / asd->sensor_array_res.height;
+		dz_config->zoom_region.origin.x =
+			dz_config->zoom_region.origin.x * eff_res.width /
+			asd->sensor_array_res.width;
+		dz_config->zoom_region.origin.y =
+			dz_config->zoom_region.origin.y * eff_res.height /
+			asd->sensor_array_res.height;
+		dz_config->zoom_region.resolution.width =
+			dz_config->zoom_region.resolution.width *
+			eff_res.width / asd->sensor_array_res.width;
+		dz_config->zoom_region.resolution.height =
+			dz_config->zoom_region.resolution.height *
+			eff_res.height / asd->sensor_array_res.height;
 		/*
 		 * Set same ratio of crop region resolution and current pipe output
 		 * resolution
 		 */
-		out_res.width = stream_env->pipe_configs[css_pipe_id].output_info[0].res.width;
-		out_res.height = stream_env->pipe_configs[css_pipe_id].output_info[0].res.height;
+		out_res.width = stream_env->pipe_configs[css_pipe_id]
+					.output_info[0]
+					.res.width;
+		out_res.height = stream_env->pipe_configs[css_pipe_id]
+					 .output_info[0]
+					 .res.height;
 		if (out_res.width == 0 || out_res.height == 0) {
-			dev_err(asd->isp->dev, "%s err current pipe output resolution"
-				, __func__);
+			dev_err(asd->isp->dev,
+				"%s err current pipe output resolution",
+				__func__);
 			return -EINVAL;
 		}
 	} else {
-		out_res.width = stream_env->pipe_configs[css_pipe_id].output_info[0].res.width;
-		out_res.height = stream_env->pipe_configs[css_pipe_id].output_info[0].res.height;
+		out_res.width = stream_env->pipe_configs[css_pipe_id]
+					.output_info[0]
+					.res.width;
+		out_res.height = stream_env->pipe_configs[css_pipe_id]
+					 .output_info[0]
+					 .res.height;
 		if (out_res.width == 0 || out_res.height == 0) {
-			dev_err(asd->isp->dev, "%s err current pipe output resolution"
-				, __func__);
+			dev_err(asd->isp->dev,
+				"%s err current pipe output resolution",
+				__func__);
 			return -EINVAL;
 		}
 
-		if (asd->sensor_array_res.width * out_res.height
-		    < out_res.width * asd->sensor_array_res.height) {
-			h_offset = asd->sensor_array_res.height
-				   - asd->sensor_array_res.width
-				   * out_res.height / out_res.width;
+		if (asd->sensor_array_res.width * out_res.height <
+		    out_res.width * asd->sensor_array_res.height) {
+			h_offset = asd->sensor_array_res.height -
+				   asd->sensor_array_res.width *
+					   out_res.height / out_res.width;
 			h_offset = h_offset / 2;
 			if (dz_config->zoom_region.origin.y < h_offset)
 				dz_config->zoom_region.origin.y = 0;
 			else
-				dz_config->zoom_region.origin.y = dz_config->zoom_region.origin.y - h_offset;
+				dz_config->zoom_region.origin.y =
+					dz_config->zoom_region.origin.y -
+					h_offset;
 			w_offset = 0;
 		} else {
-			w_offset = asd->sensor_array_res.width
-				   - asd->sensor_array_res.height
-				   * out_res.width / out_res.height;
+			w_offset = asd->sensor_array_res.width -
+				   asd->sensor_array_res.height *
+					   out_res.width / out_res.height;
 			w_offset = w_offset / 2;
 			if (dz_config->zoom_region.origin.x < w_offset)
 				dz_config->zoom_region.origin.x = 0;
 			else
-				dz_config->zoom_region.origin.x = dz_config->zoom_region.origin.x - w_offset;
+				dz_config->zoom_region.origin.x =
+					dz_config->zoom_region.origin.x -
+					w_offset;
 			h_offset = 0;
 		}
-		dz_config->zoom_region.origin.x = dz_config->zoom_region.origin.x
-						  * eff_res.width
-						  / (asd->sensor_array_res.width - 2 * w_offset);
-		dz_config->zoom_region.origin.y = dz_config->zoom_region.origin.y
-						  * eff_res.height
-						  / (asd->sensor_array_res.height - 2 * h_offset);
-		dz_config->zoom_region.resolution.width = dz_config->zoom_region.resolution.width
-						  * eff_res.width
-						  / (asd->sensor_array_res.width - 2 * w_offset);
-		dz_config->zoom_region.resolution.height = dz_config->zoom_region.resolution.height
-						  * eff_res.height
-						  / (asd->sensor_array_res.height - 2 * h_offset);
-	}
-
-	if (out_res.width * dz_config->zoom_region.resolution.height
-	    > dz_config->zoom_region.resolution.width * out_res.height) {
+		dz_config->zoom_region.origin.x =
+			dz_config->zoom_region.origin.x * eff_res.width /
+			(asd->sensor_array_res.width - 2 * w_offset);
+		dz_config->zoom_region.origin.y =
+			dz_config->zoom_region.origin.y * eff_res.height /
+			(asd->sensor_array_res.height - 2 * h_offset);
+		dz_config->zoom_region.resolution.width =
+			dz_config->zoom_region.resolution.width *
+			eff_res.width /
+			(asd->sensor_array_res.width - 2 * w_offset);
 		dz_config->zoom_region.resolution.height =
-		    dz_config->zoom_region.resolution.width
-		    * out_res.height / out_res.width;
+			dz_config->zoom_region.resolution.height *
+			eff_res.height /
+			(asd->sensor_array_res.height - 2 * h_offset);
+	}
+
+	if (out_res.width * dz_config->zoom_region.resolution.height >
+	    dz_config->zoom_region.resolution.width * out_res.height) {
+		dz_config->zoom_region.resolution.height =
+			dz_config->zoom_region.resolution.width *
+			out_res.height / out_res.width;
 	} else {
 		dz_config->zoom_region.resolution.width =
-		    dz_config->zoom_region.resolution.height
-		    * out_res.width / out_res.height;
+			dz_config->zoom_region.resolution.height *
+			out_res.width / out_res.height;
 	}
 	dev_dbg(asd->isp->dev,
 		"%s crop region:(%d,%d),(%d,%d) eff_res(%d, %d) array_size(%d,%d) out_res(%d, %d)\n",
 		__func__, dz_config->zoom_region.origin.x,
 		dz_config->zoom_region.origin.y,
 		dz_config->zoom_region.resolution.width,
-		dz_config->zoom_region.resolution.height,
-		eff_res.width, eff_res.height,
-		asd->sensor_array_res.width,
-		asd->sensor_array_res.height,
-		out_res.width, out_res.height);
+		dz_config->zoom_region.resolution.height, eff_res.width,
+		eff_res.height, asd->sensor_array_res.width,
+		asd->sensor_array_res.height, out_res.width, out_res.height);
 
 	if ((dz_config->zoom_region.origin.x +
-	     dz_config->zoom_region.resolution.width
-	     > eff_res.width) ||
+		     dz_config->zoom_region.resolution.width >
+	     eff_res.width) ||
 	    (dz_config->zoom_region.origin.y +
-	     dz_config->zoom_region.resolution.height
-	     > eff_res.height))
+		     dz_config->zoom_region.resolution.height >
+	     eff_res.height))
 		return -EINVAL;
 
 	return 0;
@@ -1884,11 +1936,10 @@ int atomisp_calculate_real_zoom_region(struct atomisp_sub_device *asd,
 /*
  * Function to check the zoom region whether is effective
  */
-static bool atomisp_check_zoom_region(
-    struct atomisp_sub_device *asd,
-    struct ia_css_dz_config *dz_config)
+static bool atomisp_check_zoom_region(struct atomisp_sub_device *asd,
+				      struct ia_css_dz_config *dz_config)
 {
-	struct atomisp_resolution  config;
+	struct atomisp_resolution config;
 	bool flag = false;
 	unsigned int w, h;
 
@@ -1913,15 +1964,14 @@ static bool atomisp_check_zoom_region(
 			__func__, dz_config->zoom_region.origin.x,
 			dz_config->zoom_region.origin.y,
 			dz_config->zoom_region.resolution.width,
-			dz_config->zoom_region.resolution.height,
-			config.width, config.height);
+			dz_config->zoom_region.resolution.height, config.width,
+			config.height);
 
 	return flag;
 }
 
-void atomisp_apply_css_parameters(
-    struct atomisp_sub_device *asd,
-    struct atomisp_css_params *css_param)
+void atomisp_apply_css_parameters(struct atomisp_sub_device *asd,
+				  struct atomisp_css_params *css_param)
 {
 	if (css_param->update_flag.wb_config)
 		asd->params.config.wb_config = &css_param->wb_config;
@@ -1972,10 +2022,12 @@ void atomisp_apply_css_parameters(
 		asd->params.config.xnr_config = &css_param->xnr_config;
 
 	if (css_param->update_flag.yuv2rgb_cc_config)
-		asd->params.config.yuv2rgb_cc_config = &css_param->yuv2rgb_cc_config;
+		asd->params.config.yuv2rgb_cc_config =
+			&css_param->yuv2rgb_cc_config;
 
 	if (css_param->update_flag.rgb2yuv_cc_config)
-		asd->params.config.rgb2yuv_cc_config = &css_param->rgb2yuv_cc_config;
+		asd->params.config.rgb2yuv_cc_config =
+			&css_param->rgb2yuv_cc_config;
 
 	if (css_param->update_flag.macc_table)
 		asd->params.config.macc_table = &css_param->macc_table;
@@ -2003,8 +2055,8 @@ void atomisp_apply_css_parameters(
 
 	if (css_param->update_flag.dvs2_coefs) {
 		struct ia_css_dvs_grid_info *dvs_grid_info =
-		    atomisp_css_get_dvs_grid_info(
-			&asd->params.curr_grid_info);
+			atomisp_css_get_dvs_grid_info(
+				&asd->params.curr_grid_info);
 
 		if (dvs_grid_info && dvs_grid_info->enable)
 			atomisp_css_set_dvs2_coefs(asd, css_param->dvs2_coeff);
@@ -2028,7 +2080,7 @@ void atomisp_apply_css_parameters(
 }
 
 static unsigned int long copy_from_compatible(void *to, const void *from,
-	unsigned long n, bool from_user)
+					      unsigned long n, bool from_user)
 {
 	if (from_user)
 		return copy_from_user(to, (void __user *)from, n);
@@ -2053,7 +2105,7 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.wb_config =
-		    (struct atomisp_wb_config *)&css_param->wb_config;
+			(struct atomisp_wb_config *)&css_param->wb_config;
 	}
 
 	if (arg->ob_config && (from_user || !cur_config->ob_config)) {
@@ -2062,7 +2114,7 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.ob_config =
-		    (struct atomisp_ob_config *)&css_param->ob_config;
+			(struct atomisp_ob_config *)&css_param->ob_config;
 	}
 
 	if (arg->dp_config && (from_user || !cur_config->dp_config)) {
@@ -2071,15 +2123,14 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.dp_config =
-		    (struct atomisp_dp_config *)&css_param->dp_config;
+			(struct atomisp_dp_config *)&css_param->dp_config;
 	}
 
 	if (asd->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {
 		if (arg->dz_config && (from_user || !cur_config->dz_config)) {
-			if (copy_from_compatible(&css_param->dz_config,
-						 arg->dz_config,
-						 sizeof(struct ia_css_dz_config),
-						 from_user))
+			if (copy_from_compatible(
+				    &css_param->dz_config, arg->dz_config,
+				    sizeof(struct ia_css_dz_config), from_user))
 				return -EFAULT;
 			if (!atomisp_check_zoom_region(asd,
 						       &css_param->dz_config)) {
@@ -2087,8 +2138,8 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 				return -EINVAL;
 			}
 			css_param->update_flag.dz_config =
-			    (struct atomisp_dz_config *)
-			    &css_param->dz_config;
+				(struct atomisp_dz_config *)&css_param
+					->dz_config;
 		}
 	}
 
@@ -2098,7 +2149,7 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.nr_config =
-		    (struct atomisp_nr_config *)&css_param->nr_config;
+			(struct atomisp_nr_config *)&css_param->nr_config;
 	}
 
 	if (arg->ee_config && (from_user || !cur_config->ee_config)) {
@@ -2107,93 +2158,79 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.ee_config =
-		    (struct atomisp_ee_config *)&css_param->ee_config;
+			(struct atomisp_ee_config *)&css_param->ee_config;
 	}
 
 	if (arg->tnr_config && (from_user || !cur_config->tnr_config)) {
-		if (copy_from_compatible(&css_param->tnr_config,
-					 arg->tnr_config,
-					 sizeof(struct ia_css_tnr_config),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->tnr_config, arg->tnr_config,
+			    sizeof(struct ia_css_tnr_config), from_user))
 			return -EFAULT;
 		css_param->update_flag.tnr_config =
-		    (struct atomisp_tnr_config *)
-		    &css_param->tnr_config;
+			(struct atomisp_tnr_config *)&css_param->tnr_config;
 	}
 
 	if (arg->a3a_config && (from_user || !cur_config->a3a_config)) {
-		if (copy_from_compatible(&css_param->s3a_config,
-					 arg->a3a_config,
-					 sizeof(struct ia_css_3a_config),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->s3a_config, arg->a3a_config,
+			    sizeof(struct ia_css_3a_config), from_user))
 			return -EFAULT;
 		css_param->update_flag.a3a_config =
-		    (struct atomisp_3a_config *)&css_param->s3a_config;
+			(struct atomisp_3a_config *)&css_param->s3a_config;
 	}
 
 	if (arg->ctc_config && (from_user || !cur_config->ctc_config)) {
-		if (copy_from_compatible(&css_param->ctc_config,
-					 arg->ctc_config,
-					 sizeof(struct ia_css_ctc_config),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->ctc_config, arg->ctc_config,
+			    sizeof(struct ia_css_ctc_config), from_user))
 			return -EFAULT;
 		css_param->update_flag.ctc_config =
-		    (struct atomisp_ctc_config *)
-		    &css_param->ctc_config;
+			(struct atomisp_ctc_config *)&css_param->ctc_config;
 	}
 
 	if (arg->cnr_config && (from_user || !cur_config->cnr_config)) {
-		if (copy_from_compatible(&css_param->cnr_config,
-					 arg->cnr_config,
-					 sizeof(struct ia_css_cnr_config),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->cnr_config, arg->cnr_config,
+			    sizeof(struct ia_css_cnr_config), from_user))
 			return -EFAULT;
 		css_param->update_flag.cnr_config =
-		    (struct atomisp_cnr_config *)
-		    &css_param->cnr_config;
+			(struct atomisp_cnr_config *)&css_param->cnr_config;
 	}
 
 	if (arg->ecd_config && (from_user || !cur_config->ecd_config)) {
-		if (copy_from_compatible(&css_param->ecd_config,
-					 arg->ecd_config,
-					 sizeof(struct ia_css_ecd_config),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->ecd_config, arg->ecd_config,
+			    sizeof(struct ia_css_ecd_config), from_user))
 			return -EFAULT;
 		css_param->update_flag.ecd_config =
-		    (struct atomisp_ecd_config *)
-		    &css_param->ecd_config;
+			(struct atomisp_ecd_config *)&css_param->ecd_config;
 	}
 
 	if (arg->ynr_config && (from_user || !cur_config->ynr_config)) {
-		if (copy_from_compatible(&css_param->ynr_config,
-					 arg->ynr_config,
-					 sizeof(struct ia_css_ynr_config),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->ynr_config, arg->ynr_config,
+			    sizeof(struct ia_css_ynr_config), from_user))
 			return -EFAULT;
 		css_param->update_flag.ynr_config =
-		    (struct atomisp_ynr_config *)
-		    &css_param->ynr_config;
+			(struct atomisp_ynr_config *)&css_param->ynr_config;
 	}
 
 	if (arg->fc_config && (from_user || !cur_config->fc_config)) {
-		if (copy_from_compatible(&css_param->fc_config,
-					 arg->fc_config,
+		if (copy_from_compatible(&css_param->fc_config, arg->fc_config,
 					 sizeof(struct ia_css_fc_config),
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.fc_config =
-		    (struct atomisp_fc_config *)&css_param->fc_config;
+			(struct atomisp_fc_config *)&css_param->fc_config;
 	}
 
 	if (arg->macc_config && (from_user || !cur_config->macc_config)) {
-		if (copy_from_compatible(&css_param->macc_config,
-					 arg->macc_config,
-					 sizeof(struct ia_css_macc_config),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->macc_config, arg->macc_config,
+			    sizeof(struct ia_css_macc_config), from_user))
 			return -EFAULT;
 		css_param->update_flag.macc_config =
-		    (struct atomisp_macc_config *)
-		    &css_param->macc_config;
+			(struct atomisp_macc_config *)&css_param->macc_config;
 	}
 
 	if (arg->aa_config && (from_user || !cur_config->aa_config)) {
@@ -2202,29 +2239,25 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.aa_config =
-		    (struct atomisp_aa_config *)&css_param->aa_config;
+			(struct atomisp_aa_config *)&css_param->aa_config;
 	}
 
 	if (arg->anr_config && (from_user || !cur_config->anr_config)) {
-		if (copy_from_compatible(&css_param->anr_config,
-					 arg->anr_config,
-					 sizeof(struct ia_css_anr_config),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->anr_config, arg->anr_config,
+			    sizeof(struct ia_css_anr_config), from_user))
 			return -EFAULT;
 		css_param->update_flag.anr_config =
-		    (struct atomisp_anr_config *)
-		    &css_param->anr_config;
+			(struct atomisp_anr_config *)&css_param->anr_config;
 	}
 
 	if (arg->xnr_config && (from_user || !cur_config->xnr_config)) {
-		if (copy_from_compatible(&css_param->xnr_config,
-					 arg->xnr_config,
-					 sizeof(struct ia_css_xnr_config),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->xnr_config, arg->xnr_config,
+			    sizeof(struct ia_css_xnr_config), from_user))
 			return -EFAULT;
 		css_param->update_flag.xnr_config =
-		    (struct atomisp_xnr_config *)
-		    &css_param->xnr_config;
+			(struct atomisp_xnr_config *)&css_param->xnr_config;
 	}
 
 	if (arg->yuv2rgb_cc_config &&
@@ -2235,8 +2268,8 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.yuv2rgb_cc_config =
-		    (struct atomisp_cc_config *)
-		    &css_param->yuv2rgb_cc_config;
+			(struct atomisp_cc_config *)&css_param
+				->yuv2rgb_cc_config;
 	}
 
 	if (arg->rgb2yuv_cc_config &&
@@ -2247,62 +2280,56 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.rgb2yuv_cc_config =
-		    (struct atomisp_cc_config *)
-		    &css_param->rgb2yuv_cc_config;
+			(struct atomisp_cc_config *)&css_param
+				->rgb2yuv_cc_config;
 	}
 
 	if (arg->macc_table && (from_user || !cur_config->macc_table)) {
-		if (copy_from_compatible(&css_param->macc_table,
-					 arg->macc_table,
-					 sizeof(struct ia_css_macc_table),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->macc_table, arg->macc_table,
+			    sizeof(struct ia_css_macc_table), from_user))
 			return -EFAULT;
 		css_param->update_flag.macc_table =
-		    (struct atomisp_macc_table *)
-		    &css_param->macc_table;
+			(struct atomisp_macc_table *)&css_param->macc_table;
 	}
 
 	if (arg->xnr_table && (from_user || !cur_config->xnr_table)) {
-		if (copy_from_compatible(&css_param->xnr_table,
-					 arg->xnr_table,
+		if (copy_from_compatible(&css_param->xnr_table, arg->xnr_table,
 					 sizeof(struct ia_css_xnr_table),
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.xnr_table =
-		    (struct atomisp_xnr_table *)&css_param->xnr_table;
+			(struct atomisp_xnr_table *)&css_param->xnr_table;
 	}
 
 	if (arg->r_gamma_table && (from_user || !cur_config->r_gamma_table)) {
-		if (copy_from_compatible(&css_param->r_gamma_table,
-					 arg->r_gamma_table,
-					 sizeof(struct ia_css_rgb_gamma_table),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->r_gamma_table, arg->r_gamma_table,
+			    sizeof(struct ia_css_rgb_gamma_table), from_user))
 			return -EFAULT;
 		css_param->update_flag.r_gamma_table =
-		    (struct atomisp_rgb_gamma_table *)
-		    &css_param->r_gamma_table;
+			(struct atomisp_rgb_gamma_table *)&css_param
+				->r_gamma_table;
 	}
 
 	if (arg->g_gamma_table && (from_user || !cur_config->g_gamma_table)) {
-		if (copy_from_compatible(&css_param->g_gamma_table,
-					 arg->g_gamma_table,
-					 sizeof(struct ia_css_rgb_gamma_table),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->g_gamma_table, arg->g_gamma_table,
+			    sizeof(struct ia_css_rgb_gamma_table), from_user))
 			return -EFAULT;
 		css_param->update_flag.g_gamma_table =
-		    (struct atomisp_rgb_gamma_table *)
-		    &css_param->g_gamma_table;
+			(struct atomisp_rgb_gamma_table *)&css_param
+				->g_gamma_table;
 	}
 
 	if (arg->b_gamma_table && (from_user || !cur_config->b_gamma_table)) {
-		if (copy_from_compatible(&css_param->b_gamma_table,
-					 arg->b_gamma_table,
-					 sizeof(struct ia_css_rgb_gamma_table),
-					 from_user))
+		if (copy_from_compatible(
+			    &css_param->b_gamma_table, arg->b_gamma_table,
+			    sizeof(struct ia_css_rgb_gamma_table), from_user))
 			return -EFAULT;
 		css_param->update_flag.b_gamma_table =
-		    (struct atomisp_rgb_gamma_table *)
-		    &css_param->b_gamma_table;
+			(struct atomisp_rgb_gamma_table *)&css_param
+				->b_gamma_table;
 	}
 
 	if (arg->anr_thres && (from_user || !cur_config->anr_thres)) {
@@ -2311,7 +2338,7 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 					 from_user))
 			return -EFAULT;
 		css_param->update_flag.anr_thres =
-		    (struct atomisp_anr_thres *)&css_param->anr_thres;
+			(struct atomisp_anr_thres *)&css_param->anr_thres;
 	}
 
 	if (from_user)
@@ -2332,8 +2359,7 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 
 int atomisp_cp_lsc_table(struct atomisp_sub_device *asd,
 			 struct atomisp_shading_table *source_st,
-			 struct atomisp_css_params *css_param,
-			 bool from_user)
+			 struct atomisp_css_params *css_param, bool from_user)
 {
 	unsigned int i;
 	unsigned int len_table;
@@ -2352,8 +2378,8 @@ int atomisp_cp_lsc_table(struct atomisp_sub_device *asd,
 
 	if (IS_ISP2401) {
 		if (copy_from_compatible(&dest_st, source_st,
-					sizeof(struct atomisp_shading_table),
-					from_user)) {
+					 sizeof(struct atomisp_shading_table),
+					 from_user)) {
 			dev_err(asd->isp->dev, "copy shading table failed!");
 			return -EFAULT;
 		}
@@ -2395,8 +2421,8 @@ int atomisp_cp_lsc_table(struct atomisp_sub_device *asd,
 
 	len_table = st->width * st->height * ATOMISP_SC_TYPE_SIZE;
 	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
-		if (copy_from_compatible(shading_table->data[i],
-					 st->data[i], len_table, from_user)) {
+		if (copy_from_compatible(shading_table->data[i], st->data[i],
+					 len_table, from_user)) {
 			atomisp_css_shading_table_free(shading_table);
 			return -EFAULT;
 		}
@@ -2433,7 +2459,8 @@ int atomisp_cp_lsc_table(struct atomisp_sub_device *asd,
 set_lsc:
 	/* set LSC to CSS */
 	css_param->shading_table = shading_table;
-	css_param->update_flag.shading_table = (struct atomisp_shading_table *)shading_table;
+	css_param->update_flag.shading_table =
+		(struct atomisp_shading_table *)shading_table;
 	asd->params.sc_en = shading_table;
 
 	if (old_table)
@@ -2448,7 +2475,7 @@ int atomisp_css_cp_dvs2_coefs(struct atomisp_sub_device *asd,
 			      bool from_user)
 {
 	struct ia_css_dvs_grid_info *cur =
-	    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
+		atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
 	int dvs_hor_coef_bytes, dvs_ver_coef_bytes;
 	struct ia_css_dvs2_coefficients dvs2_coefs;
 
@@ -2468,49 +2495,63 @@ int atomisp_css_cp_dvs2_coefs(struct atomisp_sub_device *asd,
 			return -EAGAIN;
 		}
 
-		if (!coefs->hor_coefs.odd_real ||
-		    !coefs->hor_coefs.odd_imag ||
+		if (!coefs->hor_coefs.odd_real || !coefs->hor_coefs.odd_imag ||
 		    !coefs->hor_coefs.even_real ||
-		    !coefs->hor_coefs.even_imag ||
-		    !coefs->ver_coefs.odd_real ||
-		    !coefs->ver_coefs.odd_imag ||
-		    !coefs->ver_coefs.even_real ||
+		    !coefs->hor_coefs.even_imag || !coefs->ver_coefs.odd_real ||
+		    !coefs->ver_coefs.odd_imag || !coefs->ver_coefs.even_real ||
 		    !coefs->ver_coefs.even_imag)
 			return -EINVAL;
 
 		if (!css_param->dvs2_coeff) {
 			/* DIS coefficients. */
-			css_param->dvs2_coeff = ia_css_dvs2_coefficients_allocate(cur);
+			css_param->dvs2_coeff =
+				ia_css_dvs2_coefficients_allocate(cur);
 			if (!css_param->dvs2_coeff)
 				return -ENOMEM;
 		}
 
 		dvs_hor_coef_bytes = asd->params.dvs_hor_coef_bytes;
 		dvs_ver_coef_bytes = asd->params.dvs_ver_coef_bytes;
-		if (copy_from_compatible(css_param->dvs2_coeff->hor_coefs.odd_real,
-					coefs->hor_coefs.odd_real, dvs_hor_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.odd_imag,
-					coefs->hor_coefs.odd_imag, dvs_hor_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.even_real,
-					coefs->hor_coefs.even_real, dvs_hor_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.even_imag,
-					coefs->hor_coefs.even_imag, dvs_hor_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.odd_real,
-					coefs->ver_coefs.odd_real, dvs_ver_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.odd_imag,
-					coefs->ver_coefs.odd_imag, dvs_ver_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.even_real,
-					coefs->ver_coefs.even_real, dvs_ver_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.even_imag,
-					coefs->ver_coefs.even_imag, dvs_ver_coef_bytes, from_user)) {
+		if (copy_from_compatible(
+			    css_param->dvs2_coeff->hor_coefs.odd_real,
+			    coefs->hor_coefs.odd_real, dvs_hor_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->hor_coefs.odd_imag,
+			    coefs->hor_coefs.odd_imag, dvs_hor_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->hor_coefs.even_real,
+			    coefs->hor_coefs.even_real, dvs_hor_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->hor_coefs.even_imag,
+			    coefs->hor_coefs.even_imag, dvs_hor_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->ver_coefs.odd_real,
+			    coefs->ver_coefs.odd_real, dvs_ver_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->ver_coefs.odd_imag,
+			    coefs->ver_coefs.odd_imag, dvs_ver_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->ver_coefs.even_real,
+			    coefs->ver_coefs.even_real, dvs_ver_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->ver_coefs.even_imag,
+			    coefs->ver_coefs.even_imag, dvs_ver_coef_bytes,
+			    from_user)) {
 			ia_css_dvs2_coefficients_free(css_param->dvs2_coeff);
 			css_param->dvs2_coeff = NULL;
 			return -EFAULT;
 		}
 	} else {
 		if (copy_from_compatible(&dvs2_coefs, coefs,
-					sizeof(struct ia_css_dvs2_coefficients),
-					from_user)) {
+					 sizeof(struct ia_css_dvs2_coefficients),
+					 from_user)) {
 			dev_err(asd->isp->dev, "copy dvs2 coef failed");
 			return -EFAULT;
 		}
@@ -2536,29 +2577,46 @@ int atomisp_css_cp_dvs2_coefs(struct atomisp_sub_device *asd,
 
 		if (!css_param->dvs2_coeff) {
 			/* DIS coefficients. */
-			css_param->dvs2_coeff = ia_css_dvs2_coefficients_allocate(cur);
+			css_param->dvs2_coeff =
+				ia_css_dvs2_coefficients_allocate(cur);
 			if (!css_param->dvs2_coeff)
 				return -ENOMEM;
 		}
 
 		dvs_hor_coef_bytes = asd->params.dvs_hor_coef_bytes;
 		dvs_ver_coef_bytes = asd->params.dvs_ver_coef_bytes;
-		if (copy_from_compatible(css_param->dvs2_coeff->hor_coefs.odd_real,
-					dvs2_coefs.hor_coefs.odd_real, dvs_hor_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.odd_imag,
-					dvs2_coefs.hor_coefs.odd_imag, dvs_hor_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.even_real,
-					dvs2_coefs.hor_coefs.even_real, dvs_hor_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->hor_coefs.even_imag,
-					dvs2_coefs.hor_coefs.even_imag, dvs_hor_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.odd_real,
-					dvs2_coefs.ver_coefs.odd_real, dvs_ver_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.odd_imag,
-					dvs2_coefs.ver_coefs.odd_imag, dvs_ver_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.even_real,
-					dvs2_coefs.ver_coefs.even_real, dvs_ver_coef_bytes, from_user) ||
-		    copy_from_compatible(css_param->dvs2_coeff->ver_coefs.even_imag,
-					dvs2_coefs.ver_coefs.even_imag, dvs_ver_coef_bytes, from_user)) {
+		if (copy_from_compatible(
+			    css_param->dvs2_coeff->hor_coefs.odd_real,
+			    dvs2_coefs.hor_coefs.odd_real, dvs_hor_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->hor_coefs.odd_imag,
+			    dvs2_coefs.hor_coefs.odd_imag, dvs_hor_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->hor_coefs.even_real,
+			    dvs2_coefs.hor_coefs.even_real, dvs_hor_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->hor_coefs.even_imag,
+			    dvs2_coefs.hor_coefs.even_imag, dvs_hor_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->ver_coefs.odd_real,
+			    dvs2_coefs.ver_coefs.odd_real, dvs_ver_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->ver_coefs.odd_imag,
+			    dvs2_coefs.ver_coefs.odd_imag, dvs_ver_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->ver_coefs.even_real,
+			    dvs2_coefs.ver_coefs.even_real, dvs_ver_coef_bytes,
+			    from_user) ||
+		    copy_from_compatible(
+			    css_param->dvs2_coeff->ver_coefs.even_imag,
+			    dvs2_coefs.ver_coefs.even_imag, dvs_ver_coef_bytes,
+			    from_user)) {
 			ia_css_dvs2_coefficients_free(css_param->dvs2_coeff);
 			css_param->dvs2_coeff = NULL;
 			return -EFAULT;
@@ -2566,21 +2624,21 @@ int atomisp_css_cp_dvs2_coefs(struct atomisp_sub_device *asd,
 	}
 
 	css_param->update_flag.dvs2_coefs =
-	    (struct atomisp_dis_coefficients *)css_param->dvs2_coeff;
+		(struct atomisp_dis_coefficients *)css_param->dvs2_coeff;
 	return 0;
 }
 
-int atomisp_cp_dvs_6axis_config(struct atomisp_sub_device *asd,
-				struct atomisp_dvs_6axis_config *source_6axis_config,
-				struct atomisp_css_params *css_param,
-				bool from_user)
+int atomisp_cp_dvs_6axis_config(
+	struct atomisp_sub_device *asd,
+	struct atomisp_dvs_6axis_config *source_6axis_config,
+	struct atomisp_css_params *css_param, bool from_user)
 {
 	struct ia_css_dvs_6axis_config *dvs_6axis_config;
 	struct ia_css_dvs_6axis_config *old_6axis_config;
 	struct ia_css_stream *stream =
-		    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream;
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream;
 	struct ia_css_dvs_grid_info *dvs_grid_info =
-	    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
+		atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
 	int ret = -EFAULT;
 
 	if (!stream) {
@@ -2605,75 +2663,83 @@ int atomisp_cp_dvs_6axis_config(struct atomisp_sub_device *asd,
 		struct ia_css_dvs_6axis_config t_6axis_config;
 
 		if (copy_from_compatible(&t_6axis_config, source_6axis_config,
-					sizeof(struct atomisp_dvs_6axis_config),
-					from_user)) {
+					 sizeof(struct atomisp_dvs_6axis_config),
+					 from_user)) {
 			dev_err(asd->isp->dev, "copy morph table failed!");
 			return -EFAULT;
 		}
 
 		if (old_6axis_config &&
 		    (old_6axis_config->width_y != t_6axis_config.width_y ||
-		    old_6axis_config->height_y != t_6axis_config.height_y ||
-		    old_6axis_config->width_uv != t_6axis_config.width_uv ||
-		    old_6axis_config->height_uv != t_6axis_config.height_uv)) {
+		     old_6axis_config->height_y != t_6axis_config.height_y ||
+		     old_6axis_config->width_uv != t_6axis_config.width_uv ||
+		     old_6axis_config->height_uv != t_6axis_config.height_uv)) {
 			ia_css_dvs2_6axis_config_free(css_param->dvs_6axis);
 			css_param->dvs_6axis = NULL;
 
-			dvs_6axis_config = ia_css_dvs2_6axis_config_allocate(stream);
+			dvs_6axis_config =
+				ia_css_dvs2_6axis_config_allocate(stream);
 			if (!dvs_6axis_config)
 				return -ENOMEM;
 		} else if (!dvs_6axis_config) {
-			dvs_6axis_config = ia_css_dvs2_6axis_config_allocate(stream);
+			dvs_6axis_config =
+				ia_css_dvs2_6axis_config_allocate(stream);
 			if (!dvs_6axis_config)
 				return -ENOMEM;
 		}
 
 		dvs_6axis_config->exp_id = t_6axis_config.exp_id;
 
-		if (copy_from_compatible(dvs_6axis_config->xcoords_y,
-					t_6axis_config.xcoords_y,
-					t_6axis_config.width_y *
-					t_6axis_config.height_y *
-					sizeof(*dvs_6axis_config->xcoords_y),
-					from_user))
+		if (copy_from_compatible(
+			    dvs_6axis_config->xcoords_y,
+			    t_6axis_config.xcoords_y,
+			    t_6axis_config.width_y * t_6axis_config.height_y *
+				    sizeof(*dvs_6axis_config->xcoords_y),
+			    from_user))
 			goto error;
-		if (copy_from_compatible(dvs_6axis_config->ycoords_y,
-					t_6axis_config.ycoords_y,
-					t_6axis_config.width_y *
-					t_6axis_config.height_y *
-					sizeof(*dvs_6axis_config->ycoords_y),
-					from_user))
+		if (copy_from_compatible(
+			    dvs_6axis_config->ycoords_y,
+			    t_6axis_config.ycoords_y,
+			    t_6axis_config.width_y * t_6axis_config.height_y *
+				    sizeof(*dvs_6axis_config->ycoords_y),
+			    from_user))
 			goto error;
-		if (copy_from_compatible(dvs_6axis_config->xcoords_uv,
-					t_6axis_config.xcoords_uv,
-					t_6axis_config.width_uv *
-					t_6axis_config.height_uv *
-					sizeof(*dvs_6axis_config->xcoords_uv),
-					from_user))
+		if (copy_from_compatible(
+			    dvs_6axis_config->xcoords_uv,
+			    t_6axis_config.xcoords_uv,
+			    t_6axis_config.width_uv * t_6axis_config.height_uv *
+				    sizeof(*dvs_6axis_config->xcoords_uv),
+			    from_user))
 			goto error;
-		if (copy_from_compatible(dvs_6axis_config->ycoords_uv,
-					t_6axis_config.ycoords_uv,
-					t_6axis_config.width_uv *
-					t_6axis_config.height_uv *
-					sizeof(*dvs_6axis_config->ycoords_uv),
-					from_user))
+		if (copy_from_compatible(
+			    dvs_6axis_config->ycoords_uv,
+			    t_6axis_config.ycoords_uv,
+			    t_6axis_config.width_uv * t_6axis_config.height_uv *
+				    sizeof(*dvs_6axis_config->ycoords_uv),
+			    from_user))
 			goto error;
 	} else {
 		if (old_6axis_config &&
-		    (old_6axis_config->width_y != source_6axis_config->width_y ||
-		    old_6axis_config->height_y != source_6axis_config->height_y ||
-		    old_6axis_config->width_uv != source_6axis_config->width_uv ||
-		    old_6axis_config->height_uv != source_6axis_config->height_uv)) {
+		    (old_6axis_config->width_y !=
+			     source_6axis_config->width_y ||
+		     old_6axis_config->height_y !=
+			     source_6axis_config->height_y ||
+		     old_6axis_config->width_uv !=
+			     source_6axis_config->width_uv ||
+		     old_6axis_config->height_uv !=
+			     source_6axis_config->height_uv)) {
 			ia_css_dvs2_6axis_config_free(css_param->dvs_6axis);
 			css_param->dvs_6axis = NULL;
 
-			dvs_6axis_config = ia_css_dvs2_6axis_config_allocate(stream);
+			dvs_6axis_config =
+				ia_css_dvs2_6axis_config_allocate(stream);
 			if (!dvs_6axis_config) {
 				ret = -ENOMEM;
 				goto error;
 			}
 		} else if (!dvs_6axis_config) {
-			dvs_6axis_config = ia_css_dvs2_6axis_config_allocate(stream);
+			dvs_6axis_config =
+				ia_css_dvs2_6axis_config_allocate(stream);
 			if (!dvs_6axis_config) {
 				ret = -ENOMEM;
 				goto error;
@@ -2682,38 +2748,42 @@ int atomisp_cp_dvs_6axis_config(struct atomisp_sub_device *asd,
 
 		dvs_6axis_config->exp_id = source_6axis_config->exp_id;
 
-		if (copy_from_compatible(dvs_6axis_config->xcoords_y,
-					source_6axis_config->xcoords_y,
-					source_6axis_config->width_y *
-					source_6axis_config->height_y *
-					sizeof(*source_6axis_config->xcoords_y),
-					from_user))
+		if (copy_from_compatible(
+			    dvs_6axis_config->xcoords_y,
+			    source_6axis_config->xcoords_y,
+			    source_6axis_config->width_y *
+				    source_6axis_config->height_y *
+				    sizeof(*source_6axis_config->xcoords_y),
+			    from_user))
 			goto error;
-		if (copy_from_compatible(dvs_6axis_config->ycoords_y,
-					source_6axis_config->ycoords_y,
-					source_6axis_config->width_y *
-					source_6axis_config->height_y *
-					sizeof(*source_6axis_config->ycoords_y),
-					from_user))
+		if (copy_from_compatible(
+			    dvs_6axis_config->ycoords_y,
+			    source_6axis_config->ycoords_y,
+			    source_6axis_config->width_y *
+				    source_6axis_config->height_y *
+				    sizeof(*source_6axis_config->ycoords_y),
+			    from_user))
 			goto error;
-		if (copy_from_compatible(dvs_6axis_config->xcoords_uv,
-					source_6axis_config->xcoords_uv,
-					source_6axis_config->width_uv *
-					source_6axis_config->height_uv *
-					sizeof(*source_6axis_config->xcoords_uv),
-					from_user))
+		if (copy_from_compatible(
+			    dvs_6axis_config->xcoords_uv,
+			    source_6axis_config->xcoords_uv,
+			    source_6axis_config->width_uv *
+				    source_6axis_config->height_uv *
+				    sizeof(*source_6axis_config->xcoords_uv),
+			    from_user))
 			goto error;
-		if (copy_from_compatible(dvs_6axis_config->ycoords_uv,
-					source_6axis_config->ycoords_uv,
-					source_6axis_config->width_uv *
-					source_6axis_config->height_uv *
-					sizeof(*source_6axis_config->ycoords_uv),
-					from_user))
+		if (copy_from_compatible(
+			    dvs_6axis_config->ycoords_uv,
+			    source_6axis_config->ycoords_uv,
+			    source_6axis_config->width_uv *
+				    source_6axis_config->height_uv *
+				    sizeof(*source_6axis_config->ycoords_uv),
+			    from_user))
 			goto error;
 	}
 	css_param->dvs_6axis = dvs_6axis_config;
 	css_param->update_flag.dvs_6axis_config =
-	    (struct atomisp_dvs_6axis_config *)dvs_6axis_config;
+		(struct atomisp_dvs_6axis_config *)dvs_6axis_config;
 	return 0;
 
 error:
@@ -2724,8 +2794,7 @@ int atomisp_cp_dvs_6axis_config(struct atomisp_sub_device *asd,
 
 int atomisp_cp_morph_table(struct atomisp_sub_device *asd,
 			   struct atomisp_morph_table *source_morph_table,
-			   struct atomisp_css_params *css_param,
-			   bool from_user)
+			   struct atomisp_css_params *css_param, bool from_user)
 {
 	int ret = -EFAULT;
 	unsigned int i;
@@ -2744,55 +2813,67 @@ int atomisp_cp_morph_table(struct atomisp_sub_device *asd,
 		struct ia_css_morph_table mtbl;
 
 		if (copy_from_compatible(&mtbl, source_morph_table,
-				sizeof(struct atomisp_morph_table),
-				from_user)) {
+					 sizeof(struct atomisp_morph_table),
+					 from_user)) {
 			dev_err(asd->isp->dev, "copy morph table failed!");
 			return -EFAULT;
 		}
 
-		morph_table = atomisp_css_morph_table_allocate(
-				mtbl.width,
-				mtbl.height);
+		morph_table = atomisp_css_morph_table_allocate(mtbl.width,
+							       mtbl.height);
 		if (!morph_table)
 			return -ENOMEM;
 
 		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-			if (copy_from_compatible(morph_table->coordinates_x[i],
-						(__force void *)source_morph_table->coordinates_x[i],
-						mtbl.height * mtbl.width *
-						sizeof(*morph_table->coordinates_x[i]),
-						from_user))
+			if (copy_from_compatible(
+				    morph_table->coordinates_x[i],
+				    (__force void *)source_morph_table
+					    ->coordinates_x[i],
+				    mtbl.height * mtbl.width *
+					    sizeof(*morph_table
+							    ->coordinates_x[i]),
+				    from_user))
 				goto error;
 
-			if (copy_from_compatible(morph_table->coordinates_y[i],
-						(__force void *)source_morph_table->coordinates_y[i],
-						mtbl.height * mtbl.width *
-						sizeof(*morph_table->coordinates_y[i]),
-						from_user))
+			if (copy_from_compatible(
+				    morph_table->coordinates_y[i],
+				    (__force void *)source_morph_table
+					    ->coordinates_y[i],
+				    mtbl.height * mtbl.width *
+					    sizeof(*morph_table
+							    ->coordinates_y[i]),
+				    from_user))
 				goto error;
 		}
 	} else {
 		morph_table = atomisp_css_morph_table_allocate(
-				source_morph_table->width,
-				source_morph_table->height);
+			source_morph_table->width, source_morph_table->height);
 		if (!morph_table) {
 			ret = -ENOMEM;
 			goto error;
 		}
 
 		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-			if (copy_from_compatible(morph_table->coordinates_x[i],
-						(__force void *)source_morph_table->coordinates_x[i],
-						source_morph_table->height * source_morph_table->width *
-						sizeof(*source_morph_table->coordinates_x[i]),
-						from_user))
+			if (copy_from_compatible(
+				    morph_table->coordinates_x[i],
+				    (__force void *)source_morph_table
+					    ->coordinates_x[i],
+				    source_morph_table->height *
+					    source_morph_table->width *
+					    sizeof(*source_morph_table
+							    ->coordinates_x[i]),
+				    from_user))
 				goto error;
 
-			if (copy_from_compatible(morph_table->coordinates_y[i],
-						(__force void *)source_morph_table->coordinates_y[i],
-						source_morph_table->height * source_morph_table->width *
-						sizeof(*source_morph_table->coordinates_y[i]),
-						from_user))
+			if (copy_from_compatible(
+				    morph_table->coordinates_y[i],
+				    (__force void *)source_morph_table
+					    ->coordinates_y[i],
+				    source_morph_table->height *
+					    source_morph_table->width *
+					    sizeof(*source_morph_table
+							    ->coordinates_y[i]),
+				    from_user))
 				goto error;
 		}
 	}
@@ -2801,7 +2882,7 @@ int atomisp_cp_morph_table(struct atomisp_sub_device *asd,
 	if (old_morph_table)
 		atomisp_css_morph_table_free(old_morph_table);
 	css_param->update_flag.morph_table =
-	    (struct atomisp_morph_table *)morph_table;
+		(struct atomisp_morph_table *)morph_table;
 	return 0;
 
 error:
@@ -2825,13 +2906,13 @@ int atomisp_makeup_css_parameters(struct atomisp_sub_device *asd,
 	ret = atomisp_cp_morph_table(asd, arg->morph_table, css_param, false);
 	if (ret)
 		return ret;
-	ret = atomisp_css_cp_dvs2_coefs(asd,
-					(struct ia_css_dvs2_coefficients *)arg->dvs2_coefs,
-					css_param, false);
+	ret = atomisp_css_cp_dvs2_coefs(
+		asd, (struct ia_css_dvs2_coefficients *)arg->dvs2_coefs,
+		css_param, false);
 	if (ret)
 		return ret;
-	ret = atomisp_cp_dvs_6axis_config(asd, arg->dvs_6axis_config,
-					  css_param, false);
+	ret = atomisp_cp_dvs_6axis_config(asd, arg->dvs_6axis_config, css_param,
+					  false);
 	return ret;
 }
 
@@ -2855,8 +2936,9 @@ void atomisp_free_css_parameters(struct atomisp_css_params *css_param)
 	}
 }
 
-static void atomisp_move_frame_to_activeq(struct ia_css_frame *frame,
-					  struct atomisp_css_params_with_list *param)
+static void
+atomisp_move_frame_to_activeq(struct ia_css_frame *frame,
+			      struct atomisp_css_params_with_list *param)
 {
 	struct atomisp_video_pipe *pipe = vb_to_pipe(&frame->vb.vb2_buf);
 	unsigned long irqflags;
@@ -2900,8 +2982,10 @@ void atomisp_handle_parameter_and_buffer(struct atomisp_video_pipe *pipe)
 		i = frame->vb.vb2_buf.index;
 		if (pipe->frame_request_config_id[i]) {
 			list_for_each_entry_safe(param, param_tmp,
-						 &pipe->per_frame_params, list) {
-				if (pipe->frame_request_config_id[i] != param->params.isp_config_id)
+						 &pipe->per_frame_params,
+						 list) {
+				if (pipe->frame_request_config_id[i] !=
+				    param->params.isp_config_id)
 					continue;
 
 				list_del(&param->list);
@@ -2917,7 +3001,8 @@ void atomisp_handle_parameter_and_buffer(struct atomisp_video_pipe *pipe)
 			}
 
 			/* If this is the end, stop further loop */
-			if (list_entry_is_head(param, &pipe->per_frame_params, list))
+			if (list_entry_is_head(param, &pipe->per_frame_params,
+					       list))
 				break;
 		} else {
 			atomisp_move_frame_to_activeq(frame, NULL);
@@ -2950,7 +3035,8 @@ int atomisp_set_parameters(struct video_device *vdev,
 		return -EINVAL;
 	}
 
-	dev_dbg(asd->isp->dev, "set parameter(per_frame_setting %d) isp_config_id %d of %s\n",
+	dev_dbg(asd->isp->dev,
+		"set parameter(per_frame_setting %d) isp_config_id %d of %s\n",
 		arg->per_frame_setting, arg->isp_config_id, vdev->name);
 
 	if (arg->per_frame_setting) {
@@ -2962,7 +3048,8 @@ int atomisp_set_parameters(struct video_device *vdev,
 		 */
 		param = kvzalloc(sizeof(*param), GFP_KERNEL);
 		if (!param) {
-			dev_err(asd->isp->dev, "%s: failed to alloc params buffer\n",
+			dev_err(asd->isp->dev,
+				"%s: failed to alloc params buffer\n",
 				__func__);
 			return -ENOMEM;
 		}
@@ -2981,14 +3068,14 @@ int atomisp_set_parameters(struct video_device *vdev,
 	if (ret)
 		goto apply_parameter_failed;
 
-	ret = atomisp_css_cp_dvs2_coefs(asd,
-					(struct ia_css_dvs2_coefficients *)arg->dvs2_coefs,
-					css_param, true);
+	ret = atomisp_css_cp_dvs2_coefs(
+		asd, (struct ia_css_dvs2_coefficients *)arg->dvs2_coefs,
+		css_param, true);
 	if (ret)
 		goto apply_parameter_failed;
 
-	ret = atomisp_cp_dvs_6axis_config(asd, arg->dvs_6axis_config,
-					  css_param, true);
+	ret = atomisp_cp_dvs_6axis_config(asd, arg->dvs_6axis_config, css_param,
+					  true);
 	if (ret)
 		goto apply_parameter_failed;
 
@@ -3017,31 +3104,30 @@ int atomisp_param(struct atomisp_sub_device *asd, int flag,
 		  struct atomisp_parm *config)
 {
 	struct ia_css_pipe_config *vp_cfg =
-		    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].
-		    pipe_configs[IA_CSS_PIPE_ID_VIDEO];
+		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
+			 .pipe_configs[IA_CSS_PIPE_ID_VIDEO];
 
 	/* Read parameter for 3A binary info */
 	if (flag == 0) {
 		struct ia_css_dvs_grid_info *dvs_grid_info =
-		    atomisp_css_get_dvs_grid_info(
-			&asd->params.curr_grid_info);
+			atomisp_css_get_dvs_grid_info(
+				&asd->params.curr_grid_info);
 
 		atomisp_curr_user_grid_info(asd, &config->info);
 
 		/* We always return the resolution and stride even if there is
 		 * no valid metadata. This allows the caller to get the
 		 * information needed to allocate user-space buffers. */
-		config->metadata_config.metadata_height = asd->
-			stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream_info.
-			metadata_info.resolution.height;
-		config->metadata_config.metadata_stride = asd->
-			stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream_info.
-			metadata_info.stride;
+		config->metadata_config.metadata_height =
+			asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
+				.stream_info.metadata_info.resolution.height;
+		config->metadata_config.metadata_stride =
+			asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
+				.stream_info.metadata_info.stride;
 
 		/* update dvs grid info */
 		if (dvs_grid_info)
-			memcpy(&config->dvs_grid,
-			       dvs_grid_info,
+			memcpy(&config->dvs_grid, dvs_grid_info,
 			       sizeof(struct ia_css_dvs_grid_info));
 
 		if (asd->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {
@@ -3076,12 +3162,18 @@ int atomisp_param(struct atomisp_sub_device *asd, int flag,
 	       sizeof(struct ia_css_tnr_config));
 
 	if (asd->params.color_effect == V4L2_COLORFX_NEGATIVE) {
-		asd->params.css_param.cc_config.matrix[3] = -config->cc_config.matrix[3];
-		asd->params.css_param.cc_config.matrix[4] = -config->cc_config.matrix[4];
-		asd->params.css_param.cc_config.matrix[5] = -config->cc_config.matrix[5];
-		asd->params.css_param.cc_config.matrix[6] = -config->cc_config.matrix[6];
-		asd->params.css_param.cc_config.matrix[7] = -config->cc_config.matrix[7];
-		asd->params.css_param.cc_config.matrix[8] = -config->cc_config.matrix[8];
+		asd->params.css_param.cc_config.matrix[3] =
+			-config->cc_config.matrix[3];
+		asd->params.css_param.cc_config.matrix[4] =
+			-config->cc_config.matrix[4];
+		asd->params.css_param.cc_config.matrix[5] =
+			-config->cc_config.matrix[5];
+		asd->params.css_param.cc_config.matrix[6] =
+			-config->cc_config.matrix[6];
+		asd->params.css_param.cc_config.matrix[7] =
+			-config->cc_config.matrix[7];
+		asd->params.css_param.cc_config.matrix[8] =
+			-config->cc_config.matrix[8];
 	}
 
 	if (asd->params.color_effect != V4L2_COLORFX_SEPIA &&
@@ -3125,9 +3217,9 @@ int atomisp_color_effect(struct atomisp_sub_device *asd, int flag,
 
 	control.id = V4L2_CID_COLORFX;
 	control.value = *effect;
-	ret =
-	    v4l2_s_ctrl(NULL, isp->inputs[asd->input_curr].sensor->ctrl_handler,
-			&control);
+	ret = v4l2_s_ctrl(NULL,
+			  isp->inputs[asd->input_curr].sensor->ctrl_handler,
+			  &control);
 	/*
 	 * if set color effect to sensor successfully, return
 	 * 0 directly.
@@ -3201,8 +3293,7 @@ int atomisp_color_effect(struct atomisp_sub_device *asd, int flag,
 /*
  * Function to configure bad pixel correction
  */
-int atomisp_bad_pixel(struct atomisp_sub_device *asd, int flag,
-		      __s32 *value)
+int atomisp_bad_pixel(struct atomisp_sub_device *asd, int flag, __s32 *value)
 {
 	if (flag == 0) {
 		*value = asd->params.bad_pixel_en;
@@ -3237,8 +3328,7 @@ int atomisp_bad_pixel_param(struct atomisp_sub_device *asd, int flag,
 /*
  * Function to enable/disable video image stablization
  */
-int atomisp_video_stable(struct atomisp_sub_device *asd, int flag,
-			 __s32 *value)
+int atomisp_video_stable(struct atomisp_sub_device *asd, int flag, __s32 *value)
 {
 	if (flag == 0)
 		*value = asd->params.video_dis_en;
@@ -3315,13 +3405,13 @@ atomisp_v4l2_framebuffer_to_css_frame(const struct v4l2_framebuffer *arg,
 
 	sh_format = v4l2_fmt_to_sh_fmt(arg->fmt.pixelformat);
 	padded_width = atomisp_bytesperline_to_padded_width(
-			   arg->fmt.bytesperline, sh_format);
+		arg->fmt.bytesperline, sh_format);
 
 	/* Note: the padded width on an ia_css_frame is in elements, not in
 	   bytes. The RAW frame we use here should always be a 16bit RAW
 	   frame. This is why we bytesperline/2 is equal to the padded with */
 	if (ia_css_frame_allocate(&res, arg->fmt.width, arg->fmt.height,
-				       sh_format, padded_width, 0)) {
+				  sh_format, padded_width, 0)) {
 		ret = -ENOMEM;
 		goto err;
 	}
@@ -3367,8 +3457,9 @@ int atomisp_fixed_pattern_table(struct atomisp_sub_device *asd,
 	if (ret)
 		return ret;
 
-	if (sh_css_set_black_frame(asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-				   raw_black_frame) != 0)
+	if (sh_css_set_black_frame(
+		    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		    raw_black_frame) != 0)
 		return -ENOMEM;
 
 	ia_css_frame_free(raw_black_frame);
@@ -3378,8 +3469,7 @@ int atomisp_fixed_pattern_table(struct atomisp_sub_device *asd,
 /*
  * Function to configure false color correction
  */
-int atomisp_false_color(struct atomisp_sub_device *asd, int flag,
-			__s32 *value)
+int atomisp_false_color(struct atomisp_sub_device *asd, int flag, __s32 *value)
 {
 	/* Get nr config from current setup */
 	if (flag == 0) {
@@ -3456,7 +3546,8 @@ int atomisp_3a_config_param(struct atomisp_sub_device *asd, int flag,
 		/* Set white balance to isp parameters */
 		memcpy(&asd->params.css_param.s3a_config, config,
 		       sizeof(asd->params.css_param.s3a_config));
-		asd->params.config.s3a_config = &asd->params.css_param.s3a_config;
+		asd->params.config.s3a_config =
+			&asd->params.css_param.s3a_config;
 		asd->params.css_update_params_needed = true;
 	}
 
@@ -3467,8 +3558,7 @@ int atomisp_3a_config_param(struct atomisp_sub_device *asd, int flag,
 /*
  * Function to setup digital zoom
  */
-int atomisp_digital_zoom(struct atomisp_sub_device *asd, int flag,
-			 __s32 *value)
+int atomisp_digital_zoom(struct atomisp_sub_device *asd, int flag, __s32 *value)
 {
 	u32 zoom;
 	struct atomisp_device *isp = asd->isp;
@@ -3492,8 +3582,9 @@ int atomisp_digital_zoom(struct atomisp_sub_device *asd, int flag,
 	return 0;
 }
 
-static void __atomisp_update_stream_env(struct atomisp_sub_device *asd,
-					u16 stream_index, struct atomisp_input_stream_info *stream_info)
+static void
+__atomisp_update_stream_env(struct atomisp_sub_device *asd, u16 stream_index,
+			    struct atomisp_input_stream_info *stream_info)
 {
 	int i;
 
@@ -3502,16 +3593,17 @@ static void __atomisp_update_stream_env(struct atomisp_sub_device *asd,
 	asd->stream_env[stream_index].isys_configs = stream_info->isys_configs;
 	for (i = 0; i < stream_info->isys_configs; i++) {
 		asd->stream_env[stream_index].isys_info[i].input_format =
-		    stream_info->isys_info[i].input_format;
+			stream_info->isys_info[i].input_format;
 		asd->stream_env[stream_index].isys_info[i].width =
-		    stream_info->isys_info[i].width;
+			stream_info->isys_info[i].width;
 		asd->stream_env[stream_index].isys_info[i].height =
-		    stream_info->isys_info[i].height;
+			stream_info->isys_info[i].height;
 	}
 }
 
-static void __atomisp_init_stream_info(u16 stream_index,
-				       struct atomisp_input_stream_info *stream_info)
+static void
+__atomisp_init_stream_info(u16 stream_index,
+			   struct atomisp_input_stream_info *stream_info)
 {
 	int i;
 
@@ -3526,8 +3618,8 @@ static void __atomisp_init_stream_info(u16 stream_index,
 	}
 }
 
-static void atomisp_fill_pix_format(struct v4l2_pix_format *f,
-				    u32 width, u32 height,
+static void atomisp_fill_pix_format(struct v4l2_pix_format *f, u32 width,
+				    u32 height,
 				    const struct atomisp_format_bridge *br_fmt)
 {
 	u32 bytes;
@@ -3580,7 +3672,7 @@ void atomisp_get_padding(struct atomisp_device *isp, u32 width, u32 height,
 	height = min(height, input->active_rect.height);
 
 	if (input->binning_support && width <= (input->active_rect.width / 2) &&
-				      height <= (input->active_rect.height / 2)) {
+	    height <= (input->active_rect.height / 2)) {
 		native_rect.width /= 2;
 		native_rect.height /= 2;
 	}
@@ -3592,12 +3684,14 @@ void atomisp_get_padding(struct atomisp_device *isp, u32 width, u32 height,
 	if (IS_ISP2401)
 		return;
 
-	sink = atomisp_subdev_get_ffmt(&isp->asd.subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,
+	sink = atomisp_subdev_get_ffmt(&isp->asd.subdev, NULL,
+				       V4L2_SUBDEV_FORMAT_ACTIVE,
 				       ATOMISP_SUBDEV_PAD_SINK);
 	if (sink)
 		fc = atomisp_find_in_fmt_conv(sink->code);
 	if (!fc) {
-		dev_warn(isp->dev, "%s: Could not get sensor format\n", __func__);
+		dev_warn(isp->dev, "%s: Could not get sensor format\n",
+			 __func__);
 		goto apply_min_padding;
 	}
 
@@ -3618,7 +3712,8 @@ void atomisp_get_padding(struct atomisp_device *isp, u32 width, u32 height,
 	*padding_h = max_t(u32, *padding_h, min_pad_h);
 }
 
-int atomisp_s_sensor_power(struct atomisp_device *isp, unsigned int input, bool on)
+int atomisp_s_sensor_power(struct atomisp_device *isp, unsigned int input,
+			   bool on)
 {
 	int ret;
 
@@ -3627,7 +3722,8 @@ int atomisp_s_sensor_power(struct atomisp_device *isp, unsigned int input, bool
 
 	ret = v4l2_subdev_call(isp->inputs[input].sensor, core, s_power, on);
 	if (ret && ret != -ENOIOCTLCMD) {
-		dev_err(isp->dev, "Error setting sensor power %d: %d\n", on, ret);
+		dev_err(isp->dev, "Error setting sensor power %d: %d\n", on,
+			ret);
 		return ret;
 	}
 
@@ -3667,10 +3763,12 @@ void atomisp_setup_input_links(struct atomisp_device *isp)
 
 	for (int i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
 		link = media_entity_find_link(
-				&isp->csi2_port[i].subdev.entity.pads[CSI2_PAD_SOURCE],
-				&isp->asd.subdev.entity.pads[ATOMISP_SUBDEV_PAD_SINK]);
+			&isp->csi2_port[i].subdev.entity.pads[CSI2_PAD_SOURCE],
+			&isp->asd.subdev.entity.pads[ATOMISP_SUBDEV_PAD_SINK]);
 		if (!link) {
-			dev_err(isp->dev, "Error cannot find CSI2-port[%d] -> ISP link\n", i);
+			dev_err(isp->dev,
+				"Error cannot find CSI2-port[%d] -> ISP link\n",
+				i);
 			continue; /* Should never happen */
 		}
 
@@ -3679,7 +3777,8 @@ void atomisp_setup_input_links(struct atomisp_device *isp)
 		 * will end up calling atomisp_link_setup() which calls this
 		 * function again leading to endless recursion.
 		 */
-		if (isp->sensor_subdevs[i] == isp->inputs[isp->asd.input_curr].csi_remote_source)
+		if (isp->sensor_subdevs[i] ==
+		    isp->inputs[isp->asd.input_curr].csi_remote_source)
 			link->flags |= MEDIA_LNK_FL_ENABLED;
 		else
 			link->flags &= ~MEDIA_LNK_FL_ENABLED;
@@ -3720,8 +3819,9 @@ static int atomisp_set_sensor_crop_and_fmt(struct atomisp_device *isp,
 			return ret;
 	}
 
-	sd_state = (which == V4L2_SUBDEV_FORMAT_TRY) ? input->try_sd_state :
-						       input->sensor->active_state;
+	sd_state = (which == V4L2_SUBDEV_FORMAT_TRY) ?
+			   input->try_sd_state :
+			   input->sensor->active_state;
 	if (sd_state)
 		v4l2_subdev_lock_state(sd_state);
 
@@ -3729,8 +3829,9 @@ static int atomisp_set_sensor_crop_and_fmt(struct atomisp_device *isp,
 		goto set_fmt;
 
 	/* Cropping is done before binning, when binning double the crop rect */
-	if (input->binning_support && sel.r.width <= (input->native_rect.width / 2) &&
-				      sel.r.height <= (input->native_rect.height / 2)) {
+	if (input->binning_support &&
+	    sel.r.width <= (input->native_rect.width / 2) &&
+	    sel.r.height <= (input->native_rect.height / 2)) {
 		sel.r.width *= 2;
 		sel.r.height *= 2;
 	}
@@ -3742,34 +3843,42 @@ static int atomisp_set_sensor_crop_and_fmt(struct atomisp_device *isp,
 	sel.r.left = ((input->native_rect.width - sel.r.width) / 2) & ~1;
 	sel.r.top = ((input->native_rect.height - sel.r.height) / 2) & ~1;
 
-	ret = v4l2_subdev_call(input->sensor, pad, set_selection, sd_state, &sel);
+	ret = v4l2_subdev_call(input->sensor, pad, set_selection, sd_state,
+			       &sel);
 	if (ret)
 		dev_err(isp->dev, "Error setting crop to (%d,%d)/%ux%u: %d\n",
 			sel.r.left, sel.r.top, sel.r.width, sel.r.height, ret);
 
 set_fmt:
 	if (ret == 0) {
-		ret = v4l2_subdev_call(input->sensor, pad, set_fmt, sd_state, &format);
-		dev_dbg(isp->dev, "Set sensor format ret: %d size %dx%d\n",
-			ret, format.format.width, format.format.height);
+		ret = v4l2_subdev_call(input->sensor, pad, set_fmt, sd_state,
+				       &format);
+		dev_dbg(isp->dev, "Set sensor format ret: %d size %dx%d\n", ret,
+			format.format.width, format.format.height);
 	}
 
 	if (sd_state)
 		v4l2_subdev_unlock_state(sd_state);
 
 	/* Propagate new fmt to sensor ISP */
-	if (ret == 0 && which == V4L2_SUBDEV_FORMAT_ACTIVE && input->sensor_isp) {
-		sd_state = v4l2_subdev_lock_and_get_active_state(input->sensor_isp);
+	if (ret == 0 && which == V4L2_SUBDEV_FORMAT_ACTIVE &&
+	    input->sensor_isp) {
+		sd_state = v4l2_subdev_lock_and_get_active_state(
+			input->sensor_isp);
 
 		format.pad = SENSOR_ISP_PAD_SINK;
-		ret = v4l2_subdev_call(input->sensor_isp, pad, set_fmt, sd_state, &format);
-		dev_dbg(isp->dev, "Set sensor ISP sink format ret: %d size %dx%d\n",
-			ret, format.format.width, format.format.height);
+		ret = v4l2_subdev_call(input->sensor_isp, pad, set_fmt,
+				       sd_state, &format);
+		dev_dbg(isp->dev,
+			"Set sensor ISP sink format ret: %d size %dx%d\n", ret,
+			format.format.width, format.format.height);
 
 		if (ret == 0) {
 			format.pad = SENSOR_ISP_PAD_SOURCE;
-			ret = v4l2_subdev_call(input->sensor_isp, pad, set_fmt, sd_state, &format);
-			dev_dbg(isp->dev, "Set sensor ISP source format ret: %d size %dx%d\n",
+			ret = v4l2_subdev_call(input->sensor_isp, pad, set_fmt,
+					       sd_state, &format);
+			dev_dbg(isp->dev,
+				"Set sensor ISP source format ret: %d size %dx%d\n",
 				ret, format.format.width, format.format.height);
 		}
 
@@ -3780,7 +3889,8 @@ static int atomisp_set_sensor_crop_and_fmt(struct atomisp_device *isp,
 	/* Propagate new fmt to CSI port */
 	if (ret == 0 && which == V4L2_SUBDEV_FORMAT_ACTIVE) {
 		format.pad = CSI2_PAD_SINK;
-		ret = v4l2_subdev_call(input->csi_port, pad, set_fmt, NULL, &format);
+		ret = v4l2_subdev_call(input->csi_port, pad, set_fmt, NULL,
+				       &format);
 		if (ret)
 			return ret;
 	}
@@ -3796,7 +3906,7 @@ int atomisp_try_fmt(struct atomisp_device *isp, struct v4l2_pix_format *f,
 {
 	const struct atomisp_format_bridge *fmt, *snr_fmt;
 	struct atomisp_sub_device *asd = &isp->asd;
-	struct v4l2_mbus_framefmt ffmt = { };
+	struct v4l2_mbus_framefmt ffmt = {};
 	u32 padding_w, padding_h;
 	int ret;
 
@@ -3831,7 +3941,8 @@ int atomisp_try_fmt(struct atomisp_device *isp, struct v4l2_pix_format *f,
 
 	dev_dbg(isp->dev, "try_mbus_fmt: try %ux%u\n", ffmt.width, ffmt.height);
 
-	ret = atomisp_set_sensor_crop_and_fmt(isp, &ffmt, V4L2_SUBDEV_FORMAT_TRY);
+	ret = atomisp_set_sensor_crop_and_fmt(isp, &ffmt,
+					      V4L2_SUBDEV_FORMAT_TRY);
 	if (ret)
 		return ret;
 
@@ -3839,8 +3950,7 @@ int atomisp_try_fmt(struct atomisp_device *isp, struct v4l2_pix_format *f,
 
 	snr_fmt = atomisp_get_format_bridge_from_mbus(ffmt.code);
 	if (!snr_fmt) {
-		dev_err(isp->dev, "unknown sensor format 0x%8.8x\n",
-			ffmt.code);
+		dev_err(isp->dev, "unknown sensor format 0x%8.8x\n", ffmt.code);
 		return -EINVAL;
 	}
 
@@ -3859,9 +3969,11 @@ int atomisp_try_fmt(struct atomisp_device *isp, struct v4l2_pix_format *f,
 
 	/* app vs isp */
 	f->width = rounddown(clamp_t(u32, f->width, ATOM_ISP_MIN_WIDTH,
-				     ATOM_ISP_MAX_WIDTH), ATOM_ISP_STEP_WIDTH);
+				     ATOM_ISP_MAX_WIDTH),
+			     ATOM_ISP_STEP_WIDTH);
 	f->height = rounddown(clamp_t(u32, f->height, ATOM_ISP_MIN_HEIGHT,
-				      ATOM_ISP_MAX_HEIGHT), ATOM_ISP_STEP_HEIGHT);
+				      ATOM_ISP_MAX_HEIGHT),
+			      ATOM_ISP_STEP_HEIGHT);
 
 out_fill_pix_format:
 	atomisp_fill_pix_format(f, f->width, f->height, fmt);
@@ -3891,10 +4003,10 @@ enum mipi_port_id atomisp_port_to_mipi_port(struct atomisp_device *isp,
 	}
 }
 
-static inline int atomisp_set_sensor_mipi_to_isp(
-    struct atomisp_sub_device *asd,
-    enum atomisp_input_stream_id stream_id,
-    struct camera_mipi_info *mipi_info)
+static inline int
+atomisp_set_sensor_mipi_to_isp(struct atomisp_sub_device *asd,
+			       enum atomisp_input_stream_id stream_id,
+			       struct camera_mipi_info *mipi_info)
 {
 	struct v4l2_control ctrl;
 	struct atomisp_device *isp = asd->isp;
@@ -3902,7 +4014,8 @@ static inline int atomisp_set_sensor_mipi_to_isp(
 	const struct atomisp_in_fmt_conv *fc;
 	int mipi_freq = 0;
 	unsigned int input_format, bayer_order;
-	enum atomisp_input_format metadata_format = ATOMISP_INPUT_FORMAT_EMBEDDED;
+	enum atomisp_input_format metadata_format =
+		ATOMISP_INPUT_FORMAT_EMBEDDED;
 	u32 mipi_port, metadata_width = 0, metadata_height = 0;
 
 	ctrl.id = V4L2_CID_LINK_FREQ;
@@ -3911,21 +4024,22 @@ static inline int atomisp_set_sensor_mipi_to_isp(
 
 	if (asd->stream_env[stream_id].isys_configs == 1) {
 		input_format =
-		    asd->stream_env[stream_id].isys_info[0].input_format;
-		atomisp_css_isys_set_format(asd, stream_id,
-					    input_format, IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX);
+			asd->stream_env[stream_id].isys_info[0].input_format;
+		atomisp_css_isys_set_format(
+			asd, stream_id, input_format,
+			IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX);
 	} else if (asd->stream_env[stream_id].isys_configs == 2) {
 		atomisp_css_isys_two_stream_cfg_update_stream1(
-		    asd, stream_id,
-		    asd->stream_env[stream_id].isys_info[0].input_format,
-		    asd->stream_env[stream_id].isys_info[0].width,
-		    asd->stream_env[stream_id].isys_info[0].height);
+			asd, stream_id,
+			asd->stream_env[stream_id].isys_info[0].input_format,
+			asd->stream_env[stream_id].isys_info[0].width,
+			asd->stream_env[stream_id].isys_info[0].height);
 
 		atomisp_css_isys_two_stream_cfg_update_stream2(
-		    asd, stream_id,
-		    asd->stream_env[stream_id].isys_info[1].input_format,
-		    asd->stream_env[stream_id].isys_info[1].width,
-		    asd->stream_env[stream_id].isys_info[1].height);
+			asd, stream_id,
+			asd->stream_env[stream_id].isys_info[1].input_format,
+			asd->stream_env[stream_id].isys_info[1].width,
+			asd->stream_env[stream_id].isys_info[1].height);
 	}
 
 	/* Compatibility for sensors which provide no media bus code
@@ -3936,7 +4050,7 @@ static inline int atomisp_set_sensor_mipi_to_isp(
 		/* Input stream config is still needs configured */
 		/* TODO: Check if this is necessary */
 		fc = atomisp_find_in_fmt_conv_by_atomisp_in_fmt(
-			 mipi_info->input_format);
+			mipi_info->input_format);
 		if (!fc)
 			return -EINVAL;
 		input_format = fc->atomisp_in_fmt;
@@ -3966,9 +4080,8 @@ static inline int atomisp_set_sensor_mipi_to_isp(
 	input_format = fc->atomisp_in_fmt;
 	mipi_port = atomisp_port_to_mipi_port(isp, input->port);
 	atomisp_css_input_configure_port(asd, mipi_port,
-					 isp->sensor_lanes[mipi_port],
-					 0xffff4, mipi_freq,
-					 input_format,
+					 isp->sensor_lanes[mipi_port], 0xffff4,
+					 mipi_freq, input_format,
 					 metadata_width, metadata_height);
 	return 0;
 }
@@ -4046,24 +4159,24 @@ static int atomisp_set_fmt_to_isp(struct video_device *vdev,
 	const struct atomisp_format_bridge *format;
 	struct v4l2_rect *isp_sink_crop;
 	enum ia_css_pipe_id pipe_id;
-	int (*configure_output)(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum ia_css_frame_format sh_fmt) =
-				    configure_output_nop;
+	int (*configure_output)(
+		struct atomisp_sub_device *asd, unsigned int width,
+		unsigned int height, unsigned int min_width,
+		enum ia_css_frame_format sh_fmt) = configure_output_nop;
 	int (*get_frame_info)(struct atomisp_sub_device *asd,
 			      struct ia_css_frame_info *finfo) =
-				  get_frame_info_nop;
+		get_frame_info_nop;
 	int (*configure_pp_input)(struct atomisp_sub_device *asd,
-				  unsigned int width, unsigned int height) =
-				      configure_pp_input_nop;
+				  unsigned int width,
+				  unsigned int height) = configure_pp_input_nop;
 	const struct atomisp_in_fmt_conv *fc = NULL;
 	struct v4l2_mbus_framefmt *ffmt;
 	int ret, i;
 
-	isp_sink_crop = atomisp_subdev_get_rect(
-			    &asd->subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,
-			    ATOMISP_SUBDEV_PAD_SINK, V4L2_SEL_TGT_CROP);
+	isp_sink_crop = atomisp_subdev_get_rect(&asd->subdev, NULL,
+						V4L2_SUBDEV_FORMAT_ACTIVE,
+						ATOMISP_SUBDEV_PAD_SINK,
+						V4L2_SEL_TGT_CROP);
 
 	format = atomisp_get_format_bridge(pix->pixelformat);
 	if (!format)
@@ -4076,7 +4189,8 @@ static int atomisp_set_fmt_to_isp(struct video_device *vdev,
 		return -EINVAL;
 
 	if (mipi_info)
-		fc = atomisp_find_in_fmt_conv_by_atomisp_in_fmt(mipi_info->input_format);
+		fc = atomisp_find_in_fmt_conv_by_atomisp_in_fmt(
+			mipi_info->input_format);
 	if (!fc) {
 		ffmt = atomisp_subdev_get_ffmt(&asd->subdev, NULL,
 					       V4L2_SUBDEV_FORMAT_ACTIVE,
@@ -4107,24 +4221,30 @@ static int atomisp_set_fmt_to_isp(struct video_device *vdev,
 
 		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||
 		    asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {
-			atomisp_css_video_configure_viewfinder(asd, width, height, 0,
-							       IA_CSS_FRAME_FORMAT_NV12);
-		} else if (asd->run_mode->val == ATOMISP_RUN_MODE_STILL_CAPTURE ||
+			atomisp_css_video_configure_viewfinder(
+				asd, width, height, 0,
+				IA_CSS_FRAME_FORMAT_NV12);
+		} else if (asd->run_mode->val ==
+				   ATOMISP_RUN_MODE_STILL_CAPTURE ||
 			   asd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {
-			atomisp_css_capture_configure_viewfinder(asd, width, height, 0,
-								 IA_CSS_FRAME_FORMAT_NV12);
+			atomisp_css_capture_configure_viewfinder(
+				asd, width, height, 0,
+				IA_CSS_FRAME_FORMAT_NV12);
 		}
 	}
 
 	atomisp_css_input_set_mode(asd, IA_CSS_INPUT_MODE_BUFFERED_SENSOR);
 
 	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].pipe_extra_configs[i].disable_vf_pp = asd->vfpp->val != ATOMISP_VFPP_ENABLE;
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
+			.pipe_extra_configs[i]
+			.disable_vf_pp = asd->vfpp->val != ATOMISP_VFPP_ENABLE;
 
 	/* ISP2401 new input system need to use copy pipe */
 	if (asd->copy_mode) {
 		pipe_id = IA_CSS_PIPE_ID_COPY;
-		atomisp_css_capture_enable_online(asd, ATOMISP_INPUT_STREAM_GENERAL, false);
+		atomisp_css_capture_enable_online(
+			asd, ATOMISP_INPUT_STREAM_GENERAL, false);
 	} else if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {
 		/* video same in continuouscapture and online modes */
 		configure_output = atomisp_css_video_configure_output;
@@ -4141,14 +4261,16 @@ static int atomisp_set_fmt_to_isp(struct video_device *vdev,
 		pipe_id = IA_CSS_PIPE_ID_PREVIEW;
 	} else {
 		if (format->sh_fmt == IA_CSS_FRAME_FORMAT_RAW) {
-			atomisp_css_capture_set_mode(asd, IA_CSS_CAPTURE_MODE_RAW);
+			atomisp_css_capture_set_mode(asd,
+						     IA_CSS_CAPTURE_MODE_RAW);
 			atomisp_css_enable_dz(asd, false);
 		} else {
 			atomisp_update_capture_mode(asd);
 		}
 
 		/* in case of ANR, force capture pipe to offline mode */
-		atomisp_css_capture_enable_online(asd, ATOMISP_INPUT_STREAM_GENERAL,
+		atomisp_css_capture_enable_online(asd,
+						  ATOMISP_INPUT_STREAM_GENERAL,
 						  !asd->params.low_light);
 
 		configure_output = atomisp_css_capture_configure_output;
@@ -4164,15 +4286,17 @@ static int atomisp_set_fmt_to_isp(struct video_device *vdev,
 	}
 
 	if (asd->copy_mode)
-		ret = atomisp_css_copy_configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL,
-							pix->width, pix->height,
-							format->planar ? pix->bytesperline :
-							pix->bytesperline * 8 / format->depth,
-							format->sh_fmt);
+		ret = atomisp_css_copy_configure_output(
+			asd, ATOMISP_INPUT_STREAM_GENERAL, pix->width,
+			pix->height,
+			format->planar ? pix->bytesperline :
+					 pix->bytesperline * 8 / format->depth,
+			format->sh_fmt);
 	else
 		ret = configure_output(asd, pix->width, pix->height,
 				       format->planar ? pix->bytesperline :
-				       pix->bytesperline * 8 / format->depth,
+							pix->bytesperline * 8 /
+								format->depth,
 				       format->sh_fmt);
 	if (ret) {
 		dev_err(isp->dev, "configure_output %ux%u, format %8.8x\n",
@@ -4180,21 +4304,21 @@ static int atomisp_set_fmt_to_isp(struct video_device *vdev,
 		return -EINVAL;
 	}
 
-	ret = configure_pp_input(asd, isp_sink_crop->width, isp_sink_crop->height);
+	ret = configure_pp_input(asd, isp_sink_crop->width,
+				 isp_sink_crop->height);
 	if (ret) {
 		dev_err(isp->dev, "configure_pp_input %ux%u\n",
-			isp_sink_crop->width,
-			isp_sink_crop->height);
+			isp_sink_crop->width, isp_sink_crop->height);
 		return -EINVAL;
 	}
 	if (asd->copy_mode)
-		ret = atomisp_css_copy_get_output_frame_info(asd,
-							     ATOMISP_INPUT_STREAM_GENERAL,
-							     output_info);
+		ret = atomisp_css_copy_get_output_frame_info(
+			asd, ATOMISP_INPUT_STREAM_GENERAL, output_info);
 	else
 		ret = get_frame_info(asd, output_info);
 	if (ret) {
-		dev_err(isp->dev, "__get_frame_info %ux%u (padded to %u) returned %d\n",
+		dev_err(isp->dev,
+			"__get_frame_info %ux%u (padded to %u) returned %d\n",
 			pix->width, pix->height, pix->bytesperline, ret);
 		return ret;
 	}
@@ -4205,7 +4329,8 @@ static int atomisp_set_fmt_to_isp(struct video_device *vdev,
 
 static void atomisp_get_dis_envelop(struct atomisp_sub_device *asd,
 				    unsigned int width, unsigned int height,
-				    unsigned int *dvs_env_w, unsigned int *dvs_env_h)
+				    unsigned int *dvs_env_w,
+				    unsigned int *dvs_env_h)
 {
 	if (asd->params.video_dis_en &&
 	    asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
@@ -4234,11 +4359,14 @@ static void atomisp_check_copy_mode(struct atomisp_sub_device *asd,
 	}
 
 	sink = atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-				       V4L2_SUBDEV_FORMAT_ACTIVE, ATOMISP_SUBDEV_PAD_SINK);
+				       V4L2_SUBDEV_FORMAT_ACTIVE,
+				       ATOMISP_SUBDEV_PAD_SINK);
 	src = atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-				      V4L2_SUBDEV_FORMAT_ACTIVE, ATOMISP_SUBDEV_PAD_SOURCE);
+				      V4L2_SUBDEV_FORMAT_ACTIVE,
+				      ATOMISP_SUBDEV_PAD_SOURCE);
 
-	if (sink->code == src->code && sink->width == f->width && sink->height == f->height)
+	if (sink->code == src->code && sink->width == f->width &&
+	    sink->height == f->height)
 		asd->copy_mode = true;
 	else
 		asd->copy_mode = false;
@@ -4246,16 +4374,18 @@ static void atomisp_check_copy_mode(struct atomisp_sub_device *asd,
 	dev_dbg(asd->isp->dev, "copy_mode: %d\n", asd->copy_mode);
 }
 
-static int atomisp_set_fmt_to_snr(struct video_device *vdev, const struct v4l2_pix_format *f,
-				  unsigned int dvs_env_w, unsigned int dvs_env_h)
+static int atomisp_set_fmt_to_snr(struct video_device *vdev,
+				  const struct v4l2_pix_format *f,
+				  unsigned int dvs_env_w,
+				  unsigned int dvs_env_h)
 {
 	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
 	struct atomisp_sub_device *asd = pipe->asd;
 	struct atomisp_device *isp = asd->isp;
 	const struct atomisp_format_bridge *format;
-	struct v4l2_mbus_framefmt req_ffmt, ffmt = { };
+	struct v4l2_mbus_framefmt req_ffmt, ffmt = {};
 	struct atomisp_input_stream_info *stream_info =
-	    (struct atomisp_input_stream_info *)&ffmt.reserved;
+		(struct atomisp_input_stream_info *)&ffmt.reserved;
 	int ret;
 
 	format = atomisp_get_format_bridge(f->pixelformat);
@@ -4267,16 +4397,18 @@ static int atomisp_set_fmt_to_snr(struct video_device *vdev, const struct v4l2_p
 	ffmt.width += asd->sink_pad_padding_w + dvs_env_w;
 
 	dev_dbg(isp->dev, "s_mbus_fmt: ask %ux%u (padding %ux%u, dvs %ux%u)\n",
-		ffmt.width, ffmt.height, asd->sink_pad_padding_w, asd->sink_pad_padding_h,
-		dvs_env_w, dvs_env_h);
+		ffmt.width, ffmt.height, asd->sink_pad_padding_w,
+		asd->sink_pad_padding_h, dvs_env_w, dvs_env_h);
 
 	__atomisp_init_stream_info(ATOMISP_INPUT_STREAM_GENERAL, stream_info);
 
 	req_ffmt = ffmt;
 
 	/* Disable dvs if resolution can't be supported by sensor */
-	if (asd->params.video_dis_en && asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
-		ret = atomisp_set_sensor_crop_and_fmt(isp, &ffmt, V4L2_SUBDEV_FORMAT_TRY);
+	if (asd->params.video_dis_en &&
+	    asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+		ret = atomisp_set_sensor_crop_and_fmt(isp, &ffmt,
+						      V4L2_SUBDEV_FORMAT_TRY);
 		if (ret)
 			return ret;
 
@@ -4288,34 +4420,37 @@ static int atomisp_set_fmt_to_snr(struct video_device *vdev, const struct v4l2_p
 			req_ffmt.height -= dvs_env_h;
 			req_ffmt.width -= dvs_env_w;
 			ffmt = req_ffmt;
-			dev_warn(isp->dev,
-				 "can not enable video dis due to sensor limitation.");
+			dev_warn(
+				isp->dev,
+				"can not enable video dis due to sensor limitation.");
 			asd->params.video_dis_en = false;
 		}
 	}
 
-	ret = atomisp_set_sensor_crop_and_fmt(isp, &ffmt, V4L2_SUBDEV_FORMAT_ACTIVE);
+	ret = atomisp_set_sensor_crop_and_fmt(isp, &ffmt,
+					      V4L2_SUBDEV_FORMAT_ACTIVE);
 	if (ret)
 		return ret;
 
-	__atomisp_update_stream_env(asd, ATOMISP_INPUT_STREAM_GENERAL, stream_info);
+	__atomisp_update_stream_env(asd, ATOMISP_INPUT_STREAM_GENERAL,
+				    stream_info);
 
-	dev_dbg(isp->dev, "sensor width: %d, height: %d\n",
-		ffmt.width, ffmt.height);
+	dev_dbg(isp->dev, "sensor width: %d, height: %d\n", ffmt.width,
+		ffmt.height);
 
 	if (ffmt.width < ATOM_ISP_STEP_WIDTH ||
 	    ffmt.height < ATOM_ISP_STEP_HEIGHT)
 		return -EINVAL;
 
-	if (asd->params.video_dis_en && asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&
+	if (asd->params.video_dis_en &&
+	    asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&
 	    (ffmt.width < req_ffmt.width || ffmt.height < req_ffmt.height)) {
 		dev_warn(isp->dev,
 			 "can not enable video dis due to sensor limitation.");
 		asd->params.video_dis_en = false;
 	}
 
-	atomisp_subdev_set_ffmt(&asd->subdev, NULL,
-				V4L2_SUBDEV_FORMAT_ACTIVE,
+	atomisp_subdev_set_ffmt(&asd->subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,
 				ATOMISP_SUBDEV_PAD_SINK, &ffmt);
 
 	return css_input_resolution_changed(asd, &ffmt);
@@ -4330,7 +4465,7 @@ int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)
 	const struct atomisp_format_bridge *snr_format_bridge;
 	struct ia_css_frame_info output_info;
 	unsigned int dvs_env_w = 0, dvs_env_h = 0;
-	struct v4l2_mbus_framefmt isp_source_fmt = {0};
+	struct v4l2_mbus_framefmt isp_source_fmt = { 0 };
 	struct v4l2_rect isp_sink_crop;
 	int ret;
 
@@ -4338,31 +4473,30 @@ int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)
 	if (ret)
 		return ret;
 
-	dev_dbg(isp->dev,
-		"setting resolution %ux%u bytesperline %u\n",
+	dev_dbg(isp->dev, "setting resolution %ux%u bytesperline %u\n",
 		f->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.bytesperline);
 
 	/* Ensure that the resolution is equal or below the maximum supported */
-	ret = atomisp_try_fmt(isp, &f->fmt.pix, &format_bridge, &snr_format_bridge);
+	ret = atomisp_try_fmt(isp, &f->fmt.pix, &format_bridge,
+			      &snr_format_bridge);
 	if (ret)
 		return ret;
 
 	pipe->sh_fmt = format_bridge->sh_fmt;
 	pipe->pix.pixelformat = format_bridge->pixelformat;
 
-	atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-				V4L2_SUBDEV_FORMAT_ACTIVE,
-				ATOMISP_SUBDEV_PAD_SINK)->code =
-				    snr_format_bridge->mbus_code;
+	atomisp_subdev_get_ffmt(&asd->subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SINK)
+		->code = snr_format_bridge->mbus_code;
 
 	isp_source_fmt.code = format_bridge->mbus_code;
-	atomisp_subdev_set_ffmt(&asd->subdev, NULL,
-				V4L2_SUBDEV_FORMAT_ACTIVE,
+	atomisp_subdev_set_ffmt(&asd->subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,
 				ATOMISP_SUBDEV_PAD_SOURCE, &isp_source_fmt);
 
 	if (atomisp_subdev_format_conversion(asd)) {
 		atomisp_get_padding(isp, f->fmt.pix.width, f->fmt.pix.height,
-				    &asd->sink_pad_padding_w, &asd->sink_pad_padding_h);
+				    &asd->sink_pad_padding_w,
+				    &asd->sink_pad_padding_h);
 	} else {
 		asd->sink_pad_padding_w = 0;
 		asd->sink_pad_padding_h = 0;
@@ -4373,8 +4507,8 @@ int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)
 
 	ret = atomisp_set_fmt_to_snr(vdev, &f->fmt.pix, dvs_env_w, dvs_env_h);
 	if (ret) {
-		dev_warn(isp->dev,
-			 "Set format to sensor failed with %d\n", ret);
+		dev_warn(isp->dev, "Set format to sensor failed with %d\n",
+			 ret);
 		return -EINVAL;
 	}
 
@@ -4383,14 +4517,13 @@ int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)
 	atomisp_check_copy_mode(asd, &f->fmt.pix);
 
 	isp_sink_crop = *atomisp_subdev_get_rect(&asd->subdev, NULL,
-			V4L2_SUBDEV_FORMAT_ACTIVE,
-			ATOMISP_SUBDEV_PAD_SINK,
-			V4L2_SEL_TGT_CROP);
+						 V4L2_SUBDEV_FORMAT_ACTIVE,
+						 ATOMISP_SUBDEV_PAD_SINK,
+						 V4L2_SEL_TGT_CROP);
 
 	/* Try to enable YUV downscaling if ISP input is 10 % (either
 	 * width or height) bigger than the desired result. */
-	if (!IS_MOFD ||
-	    isp_sink_crop.width * 9 / 10 < f->fmt.pix.width ||
+	if (!IS_MOFD || isp_sink_crop.width * 9 / 10 < f->fmt.pix.width ||
 	    isp_sink_crop.height * 9 / 10 < f->fmt.pix.height ||
 	    (atomisp_subdev_format_conversion(asd) &&
 	     (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||
@@ -4400,21 +4533,21 @@ int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)
 
 		atomisp_subdev_set_selection(&asd->subdev, NULL,
 					     V4L2_SUBDEV_FORMAT_ACTIVE,
-					     ATOMISP_SUBDEV_PAD_SOURCE, V4L2_SEL_TGT_COMPOSE,
-					     0, &isp_sink_crop);
+					     ATOMISP_SUBDEV_PAD_SOURCE,
+					     V4L2_SEL_TGT_COMPOSE, 0,
+					     &isp_sink_crop);
 	} else {
-		struct v4l2_rect main_compose = {0};
+		struct v4l2_rect main_compose = { 0 };
 
 		main_compose.width = isp_sink_crop.width;
 		main_compose.height =
-		    DIV_ROUND_UP(main_compose.width * f->fmt.pix.height,
-				 f->fmt.pix.width);
+			DIV_ROUND_UP(main_compose.width * f->fmt.pix.height,
+				     f->fmt.pix.width);
 		if (main_compose.height > isp_sink_crop.height) {
 			main_compose.height = isp_sink_crop.height;
-			main_compose.width =
-			    DIV_ROUND_UP(main_compose.height *
-					 f->fmt.pix.width,
-					 f->fmt.pix.height);
+			main_compose.width = DIV_ROUND_UP(
+				main_compose.height * f->fmt.pix.width,
+				f->fmt.pix.height);
 		}
 
 		atomisp_subdev_set_selection(&asd->subdev, NULL,
@@ -4430,13 +4563,13 @@ int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)
 		return -EINVAL;
 	}
 
-	atomisp_fill_pix_format(&pipe->pix, f->fmt.pix.width, f->fmt.pix.height, format_bridge);
+	atomisp_fill_pix_format(&pipe->pix, f->fmt.pix.width, f->fmt.pix.height,
+				format_bridge);
 
 	f->fmt.pix = pipe->pix;
 
 	dev_dbg(isp->dev, "%s: %dx%d, image size: %d, %d bytes per line\n",
-		__func__,
-		f->fmt.pix.width, f->fmt.pix.height,
+		__func__, f->fmt.pix.width, f->fmt.pix.height,
 		f->fmt.pix.sizeimage, f->fmt.pix.bytesperline);
 
 	return 0;
@@ -4472,7 +4605,7 @@ int atomisp_set_shading_table(struct atomisp_sub_device *asd,
 		return -EINVAL;
 
 	shading_table = atomisp_css_shading_table_alloc(
-			    user_shading_table->width, user_shading_table->height);
+		user_shading_table->width, user_shading_table->height);
 	if (!shading_table)
 		return -ENOMEM;
 
@@ -4509,7 +4642,8 @@ static int __checking_exp_id(struct atomisp_sub_device *asd, int exp_id)
 	struct atomisp_device *isp = asd->isp;
 
 	if (!asd->enable_raw_buffer_lock->val) {
-		dev_warn(isp->dev, "%s Raw Buffer Lock is disable.\n", __func__);
+		dev_warn(isp->dev, "%s Raw Buffer Lock is disable.\n",
+			 __func__);
 		return -EINVAL;
 	}
 	if (!asd->streaming) {
@@ -4581,7 +4715,8 @@ int atomisp_exp_id_capture(struct atomisp_sub_device *asd, int *exp_id)
 
 	ret = __is_raw_buffer_locked(asd, value);
 	if (ret) {
-		dev_err(isp->dev, "%s exp_id %d invalid %d.\n", __func__, value, ret);
+		dev_err(isp->dev, "%s exp_id %d invalid %d.\n", __func__, value,
+			ret);
 		return -EINVAL;
 	}
 
@@ -4604,15 +4739,16 @@ int atomisp_exp_id_unlock(struct atomisp_sub_device *asd, int *exp_id)
 
 	ret = __clear_raw_buffer_bitmap(asd, value);
 	if (ret) {
-		dev_err(isp->dev, "%s exp_id %d invalid %d.\n", __func__, value, ret);
+		dev_err(isp->dev, "%s exp_id %d invalid %d.\n", __func__, value,
+			ret);
 		return -EINVAL;
 	}
 
 	dev_dbg(isp->dev, "%s exp_id %d\n", __func__, value);
 	ret = atomisp_css_exp_id_unlock(asd, value);
 	if (ret)
-		dev_err(isp->dev, "%s exp_id %d failed, err %d.\n",
-			__func__, value, ret);
+		dev_err(isp->dev, "%s exp_id %d failed, err %d.\n", __func__,
+			value, ret);
 
 	return ret;
 }
diff --git a/drivers/staging/media/atomisp/pci/atomisp_cmd.h b/drivers/staging/media/atomisp/pci/atomisp_cmd.h
index 82199dc9284e9f8cbef05d6ef338205543335e52..8e6b56b1a43b4117677108b0900bbbafbfd3b6cd 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_cmd.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_cmd.h
@@ -7,8 +7,8 @@
  * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  */
 
-#ifndef	__ATOMISP_CMD_H__
-#define	__ATOMISP_CMD_H__
+#ifndef __ATOMISP_CMD_H__
+#define __ATOMISP_CMD_H__
 
 #include "../../include/linux/atomisp.h"
 #include <linux/interrupt.h>
@@ -24,12 +24,12 @@
 struct atomisp_device;
 struct ia_css_frame;
 
-#define MSI_ENABLE_BIT		16
-#define INTR_DISABLE_BIT	10
-#define BUS_MASTER_ENABLE	2
-#define MEMORY_SPACE_ENABLE	1
-#define INTR_IER		24
-#define INTR_IIR		16
+#define MSI_ENABLE_BIT 16
+#define INTR_DISABLE_BIT 10
+#define BUS_MASTER_ENABLE 2
+#define MEMORY_SPACE_ENABLE 1
+#define INTR_IER 24
+#define INTR_IIR 16
 
 /* Helper function */
 void dump_sp_dmem(struct atomisp_device *isp, unsigned int addr,
@@ -38,8 +38,10 @@ struct camera_mipi_info *atomisp_to_sensor_mipi_info(struct v4l2_subdev *sd);
 struct atomisp_video_pipe *atomisp_to_video_pipe(struct video_device *dev);
 int atomisp_reset(struct atomisp_device *isp);
 int atomisp_buffers_in_css(struct atomisp_video_pipe *pipe);
-void atomisp_buffer_done(struct ia_css_frame *frame, enum vb2_buffer_state state);
-void atomisp_flush_video_pipe(struct atomisp_video_pipe *pipe, enum vb2_buffer_state state,
+void atomisp_buffer_done(struct ia_css_frame *frame,
+			 enum vb2_buffer_state state);
+void atomisp_flush_video_pipe(struct atomisp_video_pipe *pipe,
+			      enum vb2_buffer_state state,
 			      bool warn_on_css_frames);
 void atomisp_clear_css_buffer_counters(struct atomisp_sub_device *asd);
 
@@ -49,8 +51,8 @@ void atomisp_msi_irq_uninit(struct atomisp_device *isp);
 void atomisp_assert_recovery_work(struct work_struct *work);
 irqreturn_t atomisp_isr(int irq, void *dev);
 irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr);
-const struct atomisp_format_bridge *get_atomisp_format_bridge_from_mbus(
-    u32 mbus_code);
+const struct atomisp_format_bridge *
+get_atomisp_format_bridge_from_mbus(u32 mbus_code);
 bool atomisp_is_mbuscode_raw(uint32_t code);
 
 /* Get internal fmt according to V4L2 fmt */
@@ -62,12 +64,10 @@ bool atomisp_is_viewfinder_support(struct atomisp_device *isp);
  * Function to enable/disable lens geometry distortion correction (GDC) and
  * chromatic aberration correction (CAC)
  */
-int atomisp_gdc_cac(struct atomisp_sub_device *asd, int flag,
-		    __s32 *value);
+int atomisp_gdc_cac(struct atomisp_sub_device *asd, int flag, __s32 *value);
 
 /* Function to enable/disable low light mode (including ANR) */
-int atomisp_low_light(struct atomisp_sub_device *asd, int flag,
-		      __s32 *value);
+int atomisp_low_light(struct atomisp_sub_device *asd, int flag, __s32 *value);
 
 /*
  * Function to enable/disable extra noise reduction (XNR) in low light
@@ -146,8 +146,7 @@ int atomisp_color_effect(struct atomisp_sub_device *asd, int flag,
 			 __s32 *effect);
 
 /* Function to configure bad pixel correction */
-int atomisp_bad_pixel(struct atomisp_sub_device *asd, int flag,
-		      __s32 *value);
+int atomisp_bad_pixel(struct atomisp_sub_device *asd, int flag, __s32 *value);
 
 /* Function to configure bad pixel correction params */
 int atomisp_bad_pixel_param(struct atomisp_sub_device *asd, int flag,
@@ -166,8 +165,7 @@ int atomisp_fixed_pattern_table(struct atomisp_sub_device *asd,
 				struct v4l2_framebuffer *config);
 
 /* Function to configure false color correction */
-int atomisp_false_color(struct atomisp_sub_device *asd, int flag,
-			__s32 *value);
+int atomisp_false_color(struct atomisp_sub_device *asd, int flag, __s32 *value);
 
 /* Function to configure false color correction params */
 int atomisp_false_color_param(struct atomisp_sub_device *asd, int flag,
@@ -186,11 +184,11 @@ int atomisp_digital_zoom(struct atomisp_sub_device *asd, int flag,
 
 /* Function  set camera_prefiles.xml current sensor pixel array size */
 int atomisp_set_array_res(struct atomisp_sub_device *asd,
-			  struct atomisp_resolution  *config);
+			  struct atomisp_resolution *config);
 
 /* Function to calculate real zoom region for every pipe */
 int atomisp_calculate_real_zoom_region(struct atomisp_sub_device *asd,
-				       struct ia_css_dz_config   *dz_config,
+				       struct ia_css_dz_config *dz_config,
 				       enum ia_css_pipe_id css_pipe_id);
 
 int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
@@ -200,8 +198,7 @@ int atomisp_cp_general_isp_parameters(struct atomisp_sub_device *asd,
 
 int atomisp_cp_lsc_table(struct atomisp_sub_device *asd,
 			 struct atomisp_shading_table *source_st,
-			 struct atomisp_css_params *css_param,
-			 bool from_user);
+			 struct atomisp_css_params *css_param, bool from_user);
 
 int atomisp_css_cp_dvs2_coefs(struct atomisp_sub_device *asd,
 			      struct ia_css_dvs2_coefficients *coefs,
@@ -213,10 +210,10 @@ int atomisp_cp_morph_table(struct atomisp_sub_device *asd,
 			   struct atomisp_css_params *css_param,
 			   bool from_user);
 
-int atomisp_cp_dvs_6axis_config(struct atomisp_sub_device *asd,
-				struct atomisp_dvs_6axis_config *user_6axis_config,
-				struct atomisp_css_params *css_param,
-				bool from_user);
+int atomisp_cp_dvs_6axis_config(
+	struct atomisp_sub_device *asd,
+	struct atomisp_dvs_6axis_config *user_6axis_config,
+	struct atomisp_css_params *css_param, bool from_user);
 
 int atomisp_makeup_css_parameters(struct atomisp_sub_device *asd,
 				  struct atomisp_parameters *arg,
@@ -230,7 +227,8 @@ void atomisp_get_padding(struct atomisp_device *isp, u32 width, u32 height,
 			 u32 *padding_w, u32 *padding_h);
 
 /* Set sensor power (no-op if already on/off) */
-int atomisp_s_sensor_power(struct atomisp_device *isp, unsigned int input, bool on);
+int atomisp_s_sensor_power(struct atomisp_device *isp, unsigned int input,
+			   bool on);
 
 /* Select which sensor to use, must be called with a valid input */
 int atomisp_select_input(struct atomisp_device *isp, unsigned int input);
@@ -251,13 +249,12 @@ int atomisp_set_shading_table(struct atomisp_sub_device *asd,
 void atomisp_free_internal_buffers(struct atomisp_sub_device *asd);
 
 int atomisp_freq_scaling(struct atomisp_device *vdev,
-			 enum atomisp_dfs_mode mode,
-			 bool force);
+			 enum atomisp_dfs_mode mode, bool force);
 
 void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 		      enum ia_css_buffer_type buf_type,
-		      enum ia_css_pipe_id css_pipe_id,
-		      bool q_buffers, enum atomisp_input_stream_id stream_id);
+		      enum ia_css_pipe_id css_pipe_id, bool q_buffers,
+		      enum atomisp_input_stream_id stream_id);
 
 /* Events. Only one event has to be exported for now. */
 void atomisp_eof_event(struct atomisp_sub_device *asd, uint8_t exp_id);
@@ -265,9 +262,8 @@ void atomisp_eof_event(struct atomisp_sub_device *asd, uint8_t exp_id);
 enum mipi_port_id atomisp_port_to_mipi_port(struct atomisp_device *isp,
 					    enum atomisp_camera_port port);
 
-void atomisp_apply_css_parameters(
-    struct atomisp_sub_device *asd,
-    struct atomisp_css_params *css_param);
+void atomisp_apply_css_parameters(struct atomisp_sub_device *asd,
+				  struct atomisp_css_params *css_param);
 void atomisp_free_css_parameters(struct atomisp_css_params *css_param);
 
 void atomisp_handle_parameter_and_buffer(struct atomisp_video_pipe *pipe);
diff --git a/drivers/staging/media/atomisp/pci/atomisp_common.h b/drivers/staging/media/atomisp/pci/atomisp_common.h
index a2462fc306fb21870d2f3198439f60a23a068410..e485cbac90a09432adab74305d8a8cb2372b8b90 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_common.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_common.h
@@ -7,8 +7,8 @@
  * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  */
 
-#ifndef	__ATOMISP_COMMON_H__
-#define	__ATOMISP_COMMON_H__
+#ifndef __ATOMISP_COMMON_H__
+#define __ATOMISP_COMMON_H__
 
 #include "../../include/linux/atomisp.h"
 
@@ -26,22 +26,22 @@ extern int pad_w;
 extern int pad_h;
 
 /* Minimum padding requirements for ISP2400 (BYT) */
-#define ISP2400_MIN_PAD_W		12
-#define ISP2400_MIN_PAD_H		12
+#define ISP2400_MIN_PAD_W 12
+#define ISP2400_MIN_PAD_H 12
 
-#define CSS_DTRACE_VERBOSITY_LEVEL	5	/* Controls trace verbosity */
-#define CSS_DTRACE_VERBOSITY_TIMEOUT	9	/* Verbosity on ISP timeout */
-#define MRFLD_MAX_ZOOM_FACTOR	1024
+#define CSS_DTRACE_VERBOSITY_LEVEL 5 /* Controls trace verbosity */
+#define CSS_DTRACE_VERBOSITY_TIMEOUT 9 /* Verbosity on ISP timeout */
+#define MRFLD_MAX_ZOOM_FACTOR 1024
 
 /* ISP2401 */
-#define ATOMISP_CSS_ISP_PIPE_VERSION_2_7    1
+#define ATOMISP_CSS_ISP_PIPE_VERSION_2_7 1
 
 struct atomisp_format_bridge {
 	unsigned int pixelformat;
 	unsigned int depth;
 	u32 mbus_code;
 	enum ia_css_frame_format sh_fmt;
-	unsigned char description[32];	/* the same as struct v4l2_fmtdesc */
+	unsigned char description[32]; /* the same as struct v4l2_fmtdesc */
 	bool planar;
 };
 
diff --git a/drivers/staging/media/atomisp/pci/atomisp_compat.h b/drivers/staging/media/atomisp/pci/atomisp_compat.h
index f0704a7e3bff31e1af929e43e46ceb02c92a3208..67fc62f90e03246cb377e3c3c7f33550cfba9268 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_compat.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_compat.h
@@ -32,14 +32,11 @@ void atomisp_css_uninit(struct atomisp_device *isp);
 
 void atomisp_css_init_struct(struct atomisp_sub_device *asd);
 
-int atomisp_css_irq_translate(struct atomisp_device *isp,
-			      unsigned int *infos);
+int atomisp_css_irq_translate(struct atomisp_device *isp, unsigned int *infos);
 
-void atomisp_css_rx_get_irq_info(enum mipi_port_id port,
-				 unsigned int *infos);
+void atomisp_css_rx_get_irq_info(enum mipi_port_id port, unsigned int *infos);
 
-void atomisp_css_rx_clear_irq_info(enum mipi_port_id port,
-				   unsigned int infos);
+void atomisp_css_rx_clear_irq_info(enum mipi_port_id port, unsigned int infos);
 
 int atomisp_css_irq_enable(struct atomisp_device *isp,
 			   enum ia_css_irq_info info, bool enable);
@@ -71,7 +68,7 @@ int atomisp_css_start(struct atomisp_sub_device *asd);
 
 void atomisp_css_update_isp_params(struct atomisp_sub_device *asd);
 void atomisp_css_update_isp_params_on_pipe(struct atomisp_sub_device *asd,
-	struct ia_css_pipe *pipe);
+					   struct ia_css_pipe *pipe);
 
 int atomisp_css_queue_buffer(struct atomisp_sub_device *asd,
 			     enum atomisp_input_stream_id stream_id,
@@ -97,8 +94,7 @@ void atomisp_css_free_3a_buffer(struct atomisp_s3a_buf *s3a_buf);
 
 void atomisp_css_free_dis_buffer(struct atomisp_dis_buf *dis_buf);
 
-void atomisp_css_free_metadata_buffer(struct atomisp_metadata_buf
-				      *metadata_buf);
+void atomisp_css_free_metadata_buffer(struct atomisp_metadata_buf *metadata_buf);
 
 int atomisp_css_get_grid_info(struct atomisp_sub_device *asd,
 			      enum ia_css_pipe_id pipe_id);
@@ -120,14 +116,12 @@ int atomisp_css_isys_set_resolution(struct atomisp_sub_device *asd,
 				    int isys_stream);
 
 void atomisp_css_isys_set_link(struct atomisp_sub_device *asd,
-			       enum atomisp_input_stream_id stream_id,
-			       int link,
+			       enum atomisp_input_stream_id stream_id, int link,
 			       int isys_stream);
 
 void atomisp_css_isys_set_valid(struct atomisp_sub_device *asd,
 				enum atomisp_input_stream_id stream_id,
-				bool valid,
-				int isys_stream);
+				bool valid, int isys_stream);
 
 void atomisp_css_isys_set_format(struct atomisp_sub_device *asd,
 				 enum atomisp_input_stream_id stream_id,
@@ -139,24 +133,22 @@ int atomisp_css_set_default_isys_config(struct atomisp_sub_device *asd,
 					struct v4l2_mbus_framefmt *ffmt);
 
 void atomisp_css_isys_two_stream_cfg_update_stream1(
-    struct atomisp_sub_device *asd,
-    enum atomisp_input_stream_id stream_id,
-    enum atomisp_input_format input_format,
-    unsigned int width, unsigned int height);
+	struct atomisp_sub_device *asd, enum atomisp_input_stream_id stream_id,
+	enum atomisp_input_format input_format, unsigned int width,
+	unsigned int height);
 
 void atomisp_css_isys_two_stream_cfg_update_stream2(
-    struct atomisp_sub_device *asd,
-    enum atomisp_input_stream_id stream_id,
-    enum atomisp_input_format input_format,
-    unsigned int width, unsigned int height);
+	struct atomisp_sub_device *asd, enum atomisp_input_stream_id stream_id,
+	enum atomisp_input_format input_format, unsigned int width,
+	unsigned int height);
 
 int atomisp_css_input_set_resolution(struct atomisp_sub_device *asd,
 				     enum atomisp_input_stream_id stream_id,
 				     struct v4l2_mbus_framefmt *ffmt);
 
 void atomisp_css_input_set_binning_factor(struct atomisp_sub_device *asd,
-	enum atomisp_input_stream_id stream_id,
-	unsigned int bin_factor);
+					  enum atomisp_input_stream_id stream_id,
+					  unsigned int bin_factor);
 
 void atomisp_css_input_set_bayer_order(struct atomisp_sub_device *asd,
 				       enum atomisp_input_stream_id stream_id,
@@ -167,17 +159,14 @@ void atomisp_css_input_set_format(struct atomisp_sub_device *asd,
 				  enum atomisp_input_format format);
 
 int atomisp_css_input_set_effective_resolution(
-    struct atomisp_sub_device *asd,
-    enum atomisp_input_stream_id stream_id,
-    unsigned int width,
-    unsigned int height);
+	struct atomisp_sub_device *asd, enum atomisp_input_stream_id stream_id,
+	unsigned int width, unsigned int height);
 
 void atomisp_css_video_set_dis_envelope(struct atomisp_sub_device *asd,
 					unsigned int dvs_w, unsigned int dvs_h);
 
-void atomisp_css_input_set_two_pixels_per_clock(
-    struct atomisp_sub_device *asd,
-    bool two_ppc);
+void atomisp_css_input_set_two_pixels_per_clock(struct atomisp_sub_device *asd,
+						bool two_ppc);
 
 void atomisp_css_enable_dz(struct atomisp_sub_device *asd, bool enable);
 
@@ -188,28 +177,26 @@ void atomisp_css_input_set_mode(struct atomisp_sub_device *asd,
 				enum ia_css_input_mode mode);
 
 void atomisp_css_capture_enable_online(struct atomisp_sub_device *asd,
-				       unsigned short stream_index, bool enable);
+				       unsigned short stream_index,
+				       bool enable);
 
 void atomisp_css_preview_enable_online(struct atomisp_sub_device *asd,
-				       unsigned short stream_index, bool enable);
+				       unsigned short stream_index,
+				       bool enable);
 
-int atomisp_css_input_configure_port(struct atomisp_sub_device *asd,
-				     enum mipi_port_id port,
-				     unsigned int num_lanes,
-				     unsigned int timeout,
-				     unsigned int mipi_freq,
-				     enum atomisp_input_format metadata_format,
-				     unsigned int metadata_width,
-				     unsigned int metadata_height);
+int atomisp_css_input_configure_port(
+	struct atomisp_sub_device *asd, enum mipi_port_id port,
+	unsigned int num_lanes, unsigned int timeout, unsigned int mipi_freq,
+	enum atomisp_input_format metadata_format, unsigned int metadata_width,
+	unsigned int metadata_height);
 
 int atomisp_create_pipes_stream(struct atomisp_sub_device *asd);
 void atomisp_destroy_pipes_stream(struct atomisp_sub_device *asd);
 
 void atomisp_css_stop(struct atomisp_sub_device *asd, bool in_reset);
 
-void atomisp_css_continuous_set_num_raw_frames(
-     struct atomisp_sub_device *asd,
-     int num_frames);
+void atomisp_css_continuous_set_num_raw_frames(struct atomisp_sub_device *asd,
+					       int num_frames);
 
 int atomisp_css_copy_configure_output(struct atomisp_sub_device *asd,
 				      unsigned int stream_index,
@@ -218,14 +205,16 @@ int atomisp_css_copy_configure_output(struct atomisp_sub_device *asd,
 				      enum ia_css_frame_format format);
 
 int atomisp_css_preview_configure_output(struct atomisp_sub_device *asd,
-	unsigned int width, unsigned int height,
-	unsigned int min_width,
-	enum ia_css_frame_format format);
+					 unsigned int width,
+					 unsigned int height,
+					 unsigned int min_width,
+					 enum ia_css_frame_format format);
 
 int atomisp_css_capture_configure_output(struct atomisp_sub_device *asd,
-	unsigned int width, unsigned int height,
-	unsigned int min_width,
-	enum ia_css_frame_format format);
+					 unsigned int width,
+					 unsigned int height,
+					 unsigned int min_width,
+					 enum ia_css_frame_format format);
 
 int atomisp_css_video_configure_output(struct atomisp_sub_device *asd,
 				       unsigned int width, unsigned int height,
@@ -236,60 +225,55 @@ int atomisp_get_css_frame_info(struct atomisp_sub_device *asd,
 			       struct ia_css_frame_info *frame_info);
 
 int atomisp_css_video_configure_viewfinder(struct atomisp_sub_device *asd,
-	unsigned int width, unsigned int height,
-	unsigned int min_width,
-	enum ia_css_frame_format format);
+					   unsigned int width,
+					   unsigned int height,
+					   unsigned int min_width,
+					   enum ia_css_frame_format format);
 
-int atomisp_css_capture_configure_viewfinder(
-    struct atomisp_sub_device *asd,
-    unsigned int width, unsigned int height,
-    unsigned int min_width,
-    enum ia_css_frame_format format);
+int atomisp_css_capture_configure_viewfinder(struct atomisp_sub_device *asd,
+					     unsigned int width,
+					     unsigned int height,
+					     unsigned int min_width,
+					     enum ia_css_frame_format format);
 
-int atomisp_css_video_get_viewfinder_frame_info(
-    struct atomisp_sub_device *asd,
-    struct ia_css_frame_info *info);
+int atomisp_css_video_get_viewfinder_frame_info(struct atomisp_sub_device *asd,
+						struct ia_css_frame_info *info);
 
 int atomisp_css_capture_get_viewfinder_frame_info(
-    struct atomisp_sub_device *asd,
-    struct ia_css_frame_info *info);
+	struct atomisp_sub_device *asd, struct ia_css_frame_info *info);
 
-int atomisp_css_copy_get_output_frame_info(
-    struct atomisp_sub_device *asd,
-    unsigned int stream_index,
-    struct ia_css_frame_info *info);
+int atomisp_css_copy_get_output_frame_info(struct atomisp_sub_device *asd,
+					   unsigned int stream_index,
+					   struct ia_css_frame_info *info);
 
-int atomisp_css_preview_get_output_frame_info(
-    struct atomisp_sub_device *asd,
-    struct ia_css_frame_info *info);
+int atomisp_css_preview_get_output_frame_info(struct atomisp_sub_device *asd,
+					      struct ia_css_frame_info *info);
 
-int atomisp_css_capture_get_output_frame_info(
-    struct atomisp_sub_device *asd,
-    struct ia_css_frame_info *info);
+int atomisp_css_capture_get_output_frame_info(struct atomisp_sub_device *asd,
+					      struct ia_css_frame_info *info);
 
-int atomisp_css_video_get_output_frame_info(
-    struct atomisp_sub_device *asd,
-    struct ia_css_frame_info *info);
+int atomisp_css_video_get_output_frame_info(struct atomisp_sub_device *asd,
+					    struct ia_css_frame_info *info);
 
-int atomisp_css_preview_configure_pp_input(
-    struct atomisp_sub_device *asd,
-    unsigned int width, unsigned int height);
+int atomisp_css_preview_configure_pp_input(struct atomisp_sub_device *asd,
+					   unsigned int width,
+					   unsigned int height);
 
-int atomisp_css_capture_configure_pp_input(
-    struct atomisp_sub_device *asd,
-    unsigned int width, unsigned int height);
+int atomisp_css_capture_configure_pp_input(struct atomisp_sub_device *asd,
+					   unsigned int width,
+					   unsigned int height);
 
-int atomisp_css_video_configure_pp_input(
-    struct atomisp_sub_device *asd,
-    unsigned int width, unsigned int height);
+int atomisp_css_video_configure_pp_input(struct atomisp_sub_device *asd,
+					 unsigned int width,
+					 unsigned int height);
 
 int atomisp_css_offline_capture_configure(struct atomisp_sub_device *asd,
-	int num_captures, unsigned int skip, int offset);
+					  int num_captures, unsigned int skip,
+					  int offset);
 int atomisp_css_exp_id_capture(struct atomisp_sub_device *asd, int exp_id);
 int atomisp_css_exp_id_unlock(struct atomisp_sub_device *asd, int exp_id);
 
-int atomisp_css_capture_enable_xnr(struct atomisp_sub_device *asd,
-				   bool enable);
+int atomisp_css_capture_enable_xnr(struct atomisp_sub_device *asd, bool enable);
 
 void atomisp_css_set_ctc_table(struct atomisp_sub_device *asd,
 			       struct ia_css_ctc_table *ctc_table);
@@ -339,25 +323,27 @@ int atomisp_css_get_gc_config(struct atomisp_sub_device *asd,
 int atomisp_css_get_3a_config(struct atomisp_sub_device *asd,
 			      struct atomisp_3a_config *config);
 
-int atomisp_css_get_formats_config(struct atomisp_sub_device *asd,
-				   struct atomisp_formats_config *formats_config);
+int atomisp_css_get_formats_config(
+	struct atomisp_sub_device *asd,
+	struct atomisp_formats_config *formats_config);
 
-void atomisp_css_set_formats_config(struct atomisp_sub_device *asd,
-				    struct ia_css_formats_config *formats_config);
+void atomisp_css_set_formats_config(
+	struct atomisp_sub_device *asd,
+	struct ia_css_formats_config *formats_config);
 
 int atomisp_css_get_zoom_factor(struct atomisp_sub_device *asd,
 				unsigned int *zoom);
 
-struct ia_css_shading_table *atomisp_css_shading_table_alloc(
-    unsigned int width, unsigned int height);
+struct ia_css_shading_table *
+atomisp_css_shading_table_alloc(unsigned int width, unsigned int height);
 
 void atomisp_css_set_shading_table(struct atomisp_sub_device *asd,
 				   struct ia_css_shading_table *table);
 
 void atomisp_css_shading_table_free(struct ia_css_shading_table *table);
 
-struct ia_css_morph_table *atomisp_css_morph_table_allocate(
-    unsigned int width, unsigned int height);
+struct ia_css_morph_table *
+atomisp_css_morph_table_allocate(unsigned int width, unsigned int height);
 
 void atomisp_css_set_morph_table(struct atomisp_sub_device *asd,
 				 struct ia_css_morph_table *table);
diff --git a/drivers/staging/media/atomisp/pci/atomisp_compat_css20.c b/drivers/staging/media/atomisp/pci/atomisp_compat_css20.c
index bc97fa2c374c78b84820708a8a3946dc66169b62..e01b3d03c994e08b97ec82b42d901bde474fd7f9 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_compat_css20.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_compat_css20.c
@@ -29,7 +29,7 @@
 #include <linux/pm_runtime.h>
 
 /* Assume max number of ACC stages */
-#define MAX_ACC_STAGES	20
+#define MAX_ACC_STAGES 20
 
 /* Ideally, this should come from CSS headers */
 #define NO_LINK -1
@@ -119,7 +119,8 @@ static uint32_t atomisp_css2_hw_load_32(hrt_address addr)
 	return ret;
 }
 
-static void atomisp_css2_hw_store(hrt_address addr, const void *from, uint32_t n)
+static void atomisp_css2_hw_store(hrt_address addr, const void *from,
+				  uint32_t n)
 {
 	struct atomisp_device *isp = dev_get_drvdata(atomisp_dev);
 	unsigned long flags;
@@ -146,7 +147,7 @@ static void atomisp_css2_hw_load(hrt_address addr, void *to, uint32_t n)
 	spin_unlock_irqrestore(&mmio_lock, flags);
 }
 
-static int  __printf(1, 0) atomisp_vprintk(const char *fmt, va_list args)
+static int __printf(1, 0) atomisp_vprintk(const char *fmt, va_list args)
 {
 	vprintk(fmt, args);
 	return 0;
@@ -157,7 +158,8 @@ void atomisp_load_uint32(hrt_address addr, uint32_t *data)
 	*data = atomisp_css2_hw_load_32(addr);
 }
 
-static int hmm_get_mmu_base_addr(struct device *dev, unsigned int *mmu_base_addr)
+static int hmm_get_mmu_base_addr(struct device *dev,
+				 unsigned int *mmu_base_addr)
 {
 	if (!sh_mmu_mrfld.get_pd_base) {
 		dev_err(dev, "get mmu base address failed.\n");
@@ -165,7 +167,7 @@ static int hmm_get_mmu_base_addr(struct device *dev, unsigned int *mmu_base_addr
 	}
 
 	*mmu_base_addr = sh_mmu_mrfld.get_pd_base(&bo_device.mmu,
-			 bo_device.mmu.base_address);
+						  bo_device.mmu.base_address);
 	return 0;
 }
 
@@ -182,72 +184,54 @@ static void __dump_pipe_config(struct atomisp_sub_device *asd,
 		p_config = &stream_env->pipe_configs[pipe_id];
 		pe_config = &stream_env->pipe_extra_configs[pipe_id];
 		dev_dbg(isp->dev, "dumping pipe[%d] config:\n", pipe_id);
-		dev_dbg(isp->dev,
-			"pipe_config.pipe_mode:%d.\n", p_config->mode);
-		dev_dbg(isp->dev,
-			"pipe_config.output_info[0] w=%d, h=%d.\n",
+		dev_dbg(isp->dev, "pipe_config.pipe_mode:%d.\n",
+			p_config->mode);
+		dev_dbg(isp->dev, "pipe_config.output_info[0] w=%d, h=%d.\n",
 			p_config->output_info[0].res.width,
 			p_config->output_info[0].res.height);
-		dev_dbg(isp->dev,
-			"pipe_config.vf_pp_in_res w=%d, h=%d.\n",
+		dev_dbg(isp->dev, "pipe_config.vf_pp_in_res w=%d, h=%d.\n",
 			p_config->vf_pp_in_res.width,
 			p_config->vf_pp_in_res.height);
-		dev_dbg(isp->dev,
-			"pipe_config.capt_pp_in_res w=%d, h=%d.\n",
+		dev_dbg(isp->dev, "pipe_config.capt_pp_in_res w=%d, h=%d.\n",
 			p_config->capt_pp_in_res.width,
 			p_config->capt_pp_in_res.height);
-		dev_dbg(isp->dev,
-			"pipe_config.output.padded w=%d.\n",
+		dev_dbg(isp->dev, "pipe_config.output.padded w=%d.\n",
 			p_config->output_info[0].padded_width);
-		dev_dbg(isp->dev,
-			"pipe_config.vf_output_info[0] w=%d, h=%d.\n",
+		dev_dbg(isp->dev, "pipe_config.vf_output_info[0] w=%d, h=%d.\n",
 			p_config->vf_output_info[0].res.width,
 			p_config->vf_output_info[0].res.height);
-		dev_dbg(isp->dev,
-			"pipe_config.bayer_ds_out_res w=%d, h=%d.\n",
+		dev_dbg(isp->dev, "pipe_config.bayer_ds_out_res w=%d, h=%d.\n",
 			p_config->bayer_ds_out_res.width,
 			p_config->bayer_ds_out_res.height);
-		dev_dbg(isp->dev,
-			"pipe_config.envelope w=%d, h=%d.\n",
+		dev_dbg(isp->dev, "pipe_config.envelope w=%d, h=%d.\n",
 			p_config->dvs_envelope.width,
 			p_config->dvs_envelope.height);
-		dev_dbg(isp->dev,
-			"pipe_config.dvs_frame_delay=%d.\n",
+		dev_dbg(isp->dev, "pipe_config.dvs_frame_delay=%d.\n",
 			p_config->dvs_frame_delay);
-		dev_dbg(isp->dev,
-			"pipe_config.isp_pipe_version:%d.\n",
+		dev_dbg(isp->dev, "pipe_config.isp_pipe_version:%d.\n",
 			p_config->isp_pipe_version);
 		dev_dbg(isp->dev,
 			"pipe_config.default_capture_config.capture_mode=%d.\n",
 			p_config->default_capture_config.mode);
-		dev_dbg(isp->dev,
-			"pipe_config.enable_dz=%d.\n",
+		dev_dbg(isp->dev, "pipe_config.enable_dz=%d.\n",
 			p_config->enable_dz);
 		dev_dbg(isp->dev,
 			"pipe_config.default_capture_config.enable_xnr=%d.\n",
 			p_config->default_capture_config.enable_xnr);
-		dev_dbg(isp->dev,
-			"dumping pipe[%d] extra config:\n", pipe_id);
-		dev_dbg(isp->dev,
-			"pipe_extra_config.enable_raw_binning:%d.\n",
+		dev_dbg(isp->dev, "dumping pipe[%d] extra config:\n", pipe_id);
+		dev_dbg(isp->dev, "pipe_extra_config.enable_raw_binning:%d.\n",
 			pe_config->enable_raw_binning);
-		dev_dbg(isp->dev,
-			"pipe_extra_config.enable_yuv_ds:%d.\n",
+		dev_dbg(isp->dev, "pipe_extra_config.enable_yuv_ds:%d.\n",
 			pe_config->enable_yuv_ds);
-		dev_dbg(isp->dev,
-			"pipe_extra_config.enable_high_speed:%d.\n",
+		dev_dbg(isp->dev, "pipe_extra_config.enable_high_speed:%d.\n",
 			pe_config->enable_high_speed);
-		dev_dbg(isp->dev,
-			"pipe_extra_config.enable_dvs_6axis:%d.\n",
+		dev_dbg(isp->dev, "pipe_extra_config.enable_dvs_6axis:%d.\n",
 			pe_config->enable_dvs_6axis);
-		dev_dbg(isp->dev,
-			"pipe_extra_config.enable_reduced_pipe:%d.\n",
+		dev_dbg(isp->dev, "pipe_extra_config.enable_reduced_pipe:%d.\n",
 			pe_config->enable_reduced_pipe);
-		dev_dbg(isp->dev,
-			"pipe_(extra_)config.enable_dz:%d.\n",
+		dev_dbg(isp->dev, "pipe_(extra_)config.enable_dz:%d.\n",
 			p_config->enable_dz);
-		dev_dbg(isp->dev,
-			"pipe_extra_config.disable_vf_pp:%d.\n",
+		dev_dbg(isp->dev, "pipe_extra_config.disable_vf_pp:%d.\n",
 			pe_config->disable_vf_pp);
 	}
 }
@@ -281,16 +265,17 @@ static void __dump_stream_config(struct atomisp_sub_device *asd,
 			s_config->source.port.timeout);
 		dev_dbg(isp->dev, "stream_config.source.port.rxcount=0x%x.\n",
 			s_config->source.port.rxcount);
-		dev_dbg(isp->dev, "stream_config.source.port.compression.type=%d.\n",
+		dev_dbg(isp->dev,
+			"stream_config.source.port.compression.type=%d.\n",
 			s_config->source.port.compression.type);
 		dev_dbg(isp->dev,
 			"stream_config.source.port.compression.compressed_bits_per_pixel=%d.\n",
-			s_config->source.port.compression.
-			compressed_bits_per_pixel);
+			s_config->source.port.compression
+				.compressed_bits_per_pixel);
 		dev_dbg(isp->dev,
 			"stream_config.source.port.compression.uncompressed_bits_per_pixel=%d.\n",
-			s_config->source.port.compression.
-			uncompressed_bits_per_pixel);
+			s_config->source.port.compression
+				.uncompressed_bits_per_pixel);
 	} else if (s_config->mode == IA_CSS_INPUT_MODE_PRBS) {
 		dev_dbg(isp->dev, "stream_config.source.prbs.id=%d.\n",
 			s_config->source.prbs.id);
@@ -305,21 +290,19 @@ static void __dump_stream_config(struct atomisp_sub_device *asd,
 	}
 
 	for (j = 0; j < IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH; j++) {
-		dev_dbg(isp->dev, "stream_configisys_config[%d].input_res w=%d, h=%d.\n",
-			j,
-			s_config->isys_config[j].input_res.width,
+		dev_dbg(isp->dev,
+			"stream_configisys_config[%d].input_res w=%d, h=%d.\n",
+			j, s_config->isys_config[j].input_res.width,
 			s_config->isys_config[j].input_res.height);
 
-		dev_dbg(isp->dev, "stream_configisys_config[%d].linked_isys_stream_id=%d\n",
-			j,
-			s_config->isys_config[j].linked_isys_stream_id);
+		dev_dbg(isp->dev,
+			"stream_configisys_config[%d].linked_isys_stream_id=%d\n",
+			j, s_config->isys_config[j].linked_isys_stream_id);
 
-		dev_dbg(isp->dev, "stream_configisys_config[%d].format=%d\n",
-			j,
+		dev_dbg(isp->dev, "stream_configisys_config[%d].format=%d\n", j,
 			s_config->isys_config[j].format);
 
-		dev_dbg(isp->dev, "stream_configisys_config[%d].valid=%d.\n",
-			j,
+		dev_dbg(isp->dev, "stream_configisys_config[%d].valid=%d.\n", j,
 			s_config->isys_config[j].valid);
 	}
 
@@ -327,7 +310,8 @@ static void __dump_stream_config(struct atomisp_sub_device *asd,
 		s_config->input_config.input_res.width,
 		s_config->input_config.input_res.height);
 
-	dev_dbg(isp->dev, "stream_config.input_config.effective_res w=%d, h=%d.\n",
+	dev_dbg(isp->dev,
+		"stream_config.input_config.effective_res w=%d, h=%d.\n",
 		s_config->input_config.effective_res.width,
 		s_config->input_config.effective_res.height);
 
@@ -360,13 +344,15 @@ static void __dump_stream_config(struct atomisp_sub_device *asd,
 		s_config->pack_raw_pixels);
 	dev_dbg(isp->dev, "stream_config.flash_gpio_pin=%d.\n",
 		s_config->flash_gpio_pin);
-	dev_dbg(isp->dev, "stream_config.mipi_buffer_config.size_mem_words=%d.\n",
+	dev_dbg(isp->dev,
+		"stream_config.mipi_buffer_config.size_mem_words=%d.\n",
 		s_config->mipi_buffer_config.size_mem_words);
 	dev_dbg(isp->dev, "stream_config.mipi_buffer_config.contiguous=%d.\n",
 		s_config->mipi_buffer_config.contiguous);
 	dev_dbg(isp->dev, "stream_config.metadata_config.data_type=%d.\n",
 		s_config->metadata_config.data_type);
-	dev_dbg(isp->dev, "stream_config.metadata_config.resolution w=%d, h=%d.\n",
+	dev_dbg(isp->dev,
+		"stream_config.metadata_config.resolution w=%d, h=%d.\n",
 		s_config->metadata_config.resolution.width,
 		s_config->metadata_config.resolution.height);
 }
@@ -380,8 +366,8 @@ static int __destroy_stream(struct atomisp_sub_device *asd,
 	if (!stream_env->stream)
 		return 0;
 
-	if (stream_env->stream_state == CSS_STREAM_STARTED
-	    && ia_css_stream_stop(stream_env->stream) != 0) {
+	if (stream_env->stream_state == CSS_STREAM_STARTED &&
+	    ia_css_stream_stop(stream_env->stream) != 0) {
 		dev_err(isp->dev, "stop stream failed.\n");
 		return -EINVAL;
 	}
@@ -440,14 +426,14 @@ static int __create_stream(struct atomisp_sub_device *asd,
 		return 0;
 
 	stream_env->stream_config.target_num_cont_raw_buf =
-	    asd->continuous_raw_buffer_size->val;
+		asd->continuous_raw_buffer_size->val;
 	stream_env->stream_config.channel_id = stream_env->ch_id;
 	stream_env->stream_config.ia_css_enable_raw_buffer_locking =
-	    asd->enable_raw_buffer_lock->val;
+		asd->enable_raw_buffer_lock->val;
 
 	__dump_stream_config(asd, stream_env);
-	if (ia_css_stream_create(&stream_env->stream_config,
-				 pipe_index, multi_pipes, &stream_env->stream) != 0)
+	if (ia_css_stream_create(&stream_env->stream_config, pipe_index,
+				 multi_pipes, &stream_env->stream) != 0)
 		return -EINVAL;
 	if (ia_css_stream_get_info(stream_env->stream,
 				   &stream_env->stream_info) != 0) {
@@ -487,8 +473,7 @@ static int __destroy_stream_pipes(struct atomisp_sub_device *asd,
 	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
 		if (!stream_env->pipes[i])
 			continue;
-		if (ia_css_pipe_destroy(stream_env->pipes[i])
-		    != 0) {
+		if (ia_css_pipe_destroy(stream_env->pipes[i]) != 0) {
 			dev_err(isp->dev,
 				"destroy pipe[%d]failed.cannot recover.\n", i);
 			ret = -EINVAL;
@@ -530,10 +515,10 @@ void atomisp_destroy_pipes_stream(struct atomisp_sub_device *asd)
 		dev_warn(asd->isp->dev, "destroy pipe failed.\n");
 }
 
-static void __apply_additional_pipe_config(
-    struct atomisp_sub_device *asd,
-    struct atomisp_stream_env *stream_env,
-    enum ia_css_pipe_id pipe_id)
+static void
+__apply_additional_pipe_config(struct atomisp_sub_device *asd,
+			       struct atomisp_stream_env *stream_env,
+			       enum ia_css_pipe_id pipe_id)
 {
 	struct atomisp_device *isp = asd->isp;
 
@@ -546,30 +531,29 @@ static void __apply_additional_pipe_config(
 	/* apply default pipe config */
 	stream_env->pipe_configs[pipe_id].isp_pipe_version = 2;
 	stream_env->pipe_configs[pipe_id].enable_dz =
-	    asd->disable_dz->val ? false : true;
+		asd->disable_dz->val ? false : true;
 	/* apply isp 2.2 specific config for baytrail*/
 	switch (pipe_id) {
 	case IA_CSS_PIPE_ID_CAPTURE:
 		/* enable capture pp/dz manually or digital zoom would
 		 * fail*/
-		if (stream_env->pipe_configs[pipe_id].
-		    default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW)
+		if (stream_env->pipe_configs[pipe_id]
+			    .default_capture_config.mode ==
+		    IA_CSS_CAPTURE_MODE_RAW)
 			stream_env->pipe_configs[pipe_id].enable_dz = false;
 		break;
 	case IA_CSS_PIPE_ID_VIDEO:
 		/* enable reduced pipe to have binary
 		 * video_dz_2_min selected*/
-		stream_env->pipe_extra_configs[pipe_id]
-		.enable_reduced_pipe = true;
-		stream_env->pipe_configs[pipe_id]
-		.enable_dz = false;
+		stream_env->pipe_extra_configs[pipe_id].enable_reduced_pipe =
+			true;
+		stream_env->pipe_configs[pipe_id].enable_dz = false;
 
 		if (asd->params.video_dis_en) {
 			stream_env->pipe_extra_configs[pipe_id]
-			.enable_dvs_6axis = true;
-			stream_env->pipe_configs[pipe_id]
-			.dvs_frame_delay =
-			    ATOMISP_CSS2_NUM_DVS_FRAME_DELAY;
+				.enable_dvs_6axis = true;
+			stream_env->pipe_configs[pipe_id].dvs_frame_delay =
+				ATOMISP_CSS2_NUM_DVS_FRAME_DELAY;
 		}
 		break;
 	case IA_CSS_PIPE_ID_PREVIEW:
@@ -584,7 +568,7 @@ static void __apply_additional_pipe_config(
 }
 
 static bool is_pipe_valid_to_current_run_mode(struct atomisp_sub_device *asd,
-	enum ia_css_pipe_id pipe_id)
+					      enum ia_css_pipe_id pipe_id)
 {
 	if (pipe_id == IA_CSS_PIPE_ID_YUVPP)
 		return true;
@@ -621,7 +605,8 @@ static bool is_pipe_valid_to_current_run_mode(struct atomisp_sub_device *asd,
 
 		return false;
 	case ATOMISP_RUN_MODE_VIDEO:
-		if (pipe_id == IA_CSS_PIPE_ID_VIDEO || pipe_id == IA_CSS_PIPE_ID_YUVPP)
+		if (pipe_id == IA_CSS_PIPE_ID_VIDEO ||
+		    pipe_id == IA_CSS_PIPE_ID_YUVPP)
 			return true;
 
 		return false;
@@ -650,17 +635,15 @@ static int __create_pipe(struct atomisp_sub_device *asd,
 	ia_css_pipe_extra_config_defaults(&extra_config);
 
 	__apply_additional_pipe_config(asd, stream_env, pipe_id);
-	if (!memcmp(&extra_config,
-		    &stream_env->pipe_extra_configs[pipe_id],
+	if (!memcmp(&extra_config, &stream_env->pipe_extra_configs[pipe_id],
 		    sizeof(extra_config)))
-		ret = ia_css_pipe_create(
-			  &stream_env->pipe_configs[pipe_id],
-			  &stream_env->pipes[pipe_id]);
+		ret = ia_css_pipe_create(&stream_env->pipe_configs[pipe_id],
+					 &stream_env->pipes[pipe_id]);
 	else
 		ret = ia_css_pipe_create_extra(
-			  &stream_env->pipe_configs[pipe_id],
-			  &stream_env->pipe_extra_configs[pipe_id],
-			  &stream_env->pipes[pipe_id]);
+			&stream_env->pipe_configs[pipe_id],
+			&stream_env->pipe_extra_configs[pipe_id],
+			&stream_env->pipes[pipe_id]);
 	if (ret)
 		dev_err(isp->dev, "create pipe[%d] error.\n", pipe_id);
 	return ret;
@@ -685,7 +668,8 @@ static int __create_pipes(struct atomisp_sub_device *asd)
 	for (; i >= 0; i--) {
 		for (j--; j >= 0; j--) {
 			if (asd->stream_env[i].pipes[j]) {
-				ia_css_pipe_destroy(asd->stream_env[i].pipes[j]);
+				ia_css_pipe_destroy(
+					asd->stream_env[i].pipes[j]);
 				asd->stream_env[i].pipes[j] = NULL;
 			}
 		}
@@ -752,7 +736,8 @@ static inline int __set_css_print_env(struct atomisp_device *isp, int opt)
 	if (opt == 0)
 		isp->css_env.isp_css_env.print_env.debug_print = NULL;
 	else if (opt == 1)
-		isp->css_env.isp_css_env.print_env.debug_print = atomisp_vprintk;
+		isp->css_env.isp_css_env.print_env.debug_print =
+			atomisp_vprintk;
 	else
 		ret = -EINVAL;
 
@@ -768,17 +753,17 @@ int atomisp_css_load_firmware(struct atomisp_device *isp)
 	isp->css_env.isp_css_fw.bytes = isp->firmware->size;
 
 	isp->css_env.isp_css_env.hw_access_env.store_8 =
-	    atomisp_css2_hw_store_8;
+		atomisp_css2_hw_store_8;
 	isp->css_env.isp_css_env.hw_access_env.store_16 =
-	    atomisp_css2_hw_store_16;
+		atomisp_css2_hw_store_16;
 	isp->css_env.isp_css_env.hw_access_env.store_32 =
-	    atomisp_css2_hw_store_32;
+		atomisp_css2_hw_store_32;
 
 	isp->css_env.isp_css_env.hw_access_env.load_8 = atomisp_css2_hw_load_8;
 	isp->css_env.isp_css_env.hw_access_env.load_16 =
-	    atomisp_css2_hw_load_16;
+		atomisp_css2_hw_load_16;
 	isp->css_env.isp_css_env.hw_access_env.load_32 =
-	    atomisp_css2_hw_load_32;
+		atomisp_css2_hw_load_32;
 
 	isp->css_env.isp_css_env.hw_access_env.load = atomisp_css2_hw_load;
 	isp->css_env.isp_css_env.hw_access_env.store = atomisp_css2_hw_store;
@@ -804,8 +789,7 @@ void atomisp_css_uninit(struct atomisp_device *isp)
 	ia_css_uninit();
 }
 
-int atomisp_css_irq_translate(struct atomisp_device *isp,
-			      unsigned int *infos)
+int atomisp_css_irq_translate(struct atomisp_device *isp, unsigned int *infos)
 {
 	int err;
 
@@ -820,8 +804,7 @@ int atomisp_css_irq_translate(struct atomisp_device *isp,
 	return 0;
 }
 
-void atomisp_css_rx_get_irq_info(enum mipi_port_id port,
-				 unsigned int *infos)
+void atomisp_css_rx_get_irq_info(enum mipi_port_id port, unsigned int *infos)
 {
 	if (IS_ISP2401)
 		*infos = 0;
@@ -829,8 +812,7 @@ void atomisp_css_rx_get_irq_info(enum mipi_port_id port,
 		ia_css_isys_rx_get_irq_info(port, infos);
 }
 
-void atomisp_css_rx_clear_irq_info(enum mipi_port_id port,
-				   unsigned int infos)
+void atomisp_css_rx_clear_irq_info(enum mipi_port_id port, unsigned int infos)
 {
 	if (!IS_ISP2401)
 		ia_css_isys_rx_clear_irq_info(port, infos);
@@ -839,13 +821,11 @@ void atomisp_css_rx_clear_irq_info(enum mipi_port_id port,
 int atomisp_css_irq_enable(struct atomisp_device *isp,
 			   enum ia_css_irq_info info, bool enable)
 {
-	dev_dbg(isp->dev, "%s: css irq info 0x%08x: %s (%d).\n",
-		__func__, info,
+	dev_dbg(isp->dev, "%s: css irq info 0x%08x: %s (%d).\n", __func__, info,
 		enable ? "enable" : "disable", enable);
 	if (ia_css_irq_enable(info, enable)) {
 		dev_warn(isp->dev, "%s:Invalid irq info: 0x%08x when %s.\n",
-			 __func__, info,
-			 enable ? "enabling" : "disabling");
+			 __func__, info, enable ? "enabling" : "disabling");
 		return -EINVAL;
 	}
 
@@ -862,11 +842,12 @@ void atomisp_css_init_struct(struct atomisp_sub_device *asd)
 			asd->stream_env[i].pipes[j] = NULL;
 			asd->stream_env[i].update_pipe[j] = false;
 			ia_css_pipe_config_defaults(
-			    &asd->stream_env[i].pipe_configs[j]);
+				&asd->stream_env[i].pipe_configs[j]);
 			ia_css_pipe_extra_config_defaults(
-			    &asd->stream_env[i].pipe_extra_configs[j]);
+				&asd->stream_env[i].pipe_extra_configs[j]);
 		}
-		ia_css_stream_config_defaults(&asd->stream_env[i].stream_config);
+		ia_css_stream_config_defaults(
+			&asd->stream_env[i].stream_config);
 	}
 }
 
@@ -877,14 +858,14 @@ int atomisp_q_video_buffer_to_css(struct atomisp_sub_device *asd,
 				  enum ia_css_pipe_id css_pipe_id)
 {
 	struct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];
-	struct ia_css_buffer css_buf = {0};
+	struct ia_css_buffer css_buf = { 0 };
 	int err;
 
 	css_buf.type = css_buf_type;
 	css_buf.data.frame = frame;
 
-	err = ia_css_pipe_enqueue_buffer(
-		  stream_env->pipes[css_pipe_id], &css_buf);
+	err = ia_css_pipe_enqueue_buffer(stream_env->pipes[css_pipe_id],
+					 &css_buf);
 	if (err)
 		return -EINVAL;
 
@@ -897,7 +878,7 @@ int atomisp_q_metadata_buffer_to_css(struct atomisp_sub_device *asd,
 				     enum ia_css_pipe_id css_pipe_id)
 {
 	struct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];
-	struct ia_css_buffer buffer = {0};
+	struct ia_css_buffer buffer = { 0 };
 	struct atomisp_device *isp = asd->isp;
 
 	buffer.type = IA_CSS_BUFFER_TYPE_METADATA;
@@ -917,14 +898,13 @@ int atomisp_q_s3a_buffer_to_css(struct atomisp_sub_device *asd,
 				enum ia_css_pipe_id css_pipe_id)
 {
 	struct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];
-	struct ia_css_buffer buffer = {0};
+	struct ia_css_buffer buffer = { 0 };
 	struct atomisp_device *isp = asd->isp;
 
 	buffer.type = IA_CSS_BUFFER_TYPE_3A_STATISTICS;
 	buffer.data.stats_3a = s3a_buf->s3a_data;
-	if (ia_css_pipe_enqueue_buffer(
-		stream_env->pipes[css_pipe_id],
-		&buffer)) {
+	if (ia_css_pipe_enqueue_buffer(stream_env->pipes[css_pipe_id],
+				       &buffer)) {
 		dev_dbg(isp->dev, "failed to q s3a stat buffer\n");
 		return -EINVAL;
 	}
@@ -938,14 +918,13 @@ int atomisp_q_dis_buffer_to_css(struct atomisp_sub_device *asd,
 				enum ia_css_pipe_id css_pipe_id)
 {
 	struct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];
-	struct ia_css_buffer buffer = {0};
+	struct ia_css_buffer buffer = { 0 };
 	struct atomisp_device *isp = asd->isp;
 
 	buffer.type = IA_CSS_BUFFER_TYPE_DIS_STATISTICS;
 	buffer.data.stats_dvs = dis_buf->dis_data;
-	if (ia_css_pipe_enqueue_buffer(
-		stream_env->pipes[css_pipe_id],
-		&buffer)) {
+	if (ia_css_pipe_enqueue_buffer(stream_env->pipes[css_pipe_id],
+				       &buffer)) {
 		dev_dbg(isp->dev, "failed to q dvs stat buffer\n");
 		return -EINVAL;
 	}
@@ -972,13 +951,15 @@ int atomisp_css_start(struct atomisp_sub_device *asd)
 
 	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
 		if (asd->stream_env[i].stream) {
-			if (ia_css_stream_start(asd->stream_env[i]
-						.stream) != 0) {
-				dev_err(isp->dev, "stream[%d] start error.\n", i);
+			if (ia_css_stream_start(asd->stream_env[i].stream) !=
+			    0) {
+				dev_err(isp->dev, "stream[%d] start error.\n",
+					i);
 				ret = -EINVAL;
 				goto start_err;
 			} else {
-				asd->stream_env[i].stream_state = CSS_STREAM_STARTED;
+				asd->stream_env[i].stream_state =
+					CSS_STREAM_STARTED;
 				dev_dbg(isp->dev, "stream[%d] started.\n", i);
 			}
 		}
@@ -1012,20 +993,21 @@ void atomisp_css_update_isp_params(struct atomisp_sub_device *asd)
 	 * Check if it is Cherry Trail and also new input system
 	 */
 	if (asd->copy_mode) {
-		dev_warn(asd->isp->dev,
-			 "%s: ia_css_stream_set_isp_config() not supported in copy mode!.\n",
-			 __func__);
+		dev_warn(
+			asd->isp->dev,
+			"%s: ia_css_stream_set_isp_config() not supported in copy mode!.\n",
+			__func__);
 		return;
 	}
 
 	ia_css_stream_set_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &asd->params.config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&asd->params.config);
 	memset(&asd->params.config, 0, sizeof(asd->params.config));
 }
 
 void atomisp_css_update_isp_params_on_pipe(struct atomisp_sub_device *asd,
-	struct ia_css_pipe *pipe)
+					   struct ia_css_pipe *pipe)
 {
 	int ret;
 
@@ -1040,10 +1022,11 @@ void atomisp_css_update_isp_params_on_pipe(struct atomisp_sub_device *asd,
 		asd->params.config.isp_config_id, pipe);
 
 	ret = ia_css_stream_set_isp_config_on_pipe(
-		  asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		  &asd->params.config, pipe);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&asd->params.config, pipe);
 	if (ret)
-		dev_warn(asd->isp->dev, "%s: ia_css_stream_set_isp_config_on_pipe failed %d\n",
+		dev_warn(asd->isp->dev,
+			 "%s: ia_css_stream_set_isp_config_on_pipe failed %d\n",
 			 __func__, ret);
 	memset(&asd->params.config, 0, sizeof(asd->params.config));
 }
@@ -1054,10 +1037,8 @@ int atomisp_css_queue_buffer(struct atomisp_sub_device *asd,
 			     enum ia_css_buffer_type buf_type,
 			     struct atomisp_css_buffer *isp_css_buffer)
 {
-	if (ia_css_pipe_enqueue_buffer(
-		asd->stream_env[stream_id].pipes[pipe_id],
-		&isp_css_buffer->css_buffer)
-	    != 0)
+	if (ia_css_pipe_enqueue_buffer(asd->stream_env[stream_id].pipes[pipe_id],
+				       &isp_css_buffer->css_buffer) != 0)
 		return -EINVAL;
 
 	return 0;
@@ -1073,32 +1054,32 @@ int atomisp_css_dequeue_buffer(struct atomisp_sub_device *asd,
 	int err;
 
 	err = ia_css_pipe_dequeue_buffer(
-		  asd->stream_env[stream_id].pipes[pipe_id],
-		  &isp_css_buffer->css_buffer);
+		asd->stream_env[stream_id].pipes[pipe_id],
+		&isp_css_buffer->css_buffer);
 	if (err) {
-		dev_err(isp->dev,
-			"ia_css_pipe_dequeue_buffer failed: 0x%x\n", err);
+		dev_err(isp->dev, "ia_css_pipe_dequeue_buffer failed: 0x%x\n",
+			err);
 		return -EINVAL;
 	}
 
 	return 0;
 }
 
-int atomisp_css_allocate_stat_buffers(struct atomisp_sub_device   *asd,
+int atomisp_css_allocate_stat_buffers(struct atomisp_sub_device *asd,
 				      u16 stream_id,
-				      struct atomisp_s3a_buf      *s3a_buf,
-				      struct atomisp_dis_buf      *dis_buf,
+				      struct atomisp_s3a_buf *s3a_buf,
+				      struct atomisp_dis_buf *dis_buf,
 				      struct atomisp_metadata_buf *md_buf)
 {
 	struct atomisp_device *isp = asd->isp;
 	struct ia_css_dvs_grid_info *dvs_grid_info =
-	    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
+		atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
 
 	if (s3a_buf && asd->params.curr_grid_info.s3a_grid.enable) {
 		void *s3a_ptr;
 
 		s3a_buf->s3a_data = ia_css_isp_3a_statistics_allocate(
-					&asd->params.curr_grid_info.s3a_grid);
+			&asd->params.curr_grid_info.s3a_grid);
 		if (!s3a_buf->s3a_data) {
 			dev_err(isp->dev, "3a buf allocation failed.\n");
 			return -EINVAL;
@@ -1106,35 +1087,38 @@ int atomisp_css_allocate_stat_buffers(struct atomisp_sub_device   *asd,
 
 		s3a_ptr = hmm_vmap(s3a_buf->s3a_data->data_ptr, true);
 		s3a_buf->s3a_map = ia_css_isp_3a_statistics_map_allocate(
-				       s3a_buf->s3a_data, s3a_ptr);
+			s3a_buf->s3a_data, s3a_ptr);
 	}
 
 	if (dis_buf && dvs_grid_info && dvs_grid_info->enable) {
 		void *dvs_ptr;
 
-		dis_buf->dis_data = ia_css_isp_dvs2_statistics_allocate(
-					dvs_grid_info);
+		dis_buf->dis_data =
+			ia_css_isp_dvs2_statistics_allocate(dvs_grid_info);
 		if (!dis_buf->dis_data) {
 			dev_err(isp->dev, "dvs buf allocation failed.\n");
 			if (s3a_buf)
-				ia_css_isp_3a_statistics_free(s3a_buf->s3a_data);
+				ia_css_isp_3a_statistics_free(
+					s3a_buf->s3a_data);
 			return -EINVAL;
 		}
 
 		dvs_ptr = hmm_vmap(dis_buf->dis_data->data_ptr, true);
 		dis_buf->dvs_map = ia_css_isp_dvs_statistics_map_allocate(
-				       dis_buf->dis_data, dvs_ptr);
+			dis_buf->dis_data, dvs_ptr);
 	}
 
-	if (asd->stream_env[stream_id].stream_info.
-	    metadata_info.size && md_buf) {
+	if (asd->stream_env[stream_id].stream_info.metadata_info.size &&
+	    md_buf) {
 		md_buf->metadata = ia_css_metadata_allocate(
-				       &asd->stream_env[stream_id].stream_info.metadata_info);
+			&asd->stream_env[stream_id].stream_info.metadata_info);
 		if (!md_buf->metadata) {
 			if (s3a_buf)
-				ia_css_isp_3a_statistics_free(s3a_buf->s3a_data);
+				ia_css_isp_3a_statistics_free(
+					s3a_buf->s3a_data);
 			if (dis_buf)
-				ia_css_isp_dvs2_statistics_free(dis_buf->dis_data);
+				ia_css_isp_dvs2_statistics_free(
+					dis_buf->dis_data);
 			dev_err(isp->dev, "metadata buf allocation failed.\n");
 			return -EINVAL;
 		}
@@ -1179,7 +1163,7 @@ void atomisp_css_free_stat_buffers(struct atomisp_sub_device *asd)
 	struct atomisp_dis_buf *dis_buf, *_dis_buf;
 	struct atomisp_metadata_buf *md_buf, *_md_buf;
 	struct ia_css_dvs_grid_info *dvs_grid_info =
-	    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
+		atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
 	unsigned int i;
 
 	/* 3A statistics use vmalloc, DIS use kmalloc */
@@ -1193,8 +1177,8 @@ void atomisp_css_free_stat_buffers(struct atomisp_sub_device *asd)
 		asd->params.dvs_hor_coef_bytes = 0;
 		asd->params.dvs_ver_coef_bytes = 0;
 		asd->params.dis_proj_data_valid = false;
-		list_for_each_entry_safe(dis_buf, _dis_buf,
-					 &asd->dis_stats, list) {
+		list_for_each_entry_safe(dis_buf, _dis_buf, &asd->dis_stats,
+					 list) {
 			atomisp_css_free_dis_buffer(dis_buf);
 			list_del(&dis_buf->list);
 			kfree(dis_buf);
@@ -1210,8 +1194,8 @@ void atomisp_css_free_stat_buffers(struct atomisp_sub_device *asd)
 		ia_css_3a_statistics_free(asd->params.s3a_user_stat);
 		asd->params.s3a_user_stat = NULL;
 		asd->params.s3a_output_bytes = 0;
-		list_for_each_entry_safe(s3a_buf, _s3a_buf,
-					 &asd->s3a_stats, list) {
+		list_for_each_entry_safe(s3a_buf, _s3a_buf, &asd->s3a_stats,
+					 list) {
 			atomisp_css_free_3a_buffer(s3a_buf);
 			list_del(&s3a_buf->list);
 			kfree(s3a_buf);
@@ -1236,8 +1220,8 @@ void atomisp_css_free_stat_buffers(struct atomisp_sub_device *asd)
 	}
 
 	for (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {
-		list_for_each_entry_safe(md_buf, _md_buf,
-					 &asd->metadata[i], list) {
+		list_for_each_entry_safe(md_buf, _md_buf, &asd->metadata[i],
+					 list) {
 			atomisp_css_free_metadata_buffer(md_buf);
 			list_del(&md_buf->list);
 			kfree(md_buf);
@@ -1265,15 +1249,15 @@ int atomisp_css_get_grid_info(struct atomisp_sub_device *asd,
 	struct ia_css_pipe_info p_info;
 	struct ia_css_grid_info old_info;
 	struct atomisp_device *isp = asd->isp;
-	int md_width = asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].
-		       stream_config.metadata_config.resolution.width;
+	int md_width = asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
+			       .stream_config.metadata_config.resolution.width;
 
 	memset(&p_info, 0, sizeof(struct ia_css_pipe_info));
 	memset(&old_info, 0, sizeof(struct ia_css_grid_info));
 
 	if (ia_css_pipe_get_info(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].pipes[pipe_id],
-		&p_info) != 0) {
+		    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].pipes[pipe_id],
+		    &p_info) != 0) {
 		dev_err(isp->dev, "ia_css_pipe_get_info failed\n");
 		return -EINVAL;
 	}
@@ -1288,7 +1272,8 @@ int atomisp_css_get_grid_info(struct atomisp_sub_device *asd,
 	 */
 	if (asd->params.curr_grid_info.s3a_grid.enable) {
 		if (asd->params.s3a_enabled_pipe != IA_CSS_PIPE_ID_NUM)
-			dev_dbg(isp->dev, "css pipe %d enabled s3a grid replaced by: %d.\n",
+			dev_dbg(isp->dev,
+				"css pipe %d enabled s3a grid replaced by: %d.\n",
 				asd->params.s3a_enabled_pipe, pipe_id);
 		asd->params.s3a_enabled_pipe = pipe_id;
 	}
@@ -1296,11 +1281,12 @@ int atomisp_css_get_grid_info(struct atomisp_sub_device *asd,
 	/* If the grid info has not changed and the buffers for 3A and
 	 * DIS statistics buffers are allocated or buffer size would be zero
 	 * then no need to do anything. */
-	if (((!memcmp(&old_info, &asd->params.curr_grid_info, sizeof(old_info))
-	      && asd->params.s3a_user_stat && asd->params.dvs_stat)
-	     || asd->params.curr_grid_info.s3a_grid.width == 0
-	     || asd->params.curr_grid_info.s3a_grid.height == 0)
-	    && asd->params.metadata_width_size == md_width) {
+	if (((!memcmp(&old_info, &asd->params.curr_grid_info,
+		      sizeof(old_info)) &&
+	      asd->params.s3a_user_stat && asd->params.dvs_stat) ||
+	     asd->params.curr_grid_info.s3a_grid.width == 0 ||
+	     asd->params.curr_grid_info.s3a_grid.height == 0) &&
+	    asd->params.metadata_width_size == md_width) {
 		dev_dbg(isp->dev,
 			"grid info change escape. memcmp=%d, s3a_user_stat=%d,dvs_stat=%d, s3a.width=%d, s3a.height=%d, metadata width =%d\n",
 			!memcmp(&old_info, &asd->params.curr_grid_info,
@@ -1323,14 +1309,14 @@ int atomisp_alloc_3a_output_buf(struct atomisp_sub_device *asd)
 		return 0;
 
 	asd->params.s3a_user_stat = ia_css_3a_statistics_allocate(
-					&asd->params.curr_grid_info.s3a_grid);
+		&asd->params.curr_grid_info.s3a_grid);
 	if (!asd->params.s3a_user_stat)
 		return -ENOMEM;
 	/* 3A statistics. These can be big, so we use vmalloc. */
 	asd->params.s3a_output_bytes =
-	    asd->params.curr_grid_info.s3a_grid.width *
-	    asd->params.curr_grid_info.s3a_grid.height *
-	    sizeof(*asd->params.s3a_user_stat->data);
+		asd->params.curr_grid_info.s3a_grid.width *
+		asd->params.curr_grid_info.s3a_grid.height *
+		sizeof(*asd->params.s3a_user_stat->data);
 
 	return 0;
 }
@@ -1338,7 +1324,7 @@ int atomisp_alloc_3a_output_buf(struct atomisp_sub_device *asd)
 int atomisp_alloc_dis_coef_buf(struct atomisp_sub_device *asd)
 {
 	struct ia_css_dvs_grid_info *dvs_grid =
-	    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
+		atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
 
 	if (!dvs_grid)
 		return 0;
@@ -1349,16 +1335,18 @@ int atomisp_alloc_dis_coef_buf(struct atomisp_sub_device *asd)
 	}
 
 	/* DIS coefficients. */
-	asd->params.css_param.dvs2_coeff = ia_css_dvs2_coefficients_allocate(
-					       dvs_grid);
+	asd->params.css_param.dvs2_coeff =
+		ia_css_dvs2_coefficients_allocate(dvs_grid);
 	if (!asd->params.css_param.dvs2_coeff)
 		return -ENOMEM;
 
-	asd->params.dvs_hor_coef_bytes = dvs_grid->num_hor_coefs *
-					 sizeof(*asd->params.css_param.dvs2_coeff->hor_coefs.odd_real);
+	asd->params.dvs_hor_coef_bytes =
+		dvs_grid->num_hor_coefs *
+		sizeof(*asd->params.css_param.dvs2_coeff->hor_coefs.odd_real);
 
-	asd->params.dvs_ver_coef_bytes = dvs_grid->num_ver_coefs *
-					 sizeof(*asd->params.css_param.dvs2_coeff->ver_coefs.odd_real);
+	asd->params.dvs_ver_coef_bytes =
+		dvs_grid->num_ver_coefs *
+		sizeof(*asd->params.css_param.dvs2_coeff->ver_coefs.odd_real);
 
 	/* DIS projections. */
 	asd->params.dis_proj_data_valid = false;
@@ -1367,12 +1355,12 @@ int atomisp_alloc_dis_coef_buf(struct atomisp_sub_device *asd)
 		return -ENOMEM;
 
 	asd->params.dvs_hor_proj_bytes =
-	    dvs_grid->aligned_height * dvs_grid->aligned_width *
-	    sizeof(*asd->params.dvs_stat->hor_prod.odd_real);
+		dvs_grid->aligned_height * dvs_grid->aligned_width *
+		sizeof(*asd->params.dvs_stat->hor_prod.odd_real);
 
 	asd->params.dvs_ver_proj_bytes =
-	    dvs_grid->aligned_height * dvs_grid->aligned_width *
-	    sizeof(*asd->params.dvs_stat->ver_prod.odd_real);
+		dvs_grid->aligned_height * dvs_grid->aligned_width *
+		sizeof(*asd->params.dvs_stat->ver_prod.odd_real);
 
 	return 0;
 }
@@ -1384,9 +1372,10 @@ int atomisp_alloc_metadata_output_buf(struct atomisp_sub_device *asd)
 	/* We allocate the cpu-side buffer used for communication with user
 	 * space */
 	for (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {
-		asd->params.metadata_user[i] = kvmalloc(
-						   asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].
-						   stream_info.metadata_info.size, GFP_KERNEL);
+		asd->params.metadata_user[i] =
+			kvmalloc(asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
+					 .stream_info.metadata_info.size,
+				 GFP_KERNEL);
 		if (!asd->params.metadata_user[i]) {
 			while (--i >= 0) {
 				kvfree(asd->params.metadata_user[i]);
@@ -1433,7 +1422,7 @@ int atomisp_css_isys_set_resolution(struct atomisp_sub_device *asd,
 				    int isys_stream)
 {
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 
 	if (isys_stream >= IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH)
 		return -EINVAL;
@@ -1448,7 +1437,7 @@ int atomisp_css_input_set_resolution(struct atomisp_sub_device *asd,
 				     struct v4l2_mbus_framefmt *ffmt)
 {
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 
 	s_config->input_config.input_res.width = ffmt->width;
 	s_config->input_config.input_res.height = ffmt->height;
@@ -1456,11 +1445,11 @@ int atomisp_css_input_set_resolution(struct atomisp_sub_device *asd,
 }
 
 void atomisp_css_input_set_binning_factor(struct atomisp_sub_device *asd,
-	enum atomisp_input_stream_id stream_id,
-	unsigned int bin_factor)
+					  enum atomisp_input_stream_id stream_id,
+					  unsigned int bin_factor)
 {
-	asd->stream_env[stream_id]
-	.stream_config.sensor_binning_factor = bin_factor;
+	asd->stream_env[stream_id].stream_config.sensor_binning_factor =
+		bin_factor;
 }
 
 void atomisp_css_input_set_bayer_order(struct atomisp_sub_device *asd,
@@ -1468,28 +1457,26 @@ void atomisp_css_input_set_bayer_order(struct atomisp_sub_device *asd,
 				       enum ia_css_bayer_order bayer_order)
 {
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 	s_config->input_config.bayer_order = bayer_order;
 }
 
 void atomisp_css_isys_set_link(struct atomisp_sub_device *asd,
-			       enum atomisp_input_stream_id stream_id,
-			       int link,
+			       enum atomisp_input_stream_id stream_id, int link,
 			       int isys_stream)
 {
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 
 	s_config->isys_config[isys_stream].linked_isys_stream_id = link;
 }
 
 void atomisp_css_isys_set_valid(struct atomisp_sub_device *asd,
 				enum atomisp_input_stream_id stream_id,
-				bool valid,
-				int isys_stream)
+				bool valid, int isys_stream)
 {
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 
 	s_config->isys_config[isys_stream].valid = valid;
 }
@@ -1500,7 +1487,7 @@ void atomisp_css_isys_set_format(struct atomisp_sub_device *asd,
 				 int isys_stream)
 {
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 
 	s_config->isys_config[isys_stream].format = format;
 }
@@ -1510,7 +1497,7 @@ void atomisp_css_input_set_format(struct atomisp_sub_device *asd,
 				  enum atomisp_input_format format)
 {
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 
 	s_config->input_config.format = format;
 }
@@ -1521,7 +1508,7 @@ int atomisp_css_set_default_isys_config(struct atomisp_sub_device *asd,
 {
 	int i;
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 	/*
 	 * Set all isys configs to not valid.
 	 * Currently we support only one stream per channel
@@ -1544,50 +1531,47 @@ int atomisp_css_set_default_isys_config(struct atomisp_sub_device *asd,
 }
 
 void atomisp_css_isys_two_stream_cfg_update_stream1(
-    struct atomisp_sub_device *asd,
-    enum atomisp_input_stream_id stream_id,
-    enum atomisp_input_format input_format,
-    unsigned int width, unsigned int height)
+	struct atomisp_sub_device *asd, enum atomisp_input_stream_id stream_id,
+	enum atomisp_input_format input_format, unsigned int width,
+	unsigned int height)
 {
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 
 	s_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_0].input_res.width =
-	    width;
+		width;
 	s_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_0].input_res.height =
-	    height;
+		height;
 	s_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_0].format =
-	    input_format;
+		input_format;
 	s_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_0].valid = true;
 }
 
 void atomisp_css_isys_two_stream_cfg_update_stream2(
-    struct atomisp_sub_device *asd,
-    enum atomisp_input_stream_id stream_id,
-    enum atomisp_input_format input_format,
-    unsigned int width, unsigned int height)
+	struct atomisp_sub_device *asd, enum atomisp_input_stream_id stream_id,
+	enum atomisp_input_format input_format, unsigned int width,
+	unsigned int height)
 {
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 
 	s_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1].input_res.width =
-	    width;
+		width;
 	s_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1].input_res.height =
-	    height;
-	s_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1].linked_isys_stream_id
-	    = IA_CSS_STREAM_ISYS_STREAM_0;
+		height;
+	s_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1]
+		.linked_isys_stream_id = IA_CSS_STREAM_ISYS_STREAM_0;
 	s_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1].format =
-	    input_format;
+		input_format;
 	s_config->isys_config[IA_CSS_STREAM_ISYS_STREAM_1].valid = true;
 }
 
 int atomisp_css_input_set_effective_resolution(
-    struct atomisp_sub_device *asd,
-    enum atomisp_input_stream_id stream_id,
-    unsigned int width, unsigned int height)
+	struct atomisp_sub_device *asd, enum atomisp_input_stream_id stream_id,
+	unsigned int width, unsigned int height)
 {
 	struct ia_css_stream_config *s_config =
-		    &asd->stream_env[stream_id].stream_config;
+		&asd->stream_env[stream_id].stream_config;
 	s_config->input_config.effective_res.width = width;
 	s_config->input_config.effective_res.height = height;
 	return 0;
@@ -1597,26 +1581,27 @@ void atomisp_css_video_set_dis_envelope(struct atomisp_sub_device *asd,
 					unsigned int dvs_w, unsigned int dvs_h)
 {
 	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-	.pipe_configs[IA_CSS_PIPE_ID_VIDEO].dvs_envelope.width = dvs_w;
+		.pipe_configs[IA_CSS_PIPE_ID_VIDEO]
+		.dvs_envelope.width = dvs_w;
 	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-	.pipe_configs[IA_CSS_PIPE_ID_VIDEO].dvs_envelope.height = dvs_h;
+		.pipe_configs[IA_CSS_PIPE_ID_VIDEO]
+		.dvs_envelope.height = dvs_h;
 }
 
-void atomisp_css_input_set_two_pixels_per_clock(
-    struct atomisp_sub_device *asd,
-    bool two_ppc)
+void atomisp_css_input_set_two_pixels_per_clock(struct atomisp_sub_device *asd,
+						bool two_ppc)
 {
 	int i;
 
 	if (asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-	    .stream_config.pixels_per_clock == (two_ppc ? 2 : 1))
+		    .stream_config.pixels_per_clock == (two_ppc ? 2 : 1))
 		return;
 
 	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-	.stream_config.pixels_per_clock = (two_ppc ? 2 : 1);
+		.stream_config.pixels_per_clock = (two_ppc ? 2 : 1);
 	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.update_pipe[i] = true;
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].update_pipe[i] =
+			true;
 }
 
 void atomisp_css_enable_dz(struct atomisp_sub_device *asd, bool enable)
@@ -1625,21 +1610,22 @@ void atomisp_css_enable_dz(struct atomisp_sub_device *asd, bool enable)
 
 	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
 		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.pipe_configs[i].enable_dz = enable;
+			.pipe_configs[i]
+			.enable_dz = enable;
 }
 
 void atomisp_css_capture_set_mode(struct atomisp_sub_device *asd,
 				  enum ia_css_capture_mode mode)
 {
 	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
+		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
 
 	if (stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE]
-	    .default_capture_config.mode == mode)
+		    .default_capture_config.mode == mode)
 		return;
 
-	stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE].
-	default_capture_config.mode = mode;
+	stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE]
+		.default_capture_config.mode = mode;
 	stream_env->update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;
 }
 
@@ -1662,25 +1648,24 @@ void atomisp_css_input_set_mode(struct atomisp_sub_device *asd,
 		 * Here using a large safe value.
 		 */
 		struct ia_css_stream_config *s_config =
-			    &asd->stream_env[i].stream_config;
+			&asd->stream_env[i].stream_config;
 
 		if (s_config->input_config.input_res.width == 0)
 			continue;
 
 		if (ia_css_mipi_frame_calculate_size(
-			s_config->input_config.input_res.width,
-			s_config->input_config.input_res.height,
-			s_config->input_config.format,
-			true,
-			0x13000,
-			&size_mem_words) != 0) {
+			    s_config->input_config.input_res.width,
+			    s_config->input_config.input_res.height,
+			    s_config->input_config.format, true, 0x13000,
+			    &size_mem_words) != 0) {
 			if (IS_MRFD)
 				size_mem_words = CSS_MIPI_FRAME_BUFFER_SIZE_2;
 			else
 				size_mem_words = CSS_MIPI_FRAME_BUFFER_SIZE_1;
-			dev_warn(asd->isp->dev,
-				 "ia_css_mipi_frame_calculate_size failed,applying pre-defined MIPI buffer size %u.\n",
-				 size_mem_words);
+			dev_warn(
+				asd->isp->dev,
+				"ia_css_mipi_frame_calculate_size failed,applying pre-defined MIPI buffer size %u.\n",
+				size_mem_words);
 		}
 		s_config->mipi_buffer_config.size_mem_words = size_mem_words;
 		s_config->mipi_buffer_config.nof_mipi_buffers = 2;
@@ -1690,8 +1675,7 @@ void atomisp_css_input_set_mode(struct atomisp_sub_device *asd,
 void atomisp_css_capture_enable_online(struct atomisp_sub_device *asd,
 				       unsigned short stream_index, bool enable)
 {
-	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[stream_index];
+	struct atomisp_stream_env *stream_env = &asd->stream_env[stream_index];
 
 	if (stream_env->stream_config.online == !!enable)
 		return;
@@ -1703,8 +1687,7 @@ void atomisp_css_capture_enable_online(struct atomisp_sub_device *asd,
 void atomisp_css_preview_enable_online(struct atomisp_sub_device *asd,
 				       unsigned short stream_index, bool enable)
 {
-	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[stream_index];
+	struct atomisp_stream_env *stream_env = &asd->stream_env[stream_index];
 	int i;
 
 	if (stream_env->stream_config.online != !!enable) {
@@ -1715,14 +1698,10 @@ void atomisp_css_preview_enable_online(struct atomisp_sub_device *asd,
 }
 
 int atomisp_css_input_configure_port(
-    struct atomisp_sub_device *asd,
-    enum mipi_port_id port,
-    unsigned int num_lanes,
-    unsigned int timeout,
-    unsigned int mipi_freq,
-    enum atomisp_input_format metadata_format,
-    unsigned int metadata_width,
-    unsigned int metadata_height)
+	struct atomisp_sub_device *asd, enum mipi_port_id port,
+	unsigned int num_lanes, unsigned int timeout, unsigned int mipi_freq,
+	enum atomisp_input_format metadata_format, unsigned int metadata_width,
+	unsigned int metadata_height)
 {
 	int i;
 	struct atomisp_stream_env *stream_env;
@@ -1738,7 +1717,7 @@ int atomisp_css_input_configure_port(
 	 * 10-bit fixed points for improved accuracy.
 	 */
 	const unsigned int rxcount =
-	    min(((mipi_freq / 46000) - 1280) >> 10, 0xffU) * 0x01010101U;
+		min(((mipi_freq / 46000) - 1280) >> 10, 0xffU) * 0x01010101U;
 
 	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
 		stream_env = &asd->stream_env[i];
@@ -1747,12 +1726,12 @@ int atomisp_css_input_configure_port(
 		stream_env->stream_config.source.port.timeout = timeout;
 		if (mipi_freq)
 			stream_env->stream_config.source.port.rxcount = rxcount;
-		stream_env->stream_config.
-		metadata_config.data_type = metadata_format;
-		stream_env->stream_config.
-		metadata_config.resolution.width = metadata_width;
-		stream_env->stream_config.
-		metadata_config.resolution.height = metadata_height;
+		stream_env->stream_config.metadata_config.data_type =
+			metadata_format;
+		stream_env->stream_config.metadata_config.resolution.width =
+			metadata_width;
+		stream_env->stream_config.metadata_config.resolution.height =
+			metadata_height;
 	}
 
 	return 0;
@@ -1781,12 +1760,12 @@ void atomisp_css_stop(struct atomisp_sub_device *asd, bool in_reset)
 			stream_env = &asd->stream_env[i];
 			for (j = 0; j < IA_CSS_PIPE_ID_NUM; j++) {
 				ia_css_pipe_config_defaults(
-				    &stream_env->pipe_configs[j]);
+					&stream_env->pipe_configs[j]);
 				ia_css_pipe_extra_config_defaults(
-				    &stream_env->pipe_extra_configs[j]);
+					&stream_env->pipe_extra_configs[j]);
 			}
 			ia_css_stream_config_defaults(
-			    &stream_env->stream_config);
+				&stream_env->stream_config);
 		}
 		memset(&asd->params.config, 0, sizeof(asd->params.config));
 		asd->params.css_update_params_needed = false;
@@ -1811,37 +1790,36 @@ void atomisp_css_stop(struct atomisp_sub_device *asd, bool in_reset)
 	memset(&asd->params.css_param, 0, sizeof(asd->params.css_param));
 }
 
-void atomisp_css_continuous_set_num_raw_frames(
-     struct atomisp_sub_device *asd,
-     int num_frames)
+void atomisp_css_continuous_set_num_raw_frames(struct atomisp_sub_device *asd,
+					       int num_frames)
 {
 	if (asd->enable_raw_buffer_lock->val) {
 		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.stream_config.init_num_cont_raw_buf =
-		    ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES_LOCK_EN;
+			.stream_config.init_num_cont_raw_buf =
+			ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES_LOCK_EN;
 		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&
 		    asd->params.video_dis_en)
 			asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-			.stream_config.init_num_cont_raw_buf +=
-			    ATOMISP_CSS2_NUM_DVS_FRAME_DELAY;
+				.stream_config.init_num_cont_raw_buf +=
+				ATOMISP_CSS2_NUM_DVS_FRAME_DELAY;
 	} else {
 		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.stream_config.init_num_cont_raw_buf =
-		    ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES;
+			.stream_config.init_num_cont_raw_buf =
+			ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES;
 	}
 
 	if (asd->params.video_dis_en)
 		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.stream_config.init_num_cont_raw_buf +=
-		    ATOMISP_CSS2_NUM_DVS_FRAME_DELAY;
+			.stream_config.init_num_cont_raw_buf +=
+			ATOMISP_CSS2_NUM_DVS_FRAME_DELAY;
 
 	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-	.stream_config.target_num_cont_raw_buf = num_frames;
+		.stream_config.target_num_cont_raw_buf = num_frames;
 }
 
-static enum ia_css_pipe_mode __pipe_id_to_pipe_mode(
-    struct atomisp_sub_device *asd,
-    enum ia_css_pipe_id pipe_id)
+static enum ia_css_pipe_mode
+__pipe_id_to_pipe_mode(struct atomisp_sub_device *asd,
+		       enum ia_css_pipe_id pipe_id)
 {
 	struct atomisp_device *isp = asd->isp;
 	struct camera_mipi_info *mipi_info = atomisp_to_sensor_mipi_info(
@@ -1854,7 +1832,7 @@ static enum ia_css_pipe_mode __pipe_id_to_pipe_mode(
 		 * YUV420_Legacy format.
 		 */
 		if (mipi_info && mipi_info->input_format ==
-		    ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY)
+					 ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY)
 			return IA_CSS_PIPE_MODE_YUVPP;
 		return IA_CSS_PIPE_MODE_COPY;
 	case IA_CSS_PIPE_ID_PREVIEW:
@@ -1872,25 +1850,24 @@ static enum ia_css_pipe_mode __pipe_id_to_pipe_mode(
 }
 
 static void __configure_output(struct atomisp_sub_device *asd,
-			       unsigned int stream_index,
-			       unsigned int width, unsigned int height,
-			       unsigned int min_width,
+			       unsigned int stream_index, unsigned int width,
+			       unsigned int height, unsigned int min_width,
 			       enum ia_css_frame_format format,
 			       enum ia_css_pipe_id pipe_id)
 {
 	struct atomisp_device *isp = asd->isp;
-	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[stream_index];
+	struct atomisp_stream_env *stream_env = &asd->stream_env[stream_index];
 	struct ia_css_stream_config *s_config = &stream_env->stream_config;
 
 	stream_env->pipe_configs[pipe_id].mode =
-	    __pipe_id_to_pipe_mode(asd, pipe_id);
+		__pipe_id_to_pipe_mode(asd, pipe_id);
 	stream_env->update_pipe[pipe_id] = true;
 
 	stream_env->pipe_configs[pipe_id].output_info[0].res.width = width;
 	stream_env->pipe_configs[pipe_id].output_info[0].res.height = height;
 	stream_env->pipe_configs[pipe_id].output_info[0].format = format;
-	stream_env->pipe_configs[pipe_id].output_info[0].padded_width = min_width;
+	stream_env->pipe_configs[pipe_id].output_info[0].padded_width =
+		min_width;
 
 	/* isp binary 2.2 specific setting*/
 	if (width > s_config->input_config.effective_res.width ||
@@ -1908,17 +1885,18 @@ static void __configure_output(struct atomisp_sub_device *asd,
  * downscaling input resolution.
  */
 static void __configure_capture_pp_input(struct atomisp_sub_device *asd,
-	unsigned int width, unsigned int height,
-	enum ia_css_pipe_id pipe_id)
+					 unsigned int width,
+					 unsigned int height,
+					 enum ia_css_pipe_id pipe_id)
 {
 	struct atomisp_device *isp = asd->isp;
 	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
+		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
 	struct ia_css_stream_config *stream_config = &stream_env->stream_config;
 	struct ia_css_pipe_config *pipe_configs =
-		    &stream_env->pipe_configs[pipe_id];
+		&stream_env->pipe_configs[pipe_id];
 	struct ia_css_pipe_extra_config *pipe_extra_configs =
-		    &stream_env->pipe_extra_configs[pipe_id];
+		&stream_env->pipe_extra_configs[pipe_id];
 	unsigned int hor_ds_factor = 0, ver_ds_factor = 0;
 
 	if (width == 0 && height == 0)
@@ -1928,14 +1906,15 @@ static void __configure_capture_pp_input(struct atomisp_sub_device *asd,
 	    height * 9 / 10 < pipe_configs->output_info[0].res.height)
 		return;
 	/* here just copy the calculation in css */
-	hor_ds_factor = CEIL_DIV(width >> 1,
-				 pipe_configs->output_info[0].res.width);
-	ver_ds_factor = CEIL_DIV(height >> 1,
-				 pipe_configs->output_info[0].res.height);
-
-	if ((asd->isp->media_dev.hw_revision <
-	     (ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT) ||
-	     IS_CHT) && hor_ds_factor != ver_ds_factor) {
+	hor_ds_factor =
+		CEIL_DIV(width >> 1, pipe_configs->output_info[0].res.width);
+	ver_ds_factor =
+		CEIL_DIV(height >> 1, pipe_configs->output_info[0].res.height);
+
+	if ((asd->isp->media_dev.hw_revision < (ATOMISP_HW_REVISION_ISP2401
+						<< ATOMISP_HW_REVISION_SHIFT) ||
+	     IS_CHT) &&
+	    hor_ds_factor != ver_ds_factor) {
 		dev_warn(asd->isp->dev,
 			 "Cropping for capture due to FW limitation");
 		return;
@@ -1947,9 +1926,9 @@ static void __configure_capture_pp_input(struct atomisp_sub_device *asd,
 	pipe_extra_configs->enable_yuv_ds = true;
 
 	pipe_configs->capt_pp_in_res.width =
-	    stream_config->input_config.effective_res.width;
+		stream_config->input_config.effective_res.width;
 	pipe_configs->capt_pp_in_res.height =
-	    stream_config->input_config.effective_res.height;
+		stream_config->input_config.effective_res.height;
 
 	dev_dbg(isp->dev, "configuring pipe[%d]capture pp input w=%d.h=%d.\n",
 		pipe_id, width, height);
@@ -1960,26 +1939,28 @@ static void __configure_capture_pp_input(struct atomisp_sub_device *asd,
  * yuv downscaling, which needs addtional configurations.
  */
 static void __configure_preview_pp_input(struct atomisp_sub_device *asd,
-	unsigned int width, unsigned int height,
-	enum ia_css_pipe_id pipe_id)
+					 unsigned int width,
+					 unsigned int height,
+					 enum ia_css_pipe_id pipe_id)
 {
 	struct atomisp_device *isp = asd->isp;
 	int out_width, out_height, yuv_ds_in_width, yuv_ds_in_height;
 	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
+		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
 	struct ia_css_stream_config *stream_config = &stream_env->stream_config;
 	struct ia_css_pipe_config *pipe_configs =
-		    &stream_env->pipe_configs[pipe_id];
+		&stream_env->pipe_configs[pipe_id];
 	struct ia_css_pipe_extra_config *pipe_extra_configs =
-		    &stream_env->pipe_extra_configs[pipe_id];
+		&stream_env->pipe_extra_configs[pipe_id];
 	struct ia_css_resolution *bayer_ds_out_res =
-		    &pipe_configs->bayer_ds_out_res;
-	struct ia_css_resolution *vf_pp_in_res =
-		    &pipe_configs->vf_pp_in_res;
-	struct ia_css_resolution  *effective_res =
-		    &stream_config->input_config.effective_res;
-
-	static const struct bayer_ds_factor bds_fct[] = {{2, 1}, {3, 2}, {5, 4} };
+		&pipe_configs->bayer_ds_out_res;
+	struct ia_css_resolution *vf_pp_in_res = &pipe_configs->vf_pp_in_res;
+	struct ia_css_resolution *effective_res =
+		&stream_config->input_config.effective_res;
+
+	static const struct bayer_ds_factor bds_fct[] = { { 2, 1 },
+							  { 3, 2 },
+							  { 5, 4 } };
 	/*
 	 * BZ201033: YUV decimation factor of 4 causes couple of rightmost
 	 * columns to be shaded. Remove this factor to work around the CSS bug.
@@ -2027,18 +2008,20 @@ static void __configure_preview_pp_input(struct atomisp_sub_device *asd,
 		bayer_ds_out_res->height = effective_res->height;
 
 		for (i = 0; i < ARRAY_SIZE(bds_fct); i++) {
-			if (effective_res->width >= out_width *
-			    bds_fct[i].numerator / bds_fct[i].denominator &&
-			    effective_res->height >= out_height *
-			    bds_fct[i].numerator / bds_fct[i].denominator) {
+			if (effective_res->width >=
+				    out_width * bds_fct[i].numerator /
+					    bds_fct[i].denominator &&
+			    effective_res->height >=
+				    out_height * bds_fct[i].numerator /
+					    bds_fct[i].denominator) {
 				bayer_ds_out_res->width =
-				    effective_res->width *
-				    bds_fct[i].denominator /
-				    bds_fct[i].numerator;
+					effective_res->width *
+					bds_fct[i].denominator /
+					bds_fct[i].numerator;
 				bayer_ds_out_res->height =
-				    effective_res->height *
-				    bds_fct[i].denominator /
-				    bds_fct[i].numerator;
+					effective_res->height *
+					bds_fct[i].denominator /
+					bds_fct[i].numerator;
 				break;
 			}
 		}
@@ -2065,7 +2048,8 @@ static void __configure_preview_pp_input(struct atomisp_sub_device *asd,
 		if (yuv_ds_in_width >= out_width * yuv_dec_fct[i] &&
 		    yuv_ds_in_height >= out_height * yuv_dec_fct[i]) {
 			vf_pp_in_res->width = yuv_ds_in_width / yuv_dec_fct[i];
-			vf_pp_in_res->height = yuv_ds_in_height / yuv_dec_fct[i];
+			vf_pp_in_res->height =
+				yuv_ds_in_height / yuv_dec_fct[i];
 			break;
 		}
 	}
@@ -2094,19 +2078,19 @@ static void __configure_video_pp_input(struct atomisp_sub_device *asd,
 	struct atomisp_device *isp = asd->isp;
 	int out_width, out_height;
 	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
+		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
 	struct ia_css_stream_config *stream_config = &stream_env->stream_config;
 	struct ia_css_pipe_config *pipe_configs =
-		    &stream_env->pipe_configs[pipe_id];
+		&stream_env->pipe_configs[pipe_id];
 	struct ia_css_pipe_extra_config *pipe_extra_configs =
-		    &stream_env->pipe_extra_configs[pipe_id];
+		&stream_env->pipe_extra_configs[pipe_id];
 	struct ia_css_resolution *bayer_ds_out_res =
-		    &pipe_configs->bayer_ds_out_res;
-	struct ia_css_resolution  *effective_res =
-		    &stream_config->input_config.effective_res;
+		&pipe_configs->bayer_ds_out_res;
+	struct ia_css_resolution *effective_res =
+		&stream_config->input_config.effective_res;
 
 	static const struct bayer_ds_factor bds_factors[] = {
-		{8, 1}, {6, 1}, {4, 1}, {3, 1}, {2, 1}, {3, 2}
+		{ 8, 1 }, { 6, 1 }, { 4, 1 }, { 3, 1 }, { 2, 1 }, { 3, 2 }
 	};
 	unsigned int i;
 
@@ -2128,7 +2112,8 @@ static void __configure_video_pp_input(struct atomisp_sub_device *asd,
 	/* taking at least 10% as envelope */
 	if (asd->params.video_dis_en) {
 		out_width = pipe_configs->output_info[0].res.width * 110 / 100;
-		out_height = pipe_configs->output_info[0].res.height * 110 / 100;
+		out_height =
+			pipe_configs->output_info[0].res.height * 110 / 100;
 	} else {
 		out_width = pipe_configs->output_info[0].res.width;
 		out_height = pipe_configs->output_info[0].res.height;
@@ -2152,10 +2137,12 @@ static void __configure_video_pp_input(struct atomisp_sub_device *asd,
 
 	for (i = 0; i < sizeof(bds_factors) / sizeof(struct bayer_ds_factor);
 	     i++) {
-		if (effective_res->width >= out_width *
-		    bds_factors[i].numerator / bds_factors[i].denominator &&
-		    effective_res->height >= out_height *
-		    bds_factors[i].numerator / bds_factors[i].denominator) {
+		if (effective_res->width >=
+			    out_width * bds_factors[i].numerator /
+				    bds_factors[i].denominator &&
+		    effective_res->height >=
+			    out_height * bds_factors[i].numerator /
+				    bds_factors[i].denominator) {
 			bayer_ds_out_res->width = effective_res->width *
 						  bds_factors[i].denominator /
 						  bds_factors[i].numerator;
@@ -2191,16 +2178,16 @@ static void __configure_vf_output(struct atomisp_sub_device *asd,
 {
 	struct atomisp_device *isp = asd->isp;
 	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
+		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
 	stream_env->pipe_configs[pipe_id].mode =
-	    __pipe_id_to_pipe_mode(asd, pipe_id);
+		__pipe_id_to_pipe_mode(asd, pipe_id);
 	stream_env->update_pipe[pipe_id] = true;
 
 	stream_env->pipe_configs[pipe_id].vf_output_info[0].res.width = width;
 	stream_env->pipe_configs[pipe_id].vf_output_info[0].res.height = height;
 	stream_env->pipe_configs[pipe_id].vf_output_info[0].format = format;
 	stream_env->pipe_configs[pipe_id].vf_output_info[0].padded_width =
-	    min_width;
+		min_width;
 	dev_dbg(isp->dev,
 		"configuring pipe[%d] vf output info w=%d.h=%d.f=%d.\n",
 		pipe_id, width, height, format);
@@ -2251,7 +2238,8 @@ static int __get_frame_info(struct atomisp_sub_device *asd,
 		dev_dbg(isp->dev, "getting raw frame info.\n");
 		break;
 	}
-	dev_dbg(isp->dev, "get frame info: w=%d, h=%d, num_invalid_frames %d.\n",
+	dev_dbg(isp->dev,
+		"get frame info: w=%d, h=%d, num_invalid_frames %d.\n",
 		info->res.width, info->res.height, p_info.num_invalid_frames);
 
 	return 0;
@@ -2275,7 +2263,8 @@ static unsigned int atomisp_get_pipe_index(struct atomisp_sub_device *asd)
 		return IA_CSS_PIPE_ID_PREVIEW;
 	}
 
-	dev_warn(asd->isp->dev, "cannot determine pipe-index return default preview pipe\n");
+	dev_warn(asd->isp->dev,
+		 "cannot determine pipe-index return default preview pipe\n");
 	return IA_CSS_PIPE_ID_PREVIEW;
 }
 
@@ -2291,8 +2280,9 @@ int atomisp_get_css_frame_info(struct atomisp_sub_device *asd,
 			       ATOMISP_INPUT_STREAM_VIDEO :
 			       ATOMISP_INPUT_STREAM_GENERAL;
 
-	if (0 != ia_css_pipe_get_info(asd->stream_env[stream_index]
-		.pipes[pipe_index], &info)) {
+	if (0 !=
+	    ia_css_pipe_get_info(
+		    asd->stream_env[stream_index].pipes[pipe_index], &info)) {
 		dev_dbg(isp->dev, "ia_css_pipe_get_info FAILED");
 		return -EINVAL;
 	}
@@ -2307,9 +2297,9 @@ int atomisp_css_copy_configure_output(struct atomisp_sub_device *asd,
 				      unsigned int padded_width,
 				      enum ia_css_frame_format format)
 {
-	asd->stream_env[stream_index].pipe_configs[IA_CSS_PIPE_ID_COPY].
-	default_capture_config.mode =
-	    IA_CSS_CAPTURE_MODE_RAW;
+	asd->stream_env[stream_index]
+		.pipe_configs[IA_CSS_PIPE_ID_COPY]
+		.default_capture_config.mode = IA_CSS_CAPTURE_MODE_RAW;
 
 	__configure_output(asd, stream_index, width, height, padded_width,
 			   format, IA_CSS_PIPE_ID_COPY);
@@ -2317,9 +2307,10 @@ int atomisp_css_copy_configure_output(struct atomisp_sub_device *asd,
 }
 
 int atomisp_css_preview_configure_output(struct atomisp_sub_device *asd,
-	unsigned int width, unsigned int height,
-	unsigned int min_width,
-	enum ia_css_frame_format format)
+					 unsigned int width,
+					 unsigned int height,
+					 unsigned int min_width,
+					 enum ia_css_frame_format format)
 {
 	__configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL, width, height,
 			   min_width, format, IA_CSS_PIPE_ID_PREVIEW);
@@ -2327,9 +2318,10 @@ int atomisp_css_preview_configure_output(struct atomisp_sub_device *asd,
 }
 
 int atomisp_css_capture_configure_output(struct atomisp_sub_device *asd,
-	unsigned int width, unsigned int height,
-	unsigned int min_width,
-	enum ia_css_frame_format format)
+					 unsigned int width,
+					 unsigned int height,
+					 unsigned int min_width,
+					 enum ia_css_frame_format format)
 {
 	__configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL, width, height,
 			   min_width, format, IA_CSS_PIPE_ID_CAPTURE);
@@ -2346,117 +2338,119 @@ int atomisp_css_video_configure_output(struct atomisp_sub_device *asd,
 	return 0;
 }
 
-int atomisp_css_video_configure_viewfinder(
-    struct atomisp_sub_device *asd,
-    unsigned int width, unsigned int height,
-    unsigned int min_width,
-    enum ia_css_frame_format format)
+int atomisp_css_video_configure_viewfinder(struct atomisp_sub_device *asd,
+					   unsigned int width,
+					   unsigned int height,
+					   unsigned int min_width,
+					   enum ia_css_frame_format format)
 {
 	__configure_vf_output(asd, width, height, min_width, format,
 			      IA_CSS_PIPE_ID_VIDEO);
 	return 0;
 }
 
-int atomisp_css_capture_configure_viewfinder(
-    struct atomisp_sub_device *asd,
-    unsigned int width, unsigned int height,
-    unsigned int min_width,
-    enum ia_css_frame_format format)
+int atomisp_css_capture_configure_viewfinder(struct atomisp_sub_device *asd,
+					     unsigned int width,
+					     unsigned int height,
+					     unsigned int min_width,
+					     enum ia_css_frame_format format)
 {
-	__configure_vf_output(asd, width, height, min_width, format, IA_CSS_PIPE_ID_CAPTURE);
+	__configure_vf_output(asd, width, height, min_width, format,
+			      IA_CSS_PIPE_ID_CAPTURE);
 	return 0;
 }
 
-int atomisp_css_video_get_viewfinder_frame_info(
-    struct atomisp_sub_device *asd,
-    struct ia_css_frame_info *info)
+int atomisp_css_video_get_viewfinder_frame_info(struct atomisp_sub_device *asd,
+						struct ia_css_frame_info *info)
 {
 	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
 				ATOMISP_CSS_VF_FRAME, IA_CSS_PIPE_ID_VIDEO);
 }
 
 int atomisp_css_capture_get_viewfinder_frame_info(
-    struct atomisp_sub_device *asd,
-    struct ia_css_frame_info *info)
+	struct atomisp_sub_device *asd, struct ia_css_frame_info *info)
 {
 	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
 				ATOMISP_CSS_VF_FRAME, IA_CSS_PIPE_ID_CAPTURE);
 }
 
-int atomisp_css_copy_get_output_frame_info(
-    struct atomisp_sub_device *asd,
-    unsigned int stream_index,
-    struct ia_css_frame_info *info)
+int atomisp_css_copy_get_output_frame_info(struct atomisp_sub_device *asd,
+					   unsigned int stream_index,
+					   struct ia_css_frame_info *info)
 {
 	return __get_frame_info(asd, stream_index, info,
 				ATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_COPY);
 }
 
-int atomisp_css_preview_get_output_frame_info(
-    struct atomisp_sub_device *asd,
-    struct ia_css_frame_info *info)
+int atomisp_css_preview_get_output_frame_info(struct atomisp_sub_device *asd,
+					      struct ia_css_frame_info *info)
 {
 	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
-				ATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_PREVIEW);
+				ATOMISP_CSS_OUTPUT_FRAME,
+				IA_CSS_PIPE_ID_PREVIEW);
 }
 
-int atomisp_css_capture_get_output_frame_info(
-    struct atomisp_sub_device *asd,
-    struct ia_css_frame_info *info)
+int atomisp_css_capture_get_output_frame_info(struct atomisp_sub_device *asd,
+					      struct ia_css_frame_info *info)
 {
 	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
-				ATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_CAPTURE);
+				ATOMISP_CSS_OUTPUT_FRAME,
+				IA_CSS_PIPE_ID_CAPTURE);
 }
 
-int atomisp_css_video_get_output_frame_info(
-    struct atomisp_sub_device *asd,
-    struct ia_css_frame_info *info)
+int atomisp_css_video_get_output_frame_info(struct atomisp_sub_device *asd,
+					    struct ia_css_frame_info *info)
 {
 	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
 				ATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_VIDEO);
 }
 
-int atomisp_css_preview_configure_pp_input(
-    struct atomisp_sub_device *asd,
-    unsigned int width, unsigned int height)
+int atomisp_css_preview_configure_pp_input(struct atomisp_sub_device *asd,
+					   unsigned int width,
+					   unsigned int height)
 {
 	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	__configure_preview_pp_input(asd, width, height, IA_CSS_PIPE_ID_PREVIEW);
+		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
+	__configure_preview_pp_input(asd, width, height,
+				     IA_CSS_PIPE_ID_PREVIEW);
 
-	if (width > stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE].
-	    capt_pp_in_res.width)
-		__configure_capture_pp_input(asd, width, height, IA_CSS_PIPE_ID_CAPTURE);
+	if (width > stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE]
+			    .capt_pp_in_res.width)
+		__configure_capture_pp_input(asd, width, height,
+					     IA_CSS_PIPE_ID_CAPTURE);
 
 	return 0;
 }
 
-int atomisp_css_capture_configure_pp_input(
-    struct atomisp_sub_device *asd,
-    unsigned int width, unsigned int height)
+int atomisp_css_capture_configure_pp_input(struct atomisp_sub_device *asd,
+					   unsigned int width,
+					   unsigned int height)
 {
-	__configure_capture_pp_input(asd, width, height, IA_CSS_PIPE_ID_CAPTURE);
+	__configure_capture_pp_input(asd, width, height,
+				     IA_CSS_PIPE_ID_CAPTURE);
 	return 0;
 }
 
-int atomisp_css_video_configure_pp_input(
-    struct atomisp_sub_device *asd,
-    unsigned int width, unsigned int height)
+int atomisp_css_video_configure_pp_input(struct atomisp_sub_device *asd,
+					 unsigned int width,
+					 unsigned int height)
 {
 	struct atomisp_stream_env *stream_env =
-		    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
+		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
 
 	__configure_video_pp_input(asd, width, height, IA_CSS_PIPE_ID_VIDEO);
 
-	if (width > stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE].
-	    capt_pp_in_res.width)
-		__configure_capture_pp_input(asd, width, height, IA_CSS_PIPE_ID_CAPTURE);
+	if (width > stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE]
+			    .capt_pp_in_res.width)
+		__configure_capture_pp_input(asd, width, height,
+					     IA_CSS_PIPE_ID_CAPTURE);
 
 	return 0;
 }
 
 int atomisp_css_offline_capture_configure(struct atomisp_sub_device *asd,
-	int num_captures, unsigned int skip, int offset)
+					  int num_captures, unsigned int skip,
+					  int offset)
 {
 	int ret;
 
@@ -2464,8 +2458,8 @@ int atomisp_css_offline_capture_configure(struct atomisp_sub_device *asd,
 		__func__, num_captures, skip, offset);
 
 	ret = ia_css_stream_capture(
-		  asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		  num_captures, skip, offset);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		num_captures, skip, offset);
 	if (ret)
 		return -EINVAL;
 
@@ -2477,8 +2471,7 @@ int atomisp_css_exp_id_capture(struct atomisp_sub_device *asd, int exp_id)
 	int ret;
 
 	ret = ia_css_stream_capture_frame(
-		  asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		  exp_id);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream, exp_id);
 	if (ret == -ENOBUFS) {
 		/* capture cmd queue is full */
 		return -EBUSY;
@@ -2494,8 +2487,7 @@ int atomisp_css_exp_id_unlock(struct atomisp_sub_device *asd, int exp_id)
 	int ret;
 
 	ret = ia_css_unlock_raw_frame(
-		  asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		  exp_id);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream, exp_id);
 	if (ret == -ENOBUFS)
 		return -EAGAIN;
 	else if (ret)
@@ -2504,15 +2496,14 @@ int atomisp_css_exp_id_unlock(struct atomisp_sub_device *asd, int exp_id)
 	return 0;
 }
 
-int atomisp_css_capture_enable_xnr(struct atomisp_sub_device *asd,
-				   bool enable)
+int atomisp_css_capture_enable_xnr(struct atomisp_sub_device *asd, bool enable)
 {
 	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-	.pipe_configs[IA_CSS_PIPE_ID_CAPTURE]
-	.default_capture_config.enable_xnr = enable;
+		.pipe_configs[IA_CSS_PIPE_ID_CAPTURE]
+		.default_capture_config.enable_xnr = enable;
 	asd->params.capture_config.enable_xnr = enable;
 	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-	.update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;
+		.update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;
 
 	return 0;
 }
@@ -2560,10 +2551,11 @@ void atomisp_css_video_set_dis_vector(struct atomisp_sub_device *asd,
 				      struct atomisp_dis_vector *vector)
 {
 	if (!asd->params.config.motion_vector)
-		asd->params.config.motion_vector = &asd->params.css_param.motion_vector;
+		asd->params.config.motion_vector =
+			&asd->params.css_param.motion_vector;
 
-	memset(asd->params.config.motion_vector,
-	       0, sizeof(struct ia_css_vector));
+	memset(asd->params.config.motion_vector, 0,
+	       sizeof(struct ia_css_vector));
 	asd->params.css_param.motion_vector.x = vector->x;
 	asd->params.css_param.motion_vector.y = vector->y;
 }
@@ -2572,7 +2564,7 @@ static int atomisp_compare_dvs_grid(struct atomisp_sub_device *asd,
 				    struct atomisp_dvs_grid_info *atomgrid)
 {
 	struct ia_css_dvs_grid_info *cur =
-	    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
+		atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
 
 	if (!cur) {
 		dev_err(asd->isp->dev, "dvs grid not available!\n");
@@ -2592,8 +2584,8 @@ static int atomisp_compare_dvs_grid(struct atomisp_sub_device *asd,
 	return memcmp(atomgrid, cur, sizeof(*cur));
 }
 
-void  atomisp_css_set_dvs2_coefs(struct atomisp_sub_device *asd,
-				 struct ia_css_dvs2_coefficients *coefs)
+void atomisp_css_set_dvs2_coefs(struct atomisp_sub_device *asd,
+				struct ia_css_dvs2_coefficients *coefs)
 {
 	asd->params.config.dvs2_coefs = coefs;
 }
@@ -2607,14 +2599,10 @@ int atomisp_css_set_dis_coefs(struct atomisp_sub_device *asd,
 		   try again. */
 		return -EAGAIN;
 
-	if (!coefs->hor_coefs.odd_real ||
-	    !coefs->hor_coefs.odd_imag ||
-	    !coefs->hor_coefs.even_real ||
-	    !coefs->hor_coefs.even_imag ||
-	    !coefs->ver_coefs.odd_real ||
-	    !coefs->ver_coefs.odd_imag ||
-	    !coefs->ver_coefs.even_real ||
-	    !coefs->ver_coefs.even_imag ||
+	if (!coefs->hor_coefs.odd_real || !coefs->hor_coefs.odd_imag ||
+	    !coefs->hor_coefs.even_real || !coefs->hor_coefs.even_imag ||
+	    !coefs->ver_coefs.odd_real || !coefs->ver_coefs.odd_imag ||
+	    !coefs->ver_coefs.even_real || !coefs->ver_coefs.even_imag ||
 	    !asd->params.css_param.dvs2_coeff->hor_coefs.odd_real ||
 	    !asd->params.css_param.dvs2_coeff->hor_coefs.odd_imag ||
 	    !asd->params.css_param.dvs2_coeff->hor_coefs.even_real ||
@@ -2626,34 +2614,42 @@ int atomisp_css_set_dis_coefs(struct atomisp_sub_device *asd,
 		return -EINVAL;
 
 	if (copy_from_user(asd->params.css_param.dvs2_coeff->hor_coefs.odd_real,
-			   coefs->hor_coefs.odd_real, asd->params.dvs_hor_coef_bytes))
+			   coefs->hor_coefs.odd_real,
+			   asd->params.dvs_hor_coef_bytes))
 		return -EFAULT;
 	if (copy_from_user(asd->params.css_param.dvs2_coeff->hor_coefs.odd_imag,
-			   coefs->hor_coefs.odd_imag, asd->params.dvs_hor_coef_bytes))
+			   coefs->hor_coefs.odd_imag,
+			   asd->params.dvs_hor_coef_bytes))
 		return -EFAULT;
-	if (copy_from_user(asd->params.css_param.dvs2_coeff->hor_coefs.even_real,
-			   coefs->hor_coefs.even_real, asd->params.dvs_hor_coef_bytes))
+	if (copy_from_user(
+		    asd->params.css_param.dvs2_coeff->hor_coefs.even_real,
+		    coefs->hor_coefs.even_real, asd->params.dvs_hor_coef_bytes))
 		return -EFAULT;
-	if (copy_from_user(asd->params.css_param.dvs2_coeff->hor_coefs.even_imag,
-			   coefs->hor_coefs.even_imag, asd->params.dvs_hor_coef_bytes))
+	if (copy_from_user(
+		    asd->params.css_param.dvs2_coeff->hor_coefs.even_imag,
+		    coefs->hor_coefs.even_imag, asd->params.dvs_hor_coef_bytes))
 		return -EFAULT;
 
 	if (copy_from_user(asd->params.css_param.dvs2_coeff->ver_coefs.odd_real,
-			   coefs->ver_coefs.odd_real, asd->params.dvs_ver_coef_bytes))
+			   coefs->ver_coefs.odd_real,
+			   asd->params.dvs_ver_coef_bytes))
 		return -EFAULT;
 	if (copy_from_user(asd->params.css_param.dvs2_coeff->ver_coefs.odd_imag,
-			   coefs->ver_coefs.odd_imag, asd->params.dvs_ver_coef_bytes))
+			   coefs->ver_coefs.odd_imag,
+			   asd->params.dvs_ver_coef_bytes))
 		return -EFAULT;
-	if (copy_from_user(asd->params.css_param.dvs2_coeff->ver_coefs.even_real,
-			   coefs->ver_coefs.even_real, asd->params.dvs_ver_coef_bytes))
+	if (copy_from_user(
+		    asd->params.css_param.dvs2_coeff->ver_coefs.even_real,
+		    coefs->ver_coefs.even_real, asd->params.dvs_ver_coef_bytes))
 		return -EFAULT;
-	if (copy_from_user(asd->params.css_param.dvs2_coeff->ver_coefs.even_imag,
-			   coefs->ver_coefs.even_imag, asd->params.dvs_ver_coef_bytes))
+	if (copy_from_user(
+		    asd->params.css_param.dvs2_coeff->ver_coefs.even_imag,
+		    coefs->ver_coefs.even_imag, asd->params.dvs_ver_coef_bytes))
 		return -EFAULT;
 
 	asd->params.css_param.update_flag.dvs2_coefs =
 		(struct atomisp_dis_coefficients *)
-		asd->params.css_param.dvs2_coeff;
+			asd->params.css_param.dvs2_coeff;
 	/* FIXME! */
 	/*	asd->params.dis_proj_data_valid = false; */
 	asd->params.css_update_params_needed = true;
@@ -2678,7 +2674,7 @@ void atomisp_css_set_zoom_factor(struct atomisp_sub_device *asd,
 	asd->params.css_param.dz_config.dy = zoom;
 
 	asd->params.css_param.update_flag.dz_config =
-	    (struct atomisp_dz_config *)&asd->params.css_param.dz_config;
+		(struct atomisp_dz_config *)&asd->params.css_param.dz_config;
 	asd->params.css_update_params_needed = true;
 }
 
@@ -2704,8 +2700,8 @@ int atomisp_css_get_wb_config(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.wb_config = &wb_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	memcpy(config, &wb_config, sizeof(*config));
 
 	return 0;
@@ -2727,8 +2723,8 @@ int atomisp_css_get_ob_config(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.ob_config = &ob_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	memcpy(config, &ob_config, sizeof(*config));
 
 	return 0;
@@ -2750,8 +2746,8 @@ int atomisp_css_get_dp_config(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.dp_config = &dp_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	memcpy(config, &dp_config, sizeof(*config));
 
 	return 0;
@@ -2773,8 +2769,8 @@ int atomisp_css_get_de_config(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.de_config = &de_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	memcpy(config, &de_config, sizeof(*config));
 
 	return 0;
@@ -2797,8 +2793,8 @@ int atomisp_css_get_nr_config(struct atomisp_sub_device *asd,
 
 	isp_config.nr_config = &nr_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	memcpy(config, &nr_config, sizeof(*config));
 
 	return 0;
@@ -2820,8 +2816,8 @@ int atomisp_css_get_ee_config(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.ee_config = &ee_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	memcpy(config, &ee_config, sizeof(*config));
 
 	return 0;
@@ -2843,8 +2839,8 @@ int atomisp_css_get_tnr_config(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.tnr_config = &tnr_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	memcpy(config, &tnr_config, sizeof(*config));
 
 	return 0;
@@ -2870,8 +2866,8 @@ int atomisp_css_get_ctc_table(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.ctc_table = tab;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	memcpy(config, tab, sizeof(*tab));
 	vfree(tab);
 
@@ -2898,8 +2894,8 @@ int atomisp_css_get_gamma_table(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.gamma_table = tab;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	memcpy(config, tab, sizeof(*tab));
 	vfree(tab);
 
@@ -2922,8 +2918,8 @@ int atomisp_css_get_gc_config(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.gc_config = &gc_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	/* Get gamma correction params from current setup */
 	memcpy(config, &gc_config, sizeof(*config));
 
@@ -2946,8 +2942,8 @@ int atomisp_css_get_3a_config(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.s3a_config = &s3a_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	/* Get white balance from current setup */
 	memcpy(config, &s3a_config, sizeof(*config));
 
@@ -2970,8 +2966,8 @@ int atomisp_css_get_formats_config(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(isp_config));
 	isp_config.formats_config = &formats_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	/* Get narrow gamma from current setup */
 	memcpy(config, &formats_config, sizeof(*config));
 
@@ -2981,7 +2977,7 @@ int atomisp_css_get_formats_config(struct atomisp_sub_device *asd,
 int atomisp_css_get_zoom_factor(struct atomisp_sub_device *asd,
 				unsigned int *zoom)
 {
-	struct ia_css_dz_config dz_config;  /** Digital Zoom */
+	struct ia_css_dz_config dz_config; /** Digital Zoom */
 	struct ia_css_isp_config isp_config;
 	struct atomisp_device *isp = asd->isp;
 
@@ -2994,8 +2990,8 @@ int atomisp_css_get_zoom_factor(struct atomisp_sub_device *asd,
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.dz_config = &dz_config;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 	*zoom = dz_config.dx;
 
 	return 0;
@@ -3040,14 +3036,13 @@ int atomisp_css_get_dis_stat(struct atomisp_sub_device *asd,
 		return -EAGAIN;
 	}
 
-	dis_buf = list_entry(asd->dis_stats.next,
-			     struct atomisp_dis_buf, list);
+	dis_buf = list_entry(asd->dis_stats.next, struct atomisp_dis_buf, list);
 	list_del_init(&dis_buf->list);
 	spin_unlock_irqrestore(&asd->dis_stats_lock, flags);
 
 	if (dis_buf->dvs_map)
-		ia_css_translate_dvs2_statistics(
-		    asd->params.dvs_stat, dis_buf->dvs_map);
+		ia_css_translate_dvs2_statistics(asd->params.dvs_stat,
+						 dis_buf->dvs_map);
 	else
 		ia_css_get_dvs2_statistics(asd->params.dvs_stat,
 					   dis_buf->dis_data);
@@ -3093,8 +3088,8 @@ int atomisp_css_get_dis_stat(struct atomisp_sub_device *asd,
 	return 0;
 }
 
-struct ia_css_shading_table *atomisp_css_shading_table_alloc(
-    unsigned int width, unsigned int height)
+struct ia_css_shading_table *
+atomisp_css_shading_table_alloc(unsigned int width, unsigned int height)
 {
 	return ia_css_shading_table_alloc(width, height);
 }
@@ -3110,8 +3105,8 @@ void atomisp_css_shading_table_free(struct ia_css_shading_table *table)
 	ia_css_shading_table_free(table);
 }
 
-struct ia_css_morph_table *atomisp_css_morph_table_allocate(
-    unsigned int width, unsigned int height)
+struct ia_css_morph_table *atomisp_css_morph_table_allocate(unsigned int width,
+							    unsigned int height)
 {
 	return ia_css_morph_table_allocate(width, height);
 }
@@ -3129,16 +3124,16 @@ void atomisp_css_get_morph_table(struct atomisp_sub_device *asd,
 	struct atomisp_device *isp = asd->isp;
 
 	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev,
-			"%s called after streamoff, skipping.\n", __func__);
+		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
+			__func__);
 		return;
 	}
 	memset(table, 0, sizeof(struct ia_css_morph_table));
 	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
 	isp_config.morph_table = table;
 	ia_css_stream_get_isp_config(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    &isp_config);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
+		&isp_config);
 }
 
 void atomisp_css_morph_table_free(struct ia_css_morph_table *table)
@@ -3146,9 +3141,10 @@ void atomisp_css_morph_table_free(struct ia_css_morph_table *table)
 	ia_css_morph_table_free(table);
 }
 
-static bool atomisp_css_isr_get_stream_id(struct ia_css_pipe *css_pipe,
-					  struct atomisp_device *isp,
-					  enum atomisp_input_stream_id *stream_id)
+static bool
+atomisp_css_isr_get_stream_id(struct ia_css_pipe *css_pipe,
+			      struct atomisp_device *isp,
+			      enum atomisp_input_stream_id *stream_id)
 {
 	struct atomisp_stream_env *stream_env;
 	int i, j;
@@ -3159,7 +3155,8 @@ static bool atomisp_css_isr_get_stream_id(struct ia_css_pipe *css_pipe,
 	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
 		stream_env = &isp->asd.stream_env[i];
 		for (j = 0; j < IA_CSS_PIPE_ID_NUM; j++) {
-			if (stream_env->pipes[j] && stream_env->pipes[j] == css_pipe) {
+			if (stream_env->pipes[j] &&
+			    stream_env->pipes[j] == css_pipe) {
 				*stream_id = i;
 				return true;
 			}
@@ -3177,8 +3174,7 @@ int atomisp_css_isr_thread(struct atomisp_device *isp)
 	lockdep_assert_held(&isp->mutex);
 
 	while (!ia_css_dequeue_psys_event(&current_event.event)) {
-		if (current_event.event.type ==
-		    IA_CSS_EVENT_TYPE_FW_ASSERT) {
+		if (current_event.event.type == IA_CSS_EVENT_TYPE_FW_ASSERT) {
 			/*
 			 * Received FW assertion signal,
 			 * trigger WDT to recover
@@ -3191,21 +3187,23 @@ int atomisp_css_isr_thread(struct atomisp_device *isp)
 
 			queue_work(system_long_wq, &isp->assert_recovery_work);
 			return -EINVAL;
-		} else if (current_event.event.type == IA_CSS_EVENT_TYPE_FW_WARNING) {
-			dev_warn(isp->dev, "%s: ISP reports warning, code is %d, exp_id %d\n",
-				 __func__, current_event.event.fw_warning,
-				 current_event.event.exp_id);
+		} else if (current_event.event.type ==
+			   IA_CSS_EVENT_TYPE_FW_WARNING) {
+			dev_warn(
+				isp->dev,
+				"%s: ISP reports warning, code is %d, exp_id %d\n",
+				__func__, current_event.event.fw_warning,
+				current_event.event.exp_id);
 			continue;
 		}
 
-		if (!atomisp_css_isr_get_stream_id(current_event.event.pipe, isp, &stream_id)) {
+		if (!atomisp_css_isr_get_stream_id(current_event.event.pipe,
+						   isp, &stream_id)) {
 			if (current_event.event.type == IA_CSS_EVENT_TYPE_TIMER)
-				dev_dbg(isp->dev,
-					"event: Timer event.");
+				dev_dbg(isp->dev, "event: Timer event.");
 			else
 				dev_warn(isp->dev, "%s:no subdev.event:%d",
-					 __func__,
-					 current_event.event.type);
+					 __func__, current_event.event.type);
 			continue;
 		}
 
@@ -3213,27 +3211,27 @@ int atomisp_css_isr_thread(struct atomisp_device *isp)
 		switch (current_event.event.type) {
 		case IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE:
 			dev_dbg(isp->dev, "event: Output frame done");
-			atomisp_buf_done(&isp->asd, 0, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
+			atomisp_buf_done(&isp->asd, 0,
+					 IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
 					 current_event.pipe, true, stream_id);
 			break;
 		case IA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE:
 			dev_dbg(isp->dev, "event: Second output frame done");
-			atomisp_buf_done(&isp->asd, 0, IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME,
+			atomisp_buf_done(&isp->asd, 0,
+					 IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME,
 					 current_event.pipe, true, stream_id);
 			break;
 		case IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE:
 			dev_dbg(isp->dev, "event: 3A stats frame done");
 			atomisp_buf_done(&isp->asd, 0,
 					 IA_CSS_BUFFER_TYPE_3A_STATISTICS,
-					 current_event.pipe,
-					 false, stream_id);
+					 current_event.pipe, false, stream_id);
 			break;
 		case IA_CSS_EVENT_TYPE_METADATA_DONE:
 			dev_dbg(isp->dev, "event: metadata frame done");
 			atomisp_buf_done(&isp->asd, 0,
 					 IA_CSS_BUFFER_TYPE_METADATA,
-					 current_event.pipe,
-					 false, stream_id);
+					 current_event.pipe, false, stream_id);
 			break;
 		case IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE:
 			dev_dbg(isp->dev, "event: VF output frame done");
@@ -3251,8 +3249,7 @@ int atomisp_css_isr_thread(struct atomisp_device *isp)
 			dev_dbg(isp->dev, "event: dis stats frame done");
 			atomisp_buf_done(&isp->asd, 0,
 					 IA_CSS_BUFFER_TYPE_DIS_STATISTICS,
-					 current_event.pipe,
-					 false, stream_id);
+					 current_event.pipe, false, stream_id);
 			break;
 		case IA_CSS_EVENT_TYPE_PIPELINE_DONE:
 			dev_dbg(isp->dev, "event: pipeline done");
@@ -3279,9 +3276,10 @@ bool atomisp_css_valid_sof(struct atomisp_device *isp)
 		if (!isp->asd.stream_env[i].stream)
 			continue;
 
-		dev_dbg(isp->dev, "stream #%d: mode: %d\n",
-			i, isp->asd.stream_env[i].stream_config.mode);
-		if (isp->asd.stream_env[i].stream_config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR)
+		dev_dbg(isp->dev, "stream #%d: mode: %d\n", i,
+			isp->asd.stream_env[i].stream_config.mode);
+		if (isp->asd.stream_env[i].stream_config.mode ==
+		    IA_CSS_INPUT_MODE_BUFFERED_SENSOR)
 			return false;
 	}
 
@@ -3300,18 +3298,18 @@ int atomisp_css_dump_sp_raw_copy_linecount(bool reduced)
 	return 0;
 }
 
-static const char * const fw_type_name[] = {
-	[ia_css_sp_firmware]		= "SP",
-	[ia_css_isp_firmware]		= "ISP",
-	[ia_css_bootloader_firmware]	= "BootLoader",
-	[ia_css_acc_firmware]		= "accel",
+static const char *const fw_type_name[] = {
+	[ia_css_sp_firmware] = "SP",
+	[ia_css_isp_firmware] = "ISP",
+	[ia_css_bootloader_firmware] = "BootLoader",
+	[ia_css_acc_firmware] = "accel",
 };
 
-static const char * const fw_acc_type_name[] = {
-	[IA_CSS_ACC_NONE] =		"Normal",
-	[IA_CSS_ACC_OUTPUT] =		"Accel stage on output",
-	[IA_CSS_ACC_VIEWFINDER] =	"Accel stage on viewfinder",
-	[IA_CSS_ACC_STANDALONE] =	"Stand-alone acceleration",
+static const char *const fw_acc_type_name[] = {
+	[IA_CSS_ACC_NONE] = "Normal",
+	[IA_CSS_ACC_OUTPUT] = "Accel stage on output",
+	[IA_CSS_ACC_VIEWFINDER] = "Accel stage on viewfinder",
+	[IA_CSS_ACC_STANDALONE] = "Stand-alone acceleration",
 };
 
 int atomisp_css_dump_blob_infor(struct atomisp_device *isp)
@@ -3331,12 +3329,11 @@ int atomisp_css_dump_blob_infor(struct atomisp_device *isp)
 	for (i = 0; i < sh_css_num_binaries - NUM_OF_SPS; i++) {
 		switch (bd[i].header.type) {
 		case ia_css_isp_firmware:
-			dev_dbg(isp->dev, "Num%2d type %s (%s), binary id is %2d, name is %s\n",
-				i + NUM_OF_SPS,
-				fw_type_name[bd[i].header.type],
+			dev_dbg(isp->dev,
+				"Num%2d type %s (%s), binary id is %2d, name is %s\n",
+				i + NUM_OF_SPS, fw_type_name[bd[i].header.type],
 				fw_acc_type_name[bd[i].header.info.isp.type],
-				bd[i].header.info.isp.sp.id,
-				bd[i].name);
+				bd[i].header.info.isp.sp.id, bd[i].name);
 			break;
 		default:
 			dev_dbg(isp->dev, "Num%2d type %s, name is %s\n",
@@ -3355,7 +3352,7 @@ void atomisp_css_set_isp_config_id(struct atomisp_sub_device *asd,
 }
 
 void atomisp_css_set_isp_config_applied_frame(struct atomisp_sub_device *asd,
-	struct ia_css_frame *output_frame)
+					      struct ia_css_frame *output_frame)
 {
 	asd->params.config.output_frame = output_frame;
 }
@@ -3379,12 +3376,11 @@ int atomisp_set_css_dbgfunc(struct atomisp_device *isp, int opt)
 void atomisp_en_dz_capt_pipe(struct atomisp_sub_device *asd, bool enable)
 {
 	ia_css_en_dz_capt_pipe(
-	    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-	    enable);
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream, enable);
 }
 
-struct ia_css_dvs_grid_info *atomisp_css_get_dvs_grid_info(
-    struct ia_css_grid_info *grid_info)
+struct ia_css_dvs_grid_info *
+atomisp_css_get_dvs_grid_info(struct ia_css_grid_info *grid_info)
 {
 	if (!grid_info)
 		return NULL;
diff --git a/drivers/staging/media/atomisp/pci/atomisp_compat_css20.h b/drivers/staging/media/atomisp/pci/atomisp_compat_css20.h
index 75781807544aa61a35ffbdfbf4ad9b104d4ee7d3..3ee4a7fa30c505f0aa359a2e874b514b9457d1bd 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_compat_css20.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_compat_css20.h
@@ -15,18 +15,18 @@
 #include "ia_css_acc_types.h"
 #include "sh_css_legacy.h"
 
-#define ATOMISP_CSS2_PIPE_MAX	2
-#define ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES     3
-#define ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES_LOCK_EN     4
-#define ATOMISP_CSS2_NUM_DVS_FRAME_DELAY     2
+#define ATOMISP_CSS2_PIPE_MAX 2
+#define ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES 3
+#define ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES_LOCK_EN 4
+#define ATOMISP_CSS2_NUM_DVS_FRAME_DELAY 2
 
-#define CSS_MIPI_FRAME_BUFFER_SIZE_1	0x60000
-#define CSS_MIPI_FRAME_BUFFER_SIZE_2	0x80000
+#define CSS_MIPI_FRAME_BUFFER_SIZE_1 0x60000
+#define CSS_MIPI_FRAME_BUFFER_SIZE_2 0x80000
 
 struct atomisp_device;
 struct atomisp_sub_device;
 
-#define MAX_STREAMS_PER_CHANNEL	2
+#define MAX_STREAMS_PER_CHANNEL 2
 
 /*
  * These are used to indicate the css stream state, corresponding
@@ -124,11 +124,13 @@ void atomisp_css_set_cnr_config(struct atomisp_sub_device *asd,
 void atomisp_css_set_ctc_config(struct atomisp_sub_device *asd,
 				struct ia_css_ctc_config *ctc_config);
 
-void atomisp_css_set_yuv2rgb_cc_config(struct atomisp_sub_device *asd,
-				       struct ia_css_cc_config *yuv2rgb_cc_config);
+void atomisp_css_set_yuv2rgb_cc_config(
+	struct atomisp_sub_device *asd,
+	struct ia_css_cc_config *yuv2rgb_cc_config);
 
-void atomisp_css_set_rgb2yuv_cc_config(struct atomisp_sub_device *asd,
-				       struct ia_css_cc_config *rgb2yuv_cc_config);
+void atomisp_css_set_rgb2yuv_cc_config(
+	struct atomisp_sub_device *asd,
+	struct ia_css_cc_config *rgb2yuv_cc_config);
 
 void atomisp_css_set_anr_thres(struct atomisp_sub_device *asd,
 			       struct ia_css_anr_thres *anr_thres);
@@ -147,12 +149,12 @@ int atomisp_css_dump_blob_infor(struct atomisp_device *isp);
 void atomisp_css_set_isp_config_id(struct atomisp_sub_device *asd,
 				   uint32_t isp_config_id);
 
-void atomisp_css_set_isp_config_applied_frame(struct atomisp_sub_device *asd,
-	struct ia_css_frame *output_frame);
+void atomisp_css_set_isp_config_applied_frame(
+	struct atomisp_sub_device *asd, struct ia_css_frame *output_frame);
 
 int atomisp_get_css_dbgfunc(void);
 
 int atomisp_set_css_dbgfunc(struct atomisp_device *isp, int opt);
-struct ia_css_dvs_grid_info *atomisp_css_get_dvs_grid_info(
-    struct ia_css_grid_info *grid_info);
+struct ia_css_dvs_grid_info *
+atomisp_css_get_dvs_grid_info(struct ia_css_grid_info *grid_info);
 #endif
diff --git a/drivers/staging/media/atomisp/pci/atomisp_csi2.c b/drivers/staging/media/atomisp/pci/atomisp_csi2.c
index 95b9113d75e90f25d7dad13589ccc4e4198fd4ef..8ec814e5ff865bc23592497e8ae86b3dbc4a3b14 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_csi2.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_csi2.c
@@ -11,11 +11,10 @@
 #include "atomisp_internal.h"
 #include "atomisp-regs.h"
 
-static struct
-v4l2_mbus_framefmt *__csi2_get_format(struct atomisp_mipi_csi2_device *csi2,
-				      struct v4l2_subdev_state *sd_state,
-				      enum v4l2_subdev_format_whence which,
-				      unsigned int pad)
+static struct v4l2_mbus_framefmt *
+__csi2_get_format(struct atomisp_mipi_csi2_device *csi2,
+		  struct v4l2_subdev_state *sd_state,
+		  enum v4l2_subdev_format_whence which, unsigned int pad)
 {
 	if (which == V4L2_SUBDEV_FORMAT_TRY)
 		return v4l2_subdev_state_get_format(sd_state, pad);
@@ -76,9 +75,8 @@ int atomisp_csi2_set_ffmt(struct v4l2_subdev *sd,
 			  struct v4l2_mbus_framefmt *ffmt)
 {
 	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
-	struct v4l2_mbus_framefmt *actual_ffmt = __csi2_get_format(csi2,
-								   sd_state,
-								   which, pad);
+	struct v4l2_mbus_framefmt *actual_ffmt =
+		__csi2_get_format(csi2, sd_state, which, pad);
 
 	if (pad == CSI2_PAD_SINK) {
 		const struct atomisp_in_fmt_conv *ic;
@@ -103,13 +101,12 @@ int atomisp_csi2_set_ffmt(struct v4l2_subdev *sd,
 		/* Always use V4L2_FIELD_ANY to match the ISP sink pad */
 		tmp_ffmt.field = V4L2_FIELD_ANY;
 		return atomisp_csi2_set_ffmt(sd, sd_state, which,
-					     CSI2_PAD_SOURCE,
-					     &tmp_ffmt);
+					     CSI2_PAD_SOURCE, &tmp_ffmt);
 	}
 
 	/* FIXME: DPCM decompression */
-	*actual_ffmt = *ffmt = *__csi2_get_format(csi2, sd_state, which,
-						  CSI2_PAD_SINK);
+	*actual_ffmt = *ffmt =
+		*__csi2_get_format(csi2, sd_state, which, CSI2_PAD_SINK);
 
 	return 0;
 }
@@ -182,8 +179,7 @@ static int mipi_csi2_init_entities(struct atomisp_mipi_csi2_device *csi2,
 	return 0;
 }
 
-void
-atomisp_mipi_csi2_unregister_entities(struct atomisp_mipi_csi2_device *csi2)
+void atomisp_mipi_csi2_unregister_entities(struct atomisp_mipi_csi2_device *csi2)
 {
 	media_entity_cleanup(&csi2->subdev.entity);
 	v4l2_device_unregister_subdev(&csi2->subdev);
@@ -206,13 +202,13 @@ int atomisp_mipi_csi2_register_entities(struct atomisp_mipi_csi2_device *csi2,
 	return ret;
 }
 
-static const int LIMIT_SHIFT = 6;	/* Limit numeric range into 31 bits */
+static const int LIMIT_SHIFT = 6; /* Limit numeric range into 31 bits */
 
-static int
-atomisp_csi2_configure_calc(const short int coeffs[2], int mipi_freq, int def)
+static int atomisp_csi2_configure_calc(const short int coeffs[2], int mipi_freq,
+				       int def)
 {
 	/* Delay counter accuracy, 1/0.0625 for ANN/CHT, 1/0.125 for BXT */
-	static const int accinv = 16;		/* 1 / COUNT_ACC */
+	static const int accinv = 16; /* 1 / COUNT_ACC */
 	int r;
 
 	if (mipi_freq >> LIMIT_SHIFT <= 0)
@@ -261,26 +257,23 @@ static void atomisp_csi2_configure_isp2401(struct atomisp_sub_device *asd)
 	static const short int coeff_clk_settle[] = { 95, -8 };
 	static const short int coeff_dat_termen[] = { 0, 0 };
 	static const short int coeff_dat_settle[] = { 85, -2 };
-	static const int TERMEN_DEFAULT		  = 0 * 0;
-	static const int SETTLE_DEFAULT		  = 0x480;
+	static const int TERMEN_DEFAULT = 0 * 0;
+	static const int SETTLE_DEFAULT = 0x480;
 
 	static const hrt_address csi2_port_base[] = {
-		[ATOMISP_CAMERA_PORT_PRIMARY]     = CSI2_PORT_A_BASE,
-		[ATOMISP_CAMERA_PORT_SECONDARY]   = CSI2_PORT_B_BASE,
-		[ATOMISP_CAMERA_PORT_TERTIARY]    = CSI2_PORT_C_BASE,
+		[ATOMISP_CAMERA_PORT_PRIMARY] = CSI2_PORT_A_BASE,
+		[ATOMISP_CAMERA_PORT_SECONDARY] = CSI2_PORT_B_BASE,
+		[ATOMISP_CAMERA_PORT_TERTIARY] = CSI2_PORT_C_BASE,
 	};
 	/* Number of lanes on each port, excluding clock lane */
 	static const unsigned char csi2_port_lanes[] = {
-		[ATOMISP_CAMERA_PORT_PRIMARY]     = 4,
-		[ATOMISP_CAMERA_PORT_SECONDARY]   = 2,
-		[ATOMISP_CAMERA_PORT_TERTIARY]    = 2,
+		[ATOMISP_CAMERA_PORT_PRIMARY] = 4,
+		[ATOMISP_CAMERA_PORT_SECONDARY] = 2,
+		[ATOMISP_CAMERA_PORT_TERTIARY] = 2,
 	};
 	static const hrt_address csi2_lane_base[] = {
-		CSI2_LANE_CL_BASE,
-		CSI2_LANE_D0_BASE,
-		CSI2_LANE_D1_BASE,
-		CSI2_LANE_D2_BASE,
-		CSI2_LANE_D3_BASE,
+		CSI2_LANE_CL_BASE, CSI2_LANE_D0_BASE, CSI2_LANE_D1_BASE,
+		CSI2_LANE_D2_BASE, CSI2_LANE_D3_BASE,
 	};
 
 	int clk_termen;
@@ -297,8 +290,8 @@ static void atomisp_csi2_configure_isp2401(struct atomisp_sub_device *asd)
 	port = isp->inputs[asd->input_curr].port;
 
 	ctrl.id = V4L2_CID_LINK_FREQ;
-	if (v4l2_g_ctrl
-	    (isp->inputs[asd->input_curr].sensor->ctrl_handler, &ctrl) == 0)
+	if (v4l2_g_ctrl(isp->inputs[asd->input_curr].sensor->ctrl_handler,
+			&ctrl) == 0)
 		mipi_freq = ctrl.value;
 
 	clk_termen = atomisp_csi2_configure_calc(coeff_clk_termen, mipi_freq,
diff --git a/drivers/staging/media/atomisp/pci/atomisp_csi2.h b/drivers/staging/media/atomisp/pci/atomisp_csi2.h
index bb998c82a438f4b98498391f7fdf01f3665c3d79..4613f76c55292bccf176475e6476bcb952160999 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_csi2.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_csi2.h
@@ -15,11 +15,11 @@
 
 #include "../../include/linux/atomisp.h"
 
-#define CSI2_PAD_SINK		0
-#define CSI2_PAD_SOURCE		1
-#define CSI2_PADS_NUM		2
+#define CSI2_PAD_SINK 0
+#define CSI2_PAD_SOURCE 1
+#define CSI2_PADS_NUM 2
 
-#define CSI2_MAX_ACPI_GPIOS	2u
+#define CSI2_MAX_ACPI_GPIOS 2u
 
 struct acpi_device;
 struct v4l2_device;
@@ -57,7 +57,7 @@ int atomisp_csi2_set_ffmt(struct v4l2_subdev *sd,
 int atomisp_mipi_csi2_init(struct atomisp_device *isp);
 void atomisp_mipi_csi2_cleanup(struct atomisp_device *isp);
 void atomisp_mipi_csi2_unregister_entities(
-    struct atomisp_mipi_csi2_device *csi2);
+	struct atomisp_mipi_csi2_device *csi2);
 int atomisp_mipi_csi2_register_entities(struct atomisp_mipi_csi2_device *csi2,
 					struct v4l2_device *vdev);
 int atomisp_csi2_bridge_init(struct atomisp_device *isp);
diff --git a/drivers/staging/media/atomisp/pci/atomisp_csi2_bridge.c b/drivers/staging/media/atomisp/pci/atomisp_csi2_bridge.c
index 6abda358a72f761a705bafbb0391ccd14ad71f9e..595040b13f4f8c9687afcaef9ba546e06ca02afa 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_csi2_bridge.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_csi2_bridge.c
@@ -22,7 +22,7 @@
 #include "atomisp_csi2.h"
 #include "atomisp_internal.h"
 
-#define PMC_CLK_RATE_19_2MHZ			19200000
+#define PMC_CLK_RATE_19_2MHZ 19200000
 
 /*
  * 79234640-9e10-4fea-a5c1-b5aa8b19756f
@@ -31,22 +31,23 @@
  * Subsequent functions return 32 bit ints encoding information about the GPIO.
  */
 static const guid_t intel_sensor_gpio_info_guid =
-	GUID_INIT(0x79234640, 0x9e10, 0x4fea,
-		  0xa5, 0xc1, 0xb5, 0xaa, 0x8b, 0x19, 0x75, 0x6f);
+	GUID_INIT(0x79234640, 0x9e10, 0x4fea, 0xa5, 0xc1, 0xb5, 0xaa, 0x8b,
+		  0x19, 0x75, 0x6f);
 
-#define INTEL_GPIO_DSM_TYPE_SHIFT			0
-#define INTEL_GPIO_DSM_TYPE_MASK			GENMASK(7, 0)
-#define INTEL_GPIO_DSM_PIN_SHIFT			8
-#define INTEL_GPIO_DSM_PIN_MASK				GENMASK(15, 8)
-#define INTEL_GPIO_DSM_SENSOR_ON_VAL_SHIFT		24
-#define INTEL_GPIO_DSM_SENSOR_ON_VAL_MASK		GENMASK(31, 24)
+#define INTEL_GPIO_DSM_TYPE_SHIFT 0
+#define INTEL_GPIO_DSM_TYPE_MASK GENMASK(7, 0)
+#define INTEL_GPIO_DSM_PIN_SHIFT 8
+#define INTEL_GPIO_DSM_PIN_MASK GENMASK(15, 8)
+#define INTEL_GPIO_DSM_SENSOR_ON_VAL_SHIFT 24
+#define INTEL_GPIO_DSM_SENSOR_ON_VAL_MASK GENMASK(31, 24)
 
 #define INTEL_GPIO_DSM_TYPE(x) \
-	(((x) & INTEL_GPIO_DSM_TYPE_MASK) >> INTEL_GPIO_DSM_TYPE_SHIFT)
+	(((x)&INTEL_GPIO_DSM_TYPE_MASK) >> INTEL_GPIO_DSM_TYPE_SHIFT)
 #define INTEL_GPIO_DSM_PIN(x) \
-	(((x) & INTEL_GPIO_DSM_PIN_MASK) >> INTEL_GPIO_DSM_PIN_SHIFT)
-#define INTEL_GPIO_DSM_SENSOR_ON_VAL(x) \
-	(((x) & INTEL_GPIO_DSM_SENSOR_ON_VAL_MASK) >> INTEL_GPIO_DSM_SENSOR_ON_VAL_SHIFT)
+	(((x)&INTEL_GPIO_DSM_PIN_MASK) >> INTEL_GPIO_DSM_PIN_SHIFT)
+#define INTEL_GPIO_DSM_SENSOR_ON_VAL(x)             \
+	(((x)&INTEL_GPIO_DSM_SENSOR_ON_VAL_MASK) >> \
+	 INTEL_GPIO_DSM_SENSOR_ON_VAL_SHIFT)
 
 /*
  * 822ace8f-2814-4174-a56b-5f029fe079ee
@@ -54,39 +55,39 @@ static const guid_t intel_sensor_gpio_info_guid =
  * module identifier.
  */
 static const guid_t intel_sensor_module_guid =
-	GUID_INIT(0x822ace8f, 0x2814, 0x4174,
-		  0xa5, 0x6b, 0x5f, 0x02, 0x9f, 0xe0, 0x79, 0xee);
+	GUID_INIT(0x822ace8f, 0x2814, 0x4174, 0xa5, 0x6b, 0x5f, 0x02, 0x9f,
+		  0xe0, 0x79, 0xee);
 
 /*
  * dc2f6c4f-045b-4f1d-97b9-882a6860a4be
  * This _DSM GUID returns a package with n*2 strings, with each set of 2 strings
  * forming a key, value pair for settings like e.g. "CsiLanes" = "1".
  */
-static const guid_t atomisp_dsm_guid =
-	GUID_INIT(0xdc2f6c4f, 0x045b, 0x4f1d,
-		  0x97, 0xb9, 0x88, 0x2a, 0x68, 0x60, 0xa4, 0xbe);
+static const guid_t atomisp_dsm_guid = GUID_INIT(0xdc2f6c4f, 0x045b, 0x4f1d,
+						 0x97, 0xb9, 0x88, 0x2a, 0x68,
+						 0x60, 0xa4, 0xbe);
 
 /*
  * 75c9a639-5c8a-4a00-9f48-a9c3b5da789f
  * This _DSM GUID returns a string giving the VCM type e.g. "AD5823".
  */
-static const guid_t vcm_dsm_guid =
-	GUID_INIT(0x75c9a639, 0x5c8a, 0x4a00,
-		  0x9f, 0x48, 0xa9, 0xc3, 0xb5, 0xda, 0x78, 0x9f);
+static const guid_t vcm_dsm_guid = GUID_INIT(0x75c9a639, 0x5c8a, 0x4a00, 0x9f,
+					     0x48, 0xa9, 0xc3, 0xb5, 0xda, 0x78,
+					     0x9f);
 
 struct atomisp_sensor_config {
 	int lanes;
 	bool vcm;
 };
 
-#define ATOMISP_SENSOR_CONFIG(_HID, _LANES, _VCM)			\
-{									\
-	.id = _HID,							\
-	.driver_data = (long)&((const struct atomisp_sensor_config) {	\
-		.lanes = _LANES,					\
-		.vcm = _VCM,						\
-	})								\
-}
+#define ATOMISP_SENSOR_CONFIG(_HID, _LANES, _VCM)                            \
+	{                                                                    \
+		.id = _HID,                                                  \
+		.driver_data = (long)&((const struct atomisp_sensor_config){ \
+			.lanes = _LANES,                                     \
+			.vcm = _VCM,                                         \
+		})                                                           \
+	}
 
 /*
  * gmin_cfg parsing code. This is a cleaned up version of the gmin_cfg parsing
@@ -149,7 +150,8 @@ static char *gmin_cfg_get_dsm(struct acpi_device *adev, const char *key)
 		key_el = &obj->package.elements[i + 0];
 		val_el = &obj->package.elements[i + 1];
 
-		if (key_el->type != ACPI_TYPE_STRING || val_el->type != ACPI_TYPE_STRING)
+		if (key_el->type != ACPI_TYPE_STRING ||
+		    val_el->type != ACPI_TYPE_STRING)
 			break;
 
 		if (!strcmp(key_el->string.pointer, key)) {
@@ -157,7 +159,8 @@ static char *gmin_cfg_get_dsm(struct acpi_device *adev, const char *key)
 			if (!val)
 				break;
 
-			acpi_handle_info(adev->handle, "%s: Using DSM entry %s=%s\n",
+			acpi_handle_info(adev->handle,
+					 "%s: Using DSM entry %s=%s\n",
 					 dev_name(&adev->dev), key, val);
 			break;
 		}
@@ -167,7 +170,8 @@ static char *gmin_cfg_get_dsm(struct acpi_device *adev, const char *key)
 	return val;
 }
 
-static char *gmin_cfg_get_dmi_override(struct acpi_device *adev, const char *key)
+static char *gmin_cfg_get_dmi_override(struct acpi_device *adev,
+				       const char *key)
 {
 	const struct dmi_system_id *id;
 	struct gmin_cfg_var *gv;
@@ -202,7 +206,8 @@ static char *gmin_cfg_get(struct acpi_device *adev, const char *key)
 	return gmin_cfg_get_dsm(adev, key);
 }
 
-static int gmin_cfg_get_int(struct acpi_device *adev, const char *key, int default_val)
+static int gmin_cfg_get_int(struct acpi_device *adev, const char *key,
+			    int default_val)
 {
 	char *str_val;
 	long int_val;
@@ -237,7 +242,8 @@ static int atomisp_csi2_get_pmc_clk_nr_from_acpi_pr0(struct acpi_device *adev)
 	acpi_status status;
 	u8 clock_num;
 
-	status = acpi_evaluate_object_typed(adev->handle, "_PR0", NULL, &buffer, ACPI_TYPE_PACKAGE);
+	status = acpi_evaluate_object_typed(adev->handle, "_PR0", NULL, &buffer,
+					    ACPI_TYPE_PACKAGE);
 	if (ACPI_FAILURE(status))
 		return -ENOENT;
 
@@ -254,8 +260,8 @@ static int atomisp_csi2_get_pmc_clk_nr_from_acpi_pr0(struct acpi_device *adev)
 
 		acpi_get_name(rhandle, ACPI_SINGLE_NAME, &b_name);
 
-		if (str_has_prefix(name, "CLK") && !kstrtou8(&name[3], 10, &clock_num) &&
-		    clock_num <= 4) {
+		if (str_has_prefix(name, "CLK") &&
+		    !kstrtou8(&name[3], 10, &clock_num) && clock_num <= 4) {
 			ret = clock_num;
 			break;
 		}
@@ -264,13 +270,15 @@ static int atomisp_csi2_get_pmc_clk_nr_from_acpi_pr0(struct acpi_device *adev)
 	ACPI_FREE(buffer.pointer);
 
 	if (ret < 0)
-		acpi_handle_warn(adev->handle, "%s: Could not find PMC clk in _PR0\n",
+		acpi_handle_warn(adev->handle,
+				 "%s: Could not find PMC clk in _PR0\n",
 				 dev_name(&adev->dev));
 
 	return ret;
 }
 
-static int atomisp_csi2_set_pmc_clk_freq(struct acpi_device *adev, int clock_num)
+static int atomisp_csi2_set_pmc_clk_freq(struct acpi_device *adev,
+					 int clock_num)
 {
 	struct clk *clk;
 	char name[14];
@@ -299,7 +307,8 @@ static int atomisp_csi2_set_pmc_clk_freq(struct acpi_device *adev, int clock_num
 	if (!ret)
 		ret = clk_set_rate(clk, PMC_CLK_RATE_19_2MHZ);
 	if (ret)
-		acpi_handle_err(adev->handle, "%s: Error setting clk-rate for %s: %d\n",
+		acpi_handle_err(adev->handle,
+				"%s: Error setting clk-rate for %s: %d\n",
 				dev_name(&adev->dev), name, ret);
 
 	clk_put(clk);
@@ -324,7 +333,8 @@ static int atomisp_csi2_get_port(struct acpi_device *adev, int clock_num)
 }
 
 /* Note this always returns 1 to continue looping so that res_count is accurate */
-static int atomisp_csi2_handle_acpi_gpio_res(struct acpi_resource *ares, void *_data)
+static int atomisp_csi2_handle_acpi_gpio_res(struct acpi_resource *ares,
+					     void *_data)
 {
 	struct atomisp_csi2_acpi_gpio_parsing_data *data = _data;
 	struct acpi_resource_gpio *agpio;
@@ -348,9 +358,10 @@ static int atomisp_csi2_handle_acpi_gpio_res(struct acpi_resource *ares, void *_
 	}
 
 	if (i == data->settings_count) {
-		acpi_handle_warn(data->adev->handle,
-				 "%s: Could not find DSM GPIO settings for pin %u\n",
-				 dev_name(&data->adev->dev), pin);
+		acpi_handle_warn(
+			data->adev->handle,
+			"%s: Could not find DSM GPIO settings for pin %u\n",
+			dev_name(&data->adev->dev), pin);
 		return 1;
 	}
 
@@ -362,7 +373,8 @@ static int atomisp_csi2_handle_acpi_gpio_res(struct acpi_resource *ares, void *_
 		name = "powerdown-gpios";
 		break;
 	default:
-		acpi_handle_warn(data->adev->handle, "%s: Unknown GPIO type 0x%02lx for pin %u\n",
+		acpi_handle_warn(data->adev->handle,
+				 "%s: Unknown GPIO type 0x%02lx for pin %u\n",
 				 dev_name(&data->adev->dev),
 				 INTEL_GPIO_DSM_TYPE(settings), pin);
 		return 1;
@@ -388,10 +400,11 @@ static int atomisp_csi2_handle_acpi_gpio_res(struct acpi_resource *ares, void *_
 	data->map->mapping[i].size = 1;
 	data->map_count++;
 
-	acpi_handle_info(data->adev->handle, "%s: %s crs %d %s pin %u active-%s\n",
-			 dev_name(&data->adev->dev), name,
-			 data->res_count - 1, agpio->resource_source.string_ptr,
-			 pin, active_low ? "low" : "high");
+	acpi_handle_info(data->adev->handle,
+			 "%s: %s crs %d %s pin %u active-%s\n",
+			 dev_name(&data->adev->dev), name, data->res_count - 1,
+			 agpio->resource_source.string_ptr, pin,
+			 active_low ? "low" : "high");
 
 	return 1;
 }
@@ -417,7 +430,7 @@ static int atomisp_csi2_handle_acpi_gpio_res(struct acpi_resource *ares, void *_
  */
 static int atomisp_csi2_add_gpio_mappings(struct acpi_device *adev)
 {
-	struct atomisp_csi2_acpi_gpio_parsing_data data = { };
+	struct atomisp_csi2_acpi_gpio_parsing_data data = {};
 	LIST_HEAD(resource_list);
 	union acpi_object *obj;
 	unsigned int i, j;
@@ -441,7 +454,8 @@ static int atomisp_csi2_add_gpio_mappings(struct acpi_device *adev)
 				      &intel_sensor_gpio_info_guid, 0x00, 1,
 				      NULL, ACPI_TYPE_INTEGER);
 	if (!obj) {
-		acpi_handle_err(adev->handle, "%s: No _DSM entry for GPIO pin count\n",
+		acpi_handle_err(adev->handle,
+				"%s: No _DSM entry for GPIO pin count\n",
 				dev_name(&adev->dev));
 		return -EIO;
 	}
@@ -463,10 +477,11 @@ static int atomisp_csi2_add_gpio_mappings(struct acpi_device *adev)
 		 */
 		obj = acpi_evaluate_dsm_typed(adev->handle,
 					      &intel_sensor_gpio_info_guid,
-					      0x00, i + 2,
-					      NULL, ACPI_TYPE_INTEGER);
+					      0x00, i + 2, NULL,
+					      ACPI_TYPE_INTEGER);
 		if (!obj) {
-			acpi_handle_err(adev->handle, "%s: No _DSM entry for pin %u\n",
+			acpi_handle_err(adev->handle,
+					"%s: No _DSM entry for pin %u\n",
 					dev_name(&adev->dev), i);
 			return -EIO;
 		}
@@ -482,7 +497,8 @@ static int atomisp_csi2_add_gpio_mappings(struct acpi_device *adev)
 			    INTEL_GPIO_DSM_PIN(data.settings[j]))
 				continue;
 
-			acpi_handle_err(adev->handle, "%s: Duplicate pin number %lu\n",
+			acpi_handle_err(adev->handle,
+					"%s: Duplicate pin number %lu\n",
 					dev_name(&adev->dev),
 					INTEL_GPIO_DSM_PIN(data.settings[i]));
 			return -EIO;
@@ -504,13 +520,16 @@ static int atomisp_csi2_add_gpio_mappings(struct acpi_device *adev)
 
 	if (data.map_count != data.settings_count ||
 	    data.res_count != data.settings_count)
-		acpi_handle_warn(adev->handle, "%s: ACPI GPIO resources vs DSM GPIO-info count mismatch (dsm: %d res: %d map %d\n",
-				 dev_name(&adev->dev), data.settings_count,
-				 data.res_count, data.map_count);
+		acpi_handle_warn(
+			adev->handle,
+			"%s: ACPI GPIO resources vs DSM GPIO-info count mismatch (dsm: %d res: %d map %d\n",
+			dev_name(&adev->dev), data.settings_count,
+			data.res_count, data.map_count);
 
 	ret = acpi_dev_add_driver_gpios(adev, data.map->mapping);
 	if (ret)
-		acpi_handle_err(adev->handle, "%s: Error adding driver GPIOs: %d\n",
+		acpi_handle_err(adev->handle,
+				"%s: Error adding driver GPIOs: %d\n",
 				dev_name(&adev->dev), ret);
 
 	return ret;
@@ -521,8 +540,8 @@ static char *atomisp_csi2_get_vcm_type(struct acpi_device *adev)
 	union acpi_object *obj;
 	char *vcm_type;
 
-	obj = acpi_evaluate_dsm_typed(adev->handle, &vcm_dsm_guid, 0, 0,
-				      NULL, ACPI_TYPE_STRING);
+	obj = acpi_evaluate_dsm_typed(adev->handle, &vcm_dsm_guid, 0, 0, NULL,
+				      ACPI_TYPE_STRING);
 	if (!obj)
 		return NULL;
 
@@ -542,7 +561,7 @@ static const struct acpi_device_id atomisp_sensor_configs[] = {
 	 * the sensor fails to start streaming when instantiating
 	 * an i2c-client for the VCM, so it is disabled for now.
 	 */
-	ATOMISP_SENSOR_CONFIG("INT33BE", 2, false),	/* OV5693 */
+	ATOMISP_SENSOR_CONFIG("INT33BE", 2, false), /* OV5693 */
 	{}
 };
 
@@ -596,7 +615,8 @@ static int atomisp_csi2_parse_sensor_fwnode(struct acpi_device *adev,
 	sensor->mclkspeed = PMC_CLK_RATE_19_2MHZ;
 	sensor->rotation = 0;
 	sensor->orientation = (sensor->link == 1) ?
-		V4L2_FWNODE_ORIENTATION_BACK : V4L2_FWNODE_ORIENTATION_FRONT;
+				      V4L2_FWNODE_ORIENTATION_BACK :
+				      V4L2_FWNODE_ORIENTATION_FRONT;
 
 	if (vcm)
 		sensor->vcm_type = atomisp_csi2_get_vcm_type(adev);
@@ -629,8 +649,8 @@ struct sensor_async_subdev {
 	int port;
 };
 
-#define to_sensor_asd(a)	container_of(a, struct sensor_async_subdev, asd)
-#define notifier_to_atomisp(n)	container_of(n, struct atomisp_device, notifier)
+#define to_sensor_asd(a) container_of(a, struct sensor_async_subdev, asd)
+#define notifier_to_atomisp(n) container_of(n, struct atomisp_device, notifier)
 
 /* .bound() notifier callback when a match is found */
 static int atomisp_notifier_bound(struct v4l2_async_notifier *notifier,
@@ -647,7 +667,8 @@ static int atomisp_notifier_bound(struct v4l2_async_notifier *notifier,
 	}
 
 	if (isp->sensor_subdevs[s_asd->port]) {
-		dev_err(isp->dev, "port %d already has a sensor attached\n", s_asd->port);
+		dev_err(isp->dev, "port %d already has a sensor attached\n",
+			s_asd->port);
 		return -EBUSY;
 	}
 
@@ -698,8 +719,8 @@ int atomisp_csi2_bridge_parse_firmware(struct atomisp_device *isp)
 		struct sensor_async_subdev *s_asd;
 		struct fwnode_handle *ep;
 
-		ep = fwnode_graph_get_endpoint_by_id(dev_fwnode(isp->dev), i, 0,
-						     FWNODE_GRAPH_ENDPOINT_NEXT);
+		ep = fwnode_graph_get_endpoint_by_id(
+			dev_fwnode(isp->dev), i, 0, FWNODE_GRAPH_ENDPOINT_NEXT);
 		if (!ep)
 			continue;
 
@@ -708,7 +729,8 @@ int atomisp_csi2_bridge_parse_firmware(struct atomisp_device *isp)
 			goto err_parse;
 
 		if (vep.base.port >= ATOMISP_CAMERA_NR_PORTS) {
-			dev_err(isp->dev, "port %d not supported\n", vep.base.port);
+			dev_err(isp->dev, "port %d not supported\n",
+				vep.base.port);
 			ret = -EINVAL;
 			goto err_parse;
 		}
@@ -716,8 +738,8 @@ int atomisp_csi2_bridge_parse_firmware(struct atomisp_device *isp)
 		mipi_port = atomisp_port_to_mipi_port(isp, vep.base.port);
 		isp->sensor_lanes[mipi_port] = vep.bus.mipi_csi2.num_data_lanes;
 
-		s_asd = v4l2_async_nf_add_fwnode_remote(&isp->notifier, ep,
-							struct sensor_async_subdev);
+		s_asd = v4l2_async_nf_add_fwnode_remote(
+			&isp->notifier, ep, struct sensor_async_subdev);
 		if (IS_ERR(s_asd)) {
 			ret = PTR_ERR(s_asd);
 			goto err_parse;
diff --git a/drivers/staging/media/atomisp/pci/atomisp_dfs_tables.h b/drivers/staging/media/atomisp/pci/atomisp_dfs_tables.h
index 03d7c08b67e6de7e04d7b868cc224195fe95cae4..c21e464dad98078d47123a62a94faa26ce1b5217 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_dfs_tables.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_dfs_tables.h
@@ -4,8 +4,8 @@
  *
  * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
  */
-#ifndef	__ATOMISP_DFS_TABLES_H__
-#define	__ATOMISP_DFS_TABLES_H__
+#ifndef __ATOMISP_DFS_TABLES_H__
+#define __ATOMISP_DFS_TABLES_H__
 
 #include <linux/kernel.h>
 
diff --git a/drivers/staging/media/atomisp/pci/atomisp_drvfs.c b/drivers/staging/media/atomisp/pci/atomisp_drvfs.c
index 31c82c3c0d33fd155b88ff99846b5b3deb6da167..1745ff760eef582ba7388854109d78cf59717977 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_drvfs.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_drvfs.c
@@ -16,9 +16,9 @@
 #include "hmm/hmm.h"
 #include "ia_css_debug.h"
 
-#define OPTION_BIN_LIST			BIT(0)
-#define OPTION_BIN_RUN			BIT(1)
-#define OPTION_VALID			(OPTION_BIN_LIST | OPTION_BIN_RUN)
+#define OPTION_BIN_LIST BIT(0)
+#define OPTION_BIN_RUN BIT(1)
+#define OPTION_VALID (OPTION_BIN_LIST | OPTION_BIN_RUN)
 
 /*
  * dbgopt: iunit debug option:
@@ -37,7 +37,8 @@ static inline int iunit_dump_dbgopt(struct atomisp_device *isp,
 		if (opt & OPTION_BIN_LIST) {
 			ret = atomisp_css_dump_blob_infor(isp);
 			if (ret) {
-				dev_err(isp->dev, "%s dump blob infor err[ret:%d]\n",
+				dev_err(isp->dev,
+					"%s dump blob infor err[ret:%d]\n",
 					__func__, ret);
 				goto opt_err;
 			}
@@ -49,7 +50,8 @@ static inline int iunit_dump_dbgopt(struct atomisp_device *isp,
 				atomisp_css_debug_dump_isp_binary();
 			} else {
 				ret = -EPERM;
-				dev_err(isp->dev, "%s dump running bin err[ret:%d]\n",
+				dev_err(isp->dev,
+					"%s dump running bin err[ret:%d]\n",
 					__func__, ret);
 				goto opt_err;
 			}
@@ -138,18 +140,12 @@ static ssize_t dbgopt_store(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RW(dbgopt);
 
-static struct attribute *dbg_attrs[] = {
-	&dev_attr_dbglvl.attr,
-	&dev_attr_dbgfun.attr,
-	&dev_attr_dbgopt.attr,
-	NULL
-};
+static struct attribute *dbg_attrs[] = { &dev_attr_dbglvl.attr,
+					 &dev_attr_dbgfun.attr,
+					 &dev_attr_dbgopt.attr, NULL };
 
 static const struct attribute_group dbg_attr_group = {
 	.attrs = dbg_attrs,
 };
 
-const struct attribute_group *dbg_attr_groups[] = {
-	&dbg_attr_group,
-	NULL
-};
+const struct attribute_group *dbg_attr_groups[] = { &dbg_attr_group, NULL };
diff --git a/drivers/staging/media/atomisp/pci/atomisp_drvfs.h b/drivers/staging/media/atomisp/pci/atomisp_drvfs.h
index 46ad59b8df284d51a719aa3e4d37e9ac47b329e3..a963e26fbefa2f468901dc696f0cee608399130e 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_drvfs.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_drvfs.h
@@ -5,8 +5,8 @@
  * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
  */
 
-#ifndef	__ATOMISP_DRVFS_H__
-#define	__ATOMISP_DRVFS_H__
+#ifndef __ATOMISP_DRVFS_H__
+#define __ATOMISP_DRVFS_H__
 
 #include <linux/sysfs.h>
 
diff --git a/drivers/staging/media/atomisp/pci/atomisp_fops.c b/drivers/staging/media/atomisp/pci/atomisp_fops.c
index 57da7ddb1503343624391852a81c3f6c6a766236..f72b930b6e0251247880de2ee572b75489f0bf1e 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_fops.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_fops.c
@@ -31,14 +31,16 @@
 /*
  * Videobuf2 ops
  */
-static int atomisp_queue_setup(struct vb2_queue *vq,
-			       unsigned int *nbuffers, unsigned int *nplanes,
-			       unsigned int sizes[], struct device *alloc_devs[])
+static int atomisp_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,
+			       unsigned int *nplanes, unsigned int sizes[],
+			       struct device *alloc_devs[])
 {
-	struct atomisp_video_pipe *pipe = container_of(vq, struct atomisp_video_pipe, vb_queue);
+	struct atomisp_video_pipe *pipe =
+		container_of(vq, struct atomisp_video_pipe, vb_queue);
 	int ret;
 
-	mutex_lock(&pipe->asd->isp->mutex); /* for get_css_frame_info() / set_fmt() */
+	mutex_lock(&pipe->asd->isp
+			    ->mutex); /* for get_css_frame_info() / set_fmt() */
 
 	/*
 	 * When VIDIOC_S_FMT has not been called before VIDIOC_REQBUFS, then
@@ -82,7 +84,8 @@ static int atomisp_buf_init(struct vb2_buffer *vb)
 		return ret;
 
 	if (frame->data_bytes > vb2_plane_size(vb, 0)) {
-		dev_err(pipe->asd->isp->dev, "Internal error frame.data_bytes(%u) > vb.length(%lu)\n",
+		dev_err(pipe->asd->isp->dev,
+			"Internal error frame.data_bytes(%u) > vb.length(%lu)\n",
 			frame->data_bytes, vb2_plane_size(vb, 0));
 		return -EIO;
 	}
@@ -96,8 +99,8 @@ static int atomisp_buf_init(struct vb2_buffer *vb)
 }
 
 static int atomisp_q_one_metadata_buffer(struct atomisp_sub_device *asd,
-	enum atomisp_input_stream_id stream_id,
-	enum ia_css_pipe_id css_pipe_id)
+					 enum atomisp_input_stream_id stream_id,
+					 enum ia_css_pipe_id css_pipe_id)
 {
 	struct atomisp_metadata_buf *metadata_buf;
 	enum atomisp_metadata_type md_type = ATOMISP_MAIN_METADATA;
@@ -112,7 +115,8 @@ static int atomisp_q_one_metadata_buffer(struct atomisp_sub_device *asd,
 	} else if (!list_empty(&asd->metadata_ready[md_type])) {
 		metadata_list = &asd->metadata_ready[md_type];
 	} else {
-		dev_warn(asd->isp->dev, "%s: No metadata buffers available for type %d!\n",
+		dev_warn(asd->isp->dev,
+			 "%s: No metadata buffers available for type %d!\n",
 			 __func__, md_type);
 		return -EINVAL;
 	}
@@ -121,8 +125,8 @@ static int atomisp_q_one_metadata_buffer(struct atomisp_sub_device *asd,
 				  struct atomisp_metadata_buf, list);
 	list_del_init(&metadata_buf->list);
 
-	if (atomisp_q_metadata_buffer_to_css(asd, metadata_buf,
-					     stream_id, css_pipe_id)) {
+	if (atomisp_q_metadata_buffer_to_css(asd, metadata_buf, stream_id,
+					     css_pipe_id)) {
 		list_add(&metadata_buf->list, metadata_list);
 		return -EINVAL;
 	} else {
@@ -160,15 +164,15 @@ static int atomisp_q_one_s3a_buffer(struct atomisp_sub_device *asd,
 	exp_id = s3a_buf->s3a_data->exp_id;
 
 	hmm_flush_vmap(s3a_buf->s3a_data->data_ptr);
-	if (atomisp_q_s3a_buffer_to_css(asd, s3a_buf,
-					stream_id, css_pipe_id)) {
+	if (atomisp_q_s3a_buffer_to_css(asd, s3a_buf, stream_id, css_pipe_id)) {
 		/* got from head, so return back to the head */
 		list_add(&s3a_buf->list, s3a_list);
 		return -EINVAL;
 	} else {
 		list_add_tail(&s3a_buf->list, &asd->s3a_stats_in_css);
 		if (s3a_list == &asd->s3a_stats_ready)
-			dev_dbg(asd->isp->dev, "drop one s3a stat with exp_id %d\n", exp_id);
+			dev_dbg(asd->isp->dev,
+				"drop one s3a stat with exp_id %d\n", exp_id);
 	}
 
 	asd->s3a_bufs_in_css[css_pipe_id]++;
@@ -182,7 +186,7 @@ static int atomisp_q_one_dis_buffer(struct atomisp_sub_device *asd,
 	struct atomisp_dis_buf *dis_buf;
 	unsigned long irqflags;
 
-	if (asd->dis_bufs_in_css >=  ATOMISP_CSS_Q_DEPTH)
+	if (asd->dis_bufs_in_css >= ATOMISP_CSS_Q_DEPTH)
 		return 0; /* we have reached CSS queue depth */
 
 	spin_lock_irqsave(&asd->dis_stats_lock, irqflags);
@@ -193,14 +197,12 @@ static int atomisp_q_one_dis_buffer(struct atomisp_sub_device *asd,
 		return -EINVAL;
 	}
 
-	dis_buf = list_entry(asd->dis_stats.prev,
-			     struct atomisp_dis_buf, list);
+	dis_buf = list_entry(asd->dis_stats.prev, struct atomisp_dis_buf, list);
 	list_del_init(&dis_buf->list);
 	spin_unlock_irqrestore(&asd->dis_stats_lock, irqflags);
 
 	hmm_flush_vmap(dis_buf->dis_data->data_ptr);
-	if (atomisp_q_dis_buffer_to_css(asd, dis_buf,
-					stream_id, css_pipe_id)) {
+	if (atomisp_q_dis_buffer_to_css(asd, dis_buf, stream_id, css_pipe_id)) {
 		spin_lock_irqsave(&asd->dis_stats_lock, irqflags);
 		/* got from tail, so return back to the tail */
 		list_add_tail(&dis_buf->list, &asd->dis_stats);
@@ -217,15 +219,14 @@ static int atomisp_q_one_dis_buffer(struct atomisp_sub_device *asd,
 	return 0;
 }
 
-static int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *asd,
-					  struct atomisp_video_pipe *pipe,
-					  enum atomisp_input_stream_id stream_id,
-					  enum ia_css_buffer_type css_buf_type,
-					  enum ia_css_pipe_id css_pipe_id)
+static int atomisp_q_video_buffers_to_css(
+	struct atomisp_sub_device *asd, struct atomisp_video_pipe *pipe,
+	enum atomisp_input_stream_id stream_id,
+	enum ia_css_buffer_type css_buf_type, enum ia_css_pipe_id css_pipe_id)
 {
 	struct atomisp_css_params_with_list *param;
 	struct ia_css_dvs_grid_info *dvs_grid =
-	    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
+		atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
 	unsigned long irqflags;
 	int space, err = 0;
 
@@ -242,7 +243,8 @@ static int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *asd,
 		struct ia_css_frame *frame;
 
 		spin_lock_irqsave(&pipe->irq_lock, irqflags);
-		frame = list_first_entry_or_null(&pipe->activeq, struct ia_css_frame, queue);
+		frame = list_first_entry_or_null(&pipe->activeq,
+						 struct ia_css_frame, queue);
 		if (frame)
 			list_move_tail(&frame->queue, &pipe->buffers_in_css);
 		spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
@@ -256,23 +258,27 @@ static int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *asd,
 		 */
 		param = pipe->frame_params[frame->vb.vb2_buf.index];
 		if (param) {
-			atomisp_makeup_css_parameters(asd,
-						      &asd->params.css_param.update_flag,
-						      &param->params);
+			atomisp_makeup_css_parameters(
+				asd, &asd->params.css_param.update_flag,
+				&param->params);
 			atomisp_apply_css_parameters(asd, &param->params);
 
 			if (param->params.update_flag.dz_config &&
 			    asd->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {
-				err = atomisp_calculate_real_zoom_region(asd,
-					&param->params.dz_config, css_pipe_id);
+				err = atomisp_calculate_real_zoom_region(
+					asd, &param->params.dz_config,
+					css_pipe_id);
 				if (!err)
-					asd->params.config.dz_config = &param->params.dz_config;
+					asd->params.config.dz_config =
+						&param->params.dz_config;
 			}
 			atomisp_css_set_isp_config_applied_frame(asd, frame);
-			atomisp_css_update_isp_params_on_pipe(asd,
-							      asd->stream_env[stream_id].pipes[css_pipe_id]);
-			asd->params.dvs_6axis = (struct ia_css_dvs_6axis_config *)
-						param->params.dvs_6axis;
+			atomisp_css_update_isp_params_on_pipe(
+				asd,
+				asd->stream_env[stream_id].pipes[css_pipe_id]);
+			asd->params.dvs_6axis =
+				(struct ia_css_dvs_6axis_config *)
+					param->params.dvs_6axis;
 
 			/*
 			 * WORKAROUND:
@@ -283,14 +289,14 @@ static int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *asd,
 			 * zoom region,I will set it to global setting.
 			 */
 			if (param->params.update_flag.dz_config &&
-			    asd->run_mode->val != ATOMISP_RUN_MODE_VIDEO
-			    && !err) {
+			    asd->run_mode->val != ATOMISP_RUN_MODE_VIDEO &&
+			    !err) {
 				memcpy(&asd->params.css_param.dz_config,
 				       &param->params.dz_config,
 				       sizeof(struct ia_css_dz_config));
 				asd->params.css_param.update_flag.dz_config =
-				    (struct atomisp_dz_config *)
-				    &asd->params.css_param.dz_config;
+					(struct atomisp_dz_config *)&asd->params
+						.css_param.dz_config;
 				asd->params.css_update_params_needed = true;
 			}
 			pipe->frame_params[frame->vb.vb2_buf.index] = NULL;
@@ -311,11 +317,10 @@ static int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *asd,
 		if (asd->params.curr_grid_info.s3a_grid.enable &&
 		    css_pipe_id == asd->params.s3a_enabled_pipe &&
 		    css_buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)
-			atomisp_q_one_s3a_buffer(asd, stream_id,
-						 css_pipe_id);
+			atomisp_q_one_s3a_buffer(asd, stream_id, css_pipe_id);
 
-		if (asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream_info.
-		    metadata_info.size &&
+		if (asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
+			    .stream_info.metadata_info.size &&
 		    css_buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)
 			atomisp_q_one_metadata_buffer(asd, stream_id,
 						      css_pipe_id);
@@ -323,8 +328,7 @@ static int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *asd,
 		if (dvs_grid && dvs_grid->enable &&
 		    css_pipe_id == IA_CSS_PIPE_ID_VIDEO &&
 		    css_buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)
-			atomisp_q_one_dis_buffer(asd, stream_id,
-						 css_pipe_id);
+			atomisp_q_one_dis_buffer(asd, stream_id, css_pipe_id);
 	}
 
 	return 0;
@@ -352,7 +356,8 @@ int atomisp_qbuffers_to_css(struct atomisp_sub_device *asd)
 
 	atomisp_q_video_buffers_to_css(asd, &asd->video_out,
 				       ATOMISP_INPUT_STREAM_GENERAL,
-				       IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, pipe_id);
+				       IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
+				       pipe_id);
 	return 0;
 }
 
@@ -424,12 +429,12 @@ static void atomisp_buf_cleanup(struct vb2_buffer *vb)
 }
 
 const struct vb2_ops atomisp_vb2_ops = {
-	.queue_setup		= atomisp_queue_setup,
-	.buf_init		= atomisp_buf_init,
-	.buf_cleanup		= atomisp_buf_cleanup,
-	.buf_queue		= atomisp_buf_queue,
-	.start_streaming	= atomisp_start_streaming,
-	.stop_streaming		= atomisp_stop_streaming,
+	.queue_setup = atomisp_queue_setup,
+	.buf_init = atomisp_buf_init,
+	.buf_cleanup = atomisp_buf_cleanup,
+	.buf_queue = atomisp_buf_queue,
+	.start_streaming = atomisp_start_streaming,
+	.stop_streaming = atomisp_stop_streaming,
 };
 
 static void atomisp_dev_init_struct(struct atomisp_device *isp)
@@ -562,7 +567,7 @@ const struct v4l2_file_operations atomisp_fops = {
 	.poll = vb2_fop_poll,
 	.unlocked_ioctl = video_ioctl2,
 #ifdef CONFIG_COMPAT
-	/*
+/*
 	 * this was removed because of bugs, the interface
 	 * needs to be made safe for compat tasks instead.
 	.compat_ioctl32 = atomisp_compat_ioctl32,
diff --git a/drivers/staging/media/atomisp/pci/atomisp_fops.h b/drivers/staging/media/atomisp/pci/atomisp_fops.h
index a5c84029b025dc6f17465716ba1d0b3972a67a90..09fabce916440a924a2f82467025eda5ca2d861f 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_fops.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_fops.h
@@ -7,8 +7,8 @@
  * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  */
 
-#ifndef	__ATOMISP_FOPS_H__
-#define	__ATOMISP_FOPS_H__
+#ifndef __ATOMISP_FOPS_H__
+#define __ATOMISP_FOPS_H__
 #include "atomisp_subdev.h"
 
 /*
diff --git a/drivers/staging/media/atomisp/pci/atomisp_gmin_platform.c b/drivers/staging/media/atomisp/pci/atomisp_gmin_platform.c
index 5f59519ac8e28a58802f28720fbefa64913fb3af..0107c3877fb134fe3cd151f1709bdbe1c0d205b3 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_gmin_platform.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_gmin_platform.c
@@ -18,53 +18,50 @@
 
 #define MAX_SUBDEVS 8
 
-enum clock_rate {
-	VLV2_CLK_XTAL_25_0MHz = 0,
-	VLV2_CLK_PLL_19P2MHZ = 1
-};
+enum clock_rate { VLV2_CLK_XTAL_25_0MHz = 0, VLV2_CLK_PLL_19P2MHZ = 1 };
 
-#define CLK_RATE_19_2MHZ	19200000
-#define CLK_RATE_25_0MHZ	25000000
+#define CLK_RATE_19_2MHZ 19200000
+#define CLK_RATE_25_0MHZ 25000000
 
 /* Valid clock number range from 0 to 5 */
-#define MAX_CLK_COUNT                   5
+#define MAX_CLK_COUNT 5
 
 /* X-Powers AXP288 register set */
-#define ALDO1_SEL_REG	0x28
-#define ALDO1_CTRL3_REG	0x13
-#define ALDO1_2P8V	0x16
+#define ALDO1_SEL_REG 0x28
+#define ALDO1_CTRL3_REG 0x13
+#define ALDO1_2P8V 0x16
 #define ALDO1_CTRL3_SHIFT 0x05
 
-#define ELDO_CTRL_REG   0x12
+#define ELDO_CTRL_REG 0x12
 
-#define ELDO1_SEL_REG	0x19
-#define ELDO1_1P6V	0x12
+#define ELDO1_SEL_REG 0x19
+#define ELDO1_1P6V 0x12
 #define ELDO1_CTRL_SHIFT 0x00
 
-#define ELDO2_SEL_REG	0x1a
-#define ELDO2_1P8V	0x16
+#define ELDO2_SEL_REG 0x1a
+#define ELDO2_1P8V 0x16
 #define ELDO2_CTRL_SHIFT 0x01
 
 /* TI SND9039 PMIC register set */
-#define LDO9_REG	0x49
-#define LDO10_REG	0x4a
-#define LDO11_REG	0x4b
+#define LDO9_REG 0x49
+#define LDO10_REG 0x4a
+#define LDO11_REG 0x4b
 
-#define LDO_2P8V_ON	0x2f /* 0x2e selects 2.85V ...      */
-#define LDO_2P8V_OFF	0x2e /* ... bottom bit is "enabled" */
+#define LDO_2P8V_ON 0x2f /* 0x2e selects 2.85V ...      */
+#define LDO_2P8V_OFF 0x2e /* ... bottom bit is "enabled" */
 
-#define LDO_1P8V_ON	0x59 /* 0x58 selects 1.80V ...      */
-#define LDO_1P8V_OFF	0x58 /* ... bottom bit is "enabled" */
+#define LDO_1P8V_ON 0x59 /* 0x58 selects 1.80V ...      */
+#define LDO_1P8V_OFF 0x58 /* ... bottom bit is "enabled" */
 
 /* CRYSTAL COVE PMIC register set */
-#define CRYSTAL_BYT_1P8V_REG	0x5d
-#define CRYSTAL_BYT_2P8V_REG	0x66
+#define CRYSTAL_BYT_1P8V_REG 0x5d
+#define CRYSTAL_BYT_2P8V_REG 0x66
 
-#define CRYSTAL_CHT_1P8V_REG	0x57
-#define CRYSTAL_CHT_2P8V_REG	0x5d
+#define CRYSTAL_CHT_1P8V_REG 0x57
+#define CRYSTAL_CHT_2P8V_REG 0x5d
 
-#define CRYSTAL_ON		0x63
-#define CRYSTAL_OFF		0x62
+#define CRYSTAL_ON 0x63
+#define CRYSTAL_OFF 0x62
 
 struct gmin_subdev {
 	struct v4l2_subdev *subdev;
@@ -95,11 +92,11 @@ struct gmin_subdev {
 static struct gmin_subdev gmin_subdevs[MAX_SUBDEVS];
 
 /* ACPI HIDs for the PMICs that could be used by this driver */
-#define PMIC_ACPI_AXP		"INT33F4"	/* XPower AXP288 PMIC */
-#define PMIC_ACPI_TI		"INT33F5"	/* Dollar Cove TI PMIC */
-#define PMIC_ACPI_CRYSTALCOVE	"INT33FD"	/* Crystal Cove PMIC */
+#define PMIC_ACPI_AXP "INT33F4" /* XPower AXP288 PMIC */
+#define PMIC_ACPI_TI "INT33F5" /* Dollar Cove TI PMIC */
+#define PMIC_ACPI_CRYSTALCOVE "INT33FD" /* Crystal Cove PMIC */
 
-#define PMIC_PLATFORM_TI	"intel_soc_pmic_chtdc_ti"
+#define PMIC_PLATFORM_TI "intel_soc_pmic_chtdc_ti"
 
 static enum {
 	PMIC_UNSET = 0,
@@ -110,11 +107,11 @@ static enum {
 } pmic_id;
 
 static const char *pmic_name[] = {
-	[PMIC_UNSET]		= "ACPI device PM",
-	[PMIC_REGULATOR]	= "regulator driver",
-	[PMIC_AXP]		= "XPower AXP288 PMIC",
-	[PMIC_TI]		= "Dollar Cove TI PMIC",
-	[PMIC_CRYSTALCOVE]	= "Crystal Cove PMIC",
+	[PMIC_UNSET] = "ACPI device PM",
+	[PMIC_REGULATOR] = "regulator driver",
+	[PMIC_AXP] = "XPower AXP288 PMIC",
+	[PMIC_TI] = "Dollar Cove TI PMIC",
+	[PMIC_CRYSTALCOVE] = "Crystal Cove PMIC",
 };
 
 static DEFINE_MUTEX(gmin_regulator_mutex);
@@ -215,51 +212,45 @@ struct gmin_cfg_var {
 };
 
 static struct gmin_cfg_var ffrd8_vars[] = {
-	{ "INTCF1B:00_ImxId",    "0x134" },
-	{ "INTCF1B:00_CsiPort",  "1" },
+	{ "INTCF1B:00_ImxId", "0x134" },
+	{ "INTCF1B:00_CsiPort", "1" },
 	{ "INTCF1B:00_CsiLanes", "4" },
 	{ "INTCF1B:00_CamClk", "0" },
 	{},
 };
 
 static struct gmin_cfg_var mrd7_vars[] = {
-	{"INT33F8:00_CamType", "1"},
-	{"INT33F8:00_CsiPort", "1"},
-	{"INT33F8:00_CsiLanes", "2"},
-	{"INT33F8:00_CsiFmt", "13"},
-	{"INT33F8:00_CsiBayer", "0"},
-	{"INT33F8:00_CamClk", "0"},
-
-	{"INT33F9:00_CamType", "1"},
-	{"INT33F9:00_CsiPort", "0"},
-	{"INT33F9:00_CsiLanes", "1"},
-	{"INT33F9:00_CsiFmt", "13"},
-	{"INT33F9:00_CsiBayer", "0"},
-	{"INT33F9:00_CamClk", "1"},
+	{ "INT33F8:00_CamType", "1" },
+	{ "INT33F8:00_CsiPort", "1" },
+	{ "INT33F8:00_CsiLanes", "2" },
+	{ "INT33F8:00_CsiFmt", "13" },
+	{ "INT33F8:00_CsiBayer", "0" },
+	{ "INT33F8:00_CamClk", "0" },
+
+	{ "INT33F9:00_CamType", "1" },
+	{ "INT33F9:00_CsiPort", "0" },
+	{ "INT33F9:00_CsiLanes", "1" },
+	{ "INT33F9:00_CsiFmt", "13" },
+	{ "INT33F9:00_CsiBayer", "0" },
+	{ "INT33F9:00_CamClk", "1" },
 	{},
 };
 
 static struct gmin_cfg_var i8880_vars[] = {
-	{"XXOV2680:00_CsiPort", "1"},
-	{"XXOV2680:00_CsiLanes", "1"},
-	{"XXOV2680:00_CamClk", "0"},
+	{ "XXOV2680:00_CsiPort", "1" }, { "XXOV2680:00_CsiLanes", "1" },
+	{ "XXOV2680:00_CamClk", "0" },
 
-	{"XXGC0310:00_CsiPort", "0"},
-	{"XXGC0310:00_CsiLanes", "1"},
-	{"XXGC0310:00_CamClk", "1"},
-	{},
+	{ "XXGC0310:00_CsiPort", "0" }, { "XXGC0310:00_CsiLanes", "1" },
+	{ "XXGC0310:00_CamClk", "1" },	{},
 };
 
 /*
  * Surface 3 does not describe CsiPort/CsiLanes in both DSDT and EFI.
  */
 static struct gmin_cfg_var surface3_vars[] = {
-	{"APTA0330:00_CsiPort", "0"},
-	{"APTA0330:00_CsiLanes", "2"},
+	{ "APTA0330:00_CsiPort", "0" }, { "APTA0330:00_CsiLanes", "2" },
 
-	{"OVTI8835:00_CsiPort", "1"},
-	{"OVTI8835:00_CsiLanes", "4"},
-	{},
+	{ "OVTI8835:00_CsiPort", "1" }, { "OVTI8835:00_CsiLanes", "4" }, {},
 };
 
 static struct gmin_cfg_var lenovo_ideapad_miix_310_vars[] = {
@@ -314,13 +305,13 @@ static const struct dmi_system_id gmin_vars[] = {
 	{}
 };
 
-#define GMIN_CFG_VAR_EFI_GUID EFI_GUID(0xecb54cd9, 0xe5ae, 0x4fdc, \
-				       0xa9, 0x71, 0xe8, 0x77,	   \
-				       0x75, 0x60, 0x68, 0xf7)
+#define GMIN_CFG_VAR_EFI_GUID                                              \
+	EFI_GUID(0xecb54cd9, 0xe5ae, 0x4fdc, 0xa9, 0x71, 0xe8, 0x77, 0x75, \
+		 0x60, 0x68, 0xf7)
 
 static const guid_t atomisp_dsm_guid = GUID_INIT(0xdc2f6c4f, 0x045b, 0x4f1d,
-						 0x97, 0xb9, 0x88, 0x2a,
-						 0x68, 0x60, 0xa4, 0xbe);
+						 0x97, 0xb9, 0x88, 0x2a, 0x68,
+						 0x60, 0xa4, 0xbe);
 
 #define CFG_VAR_NAME_MAX 64
 
@@ -346,8 +337,8 @@ static struct i2c_client *gmin_i2c_dev_exists(struct device *dev, char *name,
 	return *client;
 }
 
-static int gmin_i2c_write(struct device *dev, u16 i2c_addr, u8 reg,
-			  u32 value, u32 mask)
+static int gmin_i2c_write(struct device *dev, u16 i2c_addr, u8 reg, u32 value,
+			  u32 mask)
 {
 	int ret;
 
@@ -362,7 +353,8 @@ static int gmin_i2c_write(struct device *dev, u16 i2c_addr, u8 reg,
 		"I2C write, addr: 0x%02x, reg: 0x%02x, value: 0x%02x, mask: 0x%02x\n",
 		i2c_addr, reg, value, mask);
 
-	ret = intel_soc_pmic_exec_mipi_pmic_seq_element(i2c_addr, reg, value, mask);
+	ret = intel_soc_pmic_exec_mipi_pmic_seq_element(i2c_addr, reg, value,
+							mask);
 	if (ret == -EOPNOTSUPP)
 		dev_err(dev,
 			"ACPI didn't mapped the OpRegion needed to access I2C address 0x%02x.\n"
@@ -390,9 +382,8 @@ static int atomisp_get_acpi_power(struct device *dev)
 
 	package = buffer.pointer;
 
-	if (!buffer.length || !package
-	    || package->type != ACPI_TYPE_PACKAGE
-	    || !package->package.count)
+	if (!buffer.length || !package || package->type != ACPI_TYPE_PACKAGE ||
+	    !package->package.count)
 		goto fail;
 
 	for (i = 0; i < package->package.count; i++) {
@@ -459,7 +450,8 @@ static int gmin_detect_pmic(struct v4l2_subdev *subdev)
 	u8 pmic_i2c_addr;
 
 	pmic_i2c_addr = gmin_get_pmic_id_and_addr(dev);
-	dev_info(dev, "gmin: power management provided via %s (i2c addr 0x%02x)\n",
+	dev_info(dev,
+		 "gmin: power management provided via %s (i2c addr 0x%02x)\n",
 		 pmic_name[pmic_id], pmic_i2c_addr);
 	return pmic_i2c_addr;
 }
@@ -474,8 +466,8 @@ static int gmin_subdev_add(struct gmin_subdev *gs)
 	dev_info(dev, "%s: ACPI path is %pfw\n", __func__, dev_fwnode(dev));
 
 	/* WA:CHT requires XTAL clock as PLL is not stable. */
-	gs->clock_src = gmin_get_var_int(dev, false, "ClkSrc",
-					 VLV2_CLK_PLL_19P2MHZ);
+	gs->clock_src =
+		gmin_get_var_int(dev, false, "ClkSrc", VLV2_CLK_PLL_19P2MHZ);
 
 	/*
 	 * Get ACPI _PR0 derived clock here already because it is used
@@ -527,8 +519,7 @@ static int gmin_subdev_add(struct gmin_subdev *gs)
 	 * So, at least for the existing devices we know, the check below
 	 * will always be false.
 	 */
-	if (acpi_device_can_wakeup(adev) &&
-	    acpi_device_can_poweroff(adev)) {
+	if (acpi_device_can_wakeup(adev) && acpi_device_can_poweroff(adev)) {
 		dev_info(dev,
 			 "gmin: power management provided via device PM\n");
 		return 0;
@@ -563,13 +554,14 @@ static int gmin_subdev_add(struct gmin_subdev *gs)
 		return -EINVAL;
 	}
 
-	snprintf(gmin_pmc_clk_name, sizeof(gmin_pmc_clk_name),
-		 "%s_%d", "pmc_plt_clk", clock_num);
+	snprintf(gmin_pmc_clk_name, sizeof(gmin_pmc_clk_name), "%s_%d",
+		 "pmc_plt_clk", clock_num);
 
 	gs->pmc_clk = devm_clk_get(dev, gmin_pmc_clk_name);
 	if (IS_ERR(gs->pmc_clk)) {
 		ret = PTR_ERR(gs->pmc_clk);
-		dev_err(dev, "Failed to get clk from %s: %d\n", gmin_pmc_clk_name, ret);
+		dev_err(dev, "Failed to get clk from %s: %d\n",
+			gmin_pmc_clk_name, ret);
 		return ret;
 	}
 	dev_info(dev, "Will use CLK%d (%s)\n", clock_num, gmin_pmc_clk_name);
@@ -605,24 +597,18 @@ static int gmin_subdev_add(struct gmin_subdev *gs)
 		break;
 
 	case PMIC_AXP:
-		gs->eldo1_1p6v = gmin_get_var_int(dev, false,
-						  "eldo1_1p8v",
-						  ELDO1_1P6V);
-		gs->eldo1_sel_reg = gmin_get_var_int(dev, false,
-						     "eldo1_sel_reg",
-						     ELDO1_SEL_REG);
-		gs->eldo1_ctrl_shift = gmin_get_var_int(dev, false,
-							"eldo1_ctrl_shift",
-							ELDO1_CTRL_SHIFT);
-		gs->eldo2_1p8v = gmin_get_var_int(dev, false,
-						  "eldo2_1p8v",
-						  ELDO2_1P8V);
-		gs->eldo2_sel_reg = gmin_get_var_int(dev, false,
-						     "eldo2_sel_reg",
-						     ELDO2_SEL_REG);
-		gs->eldo2_ctrl_shift = gmin_get_var_int(dev, false,
-							"eldo2_ctrl_shift",
-							ELDO2_CTRL_SHIFT);
+		gs->eldo1_1p6v =
+			gmin_get_var_int(dev, false, "eldo1_1p8v", ELDO1_1P6V);
+		gs->eldo1_sel_reg = gmin_get_var_int(
+			dev, false, "eldo1_sel_reg", ELDO1_SEL_REG);
+		gs->eldo1_ctrl_shift = gmin_get_var_int(
+			dev, false, "eldo1_ctrl_shift", ELDO1_CTRL_SHIFT);
+		gs->eldo2_1p8v =
+			gmin_get_var_int(dev, false, "eldo2_1p8v", ELDO2_1P8V);
+		gs->eldo2_sel_reg = gmin_get_var_int(
+			dev, false, "eldo2_sel_reg", ELDO2_SEL_REG);
+		gs->eldo2_ctrl_shift = gmin_get_var_int(
+			dev, false, "eldo2_ctrl_shift", ELDO2_CTRL_SHIFT);
 		break;
 
 	default:
@@ -653,8 +639,8 @@ static struct gmin_subdev *find_free_gmin_subdev_slot(void)
 }
 
 static int axp_regulator_set(struct device *dev, struct gmin_subdev *gs,
-			     int sel_reg, u8 setting,
-			     int ctrl_reg, int shift, bool on)
+			     int sel_reg, u8 setting, int ctrl_reg, int shift,
+			     bool on)
 {
 	int ret;
 	int val;
@@ -811,8 +797,8 @@ static int gmin_v1p8_ctrl(struct v4l2_subdev *subdev, int on)
 	case PMIC_TI:
 		value = on ? LDO_1P8V_ON : LDO_1P8V_OFF;
 
-		ret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr,
-				     LDO10_REG, value, 0xff);
+		ret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr, LDO10_REG,
+				     value, 0xff);
 		break;
 	case PMIC_CRYSTALCOVE:
 		if (IS_ISP2401)
@@ -822,8 +808,8 @@ static int gmin_v1p8_ctrl(struct v4l2_subdev *subdev, int on)
 
 		value = on ? CRYSTAL_ON : CRYSTAL_OFF;
 
-		ret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr,
-				     reg, value, 0xff);
+		ret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr, reg, value,
+				     0xff);
 		break;
 	default:
 		dev_err(subdev->dev, "Couldn't set power mode for v1p8\n");
@@ -880,8 +866,8 @@ static int gmin_v2p8_ctrl(struct v4l2_subdev *subdev, int on)
 	case PMIC_TI:
 		value = on ? LDO_2P8V_ON : LDO_2P8V_OFF;
 
-		ret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr,
-				     LDO9_REG, value, 0xff);
+		ret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr, LDO9_REG,
+				     value, 0xff);
 		break;
 	case PMIC_CRYSTALCOVE:
 		if (IS_ISP2401)
@@ -891,8 +877,8 @@ static int gmin_v2p8_ctrl(struct v4l2_subdev *subdev, int on)
 
 		value = on ? CRYSTAL_ON : CRYSTAL_OFF;
 
-		ret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr,
-				     reg, value, 0xff);
+		ret = gmin_i2c_write(subdev->dev, gs->pwm_i2c_addr, reg, value,
+				     0xff);
 		break;
 	default:
 		dev_err(subdev->dev, "Couldn't set power mode for v2p8\n");
@@ -916,15 +902,12 @@ static int gmin_acpi_pm_ctrl(struct v4l2_subdev *subdev, int on)
 	if (gs->clock_on == on)
 		return 0;
 
-	dev_dbg(subdev->dev, "Setting power state to %s\n",
-		on ? "on" : "off");
+	dev_dbg(subdev->dev, "Setting power state to %s\n", on ? "on" : "off");
 
 	if (on)
-		ret = acpi_device_set_power(adev,
-					    ACPI_STATE_D0);
+		ret = acpi_device_set_power(adev, ACPI_STATE_D0);
 	else
-		ret = acpi_device_set_power(adev,
-					    ACPI_STATE_D3_COLD);
+		ret = acpi_device_set_power(adev, ACPI_STATE_D3_COLD);
 
 	if (!ret)
 		gs->clock_on = on;
@@ -945,8 +928,9 @@ static int gmin_flisclk_ctrl(struct v4l2_subdev *subdev, int on)
 		return 0;
 
 	if (on) {
-		ret = clk_set_rate(gs->pmc_clk,
-				   gs->clock_src ? CLK_RATE_19_2MHZ : CLK_RATE_25_0MHZ);
+		ret = clk_set_rate(gs->pmc_clk, gs->clock_src ?
+							CLK_RATE_19_2MHZ :
+							CLK_RATE_25_0MHZ);
 
 		if (ret)
 			dev_err(&client->dev, "unable to set PMC rate %d\n",
@@ -981,8 +965,8 @@ static int camera_sensor_csi_alloc(struct v4l2_subdev *sd, u32 port, u32 lanes,
 	csi->metadata_format = ATOMISP_INPUT_FORMAT_EMBEDDED;
 	csi->metadata_effective_width = NULL;
 	dev_info(&client->dev,
-		 "camera pdata: port: %d lanes: %d order: %8.8x\n",
-		 port, lanes, bayer_order);
+		 "camera pdata: port: %d lanes: %d order: %8.8x\n", port, lanes,
+		 bayer_order);
 
 	return 0;
 }
@@ -1031,7 +1015,8 @@ int atomisp_register_sensor_no_gmin(struct v4l2_subdev *subdev, u32 lanes,
 		}
 
 		port = gmin_get_var_int(&client->dev, false, "CsiPort", port);
-		lanes = gmin_get_var_int(&client->dev, false, "CsiLanes", lanes);
+		lanes = gmin_get_var_int(&client->dev, false, "CsiLanes",
+					 lanes);
 	}
 
 	for (i = 0; i < MAX_SUBDEVS; i++)
@@ -1039,7 +1024,8 @@ int atomisp_register_sensor_no_gmin(struct v4l2_subdev *subdev, u32 lanes,
 			break;
 
 	if (i >= MAX_SUBDEVS) {
-		dev_err(&client->dev, "Error too many subdevs already registered\n");
+		dev_err(&client->dev,
+			"Error too many subdevs already registered\n");
 		return -ENOMEM;
 	}
 
@@ -1138,9 +1124,7 @@ static int gmin_get_hardcoded_var(struct device *dev,
 	return -EINVAL;
 }
 
-
-static int gmin_get_config_dsm_var(struct device *dev,
-				   const char *var,
+static int gmin_get_config_dsm_var(struct device *dev, const char *var,
 				   char *out, size_t *out_len)
 {
 	acpi_handle handle = ACPI_HANDLE(dev);
@@ -1225,10 +1209,8 @@ static int gmin_get_config_dsm_var(struct device *dev,
  * argument should be a device with an ACPI companion, as all
  * configuration is based on firmware ID.
  */
-static int gmin_get_config_var(struct device *maindev,
-			       bool is_gmin,
-			       const char *var,
-			       char *out, size_t *out_len)
+static int gmin_get_config_var(struct device *maindev, bool is_gmin,
+			       const char *var, char *out, size_t *out_len)
 {
 	struct acpi_device *adev = ACPI_COMPANION(maindev);
 	efi_char16_t var16[CFG_VAR_NAME_MAX];
@@ -1238,7 +1220,8 @@ static int gmin_get_config_var(struct device *maindev,
 	int i, ret;
 
 	if (!is_gmin && adev)
-		ret = snprintf(var8, sizeof(var8), "%s_%s", acpi_dev_name(adev), var);
+		ret = snprintf(var8, sizeof(var8), "%s_%s", acpi_dev_name(adev),
+			       var);
 	else
 		ret = snprintf(var8, sizeof(var8), "gmin_%s", var);
 
@@ -1275,7 +1258,8 @@ static int gmin_get_config_var(struct device *maindev,
 	if (status == EFI_SUCCESS)
 		dev_info(maindev, "found EFI entry for '%s'\n", var8);
 	else if (is_gmin)
-		dev_info(maindev, "Failed to find EFI gmin variable %s\n", var8);
+		dev_info(maindev, "Failed to find EFI gmin variable %s\n",
+			 var8);
 	else
 		dev_info(maindev, "Failed to find EFI variable %s\n", var8);
 
diff --git a/drivers/staging/media/atomisp/pci/atomisp_internal.h b/drivers/staging/media/atomisp/pci/atomisp_internal.h
index 5a69580b82514aa793c6a61b5023e454ee651191..c19fd9468a4a422cd1a0ebdb8e9628ec794f384a 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_internal.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_internal.h
@@ -31,58 +31,58 @@
 #include "irq.h"
 #include <linux/vmalloc.h>
 
-#define V4L2_EVENT_FRAME_END          5
+#define V4L2_EVENT_FRAME_END 5
 
-#define IS_HWREVISION(isp, rev) \
+#define IS_HWREVISION(isp, rev)                                       \
 	(((isp)->media_dev.hw_revision & ATOMISP_HW_REVISION_MASK) == \
 	 ((rev) << ATOMISP_HW_REVISION_SHIFT))
 
-#define ATOMISP_PCI_DEVICE_SOC_BYT	0x0f38
+#define ATOMISP_PCI_DEVICE_SOC_BYT 0x0f38
 /* MRFLD with 0x1178: ISP freq can burst to 457MHz */
-#define ATOMISP_PCI_DEVICE_SOC_MRFLD	0x1178
+#define ATOMISP_PCI_DEVICE_SOC_MRFLD 0x1178
 /* MRFLD with 0x1179: max ISP freq limited to 400MHz */
-#define ATOMISP_PCI_DEVICE_SOC_MRFLD_1179	0x1179
+#define ATOMISP_PCI_DEVICE_SOC_MRFLD_1179 0x1179
 /* MRFLD with 0x117a: max ISP freq is 400MHz and max freq at Vmin is 200MHz */
-#define ATOMISP_PCI_DEVICE_SOC_MRFLD_117A	0x117a
-#define ATOMISP_PCI_DEVICE_SOC_ANN	0x1478
-#define ATOMISP_PCI_DEVICE_SOC_CHT	0x22b8
+#define ATOMISP_PCI_DEVICE_SOC_MRFLD_117A 0x117a
+#define ATOMISP_PCI_DEVICE_SOC_ANN 0x1478
+#define ATOMISP_PCI_DEVICE_SOC_CHT 0x22b8
 
-#define ATOMISP_PCI_REV_MRFLD_A0_MAX	0
-#define ATOMISP_PCI_REV_BYT_A0_MAX	4
+#define ATOMISP_PCI_REV_MRFLD_A0_MAX 0
+#define ATOMISP_PCI_REV_BYT_A0_MAX 4
 
-#define ATOM_ISP_STEP_WIDTH	2
-#define ATOM_ISP_STEP_HEIGHT	2
+#define ATOM_ISP_STEP_WIDTH 2
+#define ATOM_ISP_STEP_HEIGHT 2
 
-#define ATOM_ISP_MIN_WIDTH	4
-#define ATOM_ISP_MIN_HEIGHT	4
-#define ATOM_ISP_MAX_WIDTH	UINT_MAX
-#define ATOM_ISP_MAX_HEIGHT	UINT_MAX
+#define ATOM_ISP_MIN_WIDTH 4
+#define ATOM_ISP_MIN_HEIGHT 4
+#define ATOM_ISP_MAX_WIDTH UINT_MAX
+#define ATOM_ISP_MAX_HEIGHT UINT_MAX
 
 /* sub-QCIF resolution */
-#define ATOM_RESOLUTION_SUBQCIF_WIDTH	128
-#define ATOM_RESOLUTION_SUBQCIF_HEIGHT	96
+#define ATOM_RESOLUTION_SUBQCIF_WIDTH 128
+#define ATOM_RESOLUTION_SUBQCIF_HEIGHT 96
 
-#define ATOM_ISP_I2C_BUS_1	4
-#define ATOM_ISP_I2C_BUS_2	5
+#define ATOM_ISP_I2C_BUS_1 4
+#define ATOM_ISP_I2C_BUS_2 5
 
-#define ATOM_ISP_POWER_DOWN	0
-#define ATOM_ISP_POWER_UP	1
+#define ATOM_ISP_POWER_DOWN 0
+#define ATOM_ISP_POWER_UP 1
 
-#define ATOM_ISP_MAX_INPUTS	3
+#define ATOM_ISP_MAX_INPUTS 3
 
-#define ATOMISP_SC_TYPE_SIZE	2
+#define ATOMISP_SC_TYPE_SIZE 2
 
-#define ATOMISP_ISP_TIMEOUT_DURATION		(2 * HZ)
-#define ATOMISP_EXT_ISP_TIMEOUT_DURATION        (6 * HZ)
-#define ATOMISP_WDT_KEEP_CURRENT_DELAY          0
-#define ATOMISP_ISP_MAX_TIMEOUT_COUNT	2
-#define ATOMISP_CSS_STOP_TIMEOUT_US	200000
+#define ATOMISP_ISP_TIMEOUT_DURATION (2 * HZ)
+#define ATOMISP_EXT_ISP_TIMEOUT_DURATION (6 * HZ)
+#define ATOMISP_WDT_KEEP_CURRENT_DELAY 0
+#define ATOMISP_ISP_MAX_TIMEOUT_COUNT 2
+#define ATOMISP_CSS_STOP_TIMEOUT_US 200000
 
-#define ATOMISP_CSS_Q_DEPTH	3
-#define ATOMISP_CSS_EVENTS_MAX  16
+#define ATOMISP_CSS_Q_DEPTH 3
+#define ATOMISP_CSS_EVENTS_MAX 16
 #define ATOMISP_CONT_RAW_FRAMES 15
-#define ATOMISP_METADATA_QUEUE_DEPTH_FOR_HAL	8
-#define ATOMISP_S3A_BUF_QUEUE_DEPTH_FOR_HAL	8
+#define ATOMISP_METADATA_QUEUE_DEPTH_FOR_HAL 8
+#define ATOMISP_S3A_BUF_QUEUE_DEPTH_FOR_HAL 8
 
 /*
  * Define how fast CPU should be able to serve ISP interrupts.
@@ -92,26 +92,26 @@
  * 1000 us is a reasonable value considering that the processing
  * time is typically ~2000 us.
  */
-#define ATOMISP_MAX_ISR_LATENCY	1000
+#define ATOMISP_MAX_ISR_LATENCY 1000
 
 /* Add new YUVPP pipe for SOC sensor. */
-#define ATOMISP_CSS_SUPPORT_YUVPP     1
+#define ATOMISP_CSS_SUPPORT_YUVPP 1
 
-#define ATOMISP_CSS_OUTPUT_SECOND_INDEX     1
-#define ATOMISP_CSS_OUTPUT_DEFAULT_INDEX    0
+#define ATOMISP_CSS_OUTPUT_SECOND_INDEX 1
+#define ATOMISP_CSS_OUTPUT_DEFAULT_INDEX 0
 
 /* ISP2401 */
-#define ATOMISP_ION_DEVICE_FD_OFFSET   16
-#define ATOMISP_ION_SHARED_FD_MASK     (0xFFFF)
-#define ATOMISP_ION_DEVICE_FD_MASK     (~ATOMISP_ION_SHARED_FD_MASK)
+#define ATOMISP_ION_DEVICE_FD_OFFSET 16
+#define ATOMISP_ION_SHARED_FD_MASK (0xFFFF)
+#define ATOMISP_ION_DEVICE_FD_MASK (~ATOMISP_ION_SHARED_FD_MASK)
 #define ION_FD_UNSET (-1)
 
 #define DIV_NEAREST_STEP(n, d, step) \
 	round_down((2 * (n) + (d) * (step)) / (2 * (d)), (step))
 
-#define SENSOR_ISP_PAD_SINK		0
-#define SENSOR_ISP_PAD_SOURCE		1
-#define SENSOR_ISP_PADS_NUM		2
+#define SENSOR_ISP_PAD_SINK 0
+#define SENSOR_ISP_PAD_SOURCE 1
+#define SENSOR_ISP_PADS_NUM 2
 
 struct atomisp_input_subdev {
 	enum atomisp_camera_port port;
diff --git a/drivers/staging/media/atomisp/pci/atomisp_ioctl.c b/drivers/staging/media/atomisp/pci/atomisp_ioctl.c
index 97d99bed15601dd89f2142a0233d7125a8b41ad5..3bbd6b7f9e61cf59e88bf1e13598987e0eb10567 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_ioctl.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_ioctl.c
@@ -27,8 +27,8 @@
 #include "device_access.h"
 #include "irq.h"
 
-static const char *DRIVER = "atomisp";	/* max size 15 */
-static const char *CARD = "ATOM ISP";	/* max size 31 */
+static const char *DRIVER = "atomisp"; /* max size 15 */
+static const char *CARD = "ATOM ISP"; /* max size 31 */
 
 /*
  * FIXME: ISP should not know beforehand all CIDs supported by sensor.
@@ -142,150 +142,127 @@ static const u32 ctrls_num = ARRAY_SIZE(ci_v4l2_controls);
  * supported V4L2 fmts and resolutions
  */
 const struct atomisp_format_bridge atomisp_output_fmts[] = {
-	{
-		.pixelformat = V4L2_PIX_FMT_YUV420,
-		.depth = 12,
-		.mbus_code = V4L2_MBUS_FMT_CUSTOM_YUV420,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_YUV420,
-		.description = "YUV420, planar",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_YVU420,
-		.depth = 12,
-		.mbus_code = V4L2_MBUS_FMT_CUSTOM_YVU420,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_YV12,
-		.description = "YVU420, planar",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_YUV422P,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_CUSTOM_YUV422P,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_YUV422,
-		.description = "YUV422, planar",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_YUV444,
-		.depth = 24,
-		.mbus_code = V4L2_MBUS_FMT_CUSTOM_YUV444,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_YUV444,
-		.description = "YUV444"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_NV12,
-		.depth = 12,
-		.mbus_code = V4L2_MBUS_FMT_CUSTOM_NV12,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_NV12,
-		.description = "NV12, Y-plane, CbCr interleaved",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_NV21,
-		.depth = 12,
-		.mbus_code = V4L2_MBUS_FMT_CUSTOM_NV21,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_NV21,
-		.description = "NV21, Y-plane, CbCr interleaved",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_NV16,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_CUSTOM_NV16,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_NV16,
-		.description = "NV16, Y-plane, CbCr interleaved",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_YUYV,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_CUSTOM_YUYV,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_YUYV,
-		.description = "YUYV, interleaved"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_UYVY,
-		.depth = 16,
-		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_UYVY,
-		.description = "UYVY, interleaved"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SBGGR16,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_CUSTOM_SBGGR16,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 16"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SBGGR8,
-		.depth = 8,
-		.mbus_code = MEDIA_BUS_FMT_SBGGR8_1X8,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 8"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGBRG8,
-		.depth = 8,
-		.mbus_code = MEDIA_BUS_FMT_SGBRG8_1X8,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 8"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGRBG8,
-		.depth = 8,
-		.mbus_code = MEDIA_BUS_FMT_SGRBG8_1X8,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 8"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SRGGB8,
-		.depth = 8,
-		.mbus_code = MEDIA_BUS_FMT_SRGGB8_1X8,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 8"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SBGGR10,
-		.depth = 16,
-		.mbus_code = MEDIA_BUS_FMT_SBGGR10_1X10,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 10"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGBRG10,
-		.depth = 16,
-		.mbus_code = MEDIA_BUS_FMT_SGBRG10_1X10,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 10"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGRBG10,
-		.depth = 16,
-		.mbus_code = MEDIA_BUS_FMT_SGRBG10_1X10,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 10"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SRGGB10,
-		.depth = 16,
-		.mbus_code = MEDIA_BUS_FMT_SRGGB10_1X10,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 10"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SBGGR12,
-		.depth = 16,
-		.mbus_code = MEDIA_BUS_FMT_SBGGR12_1X12,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 12"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGBRG12,
-		.depth = 16,
-		.mbus_code = MEDIA_BUS_FMT_SGBRG12_1X12,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 12"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGRBG12,
-		.depth = 16,
-		.mbus_code = MEDIA_BUS_FMT_SGRBG12_1X12,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 12"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SRGGB12,
-		.depth = 16,
-		.mbus_code = MEDIA_BUS_FMT_SRGGB12_1X12,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 12"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_RGB565,
-		.depth = 16,
-		.mbus_code = MEDIA_BUS_FMT_BGR565_2X8_LE,
-		.sh_fmt = IA_CSS_FRAME_FORMAT_RGB565,
-		.description = "16 RGB 5-6-5"
+	{ .pixelformat = V4L2_PIX_FMT_YUV420,
+	  .depth = 12,
+	  .mbus_code = V4L2_MBUS_FMT_CUSTOM_YUV420,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_YUV420,
+	  .description = "YUV420, planar",
+	  .planar = true },
+	{ .pixelformat = V4L2_PIX_FMT_YVU420,
+	  .depth = 12,
+	  .mbus_code = V4L2_MBUS_FMT_CUSTOM_YVU420,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_YV12,
+	  .description = "YVU420, planar",
+	  .planar = true },
+	{ .pixelformat = V4L2_PIX_FMT_YUV422P,
+	  .depth = 16,
+	  .mbus_code = V4L2_MBUS_FMT_CUSTOM_YUV422P,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_YUV422,
+	  .description = "YUV422, planar",
+	  .planar = true },
+	{ .pixelformat = V4L2_PIX_FMT_YUV444,
+	  .depth = 24,
+	  .mbus_code = V4L2_MBUS_FMT_CUSTOM_YUV444,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_YUV444,
+	  .description = "YUV444" },
+	{ .pixelformat = V4L2_PIX_FMT_NV12,
+	  .depth = 12,
+	  .mbus_code = V4L2_MBUS_FMT_CUSTOM_NV12,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_NV12,
+	  .description = "NV12, Y-plane, CbCr interleaved",
+	  .planar = true },
+	{ .pixelformat = V4L2_PIX_FMT_NV21,
+	  .depth = 12,
+	  .mbus_code = V4L2_MBUS_FMT_CUSTOM_NV21,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_NV21,
+	  .description = "NV21, Y-plane, CbCr interleaved",
+	  .planar = true },
+	{ .pixelformat = V4L2_PIX_FMT_NV16,
+	  .depth = 16,
+	  .mbus_code = V4L2_MBUS_FMT_CUSTOM_NV16,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_NV16,
+	  .description = "NV16, Y-plane, CbCr interleaved",
+	  .planar = true },
+	{ .pixelformat = V4L2_PIX_FMT_YUYV,
+	  .depth = 16,
+	  .mbus_code = V4L2_MBUS_FMT_CUSTOM_YUYV,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_YUYV,
+	  .description = "YUYV, interleaved" },
+	{ .pixelformat = V4L2_PIX_FMT_UYVY,
+	  .depth = 16,
+	  .mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_UYVY,
+	  .description = "UYVY, interleaved" },
+	{ .pixelformat = V4L2_PIX_FMT_SBGGR16,
+	  .depth = 16,
+	  .mbus_code = V4L2_MBUS_FMT_CUSTOM_SBGGR16,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 16" },
+	{ .pixelformat = V4L2_PIX_FMT_SBGGR8,
+	  .depth = 8,
+	  .mbus_code = MEDIA_BUS_FMT_SBGGR8_1X8,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 8" },
+	{ .pixelformat = V4L2_PIX_FMT_SGBRG8,
+	  .depth = 8,
+	  .mbus_code = MEDIA_BUS_FMT_SGBRG8_1X8,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 8" },
+	{ .pixelformat = V4L2_PIX_FMT_SGRBG8,
+	  .depth = 8,
+	  .mbus_code = MEDIA_BUS_FMT_SGRBG8_1X8,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 8" },
+	{ .pixelformat = V4L2_PIX_FMT_SRGGB8,
+	  .depth = 8,
+	  .mbus_code = MEDIA_BUS_FMT_SRGGB8_1X8,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 8" },
+	{ .pixelformat = V4L2_PIX_FMT_SBGGR10,
+	  .depth = 16,
+	  .mbus_code = MEDIA_BUS_FMT_SBGGR10_1X10,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 10" },
+	{ .pixelformat = V4L2_PIX_FMT_SGBRG10,
+	  .depth = 16,
+	  .mbus_code = MEDIA_BUS_FMT_SGBRG10_1X10,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 10" },
+	{ .pixelformat = V4L2_PIX_FMT_SGRBG10,
+	  .depth = 16,
+	  .mbus_code = MEDIA_BUS_FMT_SGRBG10_1X10,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 10" },
+	{ .pixelformat = V4L2_PIX_FMT_SRGGB10,
+	  .depth = 16,
+	  .mbus_code = MEDIA_BUS_FMT_SRGGB10_1X10,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 10" },
+	{ .pixelformat = V4L2_PIX_FMT_SBGGR12,
+	  .depth = 16,
+	  .mbus_code = MEDIA_BUS_FMT_SBGGR12_1X12,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 12" },
+	{ .pixelformat = V4L2_PIX_FMT_SGBRG12,
+	  .depth = 16,
+	  .mbus_code = MEDIA_BUS_FMT_SGBRG12_1X12,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 12" },
+	{ .pixelformat = V4L2_PIX_FMT_SGRBG12,
+	  .depth = 16,
+	  .mbus_code = MEDIA_BUS_FMT_SGRBG12_1X12,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 12" },
+	{ .pixelformat = V4L2_PIX_FMT_SRGGB12,
+	  .depth = 16,
+	  .mbus_code = MEDIA_BUS_FMT_SRGGB12_1X12,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+	  .description = "Bayer 12" },
+	{ .pixelformat = V4L2_PIX_FMT_RGB565,
+	  .depth = 16,
+	  .mbus_code = MEDIA_BUS_FMT_BGR565_2X8_LE,
+	  .sh_fmt = IA_CSS_FRAME_FORMAT_RGB565,
+	  .description = "16 RGB 5-6-5"
 #if 0
 	}, {
 		/*
@@ -349,7 +326,8 @@ int atomisp_pipe_check(struct atomisp_video_pipe *pipe, bool settings_change)
 		return -EIO;
 
 	if (settings_change && vb2_is_busy(&pipe->vb_queue)) {
-		dev_err(pipe->isp->dev, "Set fmt/input IOCTL while streaming\n");
+		dev_err(pipe->isp->dev,
+			"Set fmt/input IOCTL while streaming\n");
 		return -EBUSY;
 	}
 
@@ -368,7 +346,8 @@ static int atomisp_querycap(struct file *file, void *fh,
 
 	strscpy(cap->driver, DRIVER, sizeof(cap->driver));
 	strscpy(cap->card, CARD, sizeof(cap->card));
-	snprintf(cap->bus_info, sizeof(cap->bus_info), "PCI:%s", dev_name(isp->dev));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "PCI:%s",
+		 dev_name(isp->dev));
 
 	return 0;
 }
@@ -412,8 +391,7 @@ static int atomisp_g_input(struct file *file, void *fh, unsigned int *input)
 	return 0;
 }
 
-static int atomisp_s_fmt_cap(struct file *file, void *fh,
-			     struct v4l2_format *f)
+static int atomisp_s_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
 {
 	struct video_device *vdev = video_devdata(file);
 
@@ -458,24 +436,17 @@ static int atomisp_enum_framesizes_crop_inner(struct atomisp_device *isp,
 					      int *valid_sizes)
 {
 	static const struct v4l2_frmsize_discrete frame_sizes[] = {
-		{ 1920, 1440 },
-		{ 1920, 1200 },
-		{ 1920, 1080 },
-		{ 1600, 1200 },
-		{ 1600, 1080 },
-		{ 1600,  900 },
-		{ 1440, 1080 },
-		{ 1280,  960 },
-		{ 1280,  720 },
-		{  800,  600 },
-		{  640,  480 },
+		{ 1920, 1440 }, { 1920, 1200 }, { 1920, 1080 }, { 1600, 1200 },
+		{ 1600, 1080 }, { 1600, 900 },	{ 1440, 1080 }, { 1280, 960 },
+		{ 1280, 720 },	{ 800, 600 },	{ 640, 480 },
 	};
 	u32 padding_w, padding_h;
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(frame_sizes); i++) {
-		atomisp_get_padding(isp, frame_sizes[i].width, frame_sizes[i].height,
-				    &padding_w, &padding_h);
+		atomisp_get_padding(isp, frame_sizes[i].width,
+				    frame_sizes[i].height, &padding_w,
+				    &padding_h);
 
 		if ((frame_sizes[i].width + padding_w) > native->width ||
 		    (frame_sizes[i].height + padding_h) > native->height)
@@ -509,7 +480,8 @@ static int atomisp_enum_framesizes_crop(struct atomisp_device *isp,
 	struct v4l2_rect native = input->native_rect;
 	int ret, valid_sizes = 0;
 
-	ret = atomisp_enum_framesizes_crop_inner(isp, fsize, &active, &native, &valid_sizes);
+	ret = atomisp_enum_framesizes_crop_inner(isp, fsize, &active, &native,
+						 &valid_sizes);
 	if (ret == 0)
 		return 0;
 
@@ -521,7 +493,8 @@ static int atomisp_enum_framesizes_crop(struct atomisp_device *isp,
 	native.width /= 2;
 	native.height /= 2;
 
-	return atomisp_enum_framesizes_crop_inner(isp, fsize, &active, &native, &valid_sizes);
+	return atomisp_enum_framesizes_crop_inner(isp, fsize, &active, &native,
+						  &valid_sizes);
 }
 
 static int atomisp_enum_framesizes(struct file *file, void *priv,
@@ -613,8 +586,8 @@ static int atomisp_enum_fmt_cap(struct file *file, void *fh,
 		return -EINVAL;
 
 	act_sd_state = v4l2_subdev_lock_and_get_active_state(input->sensor);
-	ret = v4l2_subdev_call(input->sensor, pad, enum_mbus_code,
-			       act_sd_state, &code);
+	ret = v4l2_subdev_call(input->sensor, pad, enum_mbus_code, act_sd_state,
+			       &code);
 	if (act_sd_state)
 		v4l2_subdev_unlock_state(act_sd_state);
 	if (ret)
@@ -657,8 +630,7 @@ static int atomisp_try_fmt_cap(struct file *file, void *fh,
 	return atomisp_try_fmt(isp, &f->fmt.pix, NULL, NULL);
 }
 
-static int atomisp_g_fmt_cap(struct file *file, void *fh,
-			     struct v4l2_format *f)
+static int atomisp_g_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
 {
 	struct video_device *vdev = video_devdata(file);
 	struct atomisp_video_pipe *pipe;
@@ -687,7 +659,7 @@ int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *asd,
 	struct atomisp_metadata_buf *md_buf = NULL, *_md_buf;
 	int count;
 	struct ia_css_dvs_grid_info *dvs_grid_info =
-	    atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
+		atomisp_css_get_dvs_grid_info(&asd->params.curr_grid_info);
 	unsigned int i;
 
 	if (list_empty(&asd->s3a_stats) &&
@@ -696,12 +668,13 @@ int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *asd,
 			ATOMISP_S3A_BUF_QUEUE_DEPTH_FOR_HAL;
 		dev_dbg(isp->dev, "allocating %d 3a buffers\n", count);
 		while (count--) {
-			s3a_buf = kzalloc(sizeof(struct atomisp_s3a_buf), GFP_KERNEL);
+			s3a_buf = kzalloc(sizeof(struct atomisp_s3a_buf),
+					  GFP_KERNEL);
 			if (!s3a_buf)
 				goto error;
 
 			if (atomisp_css_allocate_stat_buffers(
-				asd, stream_id, s3a_buf, NULL, NULL)) {
+				    asd, stream_id, s3a_buf, NULL, NULL)) {
 				kfree(s3a_buf);
 				goto error;
 			}
@@ -715,11 +688,12 @@ int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *asd,
 		count = ATOMISP_CSS_Q_DEPTH + 1;
 		dev_dbg(isp->dev, "allocating %d dis buffers\n", count);
 		while (count--) {
-			dis_buf = kzalloc(sizeof(struct atomisp_dis_buf), GFP_KERNEL);
+			dis_buf = kzalloc(sizeof(struct atomisp_dis_buf),
+					  GFP_KERNEL);
 			if (!dis_buf)
 				goto error;
 			if (atomisp_css_allocate_stat_buffers(
-				asd, stream_id, NULL, dis_buf, NULL)) {
+				    asd, stream_id, NULL, dis_buf, NULL)) {
 				kfree(dis_buf);
 				goto error;
 			}
@@ -734,16 +708,19 @@ int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *asd,
 		    list_empty(&asd->metadata_in_css[i])) {
 			count = ATOMISP_CSS_Q_DEPTH +
 				ATOMISP_METADATA_QUEUE_DEPTH_FOR_HAL;
-			dev_dbg(isp->dev, "allocating %d metadata buffers for type %d\n",
+			dev_dbg(isp->dev,
+				"allocating %d metadata buffers for type %d\n",
 				count, i);
 			while (count--) {
-				md_buf = kzalloc(sizeof(struct atomisp_metadata_buf),
-						 GFP_KERNEL);
+				md_buf = kzalloc(
+					sizeof(struct atomisp_metadata_buf),
+					GFP_KERNEL);
 				if (!md_buf)
 					goto error;
 
 				if (atomisp_css_allocate_stat_buffers(
-					asd, stream_id, NULL, NULL, md_buf)) {
+					    asd, stream_id, NULL, NULL,
+					    md_buf)) {
 					kfree(md_buf);
 					goto error;
 				}
@@ -787,7 +764,8 @@ int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *asd,
  * Once this is fixed these wrappers can be removed, replacing them with direct
  * calls to vb2_ioctl_[d]qbuf().
  */
-static int atomisp_qbuf_wrapper(struct file *file, void *fh, struct v4l2_buffer *buf)
+static int atomisp_qbuf_wrapper(struct file *file, void *fh,
+				struct v4l2_buffer *buf)
 {
 	struct video_device *vdev = video_devdata(file);
 	struct atomisp_device *isp = video_get_drvdata(vdev);
@@ -798,8 +776,8 @@ static int atomisp_qbuf_wrapper(struct file *file, void *fh, struct v4l2_buffer
 
 	if (buf->reserved2 & ATOMISP_BUFFER_HAS_PER_FRAME_SETTING) {
 		/* this buffer will have a per-frame parameter */
-		pipe->frame_request_config_id[buf->index] = buf->reserved2 &
-			~ATOMISP_BUFFER_HAS_PER_FRAME_SETTING;
+		pipe->frame_request_config_id[buf->index] =
+			buf->reserved2 & ~ATOMISP_BUFFER_HAS_PER_FRAME_SETTING;
 		dev_dbg(isp->dev,
 			"This buffer requires per_frame setting which has isp_config_id %d\n",
 			pipe->frame_request_config_id[buf->index]);
@@ -810,7 +788,8 @@ static int atomisp_qbuf_wrapper(struct file *file, void *fh, struct v4l2_buffer
 	return vb2_ioctl_qbuf(file, fh, buf);
 }
 
-static int atomisp_dqbuf_wrapper(struct file *file, void *fh, struct v4l2_buffer *buf)
+static int atomisp_dqbuf_wrapper(struct file *file, void *fh,
+				 struct v4l2_buffer *buf)
 {
 	struct video_device *vdev = video_devdata(file);
 	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
@@ -882,7 +861,8 @@ int atomisp_start_streaming(struct vb2_queue *vq, unsigned int count)
 	 */
 	mutex_lock(&isp->media_dev.graph_mutex);
 	atomisp_setup_input_links(isp);
-	ret = __media_pipeline_start(&asd->video_out.vdev.entity.pads[0], &asd->video_out.pipe);
+	ret = __media_pipeline_start(&asd->video_out.vdev.entity.pads[0],
+				     &asd->video_out.pipe);
 	mutex_unlock(&isp->media_dev.graph_mutex);
 	if (ret) {
 		dev_err(isp->dev, "Error starting mc pipeline: %d\n", ret);
@@ -899,7 +879,8 @@ int atomisp_start_streaming(struct vb2_queue *vq, unsigned int count)
 	if (asd->params.css_update_params_needed) {
 		atomisp_apply_css_parameters(asd, &asd->params.css_param);
 		if (asd->params.css_param.update_flag.dz_config)
-			asd->params.config.dz_config = &asd->params.css_param.dz_config;
+			asd->params.config.dz_config =
+				&asd->params.css_param.dz_config;
 		atomisp_css_update_isp_params(asd);
 		asd->params.css_update_params_needed = false;
 		memset(&asd->params.css_param.update_flag, 0,
@@ -938,10 +919,12 @@ int atomisp_start_streaming(struct vb2_queue *vq, unsigned int count)
 		dev_dbg(isp->dev, "DFS auto mode failed!\n");
 
 	/* Enable the CSI interface on ANN B0/K0 */
-	if (isp->media_dev.hw_revision >= ((ATOMISP_HW_REVISION_ISP2401 <<
-					    ATOMISP_HW_REVISION_SHIFT) | ATOMISP_HW_STEPPING_B0)) {
+	if (isp->media_dev.hw_revision >=
+	    ((ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT) |
+	     ATOMISP_HW_STEPPING_B0)) {
 		pci_write_config_word(pdev, MRFLD_PCI_CSI_CONTROL,
-				      isp->saved_regs.csi_control | MRFLD_PCI_CSI_CONTROL_CSI_READY);
+				      isp->saved_regs.csi_control |
+					      MRFLD_PCI_CSI_CONTROL_CSI_READY);
 	}
 
 	/* stream on the sensor */
@@ -987,7 +970,8 @@ void atomisp_stop_streaming(struct vb2_queue *vq)
 	mutex_lock(&isp->mutex);
 	pipe->stopping = false;
 	if (ret == 0)
-		dev_warn(isp->dev, "Warning timeout waiting for CSS to return buffers\n");
+		dev_warn(isp->dev,
+			 "Warning timeout waiting for CSS to return buffers\n");
 
 	spin_lock_irqsave(&isp->lock, flags);
 	asd->streaming = false;
@@ -1008,10 +992,12 @@ void atomisp_stop_streaming(struct vb2_queue *vq)
 		dev_warn(isp->dev, "Stopping sensor stream failed: %d\n", ret);
 
 	/* Disable the CSI interface on ANN B0/K0 */
-	if (isp->media_dev.hw_revision >= ((ATOMISP_HW_REVISION_ISP2401 <<
-					    ATOMISP_HW_REVISION_SHIFT) | ATOMISP_HW_STEPPING_B0)) {
+	if (isp->media_dev.hw_revision >=
+	    ((ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT) |
+	     ATOMISP_HW_STEPPING_B0)) {
 		pci_write_config_word(pdev, MRFLD_PCI_CSI_CONTROL,
-				      isp->saved_regs.csi_control & ~MRFLD_PCI_CSI_CONTROL_CSI_READY);
+				      isp->saved_regs.csi_control &
+					      ~MRFLD_PCI_CSI_CONTROL_CSI_READY);
 	}
 
 	if (atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW, false))
@@ -1023,7 +1009,8 @@ void atomisp_stop_streaming(struct vb2_queue *vq)
 	 * Disable PUNIT/ISP acknowledge/handshake - SRSE=3 and then reset.
 	 */
 	pci_write_config_dword(pdev, PCI_I_CONTROL,
-			       isp->saved_regs.i_control | MRFLD_PCI_I_CONTROL_SRSE_RESET_MASK);
+			       isp->saved_regs.i_control |
+				       MRFLD_PCI_I_CONTROL_SRSE_RESET_MASK);
 	atomisp_reset(isp);
 
 	/* Streams were destroyed by atomisp_css_stop(), recreate them. */
@@ -1328,12 +1315,13 @@ static int atomisp_s_parm(struct file *file, void *fh,
 	asd->high_speed_mode = false;
 	switch (parm->parm.capture.capturemode) {
 	case CI_MODE_NONE: {
-		struct v4l2_subdev_frame_interval fi = {0};
+		struct v4l2_subdev_frame_interval fi = { 0 };
 
 		fi.interval = parm->parm.capture.timeperframe;
 
-		rval = v4l2_subdev_call_state_active(isp->inputs[asd->input_curr].csi_remote_source,
-						     pad, set_frame_interval, &fi);
+		rval = v4l2_subdev_call_state_active(
+			isp->inputs[asd->input_curr].csi_remote_source, pad,
+			set_frame_interval, &fi);
 		if (!rval)
 			parm->parm.capture.timeperframe = fi.interval;
 
@@ -1363,8 +1351,8 @@ static int atomisp_s_parm(struct file *file, void *fh,
 	return rval == -ENOIOCTLCMD ? 0 : rval;
 }
 
-static long atomisp_vidioc_default(struct file *file, void *fh,
-				   bool valid_prio, unsigned int cmd, void *arg)
+static long atomisp_vidioc_default(struct file *file, void *fh, bool valid_prio,
+				   unsigned int cmd, void *arg)
 {
 	struct video_device *vdev = video_devdata(file);
 	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
@@ -1567,7 +1555,7 @@ const struct v4l2_ioctl_ops atomisp_ioctl_ops = {
 	.vidioc_query_ext_ctrl = atomisp_query_ext_ctrl,
 	.vidioc_s_ext_ctrls = atomisp_s_ext_ctrls,
 	.vidioc_g_ext_ctrls = atomisp_g_ext_ctrls,
-	.vidioc_enum_framesizes   = atomisp_enum_framesizes,
+	.vidioc_enum_framesizes = atomisp_enum_framesizes,
 	.vidioc_enum_frameintervals = atomisp_enum_frameintervals,
 	.vidioc_enum_fmt_vid_cap = atomisp_enum_fmt_cap,
 	.vidioc_try_fmt_vid_cap = atomisp_try_fmt_cap,
diff --git a/drivers/staging/media/atomisp/pci/atomisp_ioctl.h b/drivers/staging/media/atomisp/pci/atomisp_ioctl.h
index 57f608f9db56486a98361ef52752ea54a3c33f4d..99e881894d39f75c2a456f386e46aa8d213a19c4 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_ioctl.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_ioctl.h
@@ -7,8 +7,8 @@
  * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  */
 
-#ifndef	__ATOMISP_IOCTL_H__
-#define	__ATOMISP_IOCTL_H__
+#ifndef __ATOMISP_IOCTL_H__
+#define __ATOMISP_IOCTL_H__
 
 #include "ia_css.h"
 
@@ -17,11 +17,11 @@ struct atomisp_video_pipe;
 
 extern const struct atomisp_format_bridge atomisp_output_fmts[];
 
-const struct
-atomisp_format_bridge *atomisp_get_format_bridge(unsigned int pixelformat);
+const struct atomisp_format_bridge *
+atomisp_get_format_bridge(unsigned int pixelformat);
 
-const struct
-atomisp_format_bridge *atomisp_get_format_bridge_from_mbus(u32 mbus_code);
+const struct atomisp_format_bridge *
+atomisp_get_format_bridge_from_mbus(u32 mbus_code);
 
 int atomisp_pipe_check(struct atomisp_video_pipe *pipe, bool streaming_ok);
 
diff --git a/drivers/staging/media/atomisp/pci/atomisp_subdev.c b/drivers/staging/media/atomisp/pci/atomisp_subdev.c
index 22c0ae0b1b7b756f4c424a62925f62040750a3a7..36b6ff16e555ab7e0b6a8c941eccee7a2b8e0e9d 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_subdev.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_subdev.c
@@ -23,18 +23,30 @@
 #include "atomisp_ioctl.h"
 
 const struct atomisp_in_fmt_conv atomisp_in_fmt_conv[] = {
-	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_BGGR },
-	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_GBRG },
-	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_GRBG },
-	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_RGGB },
-	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_BGGR },
-	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_GBRG },
-	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_GRBG },
-	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_RGGB },
-	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_BGGR },
-	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_GBRG },
-	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_GRBG },
-	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_RGGB },
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8,
+	  IA_CSS_BAYER_ORDER_BGGR },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8,
+	  IA_CSS_BAYER_ORDER_GBRG },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8,
+	  IA_CSS_BAYER_ORDER_GRBG },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8, 8, ATOMISP_INPUT_FORMAT_RAW_8,
+	  IA_CSS_BAYER_ORDER_RGGB },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10,
+	  IA_CSS_BAYER_ORDER_BGGR },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10,
+	  IA_CSS_BAYER_ORDER_GBRG },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10,
+	  IA_CSS_BAYER_ORDER_GRBG },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10, 10, ATOMISP_INPUT_FORMAT_RAW_10,
+	  IA_CSS_BAYER_ORDER_RGGB },
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12,
+	  IA_CSS_BAYER_ORDER_BGGR },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12,
+	  IA_CSS_BAYER_ORDER_GBRG },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12,
+	  IA_CSS_BAYER_ORDER_GRBG },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12, 12, ATOMISP_INPUT_FORMAT_RAW_12,
+	  IA_CSS_BAYER_ORDER_RGGB },
 	{ MEDIA_BUS_FMT_UYVY8_1X16, 8, 8, ATOMISP_INPUT_FORMAT_YUV422_8, 0 },
 	{ MEDIA_BUS_FMT_YUYV8_1X16, 8, 8, ATOMISP_INPUT_FORMAT_YUV422_8, 0 },
 #if 0 // disabled due to clang warnings
@@ -42,7 +54,8 @@ const struct atomisp_in_fmt_conv atomisp_in_fmt_conv[] = {
 	{ V4L2_MBUS_FMT_CUSTOM_NV12, 12, 12, IA_CSS_FRAME_FORMAT_NV12, 0 },
 	{ V4L2_MBUS_FMT_CUSTOM_NV21, 12, 12, IA_CSS_FRAME_FORMAT_NV21, 0 },
 #endif
-	{ V4L2_MBUS_FMT_CUSTOM_YUV420, 12, 12, ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY, 0 },
+	{ V4L2_MBUS_FMT_CUSTOM_YUV420, 12, 12,
+	  ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY, 0 },
 #if 0
 	{ V4L2_MBUS_FMT_CUSTOM_M10MO_RAW, 8, 8, IA_CSS_FRAME_FORMAT_BINARY_8, 0 },
 #endif
@@ -96,7 +109,7 @@ const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv(u32 code)
 }
 
 const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv_by_atomisp_in_fmt(
-    enum atomisp_input_format atomisp_in_fmt)
+	enum atomisp_input_format atomisp_in_fmt)
 {
 	int i;
 
@@ -112,12 +125,14 @@ bool atomisp_subdev_format_conversion(struct atomisp_sub_device *asd)
 	struct v4l2_mbus_framefmt *sink, *src;
 
 	sink = atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-				       V4L2_SUBDEV_FORMAT_ACTIVE, ATOMISP_SUBDEV_PAD_SINK);
+				       V4L2_SUBDEV_FORMAT_ACTIVE,
+				       ATOMISP_SUBDEV_PAD_SINK);
 	src = atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-				      V4L2_SUBDEV_FORMAT_ACTIVE, ATOMISP_SUBDEV_PAD_SOURCE);
+				      V4L2_SUBDEV_FORMAT_ACTIVE,
+				      ATOMISP_SUBDEV_PAD_SOURCE);
 
-	return atomisp_is_mbuscode_raw(sink->code)
-	       && !atomisp_is_mbuscode_raw(src->code);
+	return atomisp_is_mbuscode_raw(sink->code) &&
+	       !atomisp_is_mbuscode_raw(src->code);
 }
 
 /*
@@ -132,8 +147,8 @@ bool atomisp_subdev_format_conversion(struct atomisp_sub_device *asd)
  *
  * Return 0 on success or a negative error code otherwise.
  */
-static long isp_subdev_ioctl(struct v4l2_subdev *sd,
-			     unsigned int cmd, void *arg)
+static long isp_subdev_ioctl(struct v4l2_subdev *sd, unsigned int cmd,
+			     void *arg)
 {
 	return 0;
 }
@@ -154,8 +169,7 @@ static int isp_subdev_subscribe_event(struct v4l2_subdev *sd,
 	    sub->type != V4L2_EVENT_ATOMISP_ACC_COMPLETE)
 		return -EINVAL;
 
-	if (sub->type == V4L2_EVENT_FRAME_SYNC &&
-	    !atomisp_css_valid_sof(isp))
+	if (sub->type == V4L2_EVENT_FRAME_SYNC && !atomisp_css_valid_sof(isp))
 		return -EINVAL;
 
 	return v4l2_event_subscribe(fh, sub, 16, NULL);
@@ -209,9 +223,9 @@ static int isp_subdev_validate_rect(struct v4l2_subdev *sd, uint32_t pad,
 }
 
 struct v4l2_rect *atomisp_subdev_get_rect(struct v4l2_subdev *sd,
-	struct v4l2_subdev_state *sd_state,
-	u32 which, uint32_t pad,
-	uint32_t target)
+					  struct v4l2_subdev_state *sd_state,
+					  u32 which, uint32_t pad,
+					  uint32_t target)
 {
 	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
 
@@ -234,10 +248,10 @@ struct v4l2_rect *atomisp_subdev_get_rect(struct v4l2_subdev *sd,
 	return NULL;
 }
 
-struct v4l2_mbus_framefmt
-*atomisp_subdev_get_ffmt(struct v4l2_subdev *sd,
-			 struct v4l2_subdev_state *sd_state, uint32_t which,
-			 uint32_t pad)
+struct v4l2_mbus_framefmt *
+atomisp_subdev_get_ffmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_state *sd_state, uint32_t which,
+			uint32_t pad)
 {
 	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
 
@@ -248,8 +262,7 @@ struct v4l2_mbus_framefmt
 }
 
 static void isp_get_fmt_rect(struct v4l2_subdev *sd,
-			     struct v4l2_subdev_state *sd_state,
-			     uint32_t which,
+			     struct v4l2_subdev_state *sd_state, uint32_t which,
 			     struct v4l2_mbus_framefmt **ffmt,
 			     struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
 			     struct v4l2_rect *comp[ATOMISP_SUBDEV_PADS_NUM])
@@ -297,29 +310,32 @@ static const char *atomisp_pad_str(unsigned int pad)
 }
 
 int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_state *sd_state,
-				 u32 which, uint32_t pad, uint32_t target,
-				 u32 flags, struct v4l2_rect *r)
+				 struct v4l2_subdev_state *sd_state, u32 which,
+				 uint32_t pad, uint32_t target, u32 flags,
+				 struct v4l2_rect *r)
 {
 	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
 	struct atomisp_device *isp = isp_sd->isp;
 	struct v4l2_mbus_framefmt *ffmt[ATOMISP_SUBDEV_PADS_NUM];
 	struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
-		       *comp[ATOMISP_SUBDEV_PADS_NUM];
+		*comp[ATOMISP_SUBDEV_PADS_NUM];
 
 	if ((pad == ATOMISP_SUBDEV_PAD_SINK && target != V4L2_SEL_TGT_CROP) ||
-	    (pad == ATOMISP_SUBDEV_PAD_SOURCE && target != V4L2_SEL_TGT_COMPOSE))
+	    (pad == ATOMISP_SUBDEV_PAD_SOURCE &&
+	     target != V4L2_SEL_TGT_COMPOSE))
 		return -EINVAL;
 
 	isp_get_fmt_rect(sd, sd_state, which, ffmt, crop, comp);
 
 	dev_dbg(isp->dev,
 		"sel: pad %s tgt %s l %d t %d w %d h %d which %s f 0x%8.8x\n",
-		atomisp_pad_str(pad), target == V4L2_SEL_TGT_CROP
-		? "V4L2_SEL_TGT_CROP" : "V4L2_SEL_TGT_COMPOSE",
+		atomisp_pad_str(pad),
+		target == V4L2_SEL_TGT_CROP ? "V4L2_SEL_TGT_CROP" :
+					      "V4L2_SEL_TGT_COMPOSE",
 		r->left, r->top, r->width, r->height,
-		which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY"
-		: "V4L2_SUBDEV_FORMAT_ACTIVE", flags);
+		which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY" :
+						  "V4L2_SUBDEV_FORMAT_ACTIVE",
+		flags);
 
 	r->width = rounddown(r->width, ATOM_ISP_STEP_WIDTH);
 	r->height = rounddown(r->height, ATOM_ISP_STEP_HEIGHT);
@@ -331,8 +347,8 @@ int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
 		crop[pad]->width = ffmt[pad]->width;
 		crop[pad]->height = ffmt[pad]->height;
 
-		if (atomisp_subdev_format_conversion(isp_sd)
-		    && crop[pad]->width && crop[pad]->height) {
+		if (atomisp_subdev_format_conversion(isp_sd) &&
+		    crop[pad]->width && crop[pad]->height) {
 			crop[pad]->width -= isp_sd->sink_pad_padding_w;
 			crop[pad]->height -= isp_sd->sink_pad_padding_h;
 		}
@@ -359,7 +375,8 @@ int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
 
 			atomisp_subdev_set_selection(sd, sd_state, which,
 						     ATOMISP_SUBDEV_PAD_SOURCE,
-						     V4L2_SEL_TGT_COMPOSE, flags, &tmp);
+						     V4L2_SEL_TGT_COMPOSE,
+						     flags, &tmp);
 		}
 
 		if (which == V4L2_SUBDEV_FORMAT_TRY)
@@ -382,10 +399,9 @@ int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
 			dvs_w = dvs_h = 0;
 		}
 		atomisp_css_video_set_dis_envelope(isp_sd, dvs_w, dvs_h);
-		atomisp_css_input_set_effective_resolution(isp_sd,
-							   ATOMISP_INPUT_STREAM_GENERAL,
-							   crop[pad]->width,
-							   crop[pad]->height);
+		atomisp_css_input_set_effective_resolution(
+			isp_sd, ATOMISP_INPUT_STREAM_GENERAL, crop[pad]->width,
+			crop[pad]->height);
 	} else if (isp_sd->run_mode->val != ATOMISP_RUN_MODE_PREVIEW) {
 		/* Only compose target is supported on source pads. */
 		if (isp_sd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {
@@ -394,8 +410,8 @@ int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
 			r->height = crop[ATOMISP_SUBDEV_PAD_SINK]->height;
 		}
 
-		if (crop[ATOMISP_SUBDEV_PAD_SINK]->width == r->width
-		    && crop[ATOMISP_SUBDEV_PAD_SINK]->height == r->height)
+		if (crop[ATOMISP_SUBDEV_PAD_SINK]->width == r->width &&
+		    crop[ATOMISP_SUBDEV_PAD_SINK]->height == r->height)
 			isp_sd->params.yuv_ds_en = false;
 		else
 			isp_sd->params.yuv_ds_en = true;
@@ -423,18 +439,18 @@ int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
 		 */
 		if (r->width * crop[ATOMISP_SUBDEV_PAD_SINK]->height <
 		    crop[ATOMISP_SUBDEV_PAD_SINK]->width * r->height)
-			atomisp_css_input_set_effective_resolution(isp_sd,
-				ATOMISP_INPUT_STREAM_GENERAL,
-				rounddown(crop[ATOMISP_SUBDEV_PAD_SINK]->
-					  height * r->width / r->height,
+			atomisp_css_input_set_effective_resolution(
+				isp_sd, ATOMISP_INPUT_STREAM_GENERAL,
+				rounddown(crop[ATOMISP_SUBDEV_PAD_SINK]->height *
+						  r->width / r->height,
 					  ATOM_ISP_STEP_WIDTH),
 				crop[ATOMISP_SUBDEV_PAD_SINK]->height);
 		else
-			atomisp_css_input_set_effective_resolution(isp_sd,
-				ATOMISP_INPUT_STREAM_GENERAL,
+			atomisp_css_input_set_effective_resolution(
+				isp_sd, ATOMISP_INPUT_STREAM_GENERAL,
 				crop[ATOMISP_SUBDEV_PAD_SINK]->width,
-				rounddown(crop[ATOMISP_SUBDEV_PAD_SINK]->
-					  width * r->height / r->width,
+				rounddown(crop[ATOMISP_SUBDEV_PAD_SINK]->width *
+						  r->height / r->width,
 					  ATOM_ISP_STEP_WIDTH));
 	} else {
 		comp[pad]->width = r->width;
@@ -452,8 +468,8 @@ int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
 		return -EINVAL;
 	*r = *atomisp_subdev_get_rect(sd, sd_state, which, pad, target);
 
-	dev_dbg(isp->dev, "sel actual: l %d t %d w %d h %d\n",
-		r->left, r->top, r->width, r->height);
+	dev_dbg(isp->dev, "sel actual: l %d t %d w %d h %d\n", r->left, r->top,
+		r->width, r->height);
 
 	return 0;
 }
@@ -467,30 +483,28 @@ static int isp_subdev_set_selection(struct v4l2_subdev *sd,
 	if (rval)
 		return rval;
 
-	return atomisp_subdev_set_selection(sd, sd_state, sel->which,
-					    sel->pad,
+	return atomisp_subdev_set_selection(sd, sd_state, sel->which, sel->pad,
 					    sel->target, sel->flags, &sel->r);
 }
 
 void atomisp_subdev_set_ffmt(struct v4l2_subdev *sd,
-			     struct v4l2_subdev_state *sd_state,
-			     uint32_t which,
+			     struct v4l2_subdev_state *sd_state, uint32_t which,
 			     u32 pad, struct v4l2_mbus_framefmt *ffmt)
 {
 	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
 	struct atomisp_device *isp = isp_sd->isp;
 	struct v4l2_mbus_framefmt *__ffmt =
-	    atomisp_subdev_get_ffmt(sd, sd_state, which, pad);
+		atomisp_subdev_get_ffmt(sd, sd_state, which, pad);
 
 	dev_dbg(isp->dev, "ffmt: pad %s w %d h %d code 0x%8.8x which %s\n",
 		atomisp_pad_str(pad), ffmt->width, ffmt->height, ffmt->code,
-		which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY"
-		: "V4L2_SUBDEV_FORMAT_ACTIVE");
+		which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY" :
+						  "V4L2_SUBDEV_FORMAT_ACTIVE");
 
 	switch (pad) {
 	case ATOMISP_SUBDEV_PAD_SINK: {
 		const struct atomisp_in_fmt_conv *fc =
-		    atomisp_find_in_fmt_conv(ffmt->code);
+			atomisp_find_in_fmt_conv(ffmt->code);
 		struct v4l2_rect r = {};
 
 		if (!fc) {
@@ -510,17 +524,18 @@ void atomisp_subdev_set_ffmt(struct v4l2_subdev *sd,
 					     V4L2_SEL_TGT_CROP, 0, &r);
 
 		if (which == V4L2_SUBDEV_FORMAT_ACTIVE) {
-			atomisp_css_input_set_resolution(isp_sd,
-							 ATOMISP_INPUT_STREAM_GENERAL, ffmt);
-			atomisp_css_input_set_binning_factor(isp_sd,
-							     ATOMISP_INPUT_STREAM_GENERAL,
-							     0);
-			atomisp_css_input_set_bayer_order(isp_sd, ATOMISP_INPUT_STREAM_GENERAL,
-							  fc->bayer_order);
-			atomisp_css_input_set_format(isp_sd, ATOMISP_INPUT_STREAM_GENERAL,
-						     fc->atomisp_in_fmt);
-			atomisp_css_set_default_isys_config(isp_sd, ATOMISP_INPUT_STREAM_GENERAL,
-							    ffmt);
+			atomisp_css_input_set_resolution(
+				isp_sd, ATOMISP_INPUT_STREAM_GENERAL, ffmt);
+			atomisp_css_input_set_binning_factor(
+				isp_sd, ATOMISP_INPUT_STREAM_GENERAL, 0);
+			atomisp_css_input_set_bayer_order(
+				isp_sd, ATOMISP_INPUT_STREAM_GENERAL,
+				fc->bayer_order);
+			atomisp_css_input_set_format(
+				isp_sd, ATOMISP_INPUT_STREAM_GENERAL,
+				fc->atomisp_in_fmt);
+			atomisp_css_set_default_isys_config(
+				isp_sd, ATOMISP_INPUT_STREAM_GENERAL, ffmt);
 		}
 
 		break;
@@ -545,8 +560,8 @@ static int isp_subdev_get_format(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_state *sd_state,
 				 struct v4l2_subdev_format *fmt)
 {
-	fmt->format = *atomisp_subdev_get_ffmt(sd, sd_state, fmt->which,
-					       fmt->pad);
+	fmt->format =
+		*atomisp_subdev_get_ffmt(sd, sd_state, fmt->which, fmt->pad);
 
 	return 0;
 }
@@ -617,8 +632,8 @@ static int atomisp_link_setup(struct media_entity *entity,
 			      const struct media_pad *local,
 			      const struct media_pad *remote, u32 flags)
 {
-	struct v4l2_subdev *sd = container_of(entity, struct v4l2_subdev,
-					      entity);
+	struct v4l2_subdev *sd =
+		container_of(entity, struct v4l2_subdev, entity);
 	struct atomisp_sub_device *asd = v4l2_get_subdevdata(sd);
 	struct atomisp_device *isp = asd->isp;
 	int i;
@@ -631,7 +646,8 @@ static int atomisp_link_setup(struct media_entity *entity,
 	}
 
 	for (i = 0; i < isp->input_cnt; i++) {
-		if (&isp->inputs[i].csi_port->entity.pads[CSI2_PAD_SOURCE] == remote)
+		if (&isp->inputs[i].csi_port->entity.pads[CSI2_PAD_SOURCE] ==
+		    remote)
 			break;
 	}
 
@@ -656,9 +672,9 @@ static const struct media_entity_operations isp_subdev_media_ops = {
 };
 
 static const char *const ctrl_run_mode_menu[] = {
-	[ATOMISP_RUN_MODE_VIDEO]		= "Video",
-	[ATOMISP_RUN_MODE_STILL_CAPTURE]	= "Still capture",
-	[ATOMISP_RUN_MODE_PREVIEW]		= "Preview",
+	[ATOMISP_RUN_MODE_VIDEO] = "Video",
+	[ATOMISP_RUN_MODE_STILL_CAPTURE] = "Still capture",
+	[ATOMISP_RUN_MODE_PREVIEW] = "Preview",
 };
 
 static const struct v4l2_ctrl_config ctrl_run_mode = {
@@ -672,9 +688,9 @@ static const struct v4l2_ctrl_config ctrl_run_mode = {
 };
 
 static const char *const ctrl_vfpp_mode_menu[] = {
-	"Enable",			/* vfpp always enabled */
-	"Disable to scaler mode",	/* CSS into video mode and disable */
-	"Disable to low latency mode",	/* CSS into still mode and disable */
+	"Enable", /* vfpp always enabled */
+	"Disable to scaler mode", /* CSS into video mode and disable */
+	"Disable to low latency mode", /* CSS into still mode and disable */
 };
 
 static const struct v4l2_ctrl_config ctrl_vfpp = {
@@ -769,7 +785,8 @@ static const struct v4l2_ctrl_config ctrl_disable_dz = {
 };
 
 static int atomisp_init_subdev_pipe(struct atomisp_sub_device *asd,
-				    struct atomisp_video_pipe *pipe, enum v4l2_buf_type buf_type)
+				    struct atomisp_video_pipe *pipe,
+				    enum v4l2_buf_type buf_type)
 {
 	int ret;
 
@@ -823,7 +840,8 @@ static int isp_subdev_init_entities(struct atomisp_sub_device *asd)
 	pads[ATOMISP_SUBDEV_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
 
 	asd->fmt[ATOMISP_SUBDEV_PAD_SINK].fmt.code = MEDIA_BUS_FMT_SBGGR10_1X10;
-	asd->fmt[ATOMISP_SUBDEV_PAD_SOURCE].fmt.code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	asd->fmt[ATOMISP_SUBDEV_PAD_SOURCE].fmt.code =
+		MEDIA_BUS_FMT_SBGGR10_1X10;
 
 	me->ops = &isp_subdev_media_ops;
 	me->function = MEDIA_ENT_F_PROC_VIDEO_ISP;
@@ -831,7 +849,8 @@ static int isp_subdev_init_entities(struct atomisp_sub_device *asd)
 	if (ret < 0)
 		return ret;
 
-	ret = atomisp_init_subdev_pipe(asd, &asd->video_out, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+	ret = atomisp_init_subdev_pipe(asd, &asd->video_out,
+				       V4L2_BUF_TYPE_VIDEO_CAPTURE);
 	if (ret)
 		return ret;
 
@@ -843,26 +862,18 @@ static int isp_subdev_init_entities(struct atomisp_sub_device *asd)
 	if (ret)
 		return ret;
 
-	asd->run_mode = v4l2_ctrl_new_custom(&asd->ctrl_handler,
-					     &ctrl_run_mode, NULL);
-	asd->vfpp = v4l2_ctrl_new_custom(&asd->ctrl_handler,
-					 &ctrl_vfpp, NULL);
-	asd->continuous_viewfinder = v4l2_ctrl_new_custom(&asd->ctrl_handler,
-				     &ctrl_continuous_viewfinder,
-				     NULL);
-	asd->continuous_raw_buffer_size =
-	    v4l2_ctrl_new_custom(&asd->ctrl_handler,
-				 &ctrl_continuous_raw_buffer_size,
-				 NULL);
-
-	asd->enable_raw_buffer_lock =
-	    v4l2_ctrl_new_custom(&asd->ctrl_handler,
-				 &ctrl_enable_raw_buffer_lock,
-				 NULL);
-	asd->disable_dz =
-	    v4l2_ctrl_new_custom(&asd->ctrl_handler,
-				 &ctrl_disable_dz,
-				 NULL);
+	asd->run_mode =
+		v4l2_ctrl_new_custom(&asd->ctrl_handler, &ctrl_run_mode, NULL);
+	asd->vfpp = v4l2_ctrl_new_custom(&asd->ctrl_handler, &ctrl_vfpp, NULL);
+	asd->continuous_viewfinder = v4l2_ctrl_new_custom(
+		&asd->ctrl_handler, &ctrl_continuous_viewfinder, NULL);
+	asd->continuous_raw_buffer_size = v4l2_ctrl_new_custom(
+		&asd->ctrl_handler, &ctrl_continuous_raw_buffer_size, NULL);
+
+	asd->enable_raw_buffer_lock = v4l2_ctrl_new_custom(
+		&asd->ctrl_handler, &ctrl_enable_raw_buffer_lock, NULL);
+	asd->disable_dz = v4l2_ctrl_new_custom(&asd->ctrl_handler,
+					       &ctrl_disable_dz, NULL);
 
 	/* Make controls visible on subdev as well. */
 	asd->subdev.ctrl_handler = &asd->ctrl_handler;
@@ -883,8 +894,8 @@ void atomisp_subdev_cleanup_pending_events(struct atomisp_sub_device *asd)
 	struct v4l2_event event;
 	unsigned int i, pending_event;
 
-	list_for_each_entry_safe(fh, fh_tmp,
-				 &asd->subdev.devnode->fh_list, list) {
+	list_for_each_entry_safe(fh, fh_tmp, &asd->subdev.devnode->fh_list,
+				 list) {
 		pending_event = v4l2_event_pending(fh);
 		for (i = 0; i < pending_event; i++)
 			v4l2_event_dequeue(fh, &event, 1);
diff --git a/drivers/staging/media/atomisp/pci/atomisp_subdev.h b/drivers/staging/media/atomisp/pci/atomisp_subdev.h
index bd1a198cda30e589687b5de53496f6be9b2759ea..be590ab5dfb700020cf9eb416116872df9813a4d 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_subdev.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_subdev.h
@@ -18,14 +18,14 @@
 #include "ia_css.h"
 
 /* EXP_ID's ranger is 1 ~ 250 */
-#define ATOMISP_MAX_EXP_ID     (250)
+#define ATOMISP_MAX_EXP_ID (250)
 
-#define ATOMISP_SUBDEV_PAD_SINK			0
-#define ATOMISP_SUBDEV_PAD_SOURCE		1
-#define ATOMISP_SUBDEV_PADS_NUM			2
+#define ATOMISP_SUBDEV_PAD_SINK 0
+#define ATOMISP_SUBDEV_PAD_SOURCE 1
+#define ATOMISP_SUBDEV_PADS_NUM 2
 
 struct atomisp_in_fmt_conv {
-	u32     code;
+	u32 code;
 	u8 bpp; /* bits per pixel */
 	u8 depth; /* uncompressed */
 	enum atomisp_input_format atomisp_in_fmt;
@@ -102,54 +102,54 @@ struct atomisp_pad_format {
  * struct ia_css_isp_config but without un-supported and deprecated parts.
  */
 struct atomisp_css_params {
-	struct ia_css_wb_config   wb_config;
-	struct ia_css_cc_config   cc_config;
-	struct ia_css_tnr_config  tnr_config;
-	struct ia_css_ecd_config  ecd_config;
-	struct ia_css_ynr_config  ynr_config;
-	struct ia_css_fc_config   fc_config;
+	struct ia_css_wb_config wb_config;
+	struct ia_css_cc_config cc_config;
+	struct ia_css_tnr_config tnr_config;
+	struct ia_css_ecd_config ecd_config;
+	struct ia_css_ynr_config ynr_config;
+	struct ia_css_fc_config fc_config;
 	struct ia_css_formats_config formats_config;
-	struct ia_css_cnr_config  cnr_config;
+	struct ia_css_cnr_config cnr_config;
 	struct ia_css_macc_config macc_config;
-	struct ia_css_ctc_config  ctc_config;
-	struct ia_css_aa_config   aa_config;
-	struct ia_css_aa_config   baa_config;
-	struct ia_css_ce_config   ce_config;
-	struct ia_css_ob_config   ob_config;
-	struct ia_css_dp_config   dp_config;
-	struct ia_css_de_config   de_config;
-	struct ia_css_gc_config   gc_config;
-	struct ia_css_nr_config   nr_config;
-	struct ia_css_ee_config   ee_config;
-	struct ia_css_anr_config  anr_config;
-	struct ia_css_3a_config   s3a_config;
-	struct ia_css_xnr_config  xnr_config;
-	struct ia_css_dz_config   dz_config;
+	struct ia_css_ctc_config ctc_config;
+	struct ia_css_aa_config aa_config;
+	struct ia_css_aa_config baa_config;
+	struct ia_css_ce_config ce_config;
+	struct ia_css_ob_config ob_config;
+	struct ia_css_dp_config dp_config;
+	struct ia_css_de_config de_config;
+	struct ia_css_gc_config gc_config;
+	struct ia_css_nr_config nr_config;
+	struct ia_css_ee_config ee_config;
+	struct ia_css_anr_config anr_config;
+	struct ia_css_3a_config s3a_config;
+	struct ia_css_xnr_config xnr_config;
+	struct ia_css_dz_config dz_config;
 	struct ia_css_cc_config yuv2rgb_cc_config;
 	struct ia_css_cc_config rgb2yuv_cc_config;
-	struct ia_css_macc_table  macc_table;
+	struct ia_css_macc_table macc_table;
 	struct ia_css_gamma_table gamma_table;
-	struct ia_css_ctc_table   ctc_table;
+	struct ia_css_ctc_table ctc_table;
 
-	struct ia_css_xnr_table   xnr_table;
+	struct ia_css_xnr_table xnr_table;
 	struct ia_css_rgb_gamma_table r_gamma_table;
 	struct ia_css_rgb_gamma_table g_gamma_table;
 	struct ia_css_rgb_gamma_table b_gamma_table;
 
-	struct ia_css_vector      motion_vector;
-	struct ia_css_anr_thres   anr_thres;
+	struct ia_css_vector motion_vector;
+	struct ia_css_anr_thres anr_thres;
 
 	struct ia_css_dvs_6axis_config *dvs_6axis;
 	struct ia_css_dvs2_coefficients *dvs2_coeff;
 	struct ia_css_shading_table *shading_table;
-	struct ia_css_morph_table   *morph_table;
+	struct ia_css_morph_table *morph_table;
 
 	/*
 	 * Used to store the user pointer address of the frame. driver needs to
 	 * translate to ia_css_frame * and then set to CSS.
 	 */
-	void		*output_frame;
-	u32	isp_config_id;
+	void *output_frame;
+	u32 isp_config_id;
 
 	/* Indicates which parameters need to be updated. */
 	struct atomisp_parameters update_flag;
@@ -177,8 +177,8 @@ struct atomisp_subdev_params {
 
 	bool dis_proj_data_valid;
 
-	struct ia_css_dz_config   dz_config;  /** Digital Zoom */
-	struct ia_css_capture_config   capture_config;
+	struct ia_css_dz_config dz_config; /** Digital Zoom */
+	struct ia_css_capture_config capture_config;
 
 	struct ia_css_isp_config config;
 
@@ -197,10 +197,10 @@ struct atomisp_subdev_params {
 	struct ia_css_dvs2_statistics *dvs_stat;
 	struct ia_css_dvs_6axis_config *dvs_6axis;
 	u32 exp_id;
-	int  dvs_hor_coef_bytes;
-	int  dvs_ver_coef_bytes;
-	int  dvs_ver_proj_bytes;
-	int  dvs_hor_proj_bytes;
+	int dvs_hor_coef_bytes;
+	int dvs_ver_coef_bytes;
+	int dvs_ver_proj_bytes;
+	int dvs_hor_proj_bytes;
 
 	/* Flag to check if driver needs to update params to css */
 	bool css_update_params_needed;
@@ -243,8 +243,8 @@ struct atomisp_sub_device {
 	unsigned int s3a_bufs_in_css[IA_CSS_PIPE_ID_NUM];
 	unsigned int dis_bufs_in_css;
 
-	unsigned int metadata_bufs_in_css
-	[ATOMISP_INPUT_STREAM_NUM][IA_CSS_PIPE_ID_NUM];
+	unsigned int metadata_bufs_in_css[ATOMISP_INPUT_STREAM_NUM]
+					 [IA_CSS_PIPE_ID_NUM];
 	/* The list of free and available metadata buffers for CSS */
 	struct list_head metadata[ATOMISP_METADATA_TYPE_NUM];
 	/* The list of metadata buffers which have been en-queued to CSS */
@@ -267,7 +267,7 @@ struct atomisp_sub_device {
 	int input_curr;
 
 	atomic_t sof_count;
-	atomic_t sequence;      /* Sequence value that is assigned to buffer. */
+	atomic_t sequence; /* Sequence value that is assigned to buffer. */
 	atomic_t sequence_temp;
 
 	/*
@@ -283,7 +283,7 @@ struct atomisp_sub_device {
 	bool copy_mode; /* CSI2+ use copy mode */
 
 	int raw_buffer_bitmap[ATOMISP_MAX_EXP_ID / 32 +
-						 1]; /* Record each Raw Buffer lock status */
+			      1]; /* Record each Raw Buffer lock status */
 	int raw_buffer_locked_count;
 	spinlock_t raw_buffer_bitmap_lock;
 
@@ -305,33 +305,31 @@ const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv(u32 code);
 
 /* ISP2400 */
 const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv_by_atomisp_in_fmt(
-    enum atomisp_input_format atomisp_in_fmt);
+	enum atomisp_input_format atomisp_in_fmt);
 
 /* ISP2401 */
-const struct atomisp_in_fmt_conv
-*atomisp_find_in_fmt_conv_by_atomisp_in_fmt(enum atomisp_input_format
-	atomisp_in_fmt);
+const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv_by_atomisp_in_fmt(
+	enum atomisp_input_format atomisp_in_fmt);
 
 const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv_compressed(u32 code);
 bool atomisp_subdev_format_conversion(struct atomisp_sub_device *asd);
 
 /* Get pointer to appropriate format */
-struct v4l2_mbus_framefmt
-*atomisp_subdev_get_ffmt(struct v4l2_subdev *sd,
-			 struct v4l2_subdev_state *sd_state, uint32_t which,
-			 uint32_t pad);
+struct v4l2_mbus_framefmt *
+atomisp_subdev_get_ffmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_state *sd_state, uint32_t which,
+			uint32_t pad);
 struct v4l2_rect *atomisp_subdev_get_rect(struct v4l2_subdev *sd,
-	struct v4l2_subdev_state *sd_state,
-	u32 which, uint32_t pad,
-	uint32_t target);
+					  struct v4l2_subdev_state *sd_state,
+					  u32 which, uint32_t pad,
+					  uint32_t target);
 int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_state *sd_state,
-				 u32 which, uint32_t pad, uint32_t target,
-				 u32 flags, struct v4l2_rect *r);
+				 struct v4l2_subdev_state *sd_state, u32 which,
+				 uint32_t pad, uint32_t target, u32 flags,
+				 struct v4l2_rect *r);
 /* Actually set the format */
 void atomisp_subdev_set_ffmt(struct v4l2_subdev *sd,
-			     struct v4l2_subdev_state *sd_state,
-			     uint32_t which,
+			     struct v4l2_subdev_state *sd_state, uint32_t which,
 			     u32 pad, struct v4l2_mbus_framefmt *ffmt);
 
 void atomisp_subdev_cleanup_pending_events(struct atomisp_sub_device *asd);
diff --git a/drivers/staging/media/atomisp/pci/atomisp_tables.h b/drivers/staging/media/atomisp/pci/atomisp_tables.h
index 33e6079aa73b0e0aaed905bbf741066a6c8ff128..e6e6513edb4959c674a8cbd190cb72795b8ee101 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_tables.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_tables.h
@@ -6,172 +6,113 @@
  *
  * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
  */
-#ifndef	__ATOMISP_TABLES_H__
-#define	__ATOMISP_TABLES_H__
+#ifndef __ATOMISP_TABLES_H__
+#define __ATOMISP_TABLES_H__
 
 #include "sh_css_params.h"
 
 /*Sepia image effect table*/
 static struct ia_css_cc_config sepia_cc_config = {
-	.fraction_bits  = 8,
-	.matrix	 = {141, 18, 68, -40, -5, -19, 35, 4, 16},
+	.fraction_bits = 8,
+	.matrix = { 141, 18, 68, -40, -5, -19, 35, 4, 16 },
 };
 
 /*Negative image effect table*/
 static struct ia_css_cc_config nega_cc_config = {
-	.fraction_bits  = 8,
-	.matrix	 = {255, 29, 120, 0, 374, 342, 0, 672, -301},
+	.fraction_bits = 8,
+	.matrix = { 255, 29, 120, 0, 374, 342, 0, 672, -301 },
 };
 
 /*Mono image effect table*/
 static struct ia_css_cc_config mono_cc_config = {
-	.fraction_bits  = 8,
-	.matrix	 = {255, 29, 120, 0, 0, 0, 0, 0, 0},
+	.fraction_bits = 8,
+	.matrix = { 255, 29, 120, 0, 0, 0, 0, 0, 0 },
 };
 
 /*Skin whiten image effect table*/
 static struct ia_css_macc_table skin_low_macc_table = {
-	.data = {
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		7168, 0, 2048, 8192,
-		5120, -1024, 2048, 8192,
-		8192, 2048, -1024, 5120,
-		8192, 2048, 0, 7168,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192
-	}
+	.data = { 8192, 0,     0,    8192, 8192, 0,    0,     8192, 8192, 0,
+		  0,	8192,  8192, 0,	   0,	 8192, 7168,  0,    2048, 8192,
+		  5120, -1024, 2048, 8192, 8192, 2048, -1024, 5120, 8192, 2048,
+		  0,	7168,  8192, 0,	   0,	 8192, 8192,  0,    0,	  8192,
+		  8192, 0,     0,    8192, 8192, 0,    0,     8192, 8192, 0,
+		  0,	8192,  8192, 0,	   0,	 8192, 8192,  0,    0,	  8192,
+		  8192, 0,     0,    8192 }
 };
 
 static struct ia_css_macc_table skin_medium_macc_table = {
-	.data = {
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		5120, 0, 6144, 8192,
-		3072, -1024, 2048, 6144,
-		6144, 2048, -1024, 3072,
-		8192, 6144, 0, 5120,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192
-	}
+	.data = { 8192, 0,     0,    8192, 8192, 0,    0,     8192, 8192, 0,
+		  0,	8192,  8192, 0,	   0,	 8192, 5120,  0,    6144, 8192,
+		  3072, -1024, 2048, 6144, 6144, 2048, -1024, 3072, 8192, 6144,
+		  0,	5120,  8192, 0,	   0,	 8192, 8192,  0,    0,	  8192,
+		  8192, 0,     0,    8192, 8192, 0,    0,     8192, 8192, 0,
+		  0,	8192,  8192, 0,	   0,	 8192, 8192,  0,    0,	  8192,
+		  8192, 0,     0,    8192 }
 };
 
 static struct ia_css_macc_table skin_high_macc_table = {
-	.data = {
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		4096, 0, 8192, 8192,
-		0, -2048, 4096, 6144,
-		6144, 4096, -2048, 0,
-		8192, 8192, 0, 4096,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192
-	}
+	.data = { 8192, 0,     0,    8192, 8192, 0,    0,     8192, 8192, 0,
+		  0,	8192,  8192, 0,	   0,	 8192, 4096,  0,    8192, 8192,
+		  0,	-2048, 4096, 6144, 6144, 4096, -2048, 0,    8192, 8192,
+		  0,	4096,  8192, 0,	   0,	 8192, 8192,  0,    0,	  8192,
+		  8192, 0,     0,    8192, 8192, 0,    0,     8192, 8192, 0,
+		  0,	8192,  8192, 0,	   0,	 8192, 8192,  0,    0,	  8192,
+		  8192, 0,     0,    8192 }
 };
 
 /*Blue enhencement image effect table*/
 static struct ia_css_macc_table blue_macc_table = {
-	.data = {
-		9728, -3072, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		9728, 0, -3072, 8192,
-		12800, 1536, -3072, 8192,
-		11264, 0, 0, 11264,
-		9728, -3072, 0, 11264
-	}
+	.data = { 9728,	 -3072, 0,     8192,  8192,  0,	    0,	   8192,
+		  8192,	 0,	0,     8192,  8192,  0,	    0,	   8192,
+		  8192,	 0,	0,     8192,  8192,  0,	    0,	   8192,
+		  8192,	 0,	0,     8192,  8192,  0,	    0,	   8192,
+		  8192,	 0,	0,     8192,  8192,  0,	    0,	   8192,
+		  8192,	 0,	0,     8192,  8192,  0,	    0,	   8192,
+		  9728,	 0,	-3072, 8192,  12800, 1536,  -3072, 8192,
+		  11264, 0,	0,     11264, 9728,  -3072, 0,	   11264 }
 };
 
 /*Green enhencement image effect table*/
 static struct ia_css_macc_table green_macc_table = {
-	.data = {
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		10240, 4096, 0, 8192,
-		10240, 4096, 0, 12288,
-		12288, 0, 0, 12288,
-		14336, -2048, 4096, 8192,
-		10240, 0, 4096, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192,
-		8192, 0, 0, 8192
-	}
+	.data = { 8192,	 0,	0,    8192,  8192,  0,	  0,	8192,
+		  8192,	 0,	0,    8192,  8192,  0,	  0,	8192,
+		  8192,	 0,	0,    8192,  8192,  0,	  0,	8192,
+		  8192,	 0,	0,    8192,  10240, 4096, 0,	8192,
+		  10240, 4096,	0,    12288, 12288, 0,	  0,	12288,
+		  14336, -2048, 4096, 8192,  10240, 0,	  4096, 8192,
+		  8192,	 0,	0,    8192,  8192,  0,	  0,	8192,
+		  8192,	 0,	0,    8192,  8192,  0,	  0,	8192 }
 };
 
 static struct ia_css_ctc_table vivid_ctc_table = {
-	.data.vamem_2 = {
-		0,  384,  837,  957, 1011, 1062, 1083, 1080,
-		1078, 1077, 1053, 1039, 1012,  992,  969,  951,
-		929,  906,  886,  866,  845,  823,  809,  790,
-		772,  758,  741,  726,  711,  701,  688,  675,
-		666,  656,  648,  639,  633,  626,  618,  612,
-		603,  594,  582,  572,  557,  545,  529,  516,
-		504,  491,  480,  467,  459,  447,  438,  429,
-		419,  412,  404,  397,  389,  382,  376,  368,
-		363,  357,  351,  345,  340,  336,  330,  326,
-		321,  318,  312,  308,  304,  300,  297,  294,
-		291,  286,  284,  281,  278,  275,  271,  268,
-		261,  257,  251,  245,  240,  235,  232,  225,
-		223,  218,  213,  209,  206,  204,  199,  197,
-		193,  189,  186,  185,  183,  179,  177,  175,
-		172,  170,  169,  167,  164,  164,  162,  160,
-		158,  157,  156,  154,  154,  152,  151,  150,
-		149,  148,  146,  147,  146,  144,  143,  143,
-		142,  141,  140,  141,  139,  138,  138,  138,
-		137,  136,  136,  135,  134,  134,  134,  133,
-		132,  132,  131,  130,  131,  130,  129,  128,
-		129,  127,  127,  127,  127,  125,  125,  125,
-		123,  123,  122,  120,  118,  115,  114,  111,
-		110,  108,  106,  105,  103,  102,  100,   99,
-		97,   97,   96,   95,   94,   93,   93,   91,
-		91,   91,   90,   90,   89,   89,   88,   88,
-		89,   88,   88,   87,   87,   87,   87,   86,
-		87,   87,   86,   87,   86,   86,   84,   84,
-		82,   80,   78,   76,   74,   72,   70,   68,
-		67,   65,   62,   60,   58,   56,   55,   54,
-		53,   51,   49,   49,   47,   45,   45,   45,
-		41,   40,   39,   39,   34,   33,   34,   32,
-		25,   23,   24,   20,   13,    9,   12,    0,
-		0
-	}
+	.data.vamem_2 = { 0,	384,  837,  957,  1011, 1062, 1083, 1080, 1078,
+			  1077, 1053, 1039, 1012, 992,	969,  951,  929,  906,
+			  886,	866,  845,  823,  809,	790,  772,  758,  741,
+			  726,	711,  701,  688,  675,	666,  656,  648,  639,
+			  633,	626,  618,  612,  603,	594,  582,  572,  557,
+			  545,	529,  516,  504,  491,	480,  467,  459,  447,
+			  438,	429,  419,  412,  404,	397,  389,  382,  376,
+			  368,	363,  357,  351,  345,	340,  336,  330,  326,
+			  321,	318,  312,  308,  304,	300,  297,  294,  291,
+			  286,	284,  281,  278,  275,	271,  268,  261,  257,
+			  251,	245,  240,  235,  232,	225,  223,  218,  213,
+			  209,	206,  204,  199,  197,	193,  189,  186,  185,
+			  183,	179,  177,  175,  172,	170,  169,  167,  164,
+			  164,	162,  160,  158,  157,	156,  154,  154,  152,
+			  151,	150,  149,  148,  146,	147,  146,  144,  143,
+			  143,	142,  141,  140,  141,	139,  138,  138,  138,
+			  137,	136,  136,  135,  134,	134,  134,  133,  132,
+			  132,	131,  130,  131,  130,	129,  128,  129,  127,
+			  127,	127,  127,  125,  125,	125,  123,  123,  122,
+			  120,	118,  115,  114,  111,	110,  108,  106,  105,
+			  103,	102,  100,  99,	  97,	97,   96,   95,	  94,
+			  93,	93,   91,   91,	  91,	90,   90,   89,	  89,
+			  88,	88,   89,   88,	  88,	87,   87,   87,	  87,
+			  86,	87,   87,   86,	  87,	86,   86,   84,	  84,
+			  82,	80,   78,   76,	  74,	72,   70,   68,	  67,
+			  65,	62,   60,   58,	  56,	55,   54,   53,	  51,
+			  49,	49,   47,   45,	  45,	45,   41,   40,	  39,
+			  39,	34,   33,   34,	  32,	25,   23,   24,	  20,
+			  13,	9,    12,   0,	  0 }
 };
 #endif
diff --git a/drivers/staging/media/atomisp/pci/atomisp_trace_event.h b/drivers/staging/media/atomisp/pci/atomisp_trace_event.h
index 4c58a8f5c7e84d7a86962e6cae93402a8ae2e5d6..23b91e5e6190edf5f84b675294a3383610d60e84 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_trace_event.h
+++ b/drivers/staging/media/atomisp/pci/atomisp_trace_event.h
@@ -12,43 +12,36 @@
 
 #include <linux/tracepoint.h>
 #include <linux/string.h>
-TRACE_EVENT(camera_meminfo,
-
-	    TP_PROTO(const char *name, int uptr_size, int counter, int sys_size,
-		     int sys_res_size, int cam_sys_use, int cam_dyc_use,
-		     int cam_res_use),
-
-	    TP_ARGS(name, uptr_size, counter, sys_size, sys_res_size, cam_sys_use,
-		    cam_dyc_use, cam_res_use),
-
-	    TP_STRUCT__entry(
-		__array(char, name, 24)
-		__field(int, uptr_size)
-		__field(int, counter)
-		__field(int, sys_size)
-		__field(int, sys_res_size)
-		__field(int, cam_res_use)
-		__field(int, cam_dyc_use)
-		__field(int, cam_sys_use)
-	    ),
-
-	    TP_fast_assign(
-		strscpy(__entry->name, name, 24);
-		__entry->uptr_size = uptr_size;
-		__entry->counter = counter;
-		__entry->sys_size = sys_size;
-		__entry->sys_res_size = sys_res_size;
-		__entry->cam_res_use = cam_res_use;
-		__entry->cam_dyc_use = cam_dyc_use;
-		__entry->cam_sys_use = cam_sys_use;
-	    ),
-
-	    TP_printk(
+TRACE_EVENT(
+	camera_meminfo,
+
+	TP_PROTO(const char *name, int uptr_size, int counter, int sys_size,
+		 int sys_res_size, int cam_sys_use, int cam_dyc_use,
+		 int cam_res_use),
+
+	TP_ARGS(name, uptr_size, counter, sys_size, sys_res_size, cam_sys_use,
+		cam_dyc_use, cam_res_use),
+
+	TP_STRUCT__entry(__array(char, name, 24) __field(
+		int, uptr_size) __field(int, counter) __field(int, sys_size)
+				 __field(int, sys_res_size) __field(int,
+								    cam_res_use)
+					 __field(int, cam_dyc_use)
+						 __field(int, cam_sys_use)),
+
+	TP_fast_assign(strscpy(__entry->name, name, 24);
+		       __entry->uptr_size = uptr_size;
+		       __entry->counter = counter; __entry->sys_size = sys_size;
+		       __entry->sys_res_size = sys_res_size;
+		       __entry->cam_res_use = cam_res_use;
+		       __entry->cam_dyc_use = cam_dyc_use;
+		       __entry->cam_sys_use = cam_sys_use;),
+
+	TP_printk(
 		"<%s> User ptr memory:%d pages,\tISP private memory used:%d pages:\tsysFP system size:%d,\treserved size:%d\tcamFP sysUse:%d,\tdycUse:%d,\tresUse:%d.\n",
 		__entry->name, __entry->uptr_size, __entry->counter,
 		__entry->sys_size, __entry->sys_res_size, __entry->cam_sys_use,
-		__entry->cam_dyc_use, __entry->cam_res_use)
-	   );
+		__entry->cam_dyc_use, __entry->cam_res_use));
 
 TRACE_EVENT(camera_debug,
 
@@ -56,21 +49,15 @@ TRACE_EVENT(camera_debug,
 
 	    TP_ARGS(name, info, line),
 
-	    TP_STRUCT__entry(
-		__array(char, name, 24)
-		__array(char, info, 24)
-		__field(int, line)
-	    ),
+	    TP_STRUCT__entry(__array(char, name, 24) __array(char, info, 24)
+				     __field(int, line)),
 
-	    TP_fast_assign(
-		strscpy(__entry->name, name, 24);
-		strscpy(__entry->info, info, 24);
-		__entry->line = line;
-	    ),
+	    TP_fast_assign(strscpy(__entry->name, name, 24);
+			   strscpy(__entry->info, info, 24);
+			   __entry->line = line;),
 
 	    TP_printk("<%s>-<%d> %s\n", __entry->name, __entry->line,
-		      __entry->info)
-	   );
+		      __entry->info));
 
 TRACE_EVENT(ipu_cstate,
 
@@ -78,16 +65,11 @@ TRACE_EVENT(ipu_cstate,
 
 	    TP_ARGS(cstate),
 
-	    TP_STRUCT__entry(
-		__field(int, cstate)
-	    ),
+	    TP_STRUCT__entry(__field(int, cstate)),
 
-	    TP_fast_assign(
-		__entry->cstate = cstate;
-	    ),
+	    TP_fast_assign(__entry->cstate = cstate;),
 
-	    TP_printk("cstate=%d", __entry->cstate)
-	   );
+	    TP_printk("cstate=%d", __entry->cstate));
 
 TRACE_EVENT(ipu_pstate,
 
@@ -95,23 +77,16 @@ TRACE_EVENT(ipu_pstate,
 
 	    TP_ARGS(freq, util),
 
-	    TP_STRUCT__entry(
-		__field(int, freq)
-		__field(int, util)
-	    ),
+	    TP_STRUCT__entry(__field(int, freq) __field(int, util)),
 
-	    TP_fast_assign(
-		__entry->freq = freq;
-		__entry->util = util;
-	    ),
+	    TP_fast_assign(__entry->freq = freq; __entry->util = util;),
 
-	    TP_printk("freq=%d util=%d", __entry->freq, __entry->util)
-	   );
+	    TP_printk("freq=%d util=%d", __entry->freq, __entry->util));
 #endif
 
 #undef TRACE_INCLUDE_PATH
 #undef TRACE_INCLUDE_FILE
 #define TRACE_INCLUDE_PATH .
-#define TRACE_INCLUDE_FILE   atomisp_trace_event
+#define TRACE_INCLUDE_FILE atomisp_trace_event
 /* This part must be outside protection */
 #include <trace/define_trace.h>
diff --git a/drivers/staging/media/atomisp/pci/atomisp_v4l2.c b/drivers/staging/media/atomisp/pci/atomisp_v4l2.c
index 0bd0bfded4af11bc3259d0ac164c820935e78ae2..d54562b917d4693aaa32ad53a321854e60b16a27 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_v4l2.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_v4l2.c
@@ -38,11 +38,11 @@
 #include "device_access.h"
 
 /* Timeouts to wait for all subdevs to be registered */
-#define SUBDEV_WAIT_TIMEOUT		50 /* ms */
-#define SUBDEV_WAIT_TIMEOUT_MAX_COUNT	40 /* up to 2 seconds */
+#define SUBDEV_WAIT_TIMEOUT 50 /* ms */
+#define SUBDEV_WAIT_TIMEOUT_MAX_COUNT 40 /* up to 2 seconds */
 
 /* G-Min addition: pull this in from intel_mid_pm.h */
-#define CSTATE_EXIT_LATENCY_C1  1
+#define CSTATE_EXIT_LATENCY_C1 1
 
 /* cross component debug message flag */
 int dbg_level;
@@ -52,8 +52,7 @@ MODULE_PARM_DESC(dbg_level, "debug message level (default:0)");
 /* log function switch */
 int dbg_func = 1;
 module_param(dbg_func, int, 0644);
-MODULE_PARM_DESC(dbg_func,
-		 "log function switch non/printk (default:printk)");
+MODULE_PARM_DESC(dbg_func, "log function switch non/printk (default:printk)");
 
 /*
  * Set to 16x16 since this is the amount of lines and pixels the sensor
@@ -323,7 +322,8 @@ int atomisp_video_init(struct atomisp_video_pipe *video)
 		return ret;
 
 	/* Initialize the video device. */
-	strscpy(video->vdev.name, "ATOMISP video output", sizeof(video->vdev.name));
+	strscpy(video->vdev.name, "ATOMISP video output",
+		sizeof(video->vdev.name));
 	video->vdev.fops = &atomisp_fops;
 	video->vdev.ioctl_ops = &atomisp_ioctl_ops;
 	video->vdev.lock = &video->isp->mutex;
@@ -351,16 +351,16 @@ static int atomisp_save_iunit_reg(struct atomisp_device *isp)
 	/* isp->saved_regs.ispmmadr is set from the atomisp_pci_probe() */
 	pci_read_config_dword(pdev, PCI_MSI_CAPID, &isp->saved_regs.msicap);
 	pci_read_config_dword(pdev, PCI_MSI_ADDR, &isp->saved_regs.msi_addr);
-	pci_read_config_word(pdev, PCI_MSI_DATA,  &isp->saved_regs.msi_data);
+	pci_read_config_word(pdev, PCI_MSI_DATA, &isp->saved_regs.msi_data);
 	pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &isp->saved_regs.intr);
-	pci_read_config_dword(pdev, PCI_INTERRUPT_CTRL, &isp->saved_regs.interrupt_control);
+	pci_read_config_dword(pdev, PCI_INTERRUPT_CTRL,
+			      &isp->saved_regs.interrupt_control);
 
 	pci_read_config_dword(pdev, MRFLD_PCI_PMCS, &isp->saved_regs.pmcs);
 	/* Ensure read/write combining is enabled. */
 	pci_read_config_dword(pdev, PCI_I_CONTROL, &isp->saved_regs.i_control);
-	isp->saved_regs.i_control |=
-	    MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING |
-	    MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;
+	isp->saved_regs.i_control |= MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING |
+				     MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;
 	pci_read_config_dword(pdev, MRFLD_PCI_CSI_ACCESS_CTRL_VIOL,
 			      &isp->saved_regs.csi_access_viol);
 	pci_read_config_dword(pdev, MRFLD_PCI_CSI_RCOMP_CONTROL,
@@ -373,7 +373,8 @@ static int atomisp_save_iunit_reg(struct atomisp_device *isp)
 	 * is missed, and IUNIT can hang.
 	 * For both issues, setting this bit is a workaround.
 	 */
-	isp->saved_regs.csi_rcomp_config |= MRFLD_PCI_CSI_HS_OVR_CLK_GATE_ON_UPDATE;
+	isp->saved_regs.csi_rcomp_config |=
+		MRFLD_PCI_CSI_HS_OVR_CLK_GATE_ON_UPDATE;
 	pci_read_config_dword(pdev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
 			      &isp->saved_regs.csi_afe_dly);
 	pci_read_config_dword(pdev, MRFLD_PCI_CSI_CONTROL,
@@ -384,8 +385,10 @@ static int atomisp_save_iunit_reg(struct atomisp_device *isp)
 	/*
 	 * On CHT CSI_READY bit should be enabled before stream on
 	 */
-	if (IS_CHT && (isp->media_dev.hw_revision >= ((ATOMISP_HW_REVISION_ISP2401 <<
-		       ATOMISP_HW_REVISION_SHIFT) | ATOMISP_HW_STEPPING_B0)))
+	if (IS_CHT &&
+	    (isp->media_dev.hw_revision >=
+	     ((ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT) |
+	      ATOMISP_HW_STEPPING_B0)))
 		isp->saved_regs.csi_control |= MRFLD_PCI_CSI_CONTROL_CSI_READY;
 	pci_read_config_dword(pdev, MRFLD_PCI_CSI_AFE_RCOMP_CONTROL,
 			      &isp->saved_regs.csi_afe_rcomp_config);
@@ -403,12 +406,14 @@ static int atomisp_restore_iunit_reg(struct atomisp_device *isp)
 	dev_dbg(isp->dev, "%s\n", __func__);
 
 	pci_write_config_word(pdev, PCI_COMMAND, isp->saved_regs.pcicmdsts);
-	pci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, isp->saved_regs.ispmmadr);
+	pci_write_config_dword(pdev, PCI_BASE_ADDRESS_0,
+			       isp->saved_regs.ispmmadr);
 	pci_write_config_dword(pdev, PCI_MSI_CAPID, isp->saved_regs.msicap);
 	pci_write_config_dword(pdev, PCI_MSI_ADDR, isp->saved_regs.msi_addr);
 	pci_write_config_word(pdev, PCI_MSI_DATA, isp->saved_regs.msi_data);
 	pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, isp->saved_regs.intr);
-	pci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, isp->saved_regs.interrupt_control);
+	pci_write_config_dword(pdev, PCI_INTERRUPT_CTRL,
+			       isp->saved_regs.interrupt_control);
 	pci_write_config_dword(pdev, PCI_I_CONTROL, isp->saved_regs.i_control);
 
 	pci_write_config_dword(pdev, MRFLD_PCI_PMCS, isp->saved_regs.pmcs);
@@ -537,8 +542,8 @@ static int atomisp_mrfld_power(struct atomisp_device *isp, bool enable)
 	}
 
 	/* Write to ISPSSPM0 bit[1:0] to power on/off the IUNIT */
-	iosf_mbi_modify(BT_MBI_UNIT_PMC, MBI_REG_READ, MRFLD_ISPSSPM0,
-			val, MRFLD_ISPSSPM0_ISPSSC_MASK);
+	iosf_mbi_modify(BT_MBI_UNIT_PMC, MBI_REG_READ, MRFLD_ISPSSPM0, val,
+			MRFLD_ISPSSPM0_ISPSSC_MASK);
 
 	/* WA:Enable DVFS */
 	if (IS_CHT && !enable && !isp->pm_only)
@@ -555,8 +560,10 @@ static int atomisp_mrfld_power(struct atomisp_device *isp, bool enable)
 		u32 tmp;
 
 		/* Wait until ISPSSPM0 bit[25:24] shows the right value */
-		iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, MRFLD_ISPSSPM0, &tmp);
-		tmp = (tmp >> MRFLD_ISPSSPM0_ISPSSS_OFFSET) & MRFLD_ISPSSPM0_ISPSSC_MASK;
+		iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, MRFLD_ISPSSPM0,
+			      &tmp);
+		tmp = (tmp >> MRFLD_ISPSSPM0_ISPSSS_OFFSET) &
+		      MRFLD_ISPSSPM0_ISPSSC_MASK;
 		if (tmp == val) {
 			trace_ipu_cstate(enable);
 			pdev->current_state = enable ? PCI_D0 : PCI_D3cold;
@@ -607,8 +614,8 @@ int atomisp_power_off(struct device *dev)
 
 int atomisp_power_on(struct device *dev)
 {
-	struct atomisp_device *isp = (struct atomisp_device *)
-				     dev_get_drvdata(dev);
+	struct atomisp_device *isp =
+		(struct atomisp_device *)dev_get_drvdata(dev);
 	int ret;
 
 	ret = atomisp_mrfld_power(isp, true);
@@ -632,8 +639,8 @@ int atomisp_power_on(struct device *dev)
 
 static int atomisp_suspend(struct device *dev)
 {
-	struct atomisp_device *isp = (struct atomisp_device *)
-				     dev_get_drvdata(dev);
+	struct atomisp_device *isp =
+		(struct atomisp_device *)dev_get_drvdata(dev);
 	unsigned long flags;
 
 	/* FIXME: Suspend is not supported by sensors. Abort if streaming. */
@@ -676,24 +683,24 @@ int atomisp_csi_lane_config(struct atomisp_device *isp)
 		u8 lanes[N_MIPI_PORT_ID];
 	} portconfigs[] = {
 		/* Tangier/Merrifield available lane configurations */
-		{ 0x00, { 4, 1, 0 } },		/* 00000 */
-		{ 0x01, { 3, 1, 0 } },		/* 00001 */
-		{ 0x02, { 2, 1, 0 } },		/* 00010 */
-		{ 0x03, { 1, 1, 0 } },		/* 00011 */
-		{ 0x04, { 2, 1, 2 } },		/* 00100 */
-		{ 0x08, { 3, 1, 1 } },		/* 01000 */
-		{ 0x09, { 2, 1, 1 } },		/* 01001 */
-		{ 0x0a, { 1, 1, 1 } },		/* 01010 */
+		{ 0x00, { 4, 1, 0 } }, /* 00000 */
+		{ 0x01, { 3, 1, 0 } }, /* 00001 */
+		{ 0x02, { 2, 1, 0 } }, /* 00010 */
+		{ 0x03, { 1, 1, 0 } }, /* 00011 */
+		{ 0x04, { 2, 1, 2 } }, /* 00100 */
+		{ 0x08, { 3, 1, 1 } }, /* 01000 */
+		{ 0x09, { 2, 1, 1 } }, /* 01001 */
+		{ 0x0a, { 1, 1, 1 } }, /* 01010 */
 
 		/* Anniedale/Moorefield only configurations */
-		{ 0x10, { 4, 2, 0 } },		/* 10000 */
-		{ 0x11, { 3, 2, 0 } },		/* 10001 */
-		{ 0x12, { 2, 2, 0 } },		/* 10010 */
-		{ 0x13, { 1, 2, 0 } },		/* 10011 */
-		{ 0x14, { 2, 2, 2 } },		/* 10100 */
-		{ 0x18, { 3, 2, 1 } },		/* 11000 */
-		{ 0x19, { 2, 2, 1 } },		/* 11001 */
-		{ 0x1a, { 1, 2, 1 } },		/* 11010 */
+		{ 0x10, { 4, 2, 0 } }, /* 10000 */
+		{ 0x11, { 3, 2, 0 } }, /* 10001 */
+		{ 0x12, { 2, 2, 0 } }, /* 10010 */
+		{ 0x13, { 1, 2, 0 } }, /* 10011 */
+		{ 0x14, { 2, 2, 2 } }, /* 10100 */
+		{ 0x18, { 3, 2, 1 } }, /* 11000 */
+		{ 0x19, { 2, 2, 1 } }, /* 11001 */
+		{ 0x1a, { 1, 2, 1 } }, /* 11010 */
 	};
 
 	unsigned int i, j;
@@ -702,9 +709,8 @@ int atomisp_csi_lane_config(struct atomisp_device *isp)
 	u32 port_config_mask;
 	int port3_lanes_shift;
 
-	if (isp->media_dev.hw_revision <
-	    ATOMISP_HW_REVISION_ISP2401_LEGACY <<
-	    ATOMISP_HW_REVISION_SHIFT) {
+	if (isp->media_dev.hw_revision < ATOMISP_HW_REVISION_ISP2401_LEGACY
+						 << ATOMISP_HW_REVISION_SHIFT) {
 		/* Merrifield */
 		port_config_mask = MRFLD_PORT_CONFIG_MASK;
 		port3_lanes_shift = MRFLD_PORT3_LANES_SHIFT;
@@ -714,9 +720,8 @@ int atomisp_csi_lane_config(struct atomisp_device *isp)
 		port3_lanes_shift = CHV_PORT3_LANES_SHIFT;
 	}
 
-	if (isp->media_dev.hw_revision <
-	    ATOMISP_HW_REVISION_ISP2401 <<
-	    ATOMISP_HW_REVISION_SHIFT) {
+	if (isp->media_dev.hw_revision < ATOMISP_HW_REVISION_ISP2401
+						 << ATOMISP_HW_REVISION_SHIFT) {
 		/* Merrifield / Moorefield legacy input system */
 		nportconfigs = MRFLD_PORT_CONFIG_NUM;
 	} else {
@@ -731,26 +736,32 @@ int atomisp_csi_lane_config(struct atomisp_device *isp)
 				break;
 
 		if (j == N_MIPI_PORT_ID)
-			break;			/* Found matching setting */
+			break; /* Found matching setting */
 	}
 
 	if (i >= nportconfigs) {
 		dev_err(isp->dev,
 			"%s: could not find the CSI port setting for %d-%d-%d\n",
-			__func__,
-			isp->sensor_lanes[0], isp->sensor_lanes[1], isp->sensor_lanes[2]);
+			__func__, isp->sensor_lanes[0], isp->sensor_lanes[1],
+			isp->sensor_lanes[2]);
 		return -EINVAL;
 	}
 
 	pci_read_config_dword(pdev, MRFLD_PCI_CSI_CONTROL, &csi_control);
 	csi_control &= ~port_config_mask;
-	csi_control |= (portconfigs[i].code << MRFLD_PORT_CONFIGCODE_SHIFT)
-		       | (portconfigs[i].lanes[0] ? 0 : (1 << MRFLD_PORT1_ENABLE_SHIFT))
-		       | (portconfigs[i].lanes[1] ? 0 : (1 << MRFLD_PORT2_ENABLE_SHIFT))
-		       | (portconfigs[i].lanes[2] ? 0 : (1 << MRFLD_PORT3_ENABLE_SHIFT))
-		       | (((1 << portconfigs[i].lanes[0]) - 1) << MRFLD_PORT1_LANES_SHIFT)
-		       | (((1 << portconfigs[i].lanes[1]) - 1) << MRFLD_PORT2_LANES_SHIFT)
-		       | (((1 << portconfigs[i].lanes[2]) - 1) << port3_lanes_shift);
+	csi_control |=
+		(portconfigs[i].code << MRFLD_PORT_CONFIGCODE_SHIFT) |
+		(portconfigs[i].lanes[0] ? 0 :
+					   (1 << MRFLD_PORT1_ENABLE_SHIFT)) |
+		(portconfigs[i].lanes[1] ? 0 :
+					   (1 << MRFLD_PORT2_ENABLE_SHIFT)) |
+		(portconfigs[i].lanes[2] ? 0 :
+					   (1 << MRFLD_PORT3_ENABLE_SHIFT)) |
+		(((1 << portconfigs[i].lanes[0]) - 1)
+		 << MRFLD_PORT1_LANES_SHIFT) |
+		(((1 << portconfigs[i].lanes[1]) - 1)
+		 << MRFLD_PORT2_LANES_SHIFT) |
+		(((1 << portconfigs[i].lanes[2]) - 1) << port3_lanes_shift);
 
 	pci_write_config_dword(pdev, MRFLD_PCI_CSI_CONTROL, csi_control);
 
@@ -777,18 +788,22 @@ static int atomisp_subdev_probe(struct atomisp_device *isp)
 	 * converting them to standard v4l2 sensor drivers using runtime-pm +
 	 * ACPI for pm and v4l2_async_register_subdev_sensor() registration.
 	 */
-	for (subdevs = atomisp_platform_get_subdevs(); subdevs->subdev; subdevs++) {
-		ret = v4l2_device_register_subdev(&isp->v4l2_dev, subdevs->subdev);
+	for (subdevs = atomisp_platform_get_subdevs(); subdevs->subdev;
+	     subdevs++) {
+		ret = v4l2_device_register_subdev(&isp->v4l2_dev,
+						  subdevs->subdev);
 		if (ret)
 			continue;
 
 		if (subdevs->port >= ATOMISP_CAMERA_NR_PORTS) {
-			dev_err(isp->dev, "port %d not supported\n", subdevs->port);
+			dev_err(isp->dev, "port %d not supported\n",
+				subdevs->port);
 			continue;
 		}
 
 		if (isp->sensor_subdevs[subdevs->port]) {
-			dev_err(isp->dev, "port %d already has a sensor attached\n",
+			dev_err(isp->dev,
+				"port %d already has a sensor attached\n",
 				subdevs->port);
 			continue;
 		}
@@ -847,7 +862,7 @@ static int atomisp_register_entities(struct atomisp_device *isp)
 	/* Register internal entities */
 	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
 		ret = atomisp_mipi_csi2_register_entities(&isp->csi2_port[i],
-			&isp->v4l2_dev);
+							  &isp->v4l2_dev);
 		if (ret == 0)
 			continue;
 
@@ -856,7 +871,7 @@ static int atomisp_register_entities(struct atomisp_device *isp)
 		/* deregister all registered CSI ports */
 		while (i--)
 			atomisp_mipi_csi2_unregister_entities(
-			    &isp->csi2_port[i]);
+				&isp->csi2_port[i]);
 
 		goto csi_and_subdev_probe_failed;
 	}
@@ -883,9 +898,9 @@ static int atomisp_register_entities(struct atomisp_device *isp)
 static void atomisp_init_sensor(struct atomisp_input_subdev *input)
 {
 	static struct lock_class_key try_sd_state_key;
-	struct v4l2_subdev_mbus_code_enum mbus_code_enum = { };
-	struct v4l2_subdev_frame_size_enum fse = { };
-	struct v4l2_subdev_selection sel = { };
+	struct v4l2_subdev_mbus_code_enum mbus_code_enum = {};
+	struct v4l2_subdev_frame_size_enum fse = {};
+	struct v4l2_subdev_selection sel = {};
 	struct v4l2_subdev_state *try_sd_state, *act_sd_state;
 	int i, err;
 
@@ -895,9 +910,8 @@ static void atomisp_init_sensor(struct atomisp_input_subdev *input)
 	 * it emulates a normal v4l2 device there, passing through try_fmt /
 	 * set_fmt to the sensor.
 	 */
-	try_sd_state = __v4l2_subdev_state_alloc(input->sensor,
-						 "atomisp:try_sd_state->lock",
-						 &try_sd_state_key);
+	try_sd_state = __v4l2_subdev_state_alloc(
+		input->sensor, "atomisp:try_sd_state->lock", &try_sd_state_key);
 	if (IS_ERR(try_sd_state))
 		return;
 
@@ -906,15 +920,15 @@ static void atomisp_init_sensor(struct atomisp_input_subdev *input)
 	act_sd_state = v4l2_subdev_lock_and_get_active_state(input->sensor);
 
 	mbus_code_enum.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	err = v4l2_subdev_call(input->sensor, pad, enum_mbus_code,
-			       act_sd_state, &mbus_code_enum);
+	err = v4l2_subdev_call(input->sensor, pad, enum_mbus_code, act_sd_state,
+			       &mbus_code_enum);
 	if (!err)
 		input->code = mbus_code_enum.code;
 
 	sel.which = V4L2_SUBDEV_FORMAT_ACTIVE;
 	sel.target = V4L2_SEL_TGT_NATIVE_SIZE;
-	err = v4l2_subdev_call(input->sensor, pad, get_selection,
-			       act_sd_state, &sel);
+	err = v4l2_subdev_call(input->sensor, pad, get_selection, act_sd_state,
+			       &sel);
 	if (err)
 		goto unlock_act_sd_state;
 
@@ -922,8 +936,8 @@ static void atomisp_init_sensor(struct atomisp_input_subdev *input)
 
 	sel.which = V4L2_SUBDEV_FORMAT_ACTIVE;
 	sel.target = V4L2_SEL_TGT_CROP_DEFAULT;
-	err = v4l2_subdev_call(input->sensor, pad, get_selection,
-			       act_sd_state, &sel);
+	err = v4l2_subdev_call(input->sensor, pad, get_selection, act_sd_state,
+			       &sel);
 	if (err)
 		goto unlock_act_sd_state;
 
@@ -935,7 +949,7 @@ static void atomisp_init_sensor(struct atomisp_input_subdev *input)
 	 * Do this before changing the crop-rect since that may influence
 	 * enum_frame_size results.
 	 */
-	for (i = 0; ; i++) {
+	for (i = 0;; i++) {
 		fse.index = i;
 		fse.code = input->code;
 		fse.which = V4L2_SUBDEV_FORMAT_ACTIVE;
@@ -980,12 +994,13 @@ static void atomisp_init_sensor(struct atomisp_input_subdev *input)
 	sel.which = V4L2_SUBDEV_FORMAT_ACTIVE;
 	sel.target = V4L2_SEL_TGT_CROP;
 	sel.r = input->native_rect;
-	err = v4l2_subdev_call(input->sensor, pad, set_selection,
-			       act_sd_state, &sel);
+	err = v4l2_subdev_call(input->sensor, pad, set_selection, act_sd_state,
+			       &sel);
 	if (err)
 		goto unlock_act_sd_state;
 
-	dev_info(input->sensor->dev, "Supports crop native %dx%d active %dx%d binning %d\n",
+	dev_info(input->sensor->dev,
+		 "Supports crop native %dx%d active %dx%d binning %d\n",
 		 input->native_rect.width, input->native_rect.height,
 		 input->active_rect.width, input->active_rect.height,
 		 input->binning_support);
@@ -1005,7 +1020,8 @@ int atomisp_register_device_nodes(struct atomisp_device *isp)
 
 	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
 		err = media_create_pad_link(&isp->csi2_port[i].subdev.entity,
-					    CSI2_PAD_SOURCE, &isp->asd.subdev.entity,
+					    CSI2_PAD_SOURCE,
+					    &isp->asd.subdev.entity,
 					    ATOMISP_SUBDEV_PAD_SINK, 0);
 		if (err)
 			return err;
@@ -1023,18 +1039,23 @@ int atomisp_register_device_nodes(struct atomisp_device *isp)
 		 * Special case for sensors with a ISP in the sensor modelled
 		 * as a separate v4l2-subdev, like the mt9m114.
 		 */
-		if (isp->sensor_subdevs[i]->entity.function == MEDIA_ENT_F_PROC_VIDEO_ISP) {
+		if (isp->sensor_subdevs[i]->entity.function ==
+		    MEDIA_ENT_F_PROC_VIDEO_ISP) {
 			input->sensor_isp = isp->sensor_subdevs[i];
 			source_pad = SENSOR_ISP_PAD_SOURCE;
 
-			sensor_isp_sink = &input->sensor_isp->entity.pads[SENSOR_ISP_PAD_SINK];
-			sensor_src = media_pad_remote_pad_first(sensor_isp_sink);
+			sensor_isp_sink = &input->sensor_isp->entity
+						   .pads[SENSOR_ISP_PAD_SINK];
+			sensor_src =
+				media_pad_remote_pad_first(sensor_isp_sink);
 			if (!sensor_src) {
-				dev_err(isp->dev, "Error could not find remote pad for sensor ISP sink\n");
+				dev_err(isp->dev,
+					"Error could not find remote pad for sensor ISP sink\n");
 				return -ENOENT;
 			}
 
-			input->sensor = media_entity_to_v4l2_subdev(sensor_src->entity);
+			input->sensor =
+				media_entity_to_v4l2_subdev(sensor_src->entity);
 		} else {
 			input->sensor = isp->sensor_subdevs[i];
 			source_pad = 0;
@@ -1042,10 +1063,10 @@ int atomisp_register_device_nodes(struct atomisp_device *isp)
 
 		atomisp_init_sensor(input);
 
-		err = media_create_pad_link(&isp->sensor_subdevs[i]->entity, source_pad,
-					    &isp->csi2_port[i].subdev.entity,
-					    CSI2_PAD_SINK,
-					    MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);
+		err = media_create_pad_link(
+			&isp->sensor_subdevs[i]->entity, source_pad,
+			&isp->csi2_port[i].subdev.entity, CSI2_PAD_SINK,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);
 		if (err)
 			return err;
 
@@ -1055,21 +1076,25 @@ int atomisp_register_device_nodes(struct atomisp_device *isp)
 	if (!isp->input_cnt)
 		dev_warn(isp->dev, "no camera attached or fail to detect\n");
 	else
-		dev_info(isp->dev, "detected %d camera sensors\n", isp->input_cnt);
+		dev_info(isp->dev, "detected %d camera sensors\n",
+			 isp->input_cnt);
 
 	mutex_lock(&isp->media_dev.graph_mutex);
 	atomisp_setup_input_links(isp);
 	mutex_unlock(&isp->media_dev.graph_mutex);
 
 	isp->asd.video_out.vdev.v4l2_dev = &isp->v4l2_dev;
-	isp->asd.video_out.vdev.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
-	err = video_register_device(&isp->asd.video_out.vdev, VFL_TYPE_VIDEO, -1);
+	isp->asd.video_out.vdev.device_caps = V4L2_CAP_VIDEO_CAPTURE |
+					      V4L2_CAP_STREAMING;
+	err = video_register_device(&isp->asd.video_out.vdev, VFL_TYPE_VIDEO,
+				    -1);
 	if (err)
 		return err;
 
-	err = media_create_pad_link(&isp->asd.subdev.entity, ATOMISP_SUBDEV_PAD_SOURCE,
-				    &isp->asd.video_out.vdev.entity, 0,
-				    MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);
+	err = media_create_pad_link(
+		&isp->asd.subdev.entity, ATOMISP_SUBDEV_PAD_SOURCE,
+		&isp->asd.video_out.vdev.entity, 0,
+		MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);
 	if (err)
 		return err;
 
@@ -1109,8 +1134,7 @@ static void atomisp_uninitialize_modules(struct atomisp_device *isp)
 	atomisp_mipi_csi2_cleanup(isp);
 }
 
-const struct firmware *
-atomisp_load_firmware(struct atomisp_device *isp)
+const struct firmware *atomisp_load_firmware(struct atomisp_device *isp)
 {
 	const struct firmware *fw;
 	int rc;
@@ -1142,8 +1166,8 @@ atomisp_load_firmware(struct atomisp_device *isp)
 		rc = request_firmware(&fw, kbasename(fw_path), isp->dev);
 	if (rc) {
 		dev_err(isp->dev,
-			"atomisp: Error %d while requesting firmware %s\n",
-			rc, fw_path);
+			"atomisp: Error %d while requesting firmware %s\n", rc,
+			fw_path);
 		return NULL;
 	}
 
@@ -1185,9 +1209,10 @@ static void atomisp_pm_uninit(struct atomisp_device *isp)
 	cpu_latency_qos_remove_request(&isp->pm_qos);
 }
 
-#define ATOM_ISP_PCI_BAR	0
+#define ATOM_ISP_PCI_BAR 0
 
-static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+static int atomisp_pci_probe(struct pci_dev *pdev,
+			     const struct pci_device_id *id)
 {
 	struct atomisp_device *isp;
 	unsigned int start;
@@ -1220,10 +1245,9 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 	case ATOMISP_PCI_DEVICE_SOC_MRFLD:
 	case ATOMISP_PCI_DEVICE_SOC_MRFLD_1179:
 	case ATOMISP_PCI_DEVICE_SOC_MRFLD_117A:
-		isp->media_dev.hw_revision =
-		    (ATOMISP_HW_REVISION_ISP2400
-		     << ATOMISP_HW_REVISION_SHIFT) |
-		    ATOMISP_HW_STEPPING_B0;
+		isp->media_dev.hw_revision = (ATOMISP_HW_REVISION_ISP2400
+					      << ATOMISP_HW_REVISION_SHIFT) |
+					     ATOMISP_HW_STEPPING_B0;
 
 		switch (id->device) {
 		case ATOMISP_PCI_DEVICE_SOC_MRFLD_1179:
@@ -1240,10 +1264,9 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 		isp->hpll_freq = HPLL_FREQ_1600MHZ;
 		break;
 	case ATOMISP_PCI_DEVICE_SOC_BYT:
-		isp->media_dev.hw_revision =
-		    (ATOMISP_HW_REVISION_ISP2400
-		     << ATOMISP_HW_REVISION_SHIFT) |
-		    ATOMISP_HW_STEPPING_B0;
+		isp->media_dev.hw_revision = (ATOMISP_HW_REVISION_ISP2400
+					      << ATOMISP_HW_REVISION_SHIFT) |
+					     ATOMISP_HW_STEPPING_B0;
 
 		/*
 		 * Note: some Intel-based tablets with Android use a different
@@ -1267,7 +1290,8 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 		 * have specs yet for exactly how it varies.  Default to
 		 * BYT-CR but let provisioning set it via EFI variable
 		 */
-		isp->hpll_freq = gmin_get_var_int(&pdev->dev, false, "HpllFreq", HPLL_FREQ_2000MHZ);
+		isp->hpll_freq = gmin_get_var_int(&pdev->dev, false, "HpllFreq",
+						  HPLL_FREQ_2000MHZ);
 
 		/*
 		 * for BYT/CHT we are put isp into D3cold to avoid pci registers access
@@ -1278,22 +1302,25 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 		break;
 	case ATOMISP_PCI_DEVICE_SOC_ANN:
 		isp->media_dev.hw_revision = (ATOMISP_HW_REVISION_ISP2401
-						 << ATOMISP_HW_REVISION_SHIFT);
+					      << ATOMISP_HW_REVISION_SHIFT);
 		isp->media_dev.hw_revision |= pdev->revision < 2 ?
-					      ATOMISP_HW_STEPPING_A0 : ATOMISP_HW_STEPPING_B0;
+						      ATOMISP_HW_STEPPING_A0 :
+						      ATOMISP_HW_STEPPING_B0;
 		isp->dfs = &dfs_config_merr;
 		isp->hpll_freq = HPLL_FREQ_1600MHZ;
 		break;
 	case ATOMISP_PCI_DEVICE_SOC_CHT:
 		isp->media_dev.hw_revision = (ATOMISP_HW_REVISION_ISP2401
-						 << ATOMISP_HW_REVISION_SHIFT);
+					      << ATOMISP_HW_REVISION_SHIFT);
 		isp->media_dev.hw_revision |= pdev->revision < 2 ?
-					      ATOMISP_HW_STEPPING_A0 : ATOMISP_HW_STEPPING_B0;
+						      ATOMISP_HW_STEPPING_A0 :
+						      ATOMISP_HW_STEPPING_B0;
 
 		isp->dfs = &dfs_config_cht;
 		pdev->d3cold_delay = 0;
 
-		iosf_mbi_read(BT_MBI_UNIT_CCK, MBI_REG_READ, CCK_FUSE_REG_0, &val);
+		iosf_mbi_read(BT_MBI_UNIT_CCK, MBI_REG_READ, CCK_FUSE_REG_0,
+			      &val);
 		switch (val & CCK_FUSE_HPLL_FREQ_MASK) {
 		case 0x00:
 			isp->hpll_freq = HPLL_FREQ_800MHZ;
@@ -1306,7 +1333,9 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 			break;
 		default:
 			isp->hpll_freq = HPLL_FREQ_1600MHZ;
-			dev_warn(&pdev->dev, "read HPLL from cck failed. Default to 1600 MHz.\n");
+			dev_warn(
+				&pdev->dev,
+				"read HPLL from cck failed. Default to 1600 MHz.\n");
 		}
 		break;
 	default:
@@ -1315,11 +1344,13 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 	}
 
 	if (pdev->revision <= ATOMISP_PCI_REV_BYT_A0_MAX) {
-		dev_err(&pdev->dev, "revision %d is not supported\n", pdev->revision);
+		dev_err(&pdev->dev, "revision %d is not supported\n",
+			pdev->revision);
 		return -ENODEV;
 	}
 
-	dev_info(&pdev->dev, "ISP HPLL frequency base = %d MHz\n", isp->hpll_freq);
+	dev_info(&pdev->dev, "ISP HPLL frequency base = %d MHz\n",
+		 isp->hpll_freq);
 
 	isp->max_isr_latency = ATOMISP_MAX_ISR_LATENCY;
 
@@ -1327,7 +1358,8 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 	isp->firmware = atomisp_load_firmware(isp);
 	if (!isp->firmware) {
 		/* No firmware continue in pm-only mode for S0i3 support */
-		dev_info(&pdev->dev, "Continuing in power-management only mode\n");
+		dev_info(&pdev->dev,
+			 "Continuing in power-management only mode\n");
 		isp->pm_only = true;
 		atomisp_pm_init(isp);
 		return 0;
@@ -1341,13 +1373,15 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 
 	err = pcim_enable_device(pdev);
 	if (err) {
-		dev_err(&pdev->dev, "Failed to enable ISP PCI device (%d)\n", err);
+		dev_err(&pdev->dev, "Failed to enable ISP PCI device (%d)\n",
+			err);
 		goto error_release_firmware;
 	}
 
 	err = pcim_iomap_regions(pdev, BIT(ATOM_ISP_PCI_BAR), pci_name(pdev));
 	if (err) {
-		dev_err(&pdev->dev, "Failed to I/O memory remapping (%d)\n", err);
+		dev_err(&pdev->dev, "Failed to I/O memory remapping (%d)\n",
+			err);
 		goto error_release_firmware;
 	}
 
@@ -1380,14 +1414,22 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 		 * Workaround for imbalance data eye issue which is observed
 		 * on TNG B0.
 		 */
-		pci_read_config_dword(pdev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL, &val);
-		val &= ~((MRFLD_PCI_CSI_HSRXCLKTRIM_MASK << MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT) |
-			 (MRFLD_PCI_CSI_HSRXCLKTRIM_MASK << MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT) |
-			 (MRFLD_PCI_CSI_HSRXCLKTRIM_MASK << MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT));
-		val |= (MRFLD_PCI_CSI1_HSRXCLKTRIM << MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT) |
-		       (MRFLD_PCI_CSI2_HSRXCLKTRIM << MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT) |
-		       (MRFLD_PCI_CSI3_HSRXCLKTRIM << MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT);
-		pci_write_config_dword(pdev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL, val);
+		pci_read_config_dword(pdev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
+				      &val);
+		val &= ~((MRFLD_PCI_CSI_HSRXCLKTRIM_MASK
+			  << MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT) |
+			 (MRFLD_PCI_CSI_HSRXCLKTRIM_MASK
+			  << MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT) |
+			 (MRFLD_PCI_CSI_HSRXCLKTRIM_MASK
+			  << MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT));
+		val |= (MRFLD_PCI_CSI1_HSRXCLKTRIM
+			<< MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT) |
+		       (MRFLD_PCI_CSI2_HSRXCLKTRIM
+			<< MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT) |
+		       (MRFLD_PCI_CSI3_HSRXCLKTRIM
+			<< MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT);
+		pci_write_config_dword(pdev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
+				       val);
 		break;
 	default:
 		break;
@@ -1401,7 +1443,8 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 
 	err = atomisp_register_entities(isp);
 	if (err < 0) {
-		dev_err(&pdev->dev, "atomisp_register_entities failed (%d)\n", err);
+		dev_err(&pdev->dev, "atomisp_register_entities failed (%d)\n",
+			err);
 		goto error_uninitialize_modules;
 	}
 
@@ -1413,9 +1456,9 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 	/* Init ISP memory management */
 	hmm_init();
 
-	err = devm_request_threaded_irq(&pdev->dev, pdev->irq,
-					atomisp_isr, atomisp_isr_thread,
-					IRQF_SHARED, "isp_irq", isp);
+	err = devm_request_threaded_irq(&pdev->dev, pdev->irq, atomisp_isr,
+					atomisp_isr_thread, IRQF_SHARED,
+					"isp_irq", isp);
 	if (err) {
 		dev_err(&pdev->dev, "Failed to request irq (%d)\n", err);
 		goto error_unregister_entities;
@@ -1436,7 +1479,8 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 
 	err = v4l2_async_nf_register(&isp->notifier);
 	if (err) {
-		dev_err(isp->dev, "failed to register async notifier : %d\n", err);
+		dev_err(isp->dev, "failed to register async notifier : %d\n",
+			err);
 		goto error_unload_firmware;
 	}
 
@@ -1483,16 +1527,18 @@ static void atomisp_pci_remove(struct pci_dev *pdev)
 
 static const struct pci_device_id atomisp_pci_tbl[] = {
 	/* Merrifield */
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_MRFLD)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_MRFLD_1179)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_MRFLD_117A)},
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_MRFLD) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_MRFLD_1179) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_MRFLD_117A) },
 	/* Baytrail */
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_BYT)},
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_BYT) },
 	/* Anniedale (Merrifield+ / Moorefield) */
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_ANN)},
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_ANN) },
 	/* Cherrytrail */
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_CHT)},
-	{0,}
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, ATOMISP_PCI_DEVICE_SOC_CHT) },
+	{
+		0,
+	}
 };
 MODULE_DEVICE_TABLE(pci, atomisp_pci_tbl);
 
diff --git a/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf.h b/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf.h
index 86300991d30eb944f7ad62f1a2b2e0d96ed18c68..d1a710cce9ff6406f408cee62f94d14cf8640342 100644
--- a/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf.h
+++ b/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf.h
@@ -25,8 +25,9 @@
  */
 typedef struct ia_css_circbuf_s ia_css_circbuf_t;
 struct ia_css_circbuf_s {
-	ia_css_circbuf_desc_t *desc;    /* Pointer to the descriptor of the circbuf */
-	ia_css_circbuf_elem_t *elems;	/* an array of elements    */
+	ia_css_circbuf_desc_t
+		*desc; /* Pointer to the descriptor of the circbuf */
+	ia_css_circbuf_elem_t *elems; /* an array of elements    */
 };
 
 /**
@@ -36,18 +37,15 @@ struct ia_css_circbuf_s {
  * @param elems	An array of elements.
  * @param desc	The descriptor set to the size using ia_css_circbuf_desc_init().
  */
-void ia_css_circbuf_create(
-    ia_css_circbuf_t *cb,
-    ia_css_circbuf_elem_t *elems,
-    ia_css_circbuf_desc_t *desc);
+void ia_css_circbuf_create(ia_css_circbuf_t *cb, ia_css_circbuf_elem_t *elems,
+			   ia_css_circbuf_desc_t *desc);
 
 /**
  * @brief Destroy the circular buffer.
  *
  * @param cb The pointer to the circular buffer.
  */
-void ia_css_circbuf_destroy(
-    ia_css_circbuf_t *cb);
+void ia_css_circbuf_destroy(ia_css_circbuf_t *cb);
 
 /**
  * @brief Pop a value out of the circular buffer.
@@ -59,8 +57,7 @@ void ia_css_circbuf_destroy(
  *
  * @return the pop-out value.
  */
-uint32_t ia_css_circbuf_pop(
-    ia_css_circbuf_t *cb);
+uint32_t ia_css_circbuf_pop(ia_css_circbuf_t *cb);
 
 /**
  * @brief Extract a value out of the circular buffer.
@@ -73,9 +70,7 @@ uint32_t ia_css_circbuf_pop(
  *
  * @return the extracted value.
  */
-uint32_t ia_css_circbuf_extract(
-    ia_css_circbuf_t *cb,
-    int offset);
+uint32_t ia_css_circbuf_extract(ia_css_circbuf_t *cb, int offset);
 
 /****************************************************************
  *
@@ -88,9 +83,8 @@ uint32_t ia_css_circbuf_extract(
  * @param elem The pointer to the element.
  * @param val  The value to be set.
  */
-static inline void ia_css_circbuf_elem_set_val(
-    ia_css_circbuf_elem_t *elem,
-    uint32_t val)
+static inline void ia_css_circbuf_elem_set_val(ia_css_circbuf_elem_t *elem,
+					       uint32_t val)
 {
 	OP___assert(elem);
 
@@ -102,8 +96,7 @@ static inline void ia_css_circbuf_elem_set_val(
  *
  * @param elem The pointer to the element.
  */
-static inline void ia_css_circbuf_elem_init(
-    ia_css_circbuf_elem_t *elem)
+static inline void ia_css_circbuf_elem_init(ia_css_circbuf_elem_t *elem)
 {
 	OP___assert(elem);
 	ia_css_circbuf_elem_set_val(elem, 0);
@@ -115,9 +108,8 @@ static inline void ia_css_circbuf_elem_init(
  * @param src  The element as the copy source.
  * @param dest The element as the copy destination.
  */
-static inline void ia_css_circbuf_elem_cpy(
-    ia_css_circbuf_elem_t *src,
-    ia_css_circbuf_elem_t *dest)
+static inline void ia_css_circbuf_elem_cpy(ia_css_circbuf_elem_t *src,
+					   ia_css_circbuf_elem_t *dest)
 {
 	OP___assert(src);
 	OP___assert(dest);
@@ -134,10 +126,8 @@ static inline void ia_css_circbuf_elem_cpy(
  *
  * @return the position at offset.
  */
-static inline uint8_t ia_css_circbuf_get_pos_at_offset(
-    ia_css_circbuf_t *cb,
-    u32 base,
-    int offset)
+static inline uint8_t ia_css_circbuf_get_pos_at_offset(ia_css_circbuf_t *cb,
+						       u32 base, int offset)
 {
 	u8 dest;
 
@@ -167,10 +157,8 @@ static inline uint8_t ia_css_circbuf_get_pos_at_offset(
  *
  * @return the offset.
  */
-static inline int ia_css_circbuf_get_offset(
-    ia_css_circbuf_t *cb,
-    u32 src_pos,
-    uint32_t dest_pos)
+static inline int ia_css_circbuf_get_offset(ia_css_circbuf_t *cb, u32 src_pos,
+					    uint32_t dest_pos)
 {
 	int offset;
 
@@ -192,8 +180,7 @@ static inline int ia_css_circbuf_get_offset(
  *
  * TODO: Test this API.
  */
-static inline uint32_t ia_css_circbuf_get_size(
-    ia_css_circbuf_t *cb)
+static inline uint32_t ia_css_circbuf_get_size(ia_css_circbuf_t *cb)
 {
 	OP___assert(cb);
 	OP___assert(cb->desc);
@@ -208,8 +195,7 @@ static inline uint32_t ia_css_circbuf_get_size(
  *
  * @return the number of available elements.
  */
-static inline uint32_t ia_css_circbuf_get_num_elems(
-    ia_css_circbuf_t *cb)
+static inline uint32_t ia_css_circbuf_get_num_elems(ia_css_circbuf_t *cb)
 {
 	int num;
 
@@ -230,8 +216,7 @@ static inline uint32_t ia_css_circbuf_get_num_elems(
  *	- true when it is empty.
  *	- false when it is not empty.
  */
-static inline bool ia_css_circbuf_is_empty(
-    ia_css_circbuf_t *cb)
+static inline bool ia_css_circbuf_is_empty(ia_css_circbuf_t *cb)
 {
 	OP___assert(cb);
 	OP___assert(cb->desc);
@@ -265,9 +250,8 @@ static inline bool ia_css_circbuf_is_full(ia_css_circbuf_t *cb)
  * @param cb	The pointer to the circular buffer.
  * @param elem	The new element.
  */
-static inline void ia_css_circbuf_write(
-    ia_css_circbuf_t *cb,
-    ia_css_circbuf_elem_t elem)
+static inline void ia_css_circbuf_write(ia_css_circbuf_t *cb,
+					ia_css_circbuf_elem_t elem)
 {
 	OP___assert(cb);
 	OP___assert(cb->desc);
@@ -289,9 +273,7 @@ static inline void ia_css_circbuf_write(
  * @param cb	The pointer to the circular buffer.
  * @param val	The value to be pushed in.
  */
-static inline void ia_css_circbuf_push(
-    ia_css_circbuf_t *cb,
-    uint32_t val)
+static inline void ia_css_circbuf_push(ia_css_circbuf_t *cb, uint32_t val)
 {
 	ia_css_circbuf_elem_t elem;
 
@@ -312,8 +294,7 @@ static inline void ia_css_circbuf_push(
  *
  * @return: The number of free elements.
  */
-static inline uint32_t ia_css_circbuf_get_free_elems(
-    ia_css_circbuf_t *cb)
+static inline uint32_t ia_css_circbuf_get_free_elems(ia_css_circbuf_t *cb)
 {
 	OP___assert(cb);
 	OP___assert(cb->desc);
@@ -329,9 +310,7 @@ static inline uint32_t ia_css_circbuf_get_free_elems(
  *
  * @return the elements value.
  */
-uint32_t ia_css_circbuf_peek(
-    ia_css_circbuf_t *cb,
-    int offset);
+uint32_t ia_css_circbuf_peek(ia_css_circbuf_t *cb, int offset);
 
 /**
  * @brief Get an element in Circular Buffer.
@@ -341,9 +320,7 @@ uint32_t ia_css_circbuf_peek(
  *
  * @return the elements value.
  */
-uint32_t ia_css_circbuf_peek_from_start(
-    ia_css_circbuf_t *cb,
-    int offset);
+uint32_t ia_css_circbuf_peek_from_start(ia_css_circbuf_t *cb, int offset);
 
 /**
  * @brief Increase Size of a Circular Buffer.
@@ -360,9 +337,7 @@ uint32_t ia_css_circbuf_peek_from_start(
  * @return	true on successfully increasing the size
  *			false on failure
  */
-bool ia_css_circbuf_increase_size(
-    ia_css_circbuf_t *cb,
-    unsigned int sz_delta,
-    ia_css_circbuf_elem_t *elems);
+bool ia_css_circbuf_increase_size(ia_css_circbuf_t *cb, unsigned int sz_delta,
+				  ia_css_circbuf_elem_t *elems);
 
 #endif /*_IA_CSS_CIRCBUF_H */
diff --git a/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf_comm.h b/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf_comm.h
index 971e07f2acc5357cf14828d81f9c61c27e3f20a8..a1326dd3a3e5f05e57b98aa52c132b20ee6e23ee 100644
--- a/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf_comm.h
+++ b/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf_comm.h
@@ -9,9 +9,10 @@
 
 #include <linux/build_bug.h>
 
-#include <type_support.h>  /* uint8_t, uint32_t */
+#include <type_support.h> /* uint8_t, uint32_t */
 
-#define IA_CSS_CIRCBUF_PADDING 1 /* The circular buffer is implemented in lock-less manner, wherein
+#define IA_CSS_CIRCBUF_PADDING \
+	1 /* The circular buffer is implemented in lock-less manner, wherein
 				   * the head and tail can advance independently without any locks.
 				   * But to achieve this, an extra buffer element is required to detect
 				   * queue full & empty conditions, wherein the tail trails the head for
@@ -29,28 +30,28 @@
  */
 typedef struct ia_css_circbuf_desc_s ia_css_circbuf_desc_t;
 struct ia_css_circbuf_desc_s {
-	u8 size;	/* the maximum number of elements*/
-	u8 step;   /* number of bytes per element */
-	u8 start;	/* index of the oldest element */
-	u8 end;	/* index at which to write the new element */
+	u8 size; /* the maximum number of elements*/
+	u8 step; /* number of bytes per element */
+	u8 start; /* index of the oldest element */
+	u8 end; /* index at which to write the new element */
 };
 
-#define SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT				\
-	(4 * sizeof(uint8_t))
+#define SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT (4 * sizeof(uint8_t))
 
-static_assert(sizeof(struct ia_css_circbuf_desc_s) == SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT);
+static_assert(sizeof(struct ia_css_circbuf_desc_s) ==
+	      SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT);
 
 /**
  * @brief Data structure for the circular buffer element.
  */
 typedef struct ia_css_circbuf_elem_s ia_css_circbuf_elem_t;
 struct ia_css_circbuf_elem_s {
-	u32 val;	/* the value stored in the element */
+	u32 val; /* the value stored in the element */
 };
 
-#define SIZE_OF_IA_CSS_CIRCBUF_ELEM_S_STRUCT				\
-	(sizeof(uint32_t))
+#define SIZE_OF_IA_CSS_CIRCBUF_ELEM_S_STRUCT (sizeof(uint32_t))
 
-static_assert(sizeof(struct ia_css_circbuf_elem_s) == SIZE_OF_IA_CSS_CIRCBUF_ELEM_S_STRUCT);
+static_assert(sizeof(struct ia_css_circbuf_elem_s) ==
+	      SIZE_OF_IA_CSS_CIRCBUF_ELEM_S_STRUCT);
 
 #endif /*_IA_CSS_CIRCBUF_COMM_H*/
diff --git a/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf_desc.h b/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf_desc.h
index 5645a7bf493cc48e4ea972a2ca7f3bcf462424db..960315723ca280ed1f0ae9c545b7ee00b68b5099 100644
--- a/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf_desc.h
+++ b/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf_desc.h
@@ -26,8 +26,7 @@
  *	- true when it is empty.
  *	- false when it is not empty.
  */
-static inline bool ia_css_circbuf_desc_is_empty(
-    ia_css_circbuf_desc_t *cb_desc)
+static inline bool ia_css_circbuf_desc_is_empty(ia_css_circbuf_desc_t *cb_desc)
 {
 	OP___assert(cb_desc);
 	return (cb_desc->end == cb_desc->start);
@@ -43,11 +42,11 @@ static inline bool ia_css_circbuf_desc_is_empty(
  *	- true when it is full.
  *	- false when it is not full.
  */
-static inline bool ia_css_circbuf_desc_is_full(
-    ia_css_circbuf_desc_t *cb_desc)
+static inline bool ia_css_circbuf_desc_is_full(ia_css_circbuf_desc_t *cb_desc)
 {
 	OP___assert(cb_desc);
-	return (OP_std_modadd(cb_desc->end, 1, cb_desc->size) == cb_desc->start);
+	return (OP_std_modadd(cb_desc->end, 1, cb_desc->size) ==
+		cb_desc->start);
 }
 
 /**
@@ -56,9 +55,8 @@ static inline bool ia_css_circbuf_desc_is_full(
  * @param cb_desc	The pointer circular buffer descriptor
  * @param size		The size of the circular buffer
  */
-static inline void ia_css_circbuf_desc_init(
-    ia_css_circbuf_desc_t *cb_desc,
-    int8_t size)
+static inline void ia_css_circbuf_desc_init(ia_css_circbuf_desc_t *cb_desc,
+					    int8_t size)
 {
 	OP___assert(cb_desc);
 	cb_desc->size = size;
@@ -73,10 +71,9 @@ static inline void ia_css_circbuf_desc_init(
  *
  * @return the position in the circular buffer descriptor.
  */
-static inline uint8_t ia_css_circbuf_desc_get_pos_at_offset(
-    ia_css_circbuf_desc_t *cb_desc,
-    u32 base,
-    int offset)
+static inline uint8_t
+ia_css_circbuf_desc_get_pos_at_offset(ia_css_circbuf_desc_t *cb_desc, u32 base,
+				      int offset)
 {
 	u8 dest;
 
@@ -106,10 +103,8 @@ static inline uint8_t ia_css_circbuf_desc_get_pos_at_offset(
  *
  * @return the offset.
  */
-static inline int ia_css_circbuf_desc_get_offset(
-    ia_css_circbuf_desc_t *cb_desc,
-    u32 src_pos,
-    uint32_t dest_pos)
+static inline int ia_css_circbuf_desc_get_offset(ia_css_circbuf_desc_t *cb_desc,
+						 u32 src_pos, uint32_t dest_pos)
 {
 	int offset;
 
@@ -128,15 +123,14 @@ static inline int ia_css_circbuf_desc_get_offset(
  *
  * @return The number of available elements.
  */
-static inline uint32_t ia_css_circbuf_desc_get_num_elems(
-    ia_css_circbuf_desc_t *cb_desc)
+static inline uint32_t
+ia_css_circbuf_desc_get_num_elems(ia_css_circbuf_desc_t *cb_desc)
 {
 	int num;
 
 	OP___assert(cb_desc);
 
-	num = ia_css_circbuf_desc_get_offset(cb_desc,
-					     cb_desc->start,
+	num = ia_css_circbuf_desc_get_offset(cb_desc, cb_desc->start,
 					     cb_desc->end);
 
 	return (uint32_t)num;
@@ -149,15 +143,14 @@ static inline uint32_t ia_css_circbuf_desc_get_num_elems(
  *
  * @return: The number of free elements.
  */
-static inline uint32_t ia_css_circbuf_desc_get_free_elems(
-    ia_css_circbuf_desc_t *cb_desc)
+static inline uint32_t
+ia_css_circbuf_desc_get_free_elems(ia_css_circbuf_desc_t *cb_desc)
 {
 	u32 num;
 
 	OP___assert(cb_desc);
 
-	num = ia_css_circbuf_desc_get_offset(cb_desc,
-					     cb_desc->start,
+	num = ia_css_circbuf_desc_get_offset(cb_desc, cb_desc->start,
 					     cb_desc->end);
 
 	return (cb_desc->size - num);
diff --git a/drivers/staging/media/atomisp/pci/base/circbuf/src/circbuf.c b/drivers/staging/media/atomisp/pci/base/circbuf/src/circbuf.c
index cb34d0b5abb5ef0e89a6dc8b28e34c7b71e43426..7671bad90345f25ee8844980be6d2a39484d170d 100644
--- a/drivers/staging/media/atomisp/pci/base/circbuf/src/circbuf.c
+++ b/drivers/staging/media/atomisp/pci/base/circbuf/src/circbuf.c
@@ -23,8 +23,7 @@
  *
  * @return the oldest element.
  */
-static inline ia_css_circbuf_elem_t
-ia_css_circbuf_read(ia_css_circbuf_t *cb);
+static inline ia_css_circbuf_elem_t ia_css_circbuf_read(ia_css_circbuf_t *cb);
 
 /*
  * @brief Shift a chunk of elements in the circular buffer.
@@ -37,8 +36,8 @@ ia_css_circbuf_read(ia_css_circbuf_t *cb);
  * @param chunk_dest The position to which the first element in the chunk would be shift.
  */
 static inline void ia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,
-	u32 chunk_src,
-	uint32_t chunk_dest);
+					      u32 chunk_src,
+					      uint32_t chunk_dest);
 
 /*
  * @brief Get the "val" field in the element.
@@ -47,8 +46,7 @@ static inline void ia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,
  *
  * @return the "val" field.
  */
-static inline uint32_t
-ia_css_circbuf_elem_get_val(ia_css_circbuf_elem_t *elem);
+static inline uint32_t ia_css_circbuf_elem_get_val(ia_css_circbuf_elem_t *elem);
 
 /**********************************************************************
  *
@@ -59,10 +57,8 @@ ia_css_circbuf_elem_get_val(ia_css_circbuf_elem_t *elem);
  * @brief Create the circular buffer.
  * Refer to "ia_css_circbuf.h" for details.
  */
-void
-ia_css_circbuf_create(ia_css_circbuf_t *cb,
-		      ia_css_circbuf_elem_t *elems,
-		      ia_css_circbuf_desc_t *desc)
+void ia_css_circbuf_create(ia_css_circbuf_t *cb, ia_css_circbuf_elem_t *elems,
+			   ia_css_circbuf_desc_t *desc)
 {
 	u32 i;
 
@@ -121,7 +117,8 @@ uint32_t ia_css_circbuf_extract(ia_css_circbuf_t *cb, int offset)
 	u32 dest_pos;
 
 	/* get the maximum offset */
-	max_offset = ia_css_circbuf_get_offset(cb, cb->desc->start, cb->desc->end);
+	max_offset =
+		ia_css_circbuf_get_offset(cb, cb->desc->start, cb->desc->end);
 	max_offset--;
 
 	/*
@@ -191,10 +188,8 @@ uint32_t ia_css_circbuf_peek_from_start(ia_css_circbuf_t *cb, int offset)
  * support / fix issue with increasing size for tagger only
  * Please refer to "ia_css_circbuf.h" for details.
  */
-bool ia_css_circbuf_increase_size(
-    ia_css_circbuf_t *cb,
-    unsigned int sz_delta,
-    ia_css_circbuf_elem_t *elems)
+bool ia_css_circbuf_increase_size(ia_css_circbuf_t *cb, unsigned int sz_delta,
+				  ia_css_circbuf_elem_t *elems)
 {
 	u8 curr_size;
 	u8 curr_end;
@@ -221,7 +216,7 @@ bool ia_css_circbuf_increase_size(
 		 * but pointers to new elements can be added at the end
 		 * of existing pre defined cb element array of
 		 * size >= new size if not already added */
-		for (i = curr_size; i <  cb->desc->size; i++)
+		for (i = curr_size; i < cb->desc->size; i++)
 			cb->elems[i] = elems[i - curr_size];
 	}
 	/* Fix Start / End */
@@ -231,8 +226,7 @@ bool ia_css_circbuf_increase_size(
 			cb->desc->end = curr_size;
 		} else {
 			/* Move elements and fix Start*/
-			ia_css_circbuf_shift_chunk(cb,
-						   curr_size - 1,
+			ia_css_circbuf_shift_chunk(cb, curr_size - 1,
 						   curr_size + sz_delta - 1);
 		}
 	}
@@ -249,8 +243,7 @@ bool ia_css_circbuf_increase_size(
  * @brief Get the "val" field in the element.
  * Refer to "Forward declarations" for details.
  */
-static inline uint32_t
-ia_css_circbuf_elem_get_val(ia_css_circbuf_elem_t *elem)
+static inline uint32_t ia_css_circbuf_elem_get_val(ia_css_circbuf_elem_t *elem)
 {
 	return elem->val;
 }
@@ -259,8 +252,7 @@ ia_css_circbuf_elem_get_val(ia_css_circbuf_elem_t *elem)
  * @brief Read the oldest element from the circular buffer.
  * Refer to "Forward declarations" for details.
  */
-static inline ia_css_circbuf_elem_t
-ia_css_circbuf_read(ia_css_circbuf_t *cb)
+static inline ia_css_circbuf_elem_t ia_css_circbuf_read(ia_css_circbuf_t *cb)
 {
 	ia_css_circbuf_elem_t elem;
 
@@ -271,7 +263,8 @@ ia_css_circbuf_read(ia_css_circbuf_t *cb)
 	ia_css_circbuf_elem_init(&cb->elems[cb->desc->start]);
 
 	/* adjust the "start" position */
-	cb->desc->start = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->start, 1);
+	cb->desc->start =
+		ia_css_circbuf_get_pos_at_offset(cb, cb->desc->start, 1);
 	return elem;
 }
 
@@ -279,18 +272,18 @@ ia_css_circbuf_read(ia_css_circbuf_t *cb)
  * @brief Shift a chunk of elements in the circular buffer.
  * Refer to "Forward declarations" for details.
  */
-static inline void
-ia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,
-			   u32 chunk_src, uint32_t chunk_dest)
+static inline void ia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,
+					      u32 chunk_src,
+					      uint32_t chunk_dest)
 {
 	int chunk_offset;
 	int chunk_sz;
 	int i;
 
 	/* get the chunk offset and size */
-	chunk_offset = ia_css_circbuf_get_offset(cb,
-		       chunk_src, chunk_dest);
-	chunk_sz = ia_css_circbuf_get_offset(cb, cb->desc->start, chunk_src) + 1;
+	chunk_offset = ia_css_circbuf_get_offset(cb, chunk_src, chunk_dest);
+	chunk_sz =
+		ia_css_circbuf_get_offset(cb, cb->desc->start, chunk_src) + 1;
 
 	/* shift each element to its terminal position */
 	for (i = 0; i < chunk_sz; i++) {
@@ -303,10 +296,11 @@ ia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,
 
 		/* adjust the source/terminal positions */
 		chunk_src = ia_css_circbuf_get_pos_at_offset(cb, chunk_src, -1);
-		chunk_dest = ia_css_circbuf_get_pos_at_offset(cb, chunk_dest, -1);
+		chunk_dest =
+			ia_css_circbuf_get_pos_at_offset(cb, chunk_dest, -1);
 	}
 
 	/* adjust the index "start" */
 	cb->desc->start = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->start,
-			  chunk_offset);
+							   chunk_offset);
 }
diff --git a/drivers/staging/media/atomisp/pci/base/refcount/interface/ia_css_refcount.h b/drivers/staging/media/atomisp/pci/base/refcount/interface/ia_css_refcount.h
index d78859e3a5b02e70d6db2d21f4c850d64349924e..9b788877113868bd51bb96c8dc25260f979b344c 100644
--- a/drivers/staging/media/atomisp/pci/base/refcount/interface/ia_css_refcount.h
+++ b/drivers/staging/media/atomisp/pci/base/refcount/interface/ia_css_refcount.h
@@ -61,8 +61,7 @@ bool ia_css_refcount_is_single(ia_css_ptr ptr);
  *
  *  return				None
  */
-void ia_css_refcount_clear(s32 id,
-			   clear_func clear_func_ptr);
+void ia_css_refcount_clear(s32 id, clear_func clear_func_ptr);
 
 /*! \brief Function to verify if object is valid
  *
diff --git a/drivers/staging/media/atomisp/pci/base/refcount/src/refcount.c b/drivers/staging/media/atomisp/pci/base/refcount/src/refcount.c
index 58e4e3173b405ee62be569d6859afdb58f72545e..0746a1324377473c77e6c0076643d9a9e1a79615 100644
--- a/drivers/staging/media/atomisp/pci/base/refcount/src/refcount.c
+++ b/drivers/staging/media/atomisp/pci/base/refcount/src/refcount.c
@@ -31,7 +31,7 @@ struct ia_css_refcount_list {
 static struct ia_css_refcount_list myrefcount;
 
 static struct ia_css_refcount_entry *refcount_find_entry(ia_css_ptr ptr,
-	bool firstfree)
+							 bool firstfree)
 {
 	u32 i;
 
@@ -39,7 +39,8 @@ static struct ia_css_refcount_entry *refcount_find_entry(ia_css_ptr ptr,
 		return NULL;
 	if (!myrefcount.items) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
-				    "%s(): Ref count not initialized!\n", __func__);
+				    "%s(): Ref count not initialized!\n",
+				    __func__);
 		return NULL;
 	}
 
@@ -64,16 +65,18 @@ int ia_css_refcount_init(uint32_t size)
 
 	if (size == 0) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "%s(): Size of 0 for Ref count init!\n", __func__);
+				    "%s(): Size of 0 for Ref count init!\n",
+				    __func__);
 		return -EINVAL;
 	}
 	if (myrefcount.items) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "%s(): Ref count is already initialized\n", __func__);
+				    "%s(): Ref count is already initialized\n",
+				    __func__);
 		return -EINVAL;
 	}
-	myrefcount.items =
-	    kvmalloc(sizeof(struct ia_css_refcount_entry) * size, GFP_KERNEL);
+	myrefcount.items = kvmalloc(sizeof(struct ia_css_refcount_entry) * size,
+				    GFP_KERNEL);
 	if (!myrefcount.items)
 		err = -ENOMEM;
 	if (!err) {
@@ -89,8 +92,7 @@ void ia_css_refcount_uninit(void)
 	struct ia_css_refcount_entry *entry;
 	u32 i;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "%s() entry\n", __func__);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s() entry\n", __func__);
 	for (i = 0; i < myrefcount.size; i++) {
 		/* driver verifier tool has issues with &arr[i]
 		   and prefers arr + i; as these are actually equivalent
@@ -110,8 +112,7 @@ void ia_css_refcount_uninit(void)
 	kvfree(myrefcount.items);
 	myrefcount.items = NULL;
 	myrefcount.size = 0;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "%s() leave\n", __func__);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s() leave\n", __func__);
 }
 
 ia_css_ptr ia_css_refcount_increment(s32 id, ia_css_ptr ptr)
@@ -123,8 +124,8 @@ ia_css_ptr ia_css_refcount_increment(s32 id, ia_css_ptr ptr)
 
 	entry = refcount_find_entry(ptr, false);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "%s(%x) 0x%x\n", __func__, id, ptr);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s(%x) 0x%x\n", __func__, id,
+			    ptr);
 
 	if (!entry) {
 		entry = refcount_find_entry(ptr, true);
@@ -136,7 +137,8 @@ ia_css_ptr ia_css_refcount_increment(s32 id, ia_css_ptr ptr)
 
 	if (entry->id != id) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
-				    "%s(): Ref count IDS do not match!\n", __func__);
+				    "%s(): Ref count IDS do not match!\n",
+				    __func__);
 		return mmgr_NULL;
 	}
 
@@ -155,8 +157,8 @@ bool ia_css_refcount_decrement(s32 id, ia_css_ptr ptr)
 {
 	struct ia_css_refcount_entry *entry;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "%s(%x) 0x%x\n", __func__, id, ptr);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s(%x) 0x%x\n", __func__, id,
+			    ptr);
 
 	if (ptr == mmgr_NULL)
 		return false;
@@ -165,8 +167,10 @@ bool ia_css_refcount_decrement(s32 id, ia_css_ptr ptr)
 
 	if (entry) {
 		if (entry->id != id) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
-					    "%s(): Ref count IDS do not match!\n", __func__);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_ERROR,
+				"%s(): Ref count IDS do not match!\n",
+				__func__);
 			return false;
 		}
 		if (entry->count > 0) {
@@ -185,8 +189,9 @@ bool ia_css_refcount_decrement(s32 id, ia_css_ptr ptr)
 	/* SHOULD NOT HAPPEN: ptr not managed by refcount, or not
 	   valid anymore */
 	if (entry)
-		IA_CSS_ERROR("id %x, ptr 0x%x entry %p entry->id %x entry->count %d\n",
-			     id, ptr, entry, entry->id, entry->count);
+		IA_CSS_ERROR(
+			"id %x, ptr 0x%x entry %p entry->id %x entry->count %d\n",
+			id, ptr, entry, entry->id, entry->count);
 	else
 		IA_CSS_ERROR("entry NULL\n");
 	assert(false);
@@ -216,8 +221,7 @@ void ia_css_refcount_clear(s32 id, clear_func clear_func_ptr)
 	u32 count = 0;
 
 	assert(clear_func_ptr);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s(%x)\n",
-			    __func__, id);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s(%x)\n", __func__, id);
 
 	for (i = 0; i < myrefcount.size; i++) {
 		/* driver verifier tool has issues with &arr[i]
@@ -227,19 +231,23 @@ void ia_css_refcount_clear(s32 id, clear_func clear_func_ptr)
 		entry = myrefcount.items + i;
 		if ((entry->data != mmgr_NULL) && (entry->id == id)) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-					    "%s: %x: 0x%x\n", __func__,
-					    id, entry->data);
+					    "%s: %x: 0x%x\n", __func__, id,
+					    entry->data);
 			if (clear_func_ptr) {
 				/* clear using provided function */
 				clear_func_ptr(entry->data);
 			} else {
-				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-						    "%s: using hmm_free: no clear_func\n", __func__);
+				ia_css_debug_dtrace(
+					IA_CSS_DEBUG_TRACE,
+					"%s: using hmm_free: no clear_func\n",
+					__func__);
 				hmm_free(entry->data);
 			}
 
 			if (entry->count != 0) {
-				IA_CSS_WARNING("Ref count for entry %x is not zero!", entry->id);
+				IA_CSS_WARNING(
+					"Ref count for entry %x is not zero!",
+					entry->id);
 			}
 
 			assert(entry->count == 0);
@@ -250,9 +258,8 @@ void ia_css_refcount_clear(s32 id, clear_func clear_func_ptr)
 			count++;
 		}
 	}
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "%s(%x): cleared %d\n", __func__, id,
-			    count);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s(%x): cleared %d\n",
+			    __func__, id, count);
 }
 
 bool ia_css_refcount_is_valid(ia_css_ptr ptr)
diff --git a/drivers/staging/media/atomisp/pci/bits.h b/drivers/staging/media/atomisp/pci/bits.h
index ebd9393d910fbf64598f559eb3ac622bdc62cf4f..0d7a6c05dcadf46483d5768dd094aa83d13b18e2 100644
--- a/drivers/staging/media/atomisp/pci/bits.h
+++ b/drivers/staging/media/atomisp/pci/bits.h
@@ -9,23 +9,23 @@
 
 #include <linux/args.h>
 
-#define _hrt_ones(n)	CONCATENATE(_hrt_ones_, n)
-#define _hrt_ones_0x0  0x00000000U
-#define _hrt_ones_0x1  0x00000001U
-#define _hrt_ones_0x2  0x00000003U
-#define _hrt_ones_0x3  0x00000007U
-#define _hrt_ones_0x4  0x0000000FU
-#define _hrt_ones_0x5  0x0000001FU
-#define _hrt_ones_0x6  0x0000003FU
-#define _hrt_ones_0x7  0x0000007FU
-#define _hrt_ones_0x8  0x000000FFU
-#define _hrt_ones_0x9  0x000001FFU
-#define _hrt_ones_0xA  0x000003FFU
-#define _hrt_ones_0xB  0x000007FFU
-#define _hrt_ones_0xC  0x00000FFFU
-#define _hrt_ones_0xD  0x00001FFFU
-#define _hrt_ones_0xE  0x00003FFFU
-#define _hrt_ones_0xF  0x00007FFFU
+#define _hrt_ones(n) CONCATENATE(_hrt_ones_, n)
+#define _hrt_ones_0x0 0x00000000U
+#define _hrt_ones_0x1 0x00000001U
+#define _hrt_ones_0x2 0x00000003U
+#define _hrt_ones_0x3 0x00000007U
+#define _hrt_ones_0x4 0x0000000FU
+#define _hrt_ones_0x5 0x0000001FU
+#define _hrt_ones_0x6 0x0000003FU
+#define _hrt_ones_0x7 0x0000007FU
+#define _hrt_ones_0x8 0x000000FFU
+#define _hrt_ones_0x9 0x000001FFU
+#define _hrt_ones_0xA 0x000003FFU
+#define _hrt_ones_0xB 0x000007FFU
+#define _hrt_ones_0xC 0x00000FFFU
+#define _hrt_ones_0xD 0x00001FFFU
+#define _hrt_ones_0xE 0x00003FFFU
+#define _hrt_ones_0xF 0x00007FFFU
 #define _hrt_ones_0x10 0x0000FFFFU
 #define _hrt_ones_0x11 0x0001FFFFU
 #define _hrt_ones_0x12 0x0003FFFFU
@@ -44,16 +44,16 @@
 #define _hrt_ones_0x1F 0x7FFFFFFFU
 #define _hrt_ones_0x20 0xFFFFFFFFU
 
-#define _hrt_ones_0  _hrt_ones_0x0
-#define _hrt_ones_1  _hrt_ones_0x1
-#define _hrt_ones_2  _hrt_ones_0x2
-#define _hrt_ones_3  _hrt_ones_0x3
-#define _hrt_ones_4  _hrt_ones_0x4
-#define _hrt_ones_5  _hrt_ones_0x5
-#define _hrt_ones_6  _hrt_ones_0x6
-#define _hrt_ones_7  _hrt_ones_0x7
-#define _hrt_ones_8  _hrt_ones_0x8
-#define _hrt_ones_9  _hrt_ones_0x9
+#define _hrt_ones_0 _hrt_ones_0x0
+#define _hrt_ones_1 _hrt_ones_0x1
+#define _hrt_ones_2 _hrt_ones_0x2
+#define _hrt_ones_3 _hrt_ones_0x3
+#define _hrt_ones_4 _hrt_ones_0x4
+#define _hrt_ones_5 _hrt_ones_0x5
+#define _hrt_ones_6 _hrt_ones_0x6
+#define _hrt_ones_7 _hrt_ones_0x7
+#define _hrt_ones_8 _hrt_ones_0x8
+#define _hrt_ones_9 _hrt_ones_0x9
 #define _hrt_ones_10 _hrt_ones_0xA
 #define _hrt_ones_11 _hrt_ones_0xB
 #define _hrt_ones_12 _hrt_ones_0xC
@@ -78,19 +78,13 @@
 #define _hrt_ones_31 _hrt_ones_0x1F
 #define _hrt_ones_32 _hrt_ones_0x20
 
-#define _hrt_mask(b, n) \
-  (_hrt_ones(n) << (b))
-#define _hrt_get_bits(w, b, n) \
-  (((w) >> (b)) & _hrt_ones(n))
+#define _hrt_mask(b, n) (_hrt_ones(n) << (b))
+#define _hrt_get_bits(w, b, n) (((w) >> (b)) & _hrt_ones(n))
 #define _hrt_set_bits(w, b, n, v) \
-  (((w) & ~_hrt_mask(b, n)) | (((v) & _hrt_ones(n)) << (b)))
-#define _hrt_get_bit(w, b) \
-  (((w) >> (b)) & 1)
-#define _hrt_set_bit(w, b, v) \
-  (((w) & (~(1 << (b)))) | (((v) & 1) << (b)))
-#define _hrt_set_lower_half(w, v) \
-  _hrt_set_bits(w, 0, 16, v)
-#define _hrt_set_upper_half(w, v) \
-  _hrt_set_bits(w, 16, 16, v)
+	(((w) & ~_hrt_mask(b, n)) | (((v)&_hrt_ones(n)) << (b)))
+#define _hrt_get_bit(w, b) (((w) >> (b)) & 1)
+#define _hrt_set_bit(w, b, v) (((w) & (~(1 << (b)))) | (((v)&1) << (b)))
+#define _hrt_set_lower_half(w, v) _hrt_set_bits(w, 0, 16, v)
+#define _hrt_set_upper_half(w, v) _hrt_set_bits(w, 16, 16, v)
 
 #endif /* _HRT_BITS_H */
diff --git a/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_binarydesc.h b/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_binarydesc.h
index 4e687f318c0e199f26e0cf88096a67508228e448..8e60ac1ebe7188ab076f604920a3aabf92a8f705 100644
--- a/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_binarydesc.h
+++ b/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_binarydesc.h
@@ -9,9 +9,9 @@
 
 #include <linux/math.h>
 
-#include <ia_css_types.h>		/* ia_css_pipe */
-#include <ia_css_frame_public.h>	/* ia_css_frame_info */
-#include <ia_css_binary.h>		/* ia_css_binary_descr */
+#include <ia_css_types.h> /* ia_css_pipe */
+#include <ia_css_frame_public.h> /* ia_css_frame_info */
+#include <ia_css_binary.h> /* ia_css_binary_descr */
 
 /* @brief Get a binary descriptor for copy.
  *
@@ -23,12 +23,11 @@
  * @return    None
  *
  */
-void ia_css_pipe_get_copy_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *copy_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info);
+void ia_css_pipe_get_copy_binarydesc(struct ia_css_pipe const *const pipe,
+				     struct ia_css_binary_descr *copy_descr,
+				     struct ia_css_frame_info *in_info,
+				     struct ia_css_frame_info *out_info,
+				     struct ia_css_frame_info *vf_info);
 
 /* @brief Get a binary descriptor for vfpp.
  *
@@ -39,11 +38,10 @@ void ia_css_pipe_get_copy_binarydesc(
  * @return    None
  *
  */
-void ia_css_pipe_get_vfpp_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *vf_pp_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info);
+void ia_css_pipe_get_vfpp_binarydesc(struct ia_css_pipe const *const pipe,
+				     struct ia_css_binary_descr *vf_pp_descr,
+				     struct ia_css_frame_info *in_info,
+				     struct ia_css_frame_info *out_info);
 
 /* @brief Get numerator and denominator of bayer downscaling factor.
  *
@@ -67,13 +65,12 @@ int sh_css_bds_factor_get_fract(unsigned int bds_factor, struct u32_fract *bds);
  * @return	0 or error code upon error.
  *
  */
-int ia_css_pipe_get_preview_binarydesc(
-    struct ia_css_pipe *const pipe,
-    struct ia_css_binary_descr *preview_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *bds_out_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info);
+int ia_css_pipe_get_preview_binarydesc(struct ia_css_pipe *const pipe,
+				       struct ia_css_binary_descr *preview_descr,
+				       struct ia_css_frame_info *in_info,
+				       struct ia_css_frame_info *bds_out_info,
+				       struct ia_css_frame_info *out_info,
+				       struct ia_css_frame_info *vf_info);
 
 /* @brief Get a binary descriptor for video stage.
  *
@@ -85,14 +82,13 @@ int ia_css_pipe_get_preview_binarydesc(
  * @return	0 or error code upon error.
  *
  */
-int ia_css_pipe_get_video_binarydesc(
-    struct ia_css_pipe *const pipe,
-    struct ia_css_binary_descr *video_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *bds_out_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info,
-    int stream_config_left_padding);
+int ia_css_pipe_get_video_binarydesc(struct ia_css_pipe *const pipe,
+				     struct ia_css_binary_descr *video_descr,
+				     struct ia_css_frame_info *in_info,
+				     struct ia_css_frame_info *bds_out_info,
+				     struct ia_css_frame_info *out_info,
+				     struct ia_css_frame_info *vf_info,
+				     int stream_config_left_padding);
 
 /* @brief Get a binary descriptor for yuv scaler stage.
  *
@@ -106,12 +102,11 @@ int ia_css_pipe_get_video_binarydesc(
  *
  */
 void ia_css_pipe_get_yuvscaler_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *yuv_scaler_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *internal_out_info,
-    struct ia_css_frame_info *vf_info);
+	struct ia_css_pipe const *const pipe,
+	struct ia_css_binary_descr *yuv_scaler_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *internal_out_info,
+	struct ia_css_frame_info *vf_info);
 
 /* @brief Get a binary descriptor for capture pp stage.
  *
@@ -123,11 +118,10 @@ void ia_css_pipe_get_yuvscaler_binarydesc(
  *
  */
 void ia_css_pipe_get_capturepp_binarydesc(
-    struct ia_css_pipe *const pipe,
-    struct ia_css_binary_descr *capture_pp_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info);
+	struct ia_css_pipe *const pipe,
+	struct ia_css_binary_descr *capture_pp_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info);
 
 /* @brief Get a binary descriptor for primary capture.
  *
@@ -139,13 +133,12 @@ void ia_css_pipe_get_capturepp_binarydesc(
  * @return    None
  *
  */
-void ia_css_pipe_get_primary_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *prim_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info,
-    unsigned int stage_idx);
+void ia_css_pipe_get_primary_binarydesc(struct ia_css_pipe const *const pipe,
+					struct ia_css_binary_descr *prim_descr,
+					struct ia_css_frame_info *in_info,
+					struct ia_css_frame_info *out_info,
+					struct ia_css_frame_info *vf_info,
+					unsigned int stage_idx);
 
 /* @brief Get a binary descriptor for pre gdc stage.
  *
@@ -156,11 +149,10 @@ void ia_css_pipe_get_primary_binarydesc(
  * @return    None
  *
  */
-void ia_css_pipe_get_pre_gdc_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *gdc_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info);
+void ia_css_pipe_get_pre_gdc_binarydesc(struct ia_css_pipe const *const pipe,
+					struct ia_css_binary_descr *gdc_descr,
+					struct ia_css_frame_info *in_info,
+					struct ia_css_frame_info *out_info);
 
 /* @brief Get a binary descriptor for gdc stage.
  *
@@ -171,11 +163,10 @@ void ia_css_pipe_get_pre_gdc_binarydesc(
  * @return    None
  *
  */
-void ia_css_pipe_get_gdc_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *gdc_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info);
+void ia_css_pipe_get_gdc_binarydesc(struct ia_css_pipe const *const pipe,
+				    struct ia_css_binary_descr *gdc_descr,
+				    struct ia_css_frame_info *in_info,
+				    struct ia_css_frame_info *out_info);
 
 /* @brief Get a binary descriptor for post gdc.
  *
@@ -188,11 +179,10 @@ void ia_css_pipe_get_gdc_binarydesc(
  *
  */
 void ia_css_pipe_get_post_gdc_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *post_gdc_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info);
+	struct ia_css_pipe const *const pipe,
+	struct ia_css_binary_descr *post_gdc_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info);
 
 /* @brief Get a binary descriptor for de.
  *
@@ -203,11 +193,10 @@ void ia_css_pipe_get_post_gdc_binarydesc(
  * @return    None
  *
  */
-void ia_css_pipe_get_pre_de_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *pre_de_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info);
+void ia_css_pipe_get_pre_de_binarydesc(struct ia_css_pipe const *const pipe,
+				       struct ia_css_binary_descr *pre_de_descr,
+				       struct ia_css_frame_info *in_info,
+				       struct ia_css_frame_info *out_info);
 
 /* @brief Get a binary descriptor for pre anr stage.
  *
@@ -219,10 +208,9 @@ void ia_css_pipe_get_pre_de_binarydesc(
  *
  */
 void ia_css_pipe_get_pre_anr_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *pre_anr_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info);
+	struct ia_css_pipe const *const pipe,
+	struct ia_css_binary_descr *pre_anr_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info);
 
 /* @brief Get a binary descriptor for ANR stage.
  *
@@ -233,11 +221,10 @@ void ia_css_pipe_get_pre_anr_binarydesc(
  * @return    None
  *
  */
-void ia_css_pipe_get_anr_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *anr_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info);
+void ia_css_pipe_get_anr_binarydesc(struct ia_css_pipe const *const pipe,
+				    struct ia_css_binary_descr *anr_descr,
+				    struct ia_css_frame_info *in_info,
+				    struct ia_css_frame_info *out_info);
 
 /* @brief Get a binary descriptor for post anr stage.
  *
@@ -250,11 +237,10 @@ void ia_css_pipe_get_anr_binarydesc(
  *
  */
 void ia_css_pipe_get_post_anr_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *post_anr_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info);
+	struct ia_css_pipe const *const pipe,
+	struct ia_css_binary_descr *post_anr_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info);
 
 /* @brief Get a binary descriptor for ldc stage.
  *
@@ -265,11 +251,10 @@ void ia_css_pipe_get_post_anr_binarydesc(
  * @return    None
  *
  */
-void ia_css_pipe_get_ldc_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *ldc_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info);
+void ia_css_pipe_get_ldc_binarydesc(struct ia_css_pipe const *const pipe,
+				    struct ia_css_binary_descr *ldc_descr,
+				    struct ia_css_frame_info *in_info,
+				    struct ia_css_frame_info *out_info);
 
 /* @brief Calculates the required BDS factor
  *
@@ -278,9 +263,8 @@ void ia_css_pipe_get_ldc_binarydesc(
  * @param[in/out] bds_factor
  * @return	0 or error code upon error.
  */
-int binarydesc_calculate_bds_factor(
-    struct ia_css_resolution input_res,
-    struct ia_css_resolution output_res,
-    unsigned int *bds_factor);
+int binarydesc_calculate_bds_factor(struct ia_css_resolution input_res,
+				    struct ia_css_resolution output_res,
+				    unsigned int *bds_factor);
 
 #endif /* __IA_CSS_PIPE_BINARYDESC_H__ */
diff --git a/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_stagedesc.h b/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_stagedesc.h
index 61d1bf66fbd64e15dff47a74f322dcd484618e62..00c6aaa8ff14845b5f1e95af31dc852b83f2dba8 100644
--- a/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_stagedesc.h
+++ b/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_stagedesc.h
@@ -14,25 +14,20 @@
 #include "ia_css_pipeline_common.h"
 
 void ia_css_pipe_get_generic_stage_desc(
-    struct ia_css_pipeline_stage_desc *stage_desc,
-    struct ia_css_binary *binary,
-    struct ia_css_frame *out_frame[],
-    struct ia_css_frame *in_frame,
-    struct ia_css_frame *vf_frame);
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_binary *binary, struct ia_css_frame *out_frame[],
+	struct ia_css_frame *in_frame, struct ia_css_frame *vf_frame);
 
 void ia_css_pipe_get_firmwares_stage_desc(
-    struct ia_css_pipeline_stage_desc *stage_desc,
-    struct ia_css_binary *binary,
-    struct ia_css_frame *out_frame[],
-    struct ia_css_frame *in_frame,
-    struct ia_css_frame *vf_frame,
-    const struct ia_css_fw_info *fw,
-    unsigned int mode);
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_binary *binary, struct ia_css_frame *out_frame[],
+	struct ia_css_frame *in_frame, struct ia_css_frame *vf_frame,
+	const struct ia_css_fw_info *fw, unsigned int mode);
 
 void ia_css_pipe_get_sp_func_stage_desc(
-    struct ia_css_pipeline_stage_desc *stage_desc,
-    struct ia_css_frame *out_frame,
-    enum ia_css_pipeline_stage_sp_func sp_func,
-    unsigned int max_input_width);
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_frame *out_frame,
+	enum ia_css_pipeline_stage_sp_func sp_func,
+	unsigned int max_input_width);
 
 #endif /*__IA_CSS_PIPE_STAGEDESC__H__ */
diff --git a/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_util.h b/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_util.h
index a0bdcc37553f07209d46269b38ca0aebdc9175c4..a9be3ff6556279c4d9801a459739a81d224b2bbc 100644
--- a/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_util.h
+++ b/drivers/staging/media/atomisp/pci/camera/pipe/interface/ia_css_pipe_util.h
@@ -17,15 +17,13 @@
  * @return   bits per pixel for the underlying stream
  *
  */
-unsigned int ia_css_pipe_util_pipe_input_format_bpp(
-    const struct ia_css_pipe *const pipe);
+unsigned int
+ia_css_pipe_util_pipe_input_format_bpp(const struct ia_css_pipe *const pipe);
 
-void ia_css_pipe_util_create_output_frames(
-    struct ia_css_frame *frames[]);
+void ia_css_pipe_util_create_output_frames(struct ia_css_frame *frames[]);
 
-void ia_css_pipe_util_set_output_frames(
-    struct ia_css_frame *frames[],
-    unsigned int idx,
-    struct ia_css_frame *frame);
+void ia_css_pipe_util_set_output_frames(struct ia_css_frame *frames[],
+					unsigned int idx,
+					struct ia_css_frame *frame);
 
 #endif /* __IA_CSS_PIPE_UTIL_H__ */
diff --git a/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_binarydesc.c b/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_binarydesc.c
index 8d7925a7ee0c940b806de5c0ba8030a584175b44..670b194672246f698229d43d08166009afffa62b 100644
--- a/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_binarydesc.c
+++ b/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_binarydesc.c
@@ -24,13 +24,12 @@
  * populates the frame info's when required.*/
 
 /* Generic descriptor for offline binaries. Internal function. */
-static void pipe_binarydesc_get_offline(
-    struct ia_css_pipe const *const pipe,
-    const int mode,
-    struct ia_css_binary_descr *descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info[],
-    struct ia_css_frame_info *vf_info)
+static void pipe_binarydesc_get_offline(struct ia_css_pipe const *const pipe,
+					const int mode,
+					struct ia_css_binary_descr *descr,
+					struct ia_css_frame_info *in_info,
+					struct ia_css_frame_info *out_info[],
+					struct ia_css_frame_info *vf_info)
 {
 	unsigned int i;
 	/* in_info, out_info, vf_info can be NULL */
@@ -67,12 +66,11 @@ static void pipe_binarydesc_get_offline(
 	descr->stream_config_left_padding = -1;
 }
 
-void ia_css_pipe_get_copy_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *copy_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info)
+void ia_css_pipe_get_copy_binarydesc(struct ia_css_pipe const *const pipe,
+				     struct ia_css_binary_descr *copy_descr,
+				     struct ia_css_frame_info *in_info,
+				     struct ia_css_frame_info *out_info,
+				     struct ia_css_frame_info *vf_info)
 {
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
 	unsigned int i;
@@ -85,8 +83,8 @@ void ia_css_pipe_get_copy_binarydesc(
 	out_infos[0] = out_info;
 	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
 		out_infos[i] = NULL;
-	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_COPY,
-				    copy_descr, in_info, out_infos, vf_info);
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_COPY, copy_descr,
+				    in_info, out_infos, vf_info);
 	copy_descr->online = true;
 	copy_descr->continuous = false;
 	copy_descr->two_ppc = (pipe->stream->config.pixels_per_clock == 2);
@@ -95,11 +93,10 @@ void ia_css_pipe_get_copy_binarydesc(
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
-void ia_css_pipe_get_vfpp_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *vf_pp_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info)
+void ia_css_pipe_get_vfpp_binarydesc(struct ia_css_pipe const *const pipe,
+				     struct ia_css_binary_descr *vf_pp_descr,
+				     struct ia_css_frame_info *in_info,
+				     struct ia_css_frame_info *out_info)
 {
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
 	unsigned int i;
@@ -113,25 +110,25 @@ void ia_css_pipe_get_vfpp_binarydesc(
 	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
 		out_infos[i] = NULL;
 
-	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_VF_PP,
-				    vf_pp_descr, in_info, out_infos, NULL);
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_VF_PP, vf_pp_descr,
+				    in_info, out_infos, NULL);
 	vf_pp_descr->enable_fractional_ds = true;
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
 static struct u32_fract bds_factors_list[] = {
-	[SH_CSS_BDS_FACTOR_1_00] = {1, 1},
-	[SH_CSS_BDS_FACTOR_1_25] = {5, 4},
-	[SH_CSS_BDS_FACTOR_1_50] = {3, 2},
-	[SH_CSS_BDS_FACTOR_2_00] = {2, 1},
-	[SH_CSS_BDS_FACTOR_2_25] = {9, 4},
-	[SH_CSS_BDS_FACTOR_2_50] = {5, 2},
-	[SH_CSS_BDS_FACTOR_3_00] = {3, 1},
-	[SH_CSS_BDS_FACTOR_4_00] = {4, 1},
-	[SH_CSS_BDS_FACTOR_4_50] = {9, 2},
-	[SH_CSS_BDS_FACTOR_5_00] = {5, 1},
-	[SH_CSS_BDS_FACTOR_6_00] = {6, 1},
-	[SH_CSS_BDS_FACTOR_8_00] = {8, 1},
+	[SH_CSS_BDS_FACTOR_1_00] = { 1, 1 },
+	[SH_CSS_BDS_FACTOR_1_25] = { 5, 4 },
+	[SH_CSS_BDS_FACTOR_1_50] = { 3, 2 },
+	[SH_CSS_BDS_FACTOR_2_00] = { 2, 1 },
+	[SH_CSS_BDS_FACTOR_2_25] = { 9, 4 },
+	[SH_CSS_BDS_FACTOR_2_50] = { 5, 2 },
+	[SH_CSS_BDS_FACTOR_3_00] = { 3, 1 },
+	[SH_CSS_BDS_FACTOR_4_00] = { 4, 1 },
+	[SH_CSS_BDS_FACTOR_4_50] = { 9, 2 },
+	[SH_CSS_BDS_FACTOR_5_00] = { 5, 1 },
+	[SH_CSS_BDS_FACTOR_6_00] = { 6, 1 },
+	[SH_CSS_BDS_FACTOR_8_00] = { 8, 1 },
 };
 
 int sh_css_bds_factor_get_fract(unsigned int bds_factor, struct u32_fract *bds)
@@ -144,14 +141,12 @@ int sh_css_bds_factor_get_fract(unsigned int bds_factor, struct u32_fract *bds)
 	return 0;
 }
 
-int binarydesc_calculate_bds_factor(
-    struct ia_css_resolution input_res,
-    struct ia_css_resolution output_res,
-    unsigned int *bds_factor)
+int binarydesc_calculate_bds_factor(struct ia_css_resolution input_res,
+				    struct ia_css_resolution output_res,
+				    unsigned int *bds_factor)
 {
 	unsigned int i;
-	unsigned int in_w = input_res.width,
-		     in_h = input_res.height,
+	unsigned int in_w = input_res.width, in_h = input_res.height,
 		     out_w = output_res.width, out_h = output_res.height;
 
 	unsigned int max_bds_factor = 8;
@@ -185,13 +180,12 @@ int binarydesc_calculate_bds_factor(
 	return -EINVAL;
 }
 
-int ia_css_pipe_get_preview_binarydesc(
-    struct ia_css_pipe *const pipe,
-    struct ia_css_binary_descr *preview_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *bds_out_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info)
+int ia_css_pipe_get_preview_binarydesc(struct ia_css_pipe *const pipe,
+				       struct ia_css_binary_descr *preview_descr,
+				       struct ia_css_frame_info *in_info,
+				       struct ia_css_frame_info *bds_out_info,
+				       struct ia_css_frame_info *out_info,
+				       struct ia_css_frame_info *vf_info)
 {
 	int err;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -212,7 +206,8 @@ int ia_css_pipe_get_preview_binarydesc(
 	in_info->padded_width = in_info->res.width;
 	in_info->raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);
 
-	if (ia_css_util_is_input_format_yuv(pipe->stream->config.input_config.format))
+	if (ia_css_util_is_input_format_yuv(
+		    pipe->stream->config.input_config.format))
 		mode = IA_CSS_BINARY_MODE_COPY;
 	else
 		in_info->format = IA_CSS_FRAME_FORMAT_RAW;
@@ -221,12 +216,12 @@ int ia_css_pipe_get_preview_binarydesc(
 	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
 		out_infos[i] = NULL;
 
-	pipe_binarydesc_get_offline(pipe, mode,
-				    preview_descr, in_info, out_infos, vf_info);
+	pipe_binarydesc_get_offline(pipe, mode, preview_descr, in_info,
+				    out_infos, vf_info);
 	if (pipe->stream->config.online) {
 		preview_descr->online = pipe->stream->config.online;
 		preview_descr->two_ppc =
-		    (pipe->stream->config.pixels_per_clock == 2);
+			(pipe->stream->config.pixels_per_clock == 2);
 	}
 	preview_descr->stream_format = pipe->stream->config.input_config.format;
 
@@ -237,15 +232,14 @@ int ia_css_pipe_get_preview_binarydesc(
 		if (pipe->config.bayer_ds_out_res.width != 0 &&
 		    pipe->config.bayer_ds_out_res.height != 0) {
 			bds_out_info->res.width =
-			    pipe->config.bayer_ds_out_res.width;
+				pipe->config.bayer_ds_out_res.width;
 			bds_out_info->res.height =
-			    pipe->config.bayer_ds_out_res.height;
+				pipe->config.bayer_ds_out_res.height;
 			bds_out_info->padded_width =
-			    pipe->config.bayer_ds_out_res.width;
-			err =
-			    binarydesc_calculate_bds_factor(in_info->res,
-							    bds_out_info->res,
-							    &preview_descr->required_bds_factor);
+				pipe->config.bayer_ds_out_res.width;
+			err = binarydesc_calculate_bds_factor(
+				in_info->res, bds_out_info->res,
+				&preview_descr->required_bds_factor);
 			if (err)
 				return err;
 		} else {
@@ -253,7 +247,7 @@ int ia_css_pipe_get_preview_binarydesc(
 			bds_out_info->res.height = in_info->res.height / 2;
 			bds_out_info->padded_width = in_info->padded_width / 2;
 			preview_descr->required_bds_factor =
-			    SH_CSS_BDS_FACTOR_2_00;
+				SH_CSS_BDS_FACTOR_2_00;
 		}
 	} else {
 		/* TODO: Remove this when bds_out_info->is available! */
@@ -295,7 +289,7 @@ int ia_css_pipe_get_preview_binarydesc(
 		out_info->padded_width = bds_out_info->padded_width;
 	}
 	preview_descr->enable_fractional_ds =
-	    pipe->extra_config.enable_fractional_ds;
+		pipe->extra_config.enable_fractional_ds;
 
 	preview_descr->enable_dpc = pipe->config.enable_dpc;
 
@@ -304,14 +298,13 @@ int ia_css_pipe_get_preview_binarydesc(
 	return 0;
 }
 
-int ia_css_pipe_get_video_binarydesc(
-    struct ia_css_pipe *const pipe,
-    struct ia_css_binary_descr *video_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *bds_out_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info,
-    int stream_config_left_padding)
+int ia_css_pipe_get_video_binarydesc(struct ia_css_pipe *const pipe,
+				     struct ia_css_binary_descr *video_descr,
+				     struct ia_css_frame_info *in_info,
+				     struct ia_css_frame_info *bds_out_info,
+				     struct ia_css_frame_info *out_info,
+				     struct ia_css_frame_info *vf_info,
+				     int stream_config_left_padding)
 {
 	int mode = IA_CSS_BINARY_MODE_VIDEO;
 	unsigned int i;
@@ -329,7 +322,8 @@ int ia_css_pipe_get_video_binarydesc(
 	 * But for now this fixes things; this code used to be there but was removed
 	 * with gerrit 8908 as this was wrong for Skycam; however 240x still needs this
 	 */
-	if (ia_css_util_is_input_format_yuv(pipe->stream->config.input_config.format))
+	if (ia_css_util_is_input_format_yuv(
+		    pipe->stream->config.input_config.format))
 		mode = IA_CSS_BINARY_MODE_COPY;
 
 	in_info->res = pipe->config.input_effective_res;
@@ -340,71 +334,68 @@ int ia_css_pipe_get_video_binarydesc(
 	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
 		out_infos[i] = NULL;
 
-	pipe_binarydesc_get_offline(pipe, mode,
-				    video_descr, in_info, out_infos, vf_info);
+	pipe_binarydesc_get_offline(pipe, mode, video_descr, in_info, out_infos,
+				    vf_info);
 
 	if (pipe->stream->config.online) {
 		video_descr->online = pipe->stream->config.online;
 		video_descr->two_ppc =
-		    (pipe->stream->config.pixels_per_clock == 2);
+			(pipe->stream->config.pixels_per_clock == 2);
 	}
 
 	if (mode == IA_CSS_BINARY_MODE_VIDEO) {
 		stream_dz_config =
-		    ((pipe->stream->isp_params_configs->dz_config.dx !=
-		      HRT_GDC_N)
-		     || (pipe->stream->isp_params_configs->dz_config.dy !=
-			 HRT_GDC_N));
+			((pipe->stream->isp_params_configs->dz_config.dx !=
+			  HRT_GDC_N) ||
+			 (pipe->stream->isp_params_configs->dz_config.dy !=
+			  HRT_GDC_N));
 
-		video_descr->enable_dz = pipe->config.enable_dz
-					 || stream_dz_config;
+		video_descr->enable_dz = pipe->config.enable_dz ||
+					 stream_dz_config;
 		video_descr->dvs_env = pipe->config.dvs_envelope;
 		video_descr->enable_yuv_ds = pipe->extra_config.enable_yuv_ds;
 		video_descr->enable_high_speed =
-		    pipe->extra_config.enable_high_speed;
+			pipe->extra_config.enable_high_speed;
 		video_descr->enable_dvs_6axis =
-		    pipe->extra_config.enable_dvs_6axis;
+			pipe->extra_config.enable_dvs_6axis;
 		video_descr->enable_reduced_pipe =
-		    pipe->extra_config.enable_reduced_pipe;
+			pipe->extra_config.enable_reduced_pipe;
 		video_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 		video_descr->enable_fractional_ds =
-		    pipe->extra_config.enable_fractional_ds;
-		video_descr->enable_dpc =
-		    pipe->config.enable_dpc;
-		video_descr->enable_tnr =
-		    pipe->config.enable_tnr;
+			pipe->extra_config.enable_fractional_ds;
+		video_descr->enable_dpc = pipe->config.enable_dpc;
+		video_descr->enable_tnr = pipe->config.enable_tnr;
 
 		if (pipe->extra_config.enable_raw_binning) {
 			if (pipe->config.bayer_ds_out_res.width != 0 &&
 			    pipe->config.bayer_ds_out_res.height != 0) {
 				bds_out_info->res.width =
-				    pipe->config.bayer_ds_out_res.width;
+					pipe->config.bayer_ds_out_res.width;
 				bds_out_info->res.height =
-				    pipe->config.bayer_ds_out_res.height;
+					pipe->config.bayer_ds_out_res.height;
 				bds_out_info->padded_width =
-				    pipe->config.bayer_ds_out_res.width;
-				err =
-				    binarydesc_calculate_bds_factor(
+					pipe->config.bayer_ds_out_res.width;
+				err = binarydesc_calculate_bds_factor(
 					in_info->res, bds_out_info->res,
 					&video_descr->required_bds_factor);
 				if (err)
 					return err;
 			} else {
 				bds_out_info->res.width =
-				    in_info->res.width / 2;
+					in_info->res.width / 2;
 				bds_out_info->res.height =
-				    in_info->res.height / 2;
+					in_info->res.height / 2;
 				bds_out_info->padded_width =
-				    in_info->padded_width / 2;
+					in_info->padded_width / 2;
 				video_descr->required_bds_factor =
-				    SH_CSS_BDS_FACTOR_2_00;
+					SH_CSS_BDS_FACTOR_2_00;
 			}
 		} else {
 			bds_out_info->res.width = in_info->res.width;
 			bds_out_info->res.height = in_info->res.height;
 			bds_out_info->padded_width = in_info->padded_width;
 			video_descr->required_bds_factor =
-			    SH_CSS_BDS_FACTOR_1_00;
+				SH_CSS_BDS_FACTOR_1_00;
 		}
 
 		pipe->required_bds_factor = video_descr->required_bds_factor;
@@ -418,20 +409,20 @@ int ia_css_pipe_get_video_binarydesc(
 			video_descr->bds_out_info = NULL;
 
 		video_descr->enable_fractional_ds =
-		    pipe->extra_config.enable_fractional_ds;
-		video_descr->stream_config_left_padding = stream_config_left_padding;
+			pipe->extra_config.enable_fractional_ds;
+		video_descr->stream_config_left_padding =
+			stream_config_left_padding;
 	}
 	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
 void ia_css_pipe_get_yuvscaler_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *yuv_scaler_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *internal_out_info,
-    struct ia_css_frame_info *vf_info)
+	struct ia_css_pipe const *const pipe,
+	struct ia_css_binary_descr *yuv_scaler_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *internal_out_info,
+	struct ia_css_frame_info *vf_info)
 {
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
 	struct ia_css_frame_info *this_vf_info = NULL;
@@ -456,25 +447,25 @@ void ia_css_pipe_get_yuvscaler_binarydesc(
 	 */
 
 	if (vf_info) {
-		this_vf_info = (vf_info->res.width == 0 &&
-				vf_info->res.height == 0) ? NULL : vf_info;
+		this_vf_info =
+			(vf_info->res.width == 0 && vf_info->res.height == 0) ?
+				NULL :
+				vf_info;
 	}
 
-	pipe_binarydesc_get_offline(pipe,
-				    IA_CSS_BINARY_MODE_CAPTURE_PP,
-				    yuv_scaler_descr,
-				    in_info, out_infos, this_vf_info);
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_CAPTURE_PP,
+				    yuv_scaler_descr, in_info, out_infos,
+				    this_vf_info);
 
 	yuv_scaler_descr->enable_fractional_ds = true;
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
 void ia_css_pipe_get_capturepp_binarydesc(
-    struct ia_css_pipe *const pipe,
-    struct ia_css_binary_descr *capture_pp_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info)
+	struct ia_css_pipe *const pipe,
+	struct ia_css_binary_descr *capture_pp_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
 {
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -498,16 +489,15 @@ void ia_css_pipe_get_capturepp_binarydesc(
 	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
 		out_infos[i] = NULL;
 
-	pipe_binarydesc_get_offline(pipe,
-				    IA_CSS_BINARY_MODE_CAPTURE_PP,
-				    capture_pp_descr,
-				    in_info, out_infos, vf_info);
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_CAPTURE_PP,
+				    capture_pp_descr, in_info, out_infos,
+				    vf_info);
 
 	capture_pp_descr->enable_capture_pp_bli =
-	    pipe->config.default_capture_config.enable_capture_pp_bli;
+		pipe->config.default_capture_config.enable_capture_pp_bli;
 	capture_pp_descr->enable_fractional_ds = true;
 	capture_pp_descr->enable_xnr =
-	    pipe->config.default_capture_config.enable_xnr != 0;
+		pipe->config.default_capture_config.enable_xnr != 0;
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
@@ -521,13 +511,12 @@ static unsigned int primary_hq_binary_modes[NUM_PRIMARY_HQ_STAGES] = {
 	IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE5
 };
 
-void ia_css_pipe_get_primary_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *prim_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info,
-    unsigned int stage_idx)
+void ia_css_pipe_get_primary_binarydesc(struct ia_css_pipe const *const pipe,
+					struct ia_css_binary_descr *prim_descr,
+					struct ia_css_frame_info *in_info,
+					struct ia_css_frame_info *out_info,
+					struct ia_css_frame_info *vf_info,
+					unsigned int stage_idx)
 {
 	enum ia_css_pipe_version pipe_version = pipe->config.isp_pipe_version;
 	int mode;
@@ -547,7 +536,8 @@ void ia_css_pipe_get_primary_binarydesc(
 	else
 		mode = IA_CSS_BINARY_MODE_PRIMARY;
 
-	if (ia_css_util_is_input_format_yuv(pipe->stream->config.input_config.format))
+	if (ia_css_util_is_input_format_yuv(
+		    pipe->stream->config.input_config.format))
 		mode = IA_CSS_BINARY_MODE_COPY;
 
 	in_info->res = pipe->config.input_effective_res;
@@ -563,20 +553,21 @@ void ia_css_pipe_get_primary_binarydesc(
 	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
 		out_infos[i] = NULL;
 
-	pipe_binarydesc_get_offline(pipe, mode,
-				    prim_descr, in_info, out_infos, vf_info);
+	pipe_binarydesc_get_offline(pipe, mode, prim_descr, in_info, out_infos,
+				    vf_info);
 
 	if (pipe->stream->config.online &&
 	    pipe->stream->config.mode != IA_CSS_INPUT_MODE_MEMORY) {
 		prim_descr->online = true;
 		prim_descr->two_ppc =
-		    (pipe->stream->config.pixels_per_clock == 2);
-		prim_descr->stream_format = pipe->stream->config.input_config.format;
+			(pipe->stream->config.pixels_per_clock == 2);
+		prim_descr->stream_format =
+			pipe->stream->config.input_config.format;
 	}
 	if (mode == IA_CSS_BINARY_MODE_PRIMARY) {
 		prim_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 		prim_descr->enable_fractional_ds =
-		    pipe->extra_config.enable_fractional_ds;
+			pipe->extra_config.enable_fractional_ds;
 		/* We have both striped and non-striped primary binaries,
 		 * if continuous viewfinder is required, then we must select
 		 * a striped one. Otherwise we prefer to use a non-striped
@@ -584,17 +575,18 @@ void ia_css_pipe_get_primary_binarydesc(
 		if (pipe_version == IA_CSS_PIPE_VERSION_2_6_1)
 			prim_descr->striped = false;
 		else
-			prim_descr->striped = prim_descr->continuous &&
-					      (!pipe->stream->stop_copy_preview || !pipe->stream->disable_cont_vf);
+			prim_descr->striped =
+				prim_descr->continuous &&
+				(!pipe->stream->stop_copy_preview ||
+				 !pipe->stream->disable_cont_vf);
 	}
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
 void ia_css_pipe_get_pre_gdc_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *pre_gdc_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info)
+	struct ia_css_pipe const *const pipe,
+	struct ia_css_binary_descr *pre_gdc_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info)
 {
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -617,11 +609,10 @@ void ia_css_pipe_get_pre_gdc_binarydesc(
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
-void ia_css_pipe_get_gdc_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *gdc_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info)
+void ia_css_pipe_get_gdc_binarydesc(struct ia_css_pipe const *const pipe,
+				    struct ia_css_binary_descr *gdc_descr,
+				    struct ia_css_frame_info *in_info,
+				    struct ia_css_frame_info *out_info)
 {
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -637,17 +628,16 @@ void ia_css_pipe_get_gdc_binarydesc(
 	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
 		out_infos[i] = NULL;
 
-	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_GDC,
-				    gdc_descr, in_info, out_infos, NULL);
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_GDC, gdc_descr,
+				    in_info, out_infos, NULL);
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
 void ia_css_pipe_get_post_gdc_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *post_gdc_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info)
+	struct ia_css_pipe const *const pipe,
+	struct ia_css_binary_descr *post_gdc_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
 {
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -666,17 +656,17 @@ void ia_css_pipe_get_post_gdc_binarydesc(
 		out_infos[i] = NULL;
 
 	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_POST_ISP,
-				    post_gdc_descr, in_info, out_infos, vf_info);
+				    post_gdc_descr, in_info, out_infos,
+				    vf_info);
 
 	post_gdc_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
-void ia_css_pipe_get_pre_de_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *pre_de_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info)
+void ia_css_pipe_get_pre_de_binarydesc(struct ia_css_pipe const *const pipe,
+				       struct ia_css_binary_descr *pre_de_descr,
+				       struct ia_css_frame_info *in_info,
+				       struct ia_css_frame_info *out_info)
 {
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -695,27 +685,29 @@ void ia_css_pipe_get_pre_de_binarydesc(
 
 	if (pipe->config.isp_pipe_version == IA_CSS_PIPE_VERSION_1)
 		pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_PRE_ISP,
-					    pre_de_descr, in_info, out_infos, NULL);
+					    pre_de_descr, in_info, out_infos,
+					    NULL);
 	else if (pipe->config.isp_pipe_version == IA_CSS_PIPE_VERSION_2_2) {
 		pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_PRE_DE,
-					    pre_de_descr, in_info, out_infos, NULL);
+					    pre_de_descr, in_info, out_infos,
+					    NULL);
 	}
 
 	if (pipe->stream->config.online) {
 		pre_de_descr->online = true;
 		pre_de_descr->two_ppc =
-		    (pipe->stream->config.pixels_per_clock == 2);
-		pre_de_descr->stream_format = pipe->stream->config.input_config.format;
+			(pipe->stream->config.pixels_per_clock == 2);
+		pre_de_descr->stream_format =
+			pipe->stream->config.input_config.format;
 	}
 	pre_de_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
 void ia_css_pipe_get_pre_anr_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *pre_anr_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info)
+	struct ia_css_pipe const *const pipe,
+	struct ia_css_binary_descr *pre_anr_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info)
 {
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -738,18 +730,18 @@ void ia_css_pipe_get_pre_anr_binarydesc(
 	if (pipe->stream->config.online) {
 		pre_anr_descr->online = true;
 		pre_anr_descr->two_ppc =
-		    (pipe->stream->config.pixels_per_clock == 2);
-		pre_anr_descr->stream_format = pipe->stream->config.input_config.format;
+			(pipe->stream->config.pixels_per_clock == 2);
+		pre_anr_descr->stream_format =
+			pipe->stream->config.input_config.format;
 	}
 	pre_anr_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
-void ia_css_pipe_get_anr_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *anr_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info)
+void ia_css_pipe_get_anr_binarydesc(struct ia_css_pipe const *const pipe,
+				    struct ia_css_binary_descr *anr_descr,
+				    struct ia_css_frame_info *in_info,
+				    struct ia_css_frame_info *out_info)
 {
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -766,19 +758,18 @@ void ia_css_pipe_get_anr_binarydesc(
 	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
 		out_infos[i] = NULL;
 
-	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_ANR,
-				    anr_descr, in_info, out_infos, NULL);
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_ANR, anr_descr,
+				    in_info, out_infos, NULL);
 
 	anr_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
 void ia_css_pipe_get_post_anr_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *post_anr_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info)
+	struct ia_css_pipe const *const pipe,
+	struct ia_css_binary_descr *post_anr_descr,
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
 {
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -797,17 +788,17 @@ void ia_css_pipe_get_post_anr_binarydesc(
 		out_infos[i] = NULL;
 
 	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_POST_ISP,
-				    post_anr_descr, in_info, out_infos, vf_info);
+				    post_anr_descr, in_info, out_infos,
+				    vf_info);
 
 	post_anr_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
-void ia_css_pipe_get_ldc_binarydesc(
-    struct ia_css_pipe const *const pipe,
-    struct ia_css_binary_descr *ldc_descr,
-    struct ia_css_frame_info *in_info,
-    struct ia_css_frame_info *out_info)
+void ia_css_pipe_get_ldc_binarydesc(struct ia_css_pipe const *const pipe,
+				    struct ia_css_binary_descr *ldc_descr,
+				    struct ia_css_frame_info *in_info,
+				    struct ia_css_frame_info *out_info)
 {
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -829,7 +820,6 @@ void ia_css_pipe_get_ldc_binarydesc(
 
 	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_CAPTURE_PP,
 				    ldc_descr, in_info, out_infos, NULL);
-	ldc_descr->enable_dvs_6axis =
-	    pipe->extra_config.enable_dvs_6axis;
+	ldc_descr->enable_dvs_6axis = pipe->extra_config.enable_dvs_6axis;
 	IA_CSS_LEAVE_PRIVATE("");
 }
diff --git a/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_stagedesc.c b/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_stagedesc.c
index a9f736398f50472cfd5733bcfbd67d8fa3f606e8..7b9ae3a969a9bde3d9688c16bac139a1f6b07d7d 100644
--- a/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_stagedesc.c
+++ b/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_stagedesc.c
@@ -9,16 +9,15 @@
 #include "ia_css_debug.h"
 
 void ia_css_pipe_get_generic_stage_desc(
-    struct ia_css_pipeline_stage_desc *stage_desc,
-    struct ia_css_binary *binary,
-    struct ia_css_frame *out_frame[],
-    struct ia_css_frame *in_frame,
-    struct ia_css_frame *vf_frame)
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_binary *binary, struct ia_css_frame *out_frame[],
+	struct ia_css_frame *in_frame, struct ia_css_frame *vf_frame)
 {
 	unsigned int i;
 
-	IA_CSS_ENTER_PRIVATE("stage_desc = %p, binary = %p, out_frame = %p, in_frame = %p, vf_frame = %p",
-			     stage_desc, binary, out_frame, in_frame, vf_frame);
+	IA_CSS_ENTER_PRIVATE(
+		"stage_desc = %p, binary = %p, out_frame = %p, in_frame = %p, vf_frame = %p",
+		stage_desc, binary, out_frame, in_frame, vf_frame);
 
 	assert(stage_desc && binary && binary->info);
 	if (!stage_desc || !binary || !binary->info) {
@@ -41,13 +40,10 @@ void ia_css_pipe_get_generic_stage_desc(
 }
 
 void ia_css_pipe_get_firmwares_stage_desc(
-    struct ia_css_pipeline_stage_desc *stage_desc,
-    struct ia_css_binary *binary,
-    struct ia_css_frame *out_frame[],
-    struct ia_css_frame *in_frame,
-    struct ia_css_frame *vf_frame,
-    const struct ia_css_fw_info *fw,
-    unsigned int mode)
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_binary *binary, struct ia_css_frame *out_frame[],
+	struct ia_css_frame *in_frame, struct ia_css_frame *vf_frame,
+	const struct ia_css_fw_info *fw, unsigned int mode)
 {
 	unsigned int i;
 
@@ -66,10 +62,10 @@ void ia_css_pipe_get_firmwares_stage_desc(
 }
 
 void ia_css_pipe_get_sp_func_stage_desc(
-    struct ia_css_pipeline_stage_desc *stage_desc,
-    struct ia_css_frame *out_frame,
-    enum ia_css_pipeline_stage_sp_func sp_func,
-    unsigned int max_input_width)
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_frame *out_frame,
+	enum ia_css_pipeline_stage_sp_func sp_func,
+	unsigned int max_input_width)
 {
 	unsigned int i;
 
diff --git a/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_util.c b/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_util.c
index c7c42b472cc7cf73820401a35528cf2af609f9e5..40c160d14c5d286c5a6d4af1c3f278997ccaa0b6 100644
--- a/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_util.c
+++ b/drivers/staging/media/atomisp/pci/camera/pipe/src/pipe_util.c
@@ -10,18 +10,18 @@
 #include "ia_css_util.h"
 #include "assert_support.h"
 
-unsigned int ia_css_pipe_util_pipe_input_format_bpp(
-    const struct ia_css_pipe *const pipe)
+unsigned int
+ia_css_pipe_util_pipe_input_format_bpp(const struct ia_css_pipe *const pipe)
 {
 	assert(pipe);
 	assert(pipe->stream);
 
-	return ia_css_util_input_format_bpp(pipe->stream->config.input_config.format,
-					    pipe->stream->config.pixels_per_clock == 2);
+	return ia_css_util_input_format_bpp(
+		pipe->stream->config.input_config.format,
+		pipe->stream->config.pixels_per_clock == 2);
 }
 
-void ia_css_pipe_util_create_output_frames(
-    struct ia_css_frame *frames[])
+void ia_css_pipe_util_create_output_frames(struct ia_css_frame *frames[])
 {
 	unsigned int i;
 
@@ -31,10 +31,9 @@ void ia_css_pipe_util_create_output_frames(
 	}
 }
 
-void ia_css_pipe_util_set_output_frames(
-    struct ia_css_frame *frames[],
-    unsigned int idx,
-    struct ia_css_frame *frame)
+void ia_css_pipe_util_set_output_frames(struct ia_css_frame *frames[],
+					unsigned int idx,
+					struct ia_css_frame *frame)
 {
 	assert(idx < IA_CSS_BINARY_MAX_OUTPUT_PORTS);
 
diff --git a/drivers/staging/media/atomisp/pci/camera/util/interface/ia_css_util.h b/drivers/staging/media/atomisp/pci/camera/util/interface/ia_css_util.h
index 24cd99a659cabf8fe85d59a6897da5121671115d..6358ca42d2e2c95ec61fd910ecf503c51231edf4 100644
--- a/drivers/staging/media/atomisp/pci/camera/util/interface/ia_css_util.h
+++ b/drivers/staging/media/atomisp/pci/camera/util/interface/ia_css_util.h
@@ -21,8 +21,7 @@
  * @return	"ia_css_err" error code
  *
  */
-int ia_css_convert_errno(
-    int in_err);
+int ia_css_convert_errno(int in_err);
 
 /* @brief check vf frame info.
  *
@@ -30,8 +29,7 @@ int ia_css_convert_errno(
  * @return	0 or error code upon error.
  *
  */
-int ia_css_util_check_vf_info(
-    const struct ia_css_frame_info *const info);
+int ia_css_util_check_vf_info(const struct ia_css_frame_info *const info);
 
 /* @brief check input configuration.
  *
@@ -41,9 +39,8 @@ int ia_css_util_check_vf_info(
  *
  */
 int ia_css_util_check_input(
-    const struct ia_css_stream_config *const stream_config,
-    bool must_be_raw,
-    bool must_be_yuv);
+	const struct ia_css_stream_config *const stream_config,
+	bool must_be_raw, bool must_be_yuv);
 
 /* @brief check vf and out frame info.
  *
@@ -53,8 +50,8 @@ int ia_css_util_check_input(
  *
  */
 int ia_css_util_check_vf_out_info(
-    const struct ia_css_frame_info *const out_info,
-    const struct ia_css_frame_info *const vf_info);
+	const struct ia_css_frame_info *const out_info,
+	const struct ia_css_frame_info *const vf_info);
 
 /* @brief check width and height
  *
@@ -63,9 +60,7 @@ int ia_css_util_check_vf_out_info(
  * @return	0 or error code upon error.
  *
  */
-int ia_css_util_check_res(
-    unsigned int width,
-    unsigned int height);
+int ia_css_util_check_res(unsigned int width, unsigned int height);
 
 /* ISP2401 */
 /* @brief compare resolutions (less or equal)
@@ -76,9 +71,8 @@ int ia_css_util_check_res(
  *            equal than those of b, false otherwise
  *
  */
-bool ia_css_util_res_leq(
-    struct ia_css_resolution a,
-    struct ia_css_resolution b);
+bool ia_css_util_res_leq(struct ia_css_resolution a,
+			 struct ia_css_resolution b);
 
 /* ISP2401 */
 /**
@@ -88,8 +82,7 @@ bool ia_css_util_res_leq(
  *
  * @returns true if resolution is zero
  */
-bool ia_css_util_resolution_is_zero(
-    const struct ia_css_resolution resolution);
+bool ia_css_util_resolution_is_zero(const struct ia_css_resolution resolution);
 
 /* @brief check width and height
  *
@@ -98,9 +91,9 @@ bool ia_css_util_resolution_is_zero(
  * @return bits per pixel based on given parameters.
  *
  */
-unsigned int ia_css_util_input_format_bpp(
-    enum atomisp_input_format stream_format,
-    bool two_ppc);
+unsigned int
+ia_css_util_input_format_bpp(enum atomisp_input_format stream_format,
+			     bool two_ppc);
 
 /* @brief check if input format it raw
  *
@@ -108,8 +101,7 @@ unsigned int ia_css_util_input_format_bpp(
  * @return true if the input format is raw or false otherwise
  *
  */
-bool ia_css_util_is_input_format_raw(
-    enum atomisp_input_format stream_format);
+bool ia_css_util_is_input_format_raw(enum atomisp_input_format stream_format);
 
 /* @brief check if input format it yuv
  *
@@ -117,7 +109,6 @@ bool ia_css_util_is_input_format_raw(
  * @return true if the input format is yuv or false otherwise
  *
  */
-bool ia_css_util_is_input_format_yuv(
-    enum atomisp_input_format stream_format);
+bool ia_css_util_is_input_format_yuv(enum atomisp_input_format stream_format);
 
 #endif /* __IA_CSS_UTIL_H__ */
diff --git a/drivers/staging/media/atomisp/pci/camera/util/src/util.c b/drivers/staging/media/atomisp/pci/camera/util/src/util.c
index 3a7abdc8f6b3ff474bc8a45322d536570926724c..2dffc7cc59ba558fc2939193fef863ec8de12dc3 100644
--- a/drivers/staging/media/atomisp/pci/camera/util/src/util.c
+++ b/drivers/staging/media/atomisp/pci/camera/util/src/util.c
@@ -13,9 +13,8 @@
 #include "ia_css_binary.h"
 
 /* MW: Table look-up ??? */
-unsigned int ia_css_util_input_format_bpp(
-    enum atomisp_input_format format,
-    bool two_ppc)
+unsigned int ia_css_util_input_format_bpp(enum atomisp_input_format format,
+					  bool two_ppc)
 {
 	unsigned int rval = 0;
 
@@ -76,8 +75,7 @@ unsigned int ia_css_util_input_format_bpp(
 	return rval;
 }
 
-int ia_css_util_check_vf_info(
-    const struct ia_css_frame_info *const info)
+int ia_css_util_check_vf_info(const struct ia_css_frame_info *const info)
 {
 	int err;
 	unsigned int max_vf_width;
@@ -92,9 +90,8 @@ int ia_css_util_check_vf_info(
 	return 0;
 }
 
-int ia_css_util_check_vf_out_info(
-    const struct ia_css_frame_info *const out_info,
-    const struct ia_css_frame_info *const vf_info)
+int ia_css_util_check_vf_out_info(const struct ia_css_frame_info *const out_info,
+				  const struct ia_css_frame_info *const vf_info)
 {
 	int err;
 
@@ -124,7 +121,8 @@ bool ia_css_util_resolution_is_zero(const struct ia_css_resolution resolution)
 
 int ia_css_util_check_res(unsigned int width, unsigned int height)
 {
-	const struct ia_css_resolution resolution = { .width = width, .height = height };
+	const struct ia_css_resolution resolution = { .width = width,
+						      .height = height };
 
 	if (ia_css_util_resolution_is_zero(resolution))
 		return -EINVAL;
@@ -152,18 +150,17 @@ bool ia_css_util_is_input_format_raw(enum atomisp_input_format format)
 bool ia_css_util_is_input_format_yuv(enum atomisp_input_format format)
 {
 	return format == ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY ||
-	       format == ATOMISP_INPUT_FORMAT_YUV420_8  ||
+	       format == ATOMISP_INPUT_FORMAT_YUV420_8 ||
 	       format == ATOMISP_INPUT_FORMAT_YUV420_10 ||
 	       format == ATOMISP_INPUT_FORMAT_YUV420_16 ||
-	       format == ATOMISP_INPUT_FORMAT_YUV422_8  ||
+	       format == ATOMISP_INPUT_FORMAT_YUV422_8 ||
 	       format == ATOMISP_INPUT_FORMAT_YUV422_10 ||
 	       format == ATOMISP_INPUT_FORMAT_YUV422_16;
 }
 
 int ia_css_util_check_input(
-    const struct ia_css_stream_config *const stream_config,
-    bool must_be_raw,
-    bool must_be_yuv)
+	const struct ia_css_stream_config *const stream_config,
+	bool must_be_raw, bool must_be_yuv)
 {
 	assert(stream_config);
 
@@ -173,12 +170,12 @@ int ia_css_util_check_input(
 	if (stream_config->input_config.effective_res.width == 0 ||
 	    stream_config->input_config.effective_res.height == 0)
 		return -EINVAL;
-	if (must_be_raw &&
-	    !ia_css_util_is_input_format_raw(stream_config->input_config.format))
+	if (must_be_raw && !ia_css_util_is_input_format_raw(
+				   stream_config->input_config.format))
 		return -EINVAL;
 
-	if (must_be_yuv &&
-	    !ia_css_util_is_input_format_yuv(stream_config->input_config.format))
+	if (must_be_yuv && !ia_css_util_is_input_format_yuv(
+				   stream_config->input_config.format))
 		return -EINVAL;
 
 	return 0;
diff --git a/drivers/staging/media/atomisp/pci/cell_params.h b/drivers/staging/media/atomisp/pci/cell_params.h
index a2a07b78f2a07b7884960fbe175c4b697b9484e3..153c65ea29ba27e45641af0c1d4e26cdf0c5d378 100644
--- a/drivers/staging/media/atomisp/pci/cell_params.h
+++ b/drivers/staging/media/atomisp/pci/cell_params.h
@@ -7,26 +7,26 @@
 #ifndef _cell_params_h
 #define _cell_params_h
 
-#define SP_PMEM_LOG_WIDTH_BITS           6  /*Width of PC, 64 bits, 8 bytes*/
-#define SP_ICACHE_TAG_BITS               4  /*size of tag*/
-#define SP_ICACHE_SET_BITS               8  /* 256 sets*/
-#define SP_ICACHE_BLOCKS_PER_SET_BITS    1  /* 2 way associative*/
-#define SP_ICACHE_BLOCK_ADDRESS_BITS     11 /* 2048 lines capacity*/
+#define SP_PMEM_LOG_WIDTH_BITS 6 /*Width of PC, 64 bits, 8 bytes*/
+#define SP_ICACHE_TAG_BITS 4 /*size of tag*/
+#define SP_ICACHE_SET_BITS 8 /* 256 sets*/
+#define SP_ICACHE_BLOCKS_PER_SET_BITS 1 /* 2 way associative*/
+#define SP_ICACHE_BLOCK_ADDRESS_BITS 11 /* 2048 lines capacity*/
 
 #define SP_ICACHE_ADDRESS_BITS \
-			    (SP_ICACHE_TAG_BITS + SP_ICACHE_BLOCK_ADDRESS_BITS)
+	(SP_ICACHE_TAG_BITS + SP_ICACHE_BLOCK_ADDRESS_BITS)
 
-#define SP_PMEM_DEPTH        BIT(SP_ICACHE_ADDRESS_BITS)
+#define SP_PMEM_DEPTH BIT(SP_ICACHE_ADDRESS_BITS)
 
-#define SP_FIFO_0_DEPTH      0
-#define SP_FIFO_1_DEPTH      0
-#define SP_FIFO_2_DEPTH      0
-#define SP_FIFO_3_DEPTH      0
-#define SP_FIFO_4_DEPTH      0
-#define SP_FIFO_5_DEPTH      0
-#define SP_FIFO_6_DEPTH      0
-#define SP_FIFO_7_DEPTH      0
+#define SP_FIFO_0_DEPTH 0
+#define SP_FIFO_1_DEPTH 0
+#define SP_FIFO_2_DEPTH 0
+#define SP_FIFO_3_DEPTH 0
+#define SP_FIFO_4_DEPTH 0
+#define SP_FIFO_5_DEPTH 0
+#define SP_FIFO_6_DEPTH 0
+#define SP_FIFO_7_DEPTH 0
 
-#define SP_SLV_BUS_MAXBURSTSIZE        1
+#define SP_SLV_BUS_MAXBURSTSIZE 1
 
 #endif /* _cell_params_h */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/csi_rx_global.h b/drivers/staging/media/atomisp/pci/css_2401_system/csi_rx_global.h
index ab9d091acb4e753df49ed074c033966e29eb146f..977d6279064252b7101f71663a179da60d847963 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/csi_rx_global.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/csi_rx_global.h
@@ -17,10 +17,10 @@ typedef enum {
 	N_CSI_MIPI_PACKET_TYPE
 } csi_mipi_packet_type_t;
 
-typedef struct csi_rx_backend_lut_entry_s	csi_rx_backend_lut_entry_t;
+typedef struct csi_rx_backend_lut_entry_s csi_rx_backend_lut_entry_t;
 struct csi_rx_backend_lut_entry_s {
-	u32	long_packet_entry;
-	u32	short_packet_entry;
+	u32 long_packet_entry;
+	u32 short_packet_entry;
 };
 
 typedef struct csi_rx_backend_cfg_s csi_rx_backend_cfg_t;
@@ -32,7 +32,7 @@ struct csi_rx_backend_cfg_s {
 	csi_mipi_packet_type_t csi_mipi_packet_type;
 
 	struct {
-		bool     comp_enable;
+		bool comp_enable;
 		u32 virtual_channel;
 		u32 data_type;
 		u32 comp_scheme;
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx.c b/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx.c
index f82522e2da9407d69b9054a81856730bfb50541b..2e51f4c6ce773f7369ee9445a4d43895de31737c 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx.c
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx.c
@@ -8,26 +8,22 @@
 #include "csi_rx_global.h"
 
 const u32 N_SHORT_PACKET_LUT_ENTRIES[N_CSI_RX_BACKEND_ID] = {
-	4,	/* 4 entries at CSI_RX_BACKEND0_ID*/
-	4,	/* 4 entries at CSI_RX_BACKEND1_ID*/
-	4	/* 4 entries at CSI_RX_BACKEND2_ID*/
+	4, /* 4 entries at CSI_RX_BACKEND0_ID*/
+	4, /* 4 entries at CSI_RX_BACKEND1_ID*/
+	4 /* 4 entries at CSI_RX_BACKEND2_ID*/
 };
 
 const u32 N_LONG_PACKET_LUT_ENTRIES[N_CSI_RX_BACKEND_ID] = {
-	8,	/* 8 entries at CSI_RX_BACKEND0_ID*/
-	4,	/* 4 entries at CSI_RX_BACKEND1_ID*/
-	4	/* 4 entries at CSI_RX_BACKEND2_ID*/
+	8, /* 8 entries at CSI_RX_BACKEND0_ID*/
+	4, /* 4 entries at CSI_RX_BACKEND1_ID*/
+	4 /* 4 entries at CSI_RX_BACKEND2_ID*/
 };
 
 const u32 N_CSI_RX_FE_CTRL_DLANES[N_CSI_RX_FRONTEND_ID] = {
-	N_CSI_RX_DLANE_ID,	/* 4 dlanes for CSI_RX_FR0NTEND0_ID */
-	N_CSI_RX_DLANE_ID,	/* 4 dlanes for CSI_RX_FR0NTEND1_ID */
-	N_CSI_RX_DLANE_ID	/* 4 dlanes for CSI_RX_FR0NTEND2_ID */
+	N_CSI_RX_DLANE_ID, /* 4 dlanes for CSI_RX_FR0NTEND0_ID */
+	N_CSI_RX_DLANE_ID, /* 4 dlanes for CSI_RX_FR0NTEND1_ID */
+	N_CSI_RX_DLANE_ID /* 4 dlanes for CSI_RX_FR0NTEND2_ID */
 };
 
 /* sid_width for CSI_RX_BACKEND<N>_ID */
-const u32 N_CSI_RX_BE_SID_WIDTH[N_CSI_RX_BACKEND_ID] = {
-	3,
-	2,
-	2
-};
+const u32 N_CSI_RX_BE_SID_WIDTH[N_CSI_RX_BACKEND_ID] = { 3, 2, 2 };
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx_local.h b/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx_local.h
index 81e83554d317942322af3f367c559efe06634719..3ccc8cc5ccf3028904e321695ec30a2abe157f47 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx_local.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx_local.h
@@ -8,47 +8,47 @@
 #define __CSI_RX_LOCAL_H_INCLUDED__
 
 #include "csi_rx_global.h"
-#define N_CSI_RX_BE_MIPI_COMP_FMT_REG		4
-#define N_CSI_RX_BE_MIPI_CUSTOM_PEC		12
-#define N_CSI_RX_BE_SHORT_PKT_LUT		4
-#define N_CSI_RX_BE_LONG_PKT_LUT		8
-typedef struct csi_rx_fe_ctrl_state_s		csi_rx_fe_ctrl_state_t;
-typedef struct csi_rx_fe_ctrl_lane_s		csi_rx_fe_ctrl_lane_t;
-typedef struct csi_rx_be_ctrl_state_s		csi_rx_be_ctrl_state_t;
+#define N_CSI_RX_BE_MIPI_COMP_FMT_REG 4
+#define N_CSI_RX_BE_MIPI_CUSTOM_PEC 12
+#define N_CSI_RX_BE_SHORT_PKT_LUT 4
+#define N_CSI_RX_BE_LONG_PKT_LUT 8
+typedef struct csi_rx_fe_ctrl_state_s csi_rx_fe_ctrl_state_t;
+typedef struct csi_rx_fe_ctrl_lane_s csi_rx_fe_ctrl_lane_t;
+typedef struct csi_rx_be_ctrl_state_s csi_rx_be_ctrl_state_t;
 /*mipi_backend_custom_mode_pixel_extraction_config*/
-typedef struct csi_rx_be_ctrl_pec_s		csi_rx_be_ctrl_pec_t;
+typedef struct csi_rx_be_ctrl_pec_s csi_rx_be_ctrl_pec_t;
 
 struct csi_rx_fe_ctrl_lane_s {
-	hrt_data	termen;
-	hrt_data	settle;
+	hrt_data termen;
+	hrt_data settle;
 };
 
 struct csi_rx_fe_ctrl_state_s {
-	hrt_data		enable;
-	hrt_data		nof_enable_lanes;
-	hrt_data		error_handling;
-	hrt_data		status;
-	hrt_data		status_dlane_hs;
-	hrt_data		status_dlane_lp;
-	csi_rx_fe_ctrl_lane_t	clane;
-	csi_rx_fe_ctrl_lane_t	dlane[N_CSI_RX_DLANE_ID];
+	hrt_data enable;
+	hrt_data nof_enable_lanes;
+	hrt_data error_handling;
+	hrt_data status;
+	hrt_data status_dlane_hs;
+	hrt_data status_dlane_lp;
+	csi_rx_fe_ctrl_lane_t clane;
+	csi_rx_fe_ctrl_lane_t dlane[N_CSI_RX_DLANE_ID];
 };
 
 struct csi_rx_be_ctrl_state_s {
-	hrt_data		enable;
-	hrt_data		status;
-	hrt_data		comp_format_reg[N_CSI_RX_BE_MIPI_COMP_FMT_REG];
-	hrt_data		raw16;
-	hrt_data		raw18;
-	hrt_data		force_raw8;
-	hrt_data		irq_status;
-	hrt_data		custom_mode_enable;
-	hrt_data		custom_mode_data_state;
-	hrt_data		pec[N_CSI_RX_BE_MIPI_CUSTOM_PEC];
-	hrt_data		custom_mode_valid_eop_config;
-	hrt_data		global_lut_disregard_reg;
-	hrt_data		packet_status_stall;
-	hrt_data		short_packet_lut_entry[N_CSI_RX_BE_SHORT_PKT_LUT];
-	hrt_data		long_packet_lut_entry[N_CSI_RX_BE_LONG_PKT_LUT];
+	hrt_data enable;
+	hrt_data status;
+	hrt_data comp_format_reg[N_CSI_RX_BE_MIPI_COMP_FMT_REG];
+	hrt_data raw16;
+	hrt_data raw18;
+	hrt_data force_raw8;
+	hrt_data irq_status;
+	hrt_data custom_mode_enable;
+	hrt_data custom_mode_data_state;
+	hrt_data pec[N_CSI_RX_BE_MIPI_CUSTOM_PEC];
+	hrt_data custom_mode_valid_eop_config;
+	hrt_data global_lut_disregard_reg;
+	hrt_data packet_status_stall;
+	hrt_data short_packet_lut_entry[N_CSI_RX_BE_SHORT_PKT_LUT];
+	hrt_data long_packet_lut_entry[N_CSI_RX_BE_LONG_PKT_LUT];
 };
 #endif /* __CSI_RX_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx_private.h b/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx_private.h
index 989f55bec5190b0cdf0ed4b7ae3e59ab5042c1cf..ff0d74b468e5250d1e7003e78a12b4a4741dc688 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx_private.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/csi_rx_private.h
@@ -11,7 +11,7 @@
 #include "mipi_backend_defs.h"
 #include "csi_rx.h"
 
-#include "device_access.h"	/* ia_css_device_load_uint32 */
+#include "device_access.h" /* ia_css_device_load_uint32 */
 
 #include "assert_support.h" /* assert */
 #include "print_support.h" /* print */
@@ -25,60 +25,56 @@
  * @brief Load the register value.
  * Refer to "csi_rx_public.h" for details.
  */
-static inline hrt_data csi_rx_fe_ctrl_reg_load(
-    const csi_rx_frontend_ID_t ID,
-    const hrt_address reg)
+static inline hrt_data csi_rx_fe_ctrl_reg_load(const csi_rx_frontend_ID_t ID,
+					       const hrt_address reg)
 {
 	assert(ID < N_CSI_RX_FRONTEND_ID);
 	assert(CSI_RX_FE_CTRL_BASE[ID] != (hrt_address)-1);
-	return ia_css_device_load_uint32(CSI_RX_FE_CTRL_BASE[ID] + reg * sizeof(
-					     hrt_data));
+	return ia_css_device_load_uint32(CSI_RX_FE_CTRL_BASE[ID] +
+					 reg * sizeof(hrt_data));
 }
 
 /**
  * @brief Store a value to the register.
  * Refer to "ibuf_ctrl_public.h" for details.
  */
-static inline void csi_rx_fe_ctrl_reg_store(
-    const csi_rx_frontend_ID_t ID,
-    const hrt_address reg,
-    const hrt_data value)
+static inline void csi_rx_fe_ctrl_reg_store(const csi_rx_frontend_ID_t ID,
+					    const hrt_address reg,
+					    const hrt_data value)
 {
 	assert(ID < N_CSI_RX_FRONTEND_ID);
 	assert(CSI_RX_FE_CTRL_BASE[ID] != (hrt_address)-1);
 
-	ia_css_device_store_uint32(CSI_RX_FE_CTRL_BASE[ID] + reg * sizeof(hrt_data),
-				   value);
+	ia_css_device_store_uint32(
+		CSI_RX_FE_CTRL_BASE[ID] + reg * sizeof(hrt_data), value);
 }
 
 /**
  * @brief Load the register value.
  * Refer to "csi_rx_public.h" for details.
  */
-static inline hrt_data csi_rx_be_ctrl_reg_load(
-    const csi_rx_backend_ID_t ID,
-    const hrt_address reg)
+static inline hrt_data csi_rx_be_ctrl_reg_load(const csi_rx_backend_ID_t ID,
+					       const hrt_address reg)
 {
 	assert(ID < N_CSI_RX_BACKEND_ID);
 	assert(CSI_RX_BE_CTRL_BASE[ID] != (hrt_address)-1);
-	return ia_css_device_load_uint32(CSI_RX_BE_CTRL_BASE[ID] + reg * sizeof(
-					     hrt_data));
+	return ia_css_device_load_uint32(CSI_RX_BE_CTRL_BASE[ID] +
+					 reg * sizeof(hrt_data));
 }
 
 /**
  * @brief Store a value to the register.
  * Refer to "ibuf_ctrl_public.h" for details.
  */
-static inline void csi_rx_be_ctrl_reg_store(
-    const csi_rx_backend_ID_t ID,
-    const hrt_address reg,
-    const hrt_data value)
+static inline void csi_rx_be_ctrl_reg_store(const csi_rx_backend_ID_t ID,
+					    const hrt_address reg,
+					    const hrt_data value)
 {
 	assert(ID < N_CSI_RX_BACKEND_ID);
 	assert(CSI_RX_BE_CTRL_BASE[ID] != (hrt_address)-1);
 
-	ia_css_device_store_uint32(CSI_RX_BE_CTRL_BASE[ID] + reg * sizeof(hrt_data),
-				   value);
+	ia_css_device_store_uint32(
+		CSI_RX_BE_CTRL_BASE[ID] + reg * sizeof(hrt_data), value);
 }
 
 /* end of DLI */
@@ -92,53 +88,46 @@ static inline void csi_rx_be_ctrl_reg_store(
  * @brief Get the state of the csi rx fe dlane process.
  * Refer to "csi_rx_public.h" for details.
  */
-static inline void csi_rx_fe_ctrl_get_dlane_state(
-    const csi_rx_frontend_ID_t ID,
-    const u32 lane,
-    csi_rx_fe_ctrl_lane_t *dlane_state)
+static inline void
+csi_rx_fe_ctrl_get_dlane_state(const csi_rx_frontend_ID_t ID, const u32 lane,
+			       csi_rx_fe_ctrl_lane_t *dlane_state)
 {
-	dlane_state->termen =
-	    csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_DLY_CNT_TERMEN_DLANE_REG_IDX(lane));
-	dlane_state->settle =
-	    csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_DLY_CNT_SETTLE_DLANE_REG_IDX(lane));
+	dlane_state->termen = csi_rx_fe_ctrl_reg_load(
+		ID, _HRT_CSI_RX_DLY_CNT_TERMEN_DLANE_REG_IDX(lane));
+	dlane_state->settle = csi_rx_fe_ctrl_reg_load(
+		ID, _HRT_CSI_RX_DLY_CNT_SETTLE_DLANE_REG_IDX(lane));
 }
 
 /**
  * @brief Get the csi rx fe state.
  * Refer to "csi_rx_public.h" for details.
  */
-static inline void csi_rx_fe_ctrl_get_state(
-    const csi_rx_frontend_ID_t ID,
-    csi_rx_fe_ctrl_state_t *state)
+static inline void csi_rx_fe_ctrl_get_state(const csi_rx_frontend_ID_t ID,
+					    csi_rx_fe_ctrl_state_t *state)
 {
 	u32 i;
 
-	state->enable =
-	    csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_ENABLE_REG_IDX);
-	state->nof_enable_lanes =
-	    csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_NOF_ENABLED_LANES_REG_IDX);
+	state->enable = csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_ENABLE_REG_IDX);
+	state->nof_enable_lanes = csi_rx_fe_ctrl_reg_load(
+		ID, _HRT_CSI_RX_NOF_ENABLED_LANES_REG_IDX);
 	state->error_handling =
-	    csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_ERROR_HANDLING_REG_IDX);
-	state->status =
-	    csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_STATUS_REG_IDX);
-	state->status_dlane_hs =
-	    csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_STATUS_DLANE_HS_REG_IDX);
-	state->status_dlane_lp =
-	    csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_STATUS_DLANE_LP_REG_IDX);
-	state->clane.termen =
-	    csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_DLY_CNT_TERMEN_CLANE_REG_IDX);
-	state->clane.settle =
-	    csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_DLY_CNT_SETTLE_CLANE_REG_IDX);
+		csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_ERROR_HANDLING_REG_IDX);
+	state->status = csi_rx_fe_ctrl_reg_load(ID, _HRT_CSI_RX_STATUS_REG_IDX);
+	state->status_dlane_hs = csi_rx_fe_ctrl_reg_load(
+		ID, _HRT_CSI_RX_STATUS_DLANE_HS_REG_IDX);
+	state->status_dlane_lp = csi_rx_fe_ctrl_reg_load(
+		ID, _HRT_CSI_RX_STATUS_DLANE_LP_REG_IDX);
+	state->clane.termen = csi_rx_fe_ctrl_reg_load(
+		ID, _HRT_CSI_RX_DLY_CNT_TERMEN_CLANE_REG_IDX);
+	state->clane.settle = csi_rx_fe_ctrl_reg_load(
+		ID, _HRT_CSI_RX_DLY_CNT_SETTLE_CLANE_REG_IDX);
 
 	/*
 	 * Get the values of the register-set per
 	 * dlane.
 	 */
 	for (i = 0; i < N_CSI_RX_FE_CTRL_DLANES[ID]; i++) {
-		csi_rx_fe_ctrl_get_dlane_state(
-		    ID,
-		    i,
-		    &state->dlane[i]);
+		csi_rx_fe_ctrl_get_dlane_state(ID, i, &state->dlane[i]);
 	}
 }
 
@@ -146,37 +135,41 @@ static inline void csi_rx_fe_ctrl_get_state(
  * @brief dump the csi rx fe state.
  * Refer to "csi_rx_public.h" for details.
  */
-static inline void csi_rx_fe_ctrl_dump_state(
-    const csi_rx_frontend_ID_t ID,
-    csi_rx_fe_ctrl_state_t *state)
+static inline void csi_rx_fe_ctrl_dump_state(const csi_rx_frontend_ID_t ID,
+					     csi_rx_fe_ctrl_state_t *state)
 {
 	u32 i;
 
 	ia_css_print("CSI RX FE STATE Controller %d Enable state 0x%x\n", ID,
 		     state->enable);
-	ia_css_print("CSI RX FE STATE Controller %d No Of enable lanes 0x%x\n", ID,
-		     state->nof_enable_lanes);
+	ia_css_print("CSI RX FE STATE Controller %d No Of enable lanes 0x%x\n",
+		     ID, state->nof_enable_lanes);
 	ia_css_print("CSI RX FE STATE Controller %d Error handling 0x%x\n", ID,
 		     state->error_handling);
-	ia_css_print("CSI RX FE STATE Controller %d Status 0x%x\n", ID, state->status);
+	ia_css_print("CSI RX FE STATE Controller %d Status 0x%x\n", ID,
+		     state->status);
 	ia_css_print("CSI RX FE STATE Controller %d Status Dlane HS 0x%x\n", ID,
 		     state->status_dlane_hs);
 	ia_css_print("CSI RX FE STATE Controller %d Status Dlane LP 0x%x\n", ID,
 		     state->status_dlane_lp);
-	ia_css_print("CSI RX FE STATE Controller %d Status term enable LP 0x%x\n", ID,
-		     state->clane.termen);
-	ia_css_print("CSI RX FE STATE Controller %d Status term settle LP 0x%x\n", ID,
-		     state->clane.settle);
+	ia_css_print(
+		"CSI RX FE STATE Controller %d Status term enable LP 0x%x\n",
+		ID, state->clane.termen);
+	ia_css_print(
+		"CSI RX FE STATE Controller %d Status term settle LP 0x%x\n",
+		ID, state->clane.settle);
 
 	/*
 	 * Get the values of the register-set per
 	 * dlane.
 	 */
 	for (i = 0; i < N_CSI_RX_FE_CTRL_DLANES[ID]; i++) {
-		ia_css_print("CSI RX FE STATE Controller %d DLANE ID %d termen 0x%x\n", ID, i,
-			     state->dlane[i].termen);
-		ia_css_print("CSI RX FE STATE Controller %d DLANE ID %d settle 0x%x\n", ID, i,
-			     state->dlane[i].settle);
+		ia_css_print(
+			"CSI RX FE STATE Controller %d DLANE ID %d termen 0x%x\n",
+			ID, i, state->dlane[i].termen);
+		ia_css_print(
+			"CSI RX FE STATE Controller %d DLANE ID %d settle 0x%x\n",
+			ID, i, state->dlane[i].settle);
 	}
 }
 
@@ -184,33 +177,31 @@ static inline void csi_rx_fe_ctrl_dump_state(
  * @brief Get the csi rx be state.
  * Refer to "csi_rx_public.h" for details.
  */
-static inline void csi_rx_be_ctrl_get_state(
-    const csi_rx_backend_ID_t ID,
-    csi_rx_be_ctrl_state_t *state)
+static inline void csi_rx_be_ctrl_get_state(const csi_rx_backend_ID_t ID,
+					    csi_rx_be_ctrl_state_t *state)
 {
 	u32 i;
 
 	state->enable =
-	    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_ENABLE_REG_IDX);
+		csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_ENABLE_REG_IDX);
 
 	state->status =
-	    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_STATUS_REG_IDX);
+		csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_STATUS_REG_IDX);
 
-	for (i = 0; i < N_CSI_RX_BE_MIPI_COMP_FMT_REG ; i++) {
-		state->comp_format_reg[i] =
-		    csi_rx_be_ctrl_reg_load(ID,
-					    _HRT_MIPI_BACKEND_COMP_FORMAT_REG0_IDX + i);
+	for (i = 0; i < N_CSI_RX_BE_MIPI_COMP_FMT_REG; i++) {
+		state->comp_format_reg[i] = csi_rx_be_ctrl_reg_load(
+			ID, _HRT_MIPI_BACKEND_COMP_FORMAT_REG0_IDX + i);
 	}
 
-	state->raw16 =
-	    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_RAW16_CONFIG_REG_IDX);
+	state->raw16 = csi_rx_be_ctrl_reg_load(
+		ID, _HRT_MIPI_BACKEND_RAW16_CONFIG_REG_IDX);
 
-	state->raw18 =
-	    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_RAW18_CONFIG_REG_IDX);
-	state->force_raw8 =
-	    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_FORCE_RAW8_REG_IDX);
-	state->irq_status =
-	    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_IRQ_STATUS_REG_IDX);
+	state->raw18 = csi_rx_be_ctrl_reg_load(
+		ID, _HRT_MIPI_BACKEND_RAW18_CONFIG_REG_IDX);
+	state->force_raw8 = csi_rx_be_ctrl_reg_load(
+		ID, _HRT_MIPI_BACKEND_FORCE_RAW8_REG_IDX);
+	state->irq_status = csi_rx_be_ctrl_reg_load(
+		ID, _HRT_MIPI_BACKEND_IRQ_STATUS_REG_IDX);
 #if 0 /* device access error for these registers */
 	/* ToDo: rootcause this failure */
 	state->custom_mode_enable =
@@ -225,21 +216,21 @@ static inline void csi_rx_be_ctrl_get_state(
 	state->custom_mode_valid_eop_config =
 	    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_REG_IDX);
 #endif
-	state->global_lut_disregard_reg =
-	    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_GLOBAL_LUT_DISREGARD_REG_IDX);
-	state->packet_status_stall =
-	    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_PKT_STALL_STATUS_REG_IDX);
+	state->global_lut_disregard_reg = csi_rx_be_ctrl_reg_load(
+		ID, _HRT_MIPI_BACKEND_GLOBAL_LUT_DISREGARD_REG_IDX);
+	state->packet_status_stall = csi_rx_be_ctrl_reg_load(
+		ID, _HRT_MIPI_BACKEND_PKT_STALL_STATUS_REG_IDX);
 	/*
 	 * Get the values of the register-set per
 	 * lut.
 	 */
 	for (i = 0; i < N_SHORT_PACKET_LUT_ENTRIES[ID]; i++) {
-		state->short_packet_lut_entry[i] =
-		    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_SP_LUT_ENTRY_0_REG_IDX + i);
+		state->short_packet_lut_entry[i] = csi_rx_be_ctrl_reg_load(
+			ID, _HRT_MIPI_BACKEND_SP_LUT_ENTRY_0_REG_IDX + i);
 	}
 	for (i = 0; i < N_LONG_PACKET_LUT_ENTRIES[ID]; i++) {
-		state->long_packet_lut_entry[i] =
-		    csi_rx_be_ctrl_reg_load(ID, _HRT_MIPI_BACKEND_LP_LUT_ENTRY_0_REG_IDX + i);
+		state->long_packet_lut_entry[i] = csi_rx_be_ctrl_reg_load(
+			ID, _HRT_MIPI_BACKEND_LP_LUT_ENTRY_0_REG_IDX + i);
 	}
 }
 
@@ -247,48 +238,53 @@ static inline void csi_rx_be_ctrl_get_state(
  * @brief Dump the csi rx be state.
  * Refer to "csi_rx_public.h" for details.
  */
-static inline void csi_rx_be_ctrl_dump_state(
-    const csi_rx_backend_ID_t ID,
-    csi_rx_be_ctrl_state_t *state)
+static inline void csi_rx_be_ctrl_dump_state(const csi_rx_backend_ID_t ID,
+					     csi_rx_be_ctrl_state_t *state)
 {
 	u32 i;
 
-	ia_css_print("CSI RX BE STATE Controller %d Enable 0x%x\n", ID, state->enable);
-	ia_css_print("CSI RX BE STATE Controller %d Status 0x%x\n", ID, state->status);
+	ia_css_print("CSI RX BE STATE Controller %d Enable 0x%x\n", ID,
+		     state->enable);
+	ia_css_print("CSI RX BE STATE Controller %d Status 0x%x\n", ID,
+		     state->status);
 
-	for (i = 0; i < N_CSI_RX_BE_MIPI_COMP_FMT_REG ; i++) {
-		ia_css_print("CSI RX BE STATE Controller %d comp format reg vc%d value 0x%x\n",
-			     ID, i, state->status);
+	for (i = 0; i < N_CSI_RX_BE_MIPI_COMP_FMT_REG; i++) {
+		ia_css_print(
+			"CSI RX BE STATE Controller %d comp format reg vc%d value 0x%x\n",
+			ID, i, state->status);
 	}
-	ia_css_print("CSI RX BE STATE Controller %d RAW16 0x%x\n", ID, state->raw16);
-	ia_css_print("CSI RX BE STATE Controller %d RAW18 0x%x\n", ID, state->raw18);
+	ia_css_print("CSI RX BE STATE Controller %d RAW16 0x%x\n", ID,
+		     state->raw16);
+	ia_css_print("CSI RX BE STATE Controller %d RAW18 0x%x\n", ID,
+		     state->raw18);
 	ia_css_print("CSI RX BE STATE Controller %d Force RAW8 0x%x\n", ID,
 		     state->force_raw8);
 	ia_css_print("CSI RX BE STATE Controller %d IRQ state 0x%x\n", ID,
 		     state->irq_status);
-#if 0   /* ToDo:Getting device access error for this register */
+#if 0 /* ToDo:Getting device access error for this register */
 	for (i = 0; i < N_CSI_RX_BE_MIPI_CUSTOM_PEC ; i++) {
 		ia_css_print("CSI RX BE STATE Controller %d PEC ID %d custom pec 0x%x\n", ID, i,
 			     state->pec[i]);
 	}
 #endif
-	ia_css_print("CSI RX BE STATE Controller %d Global LUT disregard reg 0x%x\n",
-		     ID, state->global_lut_disregard_reg);
-	ia_css_print("CSI RX BE STATE Controller %d packet stall reg 0x%x\n", ID,
-		     state->packet_status_stall);
+	ia_css_print(
+		"CSI RX BE STATE Controller %d Global LUT disregard reg 0x%x\n",
+		ID, state->global_lut_disregard_reg);
+	ia_css_print("CSI RX BE STATE Controller %d packet stall reg 0x%x\n",
+		     ID, state->packet_status_stall);
 	/*
 	 * Get the values of the register-set per
 	 * lut.
 	 */
 	for (i = 0; i < N_SHORT_PACKET_LUT_ENTRIES[ID]; i++) {
-		ia_css_print("CSI RX BE STATE Controller ID %d Short packet entry %d short packet lut id 0x%x\n",
-			     ID, i,
-			     state->short_packet_lut_entry[i]);
+		ia_css_print(
+			"CSI RX BE STATE Controller ID %d Short packet entry %d short packet lut id 0x%x\n",
+			ID, i, state->short_packet_lut_entry[i]);
 	}
 	for (i = 0; i < N_LONG_PACKET_LUT_ENTRIES[ID]; i++) {
-		ia_css_print("CSI RX BE STATE Controller ID %d Long packet entry %d long packet lut id 0x%x\n",
-			     ID, i,
-			     state->long_packet_lut_entry[i]);
+		ia_css_print(
+			"CSI RX BE STATE Controller ID %d Long packet entry %d long packet lut id 0x%x\n",
+			ID, i, state->long_packet_lut_entry[i]);
 	}
 }
 
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/ibuf_ctrl.c b/drivers/staging/media/atomisp/pci/css_2401_system/host/ibuf_ctrl.c
index a99928a13e75cef51ace6c7f79cf21be6e240ace..15602378c6fd3310568cdd596a1773589dd64801 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/ibuf_ctrl.c
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/ibuf_ctrl.c
@@ -9,7 +9,7 @@
 #include "ibuf_ctrl_global.h"
 
 const u32 N_IBUF_CTRL_PROCS[N_IBUF_CTRL_ID] = {
-	8,	/* IBUF_CTRL0_ID supports at most 8 processes */
-	4,	/* IBUF_CTRL1_ID supports at most 4 processes */
-	4	/* IBUF_CTRL2_ID supports at most 4 processes */
+	8, /* IBUF_CTRL0_ID supports at most 8 processes */
+	4, /* IBUF_CTRL1_ID supports at most 4 processes */
+	4 /* IBUF_CTRL2_ID supports at most 4 processes */
 };
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/ibuf_ctrl_local.h b/drivers/staging/media/atomisp/pci/css_2401_system/host/ibuf_ctrl_local.h
index 814687251ec50c91487f0bbce9ea4e6062b823b8..8a2b4d277bda078e029882c67aec1024729f208e 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/ibuf_ctrl_local.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/ibuf_ctrl_local.h
@@ -10,8 +10,8 @@
 #include "ibuf_ctrl_global.h"
 #include "ibuf_ctrl_local.h"
 
-typedef struct ibuf_ctrl_proc_state_s	ibuf_ctrl_proc_state_t;
-typedef struct ibuf_ctrl_state_s		ibuf_ctrl_state_t;
+typedef struct ibuf_ctrl_proc_state_s ibuf_ctrl_proc_state_t;
+typedef struct ibuf_ctrl_state_s ibuf_ctrl_state_t;
 
 struct ibuf_ctrl_proc_state_s {
 	hrt_data num_items;
@@ -43,9 +43,9 @@ struct ibuf_ctrl_proc_state_s {
 };
 
 struct ibuf_ctrl_state_s {
-	hrt_data	recalc_words;
-	hrt_data	arbiters;
-	ibuf_ctrl_proc_state_t	proc_state[N_STREAM2MMIO_SID_ID];
+	hrt_data recalc_words;
+	hrt_data arbiters;
+	ibuf_ctrl_proc_state_t proc_state[N_STREAM2MMIO_SID_ID];
 };
 
 #endif /* __IBUF_CTRL_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_dma.c b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_dma.c
index dfa7edefdff864086d0ed800c41caed480626e45..19b8b68c3cf457c74c803be05a5b6ac9b0b8ce2f 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_dma.c
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_dma.c
@@ -13,14 +13,15 @@ const isys2401_dma_channel N_ISYS2401_DMA_CHANNEL_PROCS[N_ISYS2401_DMA_ID] = {
 	N_ISYS2401_DMA_CHANNEL
 };
 
-void isys2401_dma_set_max_burst_size(
-    const isys2401_dma_ID_t	dma_id,
-    uint32_t		max_burst_size)
+void isys2401_dma_set_max_burst_size(const isys2401_dma_ID_t dma_id,
+				     uint32_t max_burst_size)
 {
 	assert(dma_id < N_ISYS2401_DMA_ID);
 	assert((max_burst_size > 0x00) && (max_burst_size <= 0xFF));
 
-	isys2401_dma_reg_store(dma_id,
-			       DMA_DEV_INFO_REG_IDX(_DMA_V2_DEV_INTERF_MAX_BURST_IDX, HIVE_DMA_BUS_DDR_CONN),
-			       (max_burst_size - 1));
+	isys2401_dma_reg_store(
+		dma_id,
+		DMA_DEV_INFO_REG_IDX(_DMA_V2_DEV_INTERF_MAX_BURST_IDX,
+				     HIVE_DMA_BUS_DDR_CONN),
+		(max_burst_size - 1));
 }
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_dma_private.h b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_dma_private.h
index da51b44d48a9333421a3d34b9223ed51c85cdb29..325cc423a0ed94f030c0ff85dabd44ed2c2bcb60 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_dma_private.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_dma_private.h
@@ -14,28 +14,27 @@
 #include "dma_v2_defs.h"
 #include "print_support.h"
 
-void isys2401_dma_reg_store(const isys2401_dma_ID_t	dma_id,
-			    const unsigned int		reg,
-			    const hrt_data		value)
+void isys2401_dma_reg_store(const isys2401_dma_ID_t dma_id,
+			    const unsigned int reg, const hrt_data value)
 {
 	unsigned int reg_loc;
 
 	assert(dma_id < N_ISYS2401_DMA_ID);
-	assert(ISYS2401_DMA_BASE[dma_id] != (hrt_address) - 1);
+	assert(ISYS2401_DMA_BASE[dma_id] != (hrt_address)-1);
 
 	reg_loc = ISYS2401_DMA_BASE[dma_id] + (reg * sizeof(hrt_data));
 
 	ia_css_device_store_uint32(reg_loc, value);
 }
 
-hrt_data isys2401_dma_reg_load(const isys2401_dma_ID_t	dma_id,
-			       const unsigned int	reg)
+hrt_data isys2401_dma_reg_load(const isys2401_dma_ID_t dma_id,
+			       const unsigned int reg)
 {
 	unsigned int reg_loc;
 	hrt_data value;
 
 	assert(dma_id < N_ISYS2401_DMA_ID);
-	assert(ISYS2401_DMA_BASE[dma_id] != (hrt_address) - 1);
+	assert(ISYS2401_DMA_BASE[dma_id] != (hrt_address)-1);
 
 	reg_loc = ISYS2401_DMA_BASE[dma_id] + (reg * sizeof(hrt_data));
 
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq.c b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq.c
index 3847884e2dc07d6ad252ab3891fd8f34960d85aa..fc8880ace22505a7c40eef53f5f3fed02358e9b2 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq.c
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq.c
@@ -19,12 +19,12 @@
 #endif
 
 /* Public interface */
-void isys_irqc_status_enable(const isys_irq_ID_t	isys_irqc_id)
+void isys_irqc_status_enable(const isys_irq_ID_t isys_irqc_id)
 {
 	assert(isys_irqc_id < N_ISYS_IRQ_ID);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "Setting irq mask for port %u\n",
-			    isys_irqc_id);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "Setting irq mask for port %u\n", isys_irqc_id);
 	isys_irqc_reg_store(isys_irqc_id, ISYS_IRQ_MASK_REG_IDX,
 			    ISYS_IRQ_MASK_REG_VALUE);
 	isys_irqc_reg_store(isys_irqc_id, ISYS_IRQ_CLEAR_REG_IDX,
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq_local.h b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq_local.h
index 0c5f1094f90175fc5cfdd626cd790c802d1bc40e..237b6cbe27d1e2565fd4fcabd1b73b98eb9f24d9 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq_local.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq_local.h
@@ -17,8 +17,7 @@ struct isys_irqc_state_s {
 	hrt_data status;
 	hrt_data enable;
 	hrt_data level_no;
-	/*hrt_data clear;	*/	/* write-only register */
+	/*hrt_data clear;	*/ /* write-only register */
 };
 
-
-#endif	/* __ISYS_IRQ_LOCAL_H__ */
+#endif /* __ISYS_IRQ_LOCAL_H__ */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq_private.h b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq_private.h
index 4bd8209aaa01931fad7149471a343f4184640f10..18ee08c73a8b1456266fecb88cda948bbc9a8c98 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq_private.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_irq_private.h
@@ -10,7 +10,6 @@
 #include "isys_irq_global.h"
 #include "isys_irq_local.h"
 
-
 /* -------------------------------------------------------+
  |             Native command interface (NCI)             |
  + -------------------------------------------------------*/
@@ -19,15 +18,17 @@
 * @brief Get the isys irq status.
 * Refer to "isys_irq.h" for details.
 */
-void isys_irqc_state_get(
-    const isys_irq_ID_t	isys_irqc_id,
-    isys_irqc_state_t *state)
+void isys_irqc_state_get(const isys_irq_ID_t isys_irqc_id,
+			 isys_irqc_state_t *state)
 {
-	state->edge     = isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_EDGE_REG_IDX);
-	state->mask     = isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_MASK_REG_IDX);
-	state->status   = isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_STATUS_REG_IDX);
-	state->enable   = isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_ENABLE_REG_IDX);
-	state->level_no = isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_LEVEL_NO_REG_IDX);
+	state->edge = isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_EDGE_REG_IDX);
+	state->mask = isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_MASK_REG_IDX);
+	state->status =
+		isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_STATUS_REG_IDX);
+	state->enable =
+		isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_ENABLE_REG_IDX);
+	state->level_no =
+		isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_LEVEL_NO_REG_IDX);
 	/*
 	** Invalid to read/load from write-only register 'clear'
 	** state->clear = isys_irqc_reg_load(isys_irqc_id, ISYS_IRQ_CLEAR_REG_IDX);
@@ -38,14 +39,14 @@ void isys_irqc_state_get(
 * @brief Dump the isys irq status.
 * Refer to "isys_irq.h" for details.
 */
-void isys_irqc_state_dump(
-    const isys_irq_ID_t	isys_irqc_id,
-    const isys_irqc_state_t *state)
+void isys_irqc_state_dump(const isys_irq_ID_t isys_irqc_id,
+			  const isys_irqc_state_t *state)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "isys irq controller id %d\n\tstatus:0x%x\n\tedge:0x%x\n\tmask:0x%x\n\tenable:0x%x\n\tlevel_not_pulse:0x%x\n",
-			    isys_irqc_id,
-			    state->status, state->edge, state->mask, state->enable, state->level_no);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"isys irq controller id %d\n\tstatus:0x%x\n\tedge:0x%x\n\tmask:0x%x\n\tenable:0x%x\n\tlevel_not_pulse:0x%x\n",
+		isys_irqc_id, state->status, state->edge, state->mask,
+		state->enable, state->level_no);
 }
 
 /* end of NCI */
@@ -55,10 +56,8 @@ void isys_irqc_state_dump(
  + -------------------------------------------------------*/
 
 /* Support functions */
-void isys_irqc_reg_store(
-    const isys_irq_ID_t	isys_irqc_id,
-    const unsigned int	reg_idx,
-    const hrt_data	value)
+void isys_irqc_reg_store(const isys_irq_ID_t isys_irqc_id,
+			 const unsigned int reg_idx, const hrt_data value)
 {
 	unsigned int reg_addr;
 
@@ -67,14 +66,14 @@ void isys_irqc_reg_store(
 
 	reg_addr = ISYS_IRQ_BASE[isys_irqc_id] + (reg_idx * sizeof(hrt_data));
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "isys irq store at addr(0x%x) val(%u)\n", reg_addr, (unsigned int)value);
+			    "isys irq store at addr(0x%x) val(%u)\n", reg_addr,
+			    (unsigned int)value);
 
 	ia_css_device_store_uint32(reg_addr, value);
 }
 
-hrt_data isys_irqc_reg_load(
-    const isys_irq_ID_t	isys_irqc_id,
-    const unsigned int	reg_idx)
+hrt_data isys_irqc_reg_load(const isys_irq_ID_t isys_irqc_id,
+			    const unsigned int reg_idx)
 {
 	unsigned int reg_addr;
 	hrt_data value;
@@ -85,12 +84,12 @@ hrt_data isys_irqc_reg_load(
 	reg_addr = ISYS_IRQ_BASE[isys_irqc_id] + (reg_idx * sizeof(hrt_data));
 	value = ia_css_device_load_uint32(reg_addr);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "isys irq load from addr(0x%x) val(%u)\n", reg_addr, (unsigned int)value);
+			    "isys irq load from addr(0x%x) val(%u)\n", reg_addr,
+			    (unsigned int)value);
 
 	return value;
 }
 
 /* end of DLI */
 
-
-#endif	/* __ISYS_IRQ_PRIVATE_H__ */
+#endif /* __ISYS_IRQ_PRIVATE_H__ */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio.c b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio.c
index 21b19b4abeaa9aa67a1e9cb798e96ae79bb9c1f4..38fff9cfb74537544a85f66abafa25ecd7fe824f 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio.c
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio.c
@@ -7,7 +7,5 @@
 #include "isys_stream2mmio.h"
 
 const stream2mmio_sid_ID_t N_STREAM2MMIO_SID_PROCS[N_STREAM2MMIO_ID] = {
-	N_STREAM2MMIO_SID_ID,
-	STREAM2MMIO_SID4_ID,
-	STREAM2MMIO_SID4_ID
+	N_STREAM2MMIO_SID_ID, STREAM2MMIO_SID4_ID, STREAM2MMIO_SID4_ID
 };
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio_local.h b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio_local.h
index de985674bddd16b7edc19a032b11e40ce1ddc30b..7e3d83b325da152eae81a6a30933ec71738a73e0 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio_local.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio_local.h
@@ -9,8 +9,8 @@
 
 #include "isys_stream2mmio_global.h"
 
-typedef struct stream2mmio_state_s		stream2mmio_state_t;
-typedef struct stream2mmio_sid_state_s	stream2mmio_sid_state_t;
+typedef struct stream2mmio_state_s stream2mmio_state_t;
+typedef struct stream2mmio_sid_state_s stream2mmio_sid_state_t;
 
 struct stream2mmio_sid_state_s {
 	hrt_data rcv_ack;
@@ -23,6 +23,6 @@ struct stream2mmio_sid_state_s {
 };
 
 struct stream2mmio_state_s {
-	stream2mmio_sid_state_t	sid_state[N_STREAM2MMIO_SID_ID];
+	stream2mmio_sid_state_t sid_state[N_STREAM2MMIO_SID_ID];
 };
 #endif /* __ISYS_STREAM2MMIO_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio_private.h b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio_private.h
index 3210dd6bf9ca7bf2d5dd890699e474bb4c14e1d7..df1b924b29dcff7961dad5129aa61429dab63adf 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio_private.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/isys_stream2mmio_private.h
@@ -8,19 +8,22 @@
 #define __ISYS_STREAM2MMIO_PRIVATE_H_INCLUDED__
 
 #include "isys_stream2mmio_public.h"
-#include "device_access.h"	/* ia_css_device_load_uint32 */
-#include "assert_support.h"	/* assert */
-#include "print_support.h"	/* print */
-
-#define STREAM2MMIO_COMMAND_REG_ID             0
-#define STREAM2MMIO_ACKNOWLEDGE_REG_ID         1
-#define STREAM2MMIO_PIX_WIDTH_ID_REG_ID        2
-#define STREAM2MMIO_START_ADDR_REG_ID          3      /* master port address,NOT Byte */
-#define STREAM2MMIO_END_ADDR_REG_ID            4      /* master port address,NOT Byte */
-#define STREAM2MMIO_STRIDE_REG_ID              5      /* stride in master port words, increment is per packet for long sids, stride is not used for short sid's*/
-#define STREAM2MMIO_NUM_ITEMS_REG_ID           6      /* number of packets for store packets cmd, number of words for store_words cmd */
-#define STREAM2MMIO_BLOCK_WHEN_NO_CMD_REG_ID   7      /* if this register is 1, input will be stalled if there is no pending command for this sid */
-#define STREAM2MMIO_REGS_PER_SID               8
+#include "device_access.h" /* ia_css_device_load_uint32 */
+#include "assert_support.h" /* assert */
+#include "print_support.h" /* print */
+
+#define STREAM2MMIO_COMMAND_REG_ID 0
+#define STREAM2MMIO_ACKNOWLEDGE_REG_ID 1
+#define STREAM2MMIO_PIX_WIDTH_ID_REG_ID 2
+#define STREAM2MMIO_START_ADDR_REG_ID 3 /* master port address,NOT Byte */
+#define STREAM2MMIO_END_ADDR_REG_ID 4 /* master port address,NOT Byte */
+#define STREAM2MMIO_STRIDE_REG_ID \
+	5 /* stride in master port words, increment is per packet for long sids, stride is not used for short sid's*/
+#define STREAM2MMIO_NUM_ITEMS_REG_ID \
+	6 /* number of packets for store packets cmd, number of words for store_words cmd */
+#define STREAM2MMIO_BLOCK_WHEN_NO_CMD_REG_ID \
+	7 /* if this register is 1, input will be stalled if there is no pending command for this sid */
+#define STREAM2MMIO_REGS_PER_SID 8
 
 /*****************************************************
  *
@@ -31,9 +34,8 @@
  * @brief Get the stream2mmio-controller state.
  * Refer to "stream2mmio_public.h" for details.
  */
-STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_get_state(
-    const stream2mmio_ID_t ID,
-    stream2mmio_state_t *state)
+STORAGE_CLASS_STREAM2MMIO_C void
+stream2mmio_get_state(const stream2mmio_ID_t ID, stream2mmio_state_t *state)
 {
 	stream2mmio_sid_ID_t i;
 
@@ -50,39 +52,39 @@ STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_get_state(
  * @brief Get the state of the stream2mmio-controller sidess.
  * Refer to "stream2mmio_public.h" for details.
  */
-STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_get_sid_state(
-    const stream2mmio_ID_t ID,
-    const stream2mmio_sid_ID_t sid_id,
-    stream2mmio_sid_state_t	*state)
+STORAGE_CLASS_STREAM2MMIO_C void
+stream2mmio_get_sid_state(const stream2mmio_ID_t ID,
+			  const stream2mmio_sid_ID_t sid_id,
+			  stream2mmio_sid_state_t *state)
 {
-	state->rcv_ack =
-	    stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_ACKNOWLEDGE_REG_ID);
+	state->rcv_ack = stream2mmio_reg_load(ID, sid_id,
+					      STREAM2MMIO_ACKNOWLEDGE_REG_ID);
 
-	state->pix_width_id =
-	    stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_PIX_WIDTH_ID_REG_ID);
+	state->pix_width_id = stream2mmio_reg_load(
+		ID, sid_id, STREAM2MMIO_PIX_WIDTH_ID_REG_ID);
 
 	state->start_addr =
-	    stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_START_ADDR_REG_ID);
+		stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_START_ADDR_REG_ID);
 
 	state->end_addr =
-	    stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_END_ADDR_REG_ID);
+		stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_END_ADDR_REG_ID);
 
 	state->strides =
-	    stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_STRIDE_REG_ID);
+		stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_STRIDE_REG_ID);
 
 	state->num_items =
-	    stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_NUM_ITEMS_REG_ID);
+		stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_NUM_ITEMS_REG_ID);
 
-	state->block_when_no_cmd =
-	    stream2mmio_reg_load(ID, sid_id, STREAM2MMIO_BLOCK_WHEN_NO_CMD_REG_ID);
+	state->block_when_no_cmd = stream2mmio_reg_load(
+		ID, sid_id, STREAM2MMIO_BLOCK_WHEN_NO_CMD_REG_ID);
 }
 
 /**
  * @brief Dump the state of the stream2mmio-controller sidess.
  * Refer to "stream2mmio_public.h" for details.
  */
-STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_print_sid_state(
-    stream2mmio_sid_state_t	*state)
+STORAGE_CLASS_STREAM2MMIO_C void
+stream2mmio_print_sid_state(stream2mmio_sid_state_t *state)
 {
 	ia_css_print("\t \t Receive acks 0x%x\n", state->rcv_ack);
 	ia_css_print("\t \t Pixel width 0x%x\n", state->pix_width_id);
@@ -90,16 +92,16 @@ STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_print_sid_state(
 	ia_css_print("\t \t Endaddr 0x%x\n", state->end_addr);
 	ia_css_print("\t \t Strides 0x%x\n", state->strides);
 	ia_css_print("\t \t Num Items 0x%x\n", state->num_items);
-	ia_css_print("\t \t block when no cmd 0x%x\n", state->block_when_no_cmd);
+	ia_css_print("\t \t block when no cmd 0x%x\n",
+		     state->block_when_no_cmd);
 }
 
 /**
  * @brief Dump the ibuf-controller state.
  * Refer to "stream2mmio_public.h" for details.
  */
-STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_dump_state(
-    const stream2mmio_ID_t ID,
-    stream2mmio_state_t *state)
+STORAGE_CLASS_STREAM2MMIO_C void
+stream2mmio_dump_state(const stream2mmio_ID_t ID, stream2mmio_state_t *state)
 {
 	stream2mmio_sid_ID_t i;
 
@@ -124,10 +126,9 @@ STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_dump_state(
  * @brief Load the register value.
  * Refer to "stream2mmio_public.h" for details.
  */
-STORAGE_CLASS_STREAM2MMIO_C hrt_data stream2mmio_reg_load(
-    const stream2mmio_ID_t ID,
-    const stream2mmio_sid_ID_t sid_id,
-    const uint32_t reg_idx)
+STORAGE_CLASS_STREAM2MMIO_C hrt_data
+stream2mmio_reg_load(const stream2mmio_ID_t ID,
+		     const stream2mmio_sid_ID_t sid_id, const uint32_t reg_idx)
 {
 	u32 reg_bank_offset;
 
@@ -135,23 +136,23 @@ STORAGE_CLASS_STREAM2MMIO_C hrt_data stream2mmio_reg_load(
 
 	reg_bank_offset = STREAM2MMIO_REGS_PER_SID * sid_id;
 	return ia_css_device_load_uint32(STREAM2MMIO_CTRL_BASE[ID] +
-					 (reg_bank_offset + reg_idx) * sizeof(hrt_data));
+					 (reg_bank_offset + reg_idx) *
+						 sizeof(hrt_data));
 }
 
 /**
  * @brief Store a value to the register.
  * Refer to "stream2mmio_public.h" for details.
  */
-STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_reg_store(
-    const stream2mmio_ID_t ID,
-    const hrt_address reg,
-    const hrt_data value)
+STORAGE_CLASS_STREAM2MMIO_C void
+stream2mmio_reg_store(const stream2mmio_ID_t ID, const hrt_address reg,
+		      const hrt_data value)
 {
 	assert(ID < N_STREAM2MMIO_ID);
 	assert(STREAM2MMIO_CTRL_BASE[ID] != (hrt_address)-1);
 
-	ia_css_device_store_uint32(STREAM2MMIO_CTRL_BASE[ID] +
-				   reg * sizeof(hrt_data), value);
+	ia_css_device_store_uint32(
+		STREAM2MMIO_CTRL_BASE[ID] + reg * sizeof(hrt_data), value);
 }
 
 /* end of DLI */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/pixelgen_local.h b/drivers/staging/media/atomisp/pci/css_2401_system/host/pixelgen_local.h
index 4e091406efa990784a4ab9b5d12bae09163601aa..30103f6c6266ab939f915b26363ae9808b3adcaf 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/pixelgen_local.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/pixelgen_local.h
@@ -9,34 +9,34 @@
 
 #include "pixelgen_global.h"
 
-typedef struct pixelgen_ctrl_state_s	pixelgen_ctrl_state_t;
+typedef struct pixelgen_ctrl_state_s pixelgen_ctrl_state_t;
 struct pixelgen_ctrl_state_s {
-	hrt_data	com_enable;
-	hrt_data	prbs_rstval0;
-	hrt_data	prbs_rstval1;
-	hrt_data	syng_sid;
-	hrt_data	syng_free_run;
-	hrt_data	syng_pause;
-	hrt_data	syng_nof_frames;
-	hrt_data	syng_nof_pixels;
-	hrt_data	syng_nof_line;
-	hrt_data	syng_hblank_cyc;
-	hrt_data	syng_vblank_cyc;
-	hrt_data	syng_stat_hcnt;
-	hrt_data	syng_stat_vcnt;
-	hrt_data	syng_stat_fcnt;
-	hrt_data	syng_stat_done;
-	hrt_data	tpg_mode;
-	hrt_data	tpg_hcnt_mask;
-	hrt_data	tpg_vcnt_mask;
-	hrt_data	tpg_xycnt_mask;
-	hrt_data	tpg_hcnt_delta;
-	hrt_data	tpg_vcnt_delta;
-	hrt_data	tpg_r1;
-	hrt_data	tpg_g1;
-	hrt_data	tpg_b1;
-	hrt_data	tpg_r2;
-	hrt_data	tpg_g2;
-	hrt_data	tpg_b2;
+	hrt_data com_enable;
+	hrt_data prbs_rstval0;
+	hrt_data prbs_rstval1;
+	hrt_data syng_sid;
+	hrt_data syng_free_run;
+	hrt_data syng_pause;
+	hrt_data syng_nof_frames;
+	hrt_data syng_nof_pixels;
+	hrt_data syng_nof_line;
+	hrt_data syng_hblank_cyc;
+	hrt_data syng_vblank_cyc;
+	hrt_data syng_stat_hcnt;
+	hrt_data syng_stat_vcnt;
+	hrt_data syng_stat_fcnt;
+	hrt_data syng_stat_done;
+	hrt_data tpg_mode;
+	hrt_data tpg_hcnt_mask;
+	hrt_data tpg_vcnt_mask;
+	hrt_data tpg_xycnt_mask;
+	hrt_data tpg_hcnt_delta;
+	hrt_data tpg_vcnt_delta;
+	hrt_data tpg_r1;
+	hrt_data tpg_g1;
+	hrt_data tpg_b1;
+	hrt_data tpg_r2;
+	hrt_data tpg_g2;
+	hrt_data tpg_b2;
 };
 #endif /* __PIXELGEN_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/host/pixelgen_private.h b/drivers/staging/media/atomisp/pci/css_2401_system/host/pixelgen_private.h
index b8b98106bd318fd8950e6db57abd4a7daad7334b..f5c086da42886a6dcb49c4ea63049db9d101021d 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/host/pixelgen_private.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/host/pixelgen_private.h
@@ -8,7 +8,7 @@
 #define __PIXELGEN_PRIVATE_H_INCLUDED__
 #include "pixelgen_public.h"
 #include "PixelGen_SysBlock_defs.h"
-#include "device_access.h"	/* ia_css_device_load_uint32 */
+#include "device_access.h" /* ia_css_device_load_uint32 */
 #include "assert_support.h" /* assert */
 
 /*****************************************************
@@ -20,30 +20,28 @@
  * @brief Load the register value.
  * Refer to "pixelgen_public.h" for details.
  */
-STORAGE_CLASS_PIXELGEN_C hrt_data pixelgen_ctrl_reg_load(
-    const pixelgen_ID_t ID,
-    const hrt_address reg)
+STORAGE_CLASS_PIXELGEN_C hrt_data pixelgen_ctrl_reg_load(const pixelgen_ID_t ID,
+							 const hrt_address reg)
 {
 	assert(ID < N_PIXELGEN_ID);
-	assert(PIXELGEN_CTRL_BASE[ID] != (hrt_address) - 1);
-	return ia_css_device_load_uint32(PIXELGEN_CTRL_BASE[ID] + reg * sizeof(
-					     hrt_data));
+	assert(PIXELGEN_CTRL_BASE[ID] != (hrt_address)-1);
+	return ia_css_device_load_uint32(PIXELGEN_CTRL_BASE[ID] +
+					 reg * sizeof(hrt_data));
 }
 
 /**
  * @brief Store a value to the register.
  * Refer to "pixelgen_ctrl_public.h" for details.
  */
-STORAGE_CLASS_PIXELGEN_C void pixelgen_ctrl_reg_store(
-    const pixelgen_ID_t ID,
-    const hrt_address reg,
-    const hrt_data value)
+STORAGE_CLASS_PIXELGEN_C void pixelgen_ctrl_reg_store(const pixelgen_ID_t ID,
+						      const hrt_address reg,
+						      const hrt_data value)
 {
 	assert(ID < N_PIXELGEN_ID);
 	assert(PIXELGEN_CTRL_BASE[ID] != (hrt_address)-1);
 
-	ia_css_device_store_uint32(PIXELGEN_CTRL_BASE[ID] + reg * sizeof(hrt_data),
-				   value);
+	ia_css_device_store_uint32(
+		PIXELGEN_CTRL_BASE[ID] + reg * sizeof(hrt_data), value);
 }
 
 /* end of DLI */
@@ -57,83 +55,74 @@ STORAGE_CLASS_PIXELGEN_C void pixelgen_ctrl_reg_store(
  * @brief Get the pixelgen state.
  * Refer to "pixelgen_public.h" for details.
  */
-STORAGE_CLASS_PIXELGEN_C void pixelgen_ctrl_get_state(
-    const pixelgen_ID_t ID,
-    pixelgen_ctrl_state_t *state)
+STORAGE_CLASS_PIXELGEN_C void
+pixelgen_ctrl_get_state(const pixelgen_ID_t ID, pixelgen_ctrl_state_t *state)
 {
-	state->com_enable =
-	    pixelgen_ctrl_reg_load(ID, _PXG_COM_ENABLE_REG_IDX);
+	state->com_enable = pixelgen_ctrl_reg_load(ID, _PXG_COM_ENABLE_REG_IDX);
 	state->prbs_rstval0 =
-	    pixelgen_ctrl_reg_load(ID, _PXG_PRBS_RSTVAL_REG0_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_PRBS_RSTVAL_REG0_IDX);
 	state->prbs_rstval1 =
-	    pixelgen_ctrl_reg_load(ID, _PXG_PRBS_RSTVAL_REG1_IDX);
-	state->syng_sid =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_SID_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_PRBS_RSTVAL_REG1_IDX);
+	state->syng_sid = pixelgen_ctrl_reg_load(ID, _PXG_SYNG_SID_REG_IDX);
 	state->syng_free_run =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_FREE_RUN_REG_IDX);
-	state->syng_pause =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_PAUSE_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_SYNG_FREE_RUN_REG_IDX);
+	state->syng_pause = pixelgen_ctrl_reg_load(ID, _PXG_SYNG_PAUSE_REG_IDX);
 	state->syng_nof_frames =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_NOF_FRAME_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_SYNG_NOF_FRAME_REG_IDX);
 	state->syng_nof_pixels =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_NOF_PIXEL_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_SYNG_NOF_PIXEL_REG_IDX);
 	state->syng_nof_line =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_NOF_LINE_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_SYNG_NOF_LINE_REG_IDX);
 	state->syng_hblank_cyc =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_HBLANK_CYC_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_SYNG_HBLANK_CYC_REG_IDX);
 	state->syng_vblank_cyc =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_VBLANK_CYC_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_SYNG_VBLANK_CYC_REG_IDX);
 	state->syng_stat_hcnt =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_STAT_HCNT_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_SYNG_STAT_HCNT_REG_IDX);
 	state->syng_stat_vcnt =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_STAT_VCNT_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_SYNG_STAT_VCNT_REG_IDX);
 	state->syng_stat_fcnt =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_STAT_FCNT_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_SYNG_STAT_FCNT_REG_IDX);
 	state->syng_stat_done =
-	    pixelgen_ctrl_reg_load(ID, _PXG_SYNG_STAT_DONE_REG_IDX);
-	state->tpg_mode =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_MODE_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_SYNG_STAT_DONE_REG_IDX);
+	state->tpg_mode = pixelgen_ctrl_reg_load(ID, _PXG_TPG_MODE_REG_IDX);
 	state->tpg_hcnt_mask =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_HCNT_MASK_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_TPG_HCNT_MASK_REG_IDX);
 	state->tpg_vcnt_mask =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_VCNT_MASK_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_TPG_VCNT_MASK_REG_IDX);
 	state->tpg_xycnt_mask =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_XYCNT_MASK_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_TPG_XYCNT_MASK_REG_IDX);
 	state->tpg_hcnt_delta =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_HCNT_DELTA_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_TPG_HCNT_DELTA_REG_IDX);
 	state->tpg_vcnt_delta =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_VCNT_DELTA_REG_IDX);
-	state->tpg_r1 =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_R1_REG_IDX);
-	state->tpg_g1 =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_G1_REG_IDX);
-	state->tpg_b1 =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_B1_REG_IDX);
-	state->tpg_r2 =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_R2_REG_IDX);
-	state->tpg_g2 =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_G2_REG_IDX);
-	state->tpg_b2 =
-	    pixelgen_ctrl_reg_load(ID, _PXG_TPG_B2_REG_IDX);
+		pixelgen_ctrl_reg_load(ID, _PXG_TPG_VCNT_DELTA_REG_IDX);
+	state->tpg_r1 = pixelgen_ctrl_reg_load(ID, _PXG_TPG_R1_REG_IDX);
+	state->tpg_g1 = pixelgen_ctrl_reg_load(ID, _PXG_TPG_G1_REG_IDX);
+	state->tpg_b1 = pixelgen_ctrl_reg_load(ID, _PXG_TPG_B1_REG_IDX);
+	state->tpg_r2 = pixelgen_ctrl_reg_load(ID, _PXG_TPG_R2_REG_IDX);
+	state->tpg_g2 = pixelgen_ctrl_reg_load(ID, _PXG_TPG_G2_REG_IDX);
+	state->tpg_b2 = pixelgen_ctrl_reg_load(ID, _PXG_TPG_B2_REG_IDX);
 }
 
 /**
  * @brief Dump the pixelgen state.
  * Refer to "pixelgen_public.h" for details.
  */
-STORAGE_CLASS_PIXELGEN_C void pixelgen_ctrl_dump_state(
-    const pixelgen_ID_t ID,
-    pixelgen_ctrl_state_t *state)
+STORAGE_CLASS_PIXELGEN_C void
+pixelgen_ctrl_dump_state(const pixelgen_ID_t ID, pixelgen_ctrl_state_t *state)
 {
-	ia_css_print("Pixel Generator ID %d Enable  0x%x\n", ID, state->com_enable);
+	ia_css_print("Pixel Generator ID %d Enable  0x%x\n", ID,
+		     state->com_enable);
 	ia_css_print("Pixel Generator ID %d PRBS reset value 0 0x%x\n", ID,
 		     state->prbs_rstval0);
 	ia_css_print("Pixel Generator ID %d PRBS reset value 1 0x%x\n", ID,
 		     state->prbs_rstval1);
-	ia_css_print("Pixel Generator ID %d SYNC SID 0x%x\n", ID, state->syng_sid);
+	ia_css_print("Pixel Generator ID %d SYNC SID 0x%x\n", ID,
+		     state->syng_sid);
 	ia_css_print("Pixel Generator ID %d syng free run 0x%x\n", ID,
 		     state->syng_free_run);
-	ia_css_print("Pixel Generator ID %d syng pause 0x%x\n", ID, state->syng_pause);
+	ia_css_print("Pixel Generator ID %d syng pause 0x%x\n", ID,
+		     state->syng_pause);
 	ia_css_print("Pixel Generator ID %d syng no of frames 0x%x\n", ID,
 		     state->syng_nof_frames);
 	ia_css_print("Pixel Generator ID %d syng no of pixels 0x%x\n", ID,
@@ -152,7 +141,8 @@ STORAGE_CLASS_PIXELGEN_C void pixelgen_ctrl_dump_state(
 		     state->syng_stat_fcnt);
 	ia_css_print("Pixel Generator ID %d syng stat done  0x%x\n", ID,
 		     state->syng_stat_done);
-	ia_css_print("Pixel Generator ID %d tpg mode  0x%x\n", ID, state->tpg_mode);
+	ia_css_print("Pixel Generator ID %d tpg mode  0x%x\n", ID,
+		     state->tpg_mode);
 	ia_css_print("Pixel Generator ID %d tpg hcnt mask  0x%x\n", ID,
 		     state->tpg_hcnt_mask);
 	ia_css_print("Pixel Generator ID %d tpg hcnt mask  0x%x\n", ID,
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/PixelGen_SysBlock_defs.h b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/PixelGen_SysBlock_defs.h
index 323925ba297179ce6c115b02f864100dc0b56858..01af6420b4fe6bc15f1c343c45a9e76ba51f2497 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/PixelGen_SysBlock_defs.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/PixelGen_SysBlock_defs.h
@@ -8,62 +8,62 @@
 #define _PixelGen_SysBlock_defs_h
 
 /* Parematers and User_Parameters for HSS */
-#define _PXG_PPC                       Ppc
-#define _PXG_PIXEL_BITS                PixelWidth
-#define _PXG_MAX_NOF_SID               MaxNofSids
-#define _PXG_DATA_BITS                 DataWidth
-#define _PXG_CNT_BITS                  CntWidth
-#define _PXG_FIFODEPTH                 FifoDepth
-#define _PXG_DBG                       Dbg_device_not_included
+#define _PXG_PPC Ppc
+#define _PXG_PIXEL_BITS PixelWidth
+#define _PXG_MAX_NOF_SID MaxNofSids
+#define _PXG_DATA_BITS DataWidth
+#define _PXG_CNT_BITS CntWidth
+#define _PXG_FIFODEPTH FifoDepth
+#define _PXG_DBG Dbg_device_not_included
 
 /* ID's and Address */
-#define _PXG_ADRRESS_ALIGN_REG         4
+#define _PXG_ADRRESS_ALIGN_REG 4
 
-#define _PXG_COM_ENABLE_REG_IDX        0
-#define _PXG_PRBS_RSTVAL_REG0_IDX      1
-#define _PXG_PRBS_RSTVAL_REG1_IDX      2
-#define _PXG_SYNG_SID_REG_IDX          3
-#define _PXG_SYNG_FREE_RUN_REG_IDX     4
-#define _PXG_SYNG_PAUSE_REG_IDX        5
-#define _PXG_SYNG_NOF_FRAME_REG_IDX    6
-#define _PXG_SYNG_NOF_PIXEL_REG_IDX    7
-#define _PXG_SYNG_NOF_LINE_REG_IDX     8
-#define _PXG_SYNG_HBLANK_CYC_REG_IDX   9
-#define _PXG_SYNG_VBLANK_CYC_REG_IDX  10
-#define _PXG_SYNG_STAT_HCNT_REG_IDX   11
-#define _PXG_SYNG_STAT_VCNT_REG_IDX   12
-#define _PXG_SYNG_STAT_FCNT_REG_IDX   13
-#define _PXG_SYNG_STAT_DONE_REG_IDX   14
-#define _PXG_TPG_MODE_REG_IDX         15
-#define _PXG_TPG_HCNT_MASK_REG_IDX    16
-#define _PXG_TPG_VCNT_MASK_REG_IDX    17
-#define _PXG_TPG_XYCNT_MASK_REG_IDX   18
-#define _PXG_TPG_HCNT_DELTA_REG_IDX   19
-#define _PXG_TPG_VCNT_DELTA_REG_IDX   20
-#define _PXG_TPG_R1_REG_IDX           21
-#define _PXG_TPG_G1_REG_IDX           22
-#define _PXG_TPG_B1_REG_IDX           23
-#define _PXG_TPG_R2_REG_IDX           24
-#define _PXG_TPG_G2_REG_IDX           25
-#define _PXG_TPG_B2_REG_IDX           26
+#define _PXG_COM_ENABLE_REG_IDX 0
+#define _PXG_PRBS_RSTVAL_REG0_IDX 1
+#define _PXG_PRBS_RSTVAL_REG1_IDX 2
+#define _PXG_SYNG_SID_REG_IDX 3
+#define _PXG_SYNG_FREE_RUN_REG_IDX 4
+#define _PXG_SYNG_PAUSE_REG_IDX 5
+#define _PXG_SYNG_NOF_FRAME_REG_IDX 6
+#define _PXG_SYNG_NOF_PIXEL_REG_IDX 7
+#define _PXG_SYNG_NOF_LINE_REG_IDX 8
+#define _PXG_SYNG_HBLANK_CYC_REG_IDX 9
+#define _PXG_SYNG_VBLANK_CYC_REG_IDX 10
+#define _PXG_SYNG_STAT_HCNT_REG_IDX 11
+#define _PXG_SYNG_STAT_VCNT_REG_IDX 12
+#define _PXG_SYNG_STAT_FCNT_REG_IDX 13
+#define _PXG_SYNG_STAT_DONE_REG_IDX 14
+#define _PXG_TPG_MODE_REG_IDX 15
+#define _PXG_TPG_HCNT_MASK_REG_IDX 16
+#define _PXG_TPG_VCNT_MASK_REG_IDX 17
+#define _PXG_TPG_XYCNT_MASK_REG_IDX 18
+#define _PXG_TPG_HCNT_DELTA_REG_IDX 19
+#define _PXG_TPG_VCNT_DELTA_REG_IDX 20
+#define _PXG_TPG_R1_REG_IDX 21
+#define _PXG_TPG_G1_REG_IDX 22
+#define _PXG_TPG_B1_REG_IDX 23
+#define _PXG_TPG_R2_REG_IDX 24
+#define _PXG_TPG_G2_REG_IDX 25
+#define _PXG_TPG_B2_REG_IDX 26
 /* */
-#define _PXG_SYNG_PAUSE_CYCLES        0
+#define _PXG_SYNG_PAUSE_CYCLES 0
 /* Subblock ID's */
-#define _PXG_DISABLE_IDX              0
-#define _PXG_PRBS_IDX                 0
-#define _PXG_TPG_IDX                  1
-#define _PXG_SYNG_IDX                 2
-#define _PXG_SMUX_IDX                 3
+#define _PXG_DISABLE_IDX 0
+#define _PXG_PRBS_IDX 0
+#define _PXG_TPG_IDX 1
+#define _PXG_SYNG_IDX 2
+#define _PXG_SMUX_IDX 3
 /* Register Widths */
-#define _PXG_COM_ENABLE_REG_WIDTH     2
-#define _PXG_COM_SRST_REG_WIDTH       4
-#define _PXG_PRBS_RSTVAL_REG0_WIDTH  31
-#define _PXG_PRBS_RSTVAL_REG1_WIDTH  31
+#define _PXG_COM_ENABLE_REG_WIDTH 2
+#define _PXG_COM_SRST_REG_WIDTH 4
+#define _PXG_PRBS_RSTVAL_REG0_WIDTH 31
+#define _PXG_PRBS_RSTVAL_REG1_WIDTH 31
 
-#define _PXG_SYNG_SID_REG_WIDTH        3
+#define _PXG_SYNG_SID_REG_WIDTH 3
 
-#define _PXG_SYNG_FREE_RUN_REG_WIDTH   1
-#define _PXG_SYNG_PAUSE_REG_WIDTH      1
+#define _PXG_SYNG_FREE_RUN_REG_WIDTH 1
+#define _PXG_SYNG_PAUSE_REG_WIDTH 1
 /*
 #define _PXG_SYNG_NOF_FRAME_REG_WIDTH  <sync_gen_cnt_width>
 #define _PXG_SYNG_NOF_PIXEL_REG_WIDTH  <sync_gen_cnt_width>
@@ -74,15 +74,15 @@
 #define _PXG_SYNG_STAT_VCNT_REG_WIDTH  <sync_gen_cnt_width>
 #define _PXG_SYNG_STAT_FCNT_REG_WIDTH  <sync_gen_cnt_width>
 */
-#define _PXG_SYNG_STAT_DONE_REG_WIDTH  1
-#define _PXG_TPG_MODE_REG_WIDTH        2
+#define _PXG_SYNG_STAT_DONE_REG_WIDTH 1
+#define _PXG_TPG_MODE_REG_WIDTH 2
 /*
 #define _PXG_TPG_HCNT_MASK_REG_WIDTH   <sync_gen_cnt_width>
 #define _PXG_TPG_VCNT_MASK_REG_WIDTH   <sync_gen_cnt_width>
 #define _PXG_TPG_XYCNT_MASK_REG_WIDTH  <pixle_width>
 */
-#define _PXG_TPG_HCNT_DELTA_REG_WIDTH  4
-#define _PXG_TPG_VCNT_DELTA_REG_WIDTH  4
+#define _PXG_TPG_HCNT_DELTA_REG_WIDTH 4
+#define _PXG_TPG_VCNT_DELTA_REG_WIDTH 4
 /*
 #define _PXG_TPG_R1_REG_WIDTH          <pixle_width>
 #define _PXG_TPG_G1_REG_WIDTH          <pixle_width>
@@ -91,15 +91,15 @@
 #define _PXG_TPG_G2_REG_WIDTH          <pixle_width>
 #define _PXG_TPG_B2_REG_WIDTH          <pixle_width>
 */
-#define _PXG_FIFO_DEPTH                2
+#define _PXG_FIFO_DEPTH 2
 /* MISC */
-#define _PXG_ENABLE_REG_VAL            1
-#define _PXG_PRBS_ENABLE_REG_VAL       1
-#define _PXG_TPG_ENABLE_REG_VAL        2
-#define _PXG_SYNG_ENABLE_REG_VAL       4
-#define _PXG_FIFO_ENABLE_REG_VAL       8
-#define _PXG_PXL_BITS                 14
-#define _PXG_INVALID_FLAG              0xDEADBEEF
-#define _PXG_CAFE_FLAG                 0xCAFEBABE
+#define _PXG_ENABLE_REG_VAL 1
+#define _PXG_PRBS_ENABLE_REG_VAL 1
+#define _PXG_TPG_ENABLE_REG_VAL 2
+#define _PXG_SYNG_ENABLE_REG_VAL 4
+#define _PXG_FIFO_ENABLE_REG_VAL 8
+#define _PXG_PXL_BITS 14
+#define _PXG_INVALID_FLAG 0xDEADBEEF
+#define _PXG_CAFE_FLAG 0xCAFEBABE
 
 #endif /* _PixelGen_SysBlock_defs_h */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/ibuf_cntrl_defs.h b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/ibuf_cntrl_defs.h
index a41e2b957bd17949cf7227040f4a3511cbb7c6f7..c704dc65ca16a25c936745bebceadbbb17da27d0 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/ibuf_cntrl_defs.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/ibuf_cntrl_defs.h
@@ -12,115 +12,122 @@
 
 #define _IBUF_CNTRL_REG_ALIGN 4
 /* alignment of register banks, first bank are shared configuration and status registers: */
-#define _IBUF_CNTRL_PROC_REG_ALIGN        32
+#define _IBUF_CNTRL_PROC_REG_ALIGN 32
 
 /* the actual amount of configuration registers per proc: */
 #define _IBUF_CNTRL_CONFIG_REGS_PER_PROC 18
 /* the actual amount of shared configuration registers: */
-#define _IBUF_CNTRL_CONFIG_REGS_NO_PROC  0
+#define _IBUF_CNTRL_CONFIG_REGS_NO_PROC 0
 
 /* the actual amount of status registers per proc */
 #define _IBUF_CNTRL_STATUS_REGS_PER_PROC (_IBUF_CNTRL_CONFIG_REGS_PER_PROC + 10)
 /* the actual amount shared status registers */
-#define _IBUF_CNTRL_STATUS_REGS_NO_PROC  (_IBUF_CNTRL_CONFIG_REGS_NO_PROC + 2)
+#define _IBUF_CNTRL_STATUS_REGS_NO_PROC (_IBUF_CNTRL_CONFIG_REGS_NO_PROC + 2)
 
 /* time out bits, maximum time out value is 2^_IBUF_CNTRL_TIME_OUT_BITS - 1 */
-#define _IBUF_CNTRL_TIME_OUT_BITS         5
+#define _IBUF_CNTRL_TIME_OUT_BITS 5
 
 /* command token definition */
-#define _IBUF_CNTRL_CMD_TOKEN_LSB          0
-#define _IBUF_CNTRL_CMD_TOKEN_MSB          1
+#define _IBUF_CNTRL_CMD_TOKEN_LSB 0
+#define _IBUF_CNTRL_CMD_TOKEN_MSB 1
 
 /* Str2MMIO defines */
-#define _IBUF_CNTRL_STREAM2MMIO_CMD_TOKEN_MSB        _STREAM2MMIO_CMD_TOKEN_CMD_MSB
-#define _IBUF_CNTRL_STREAM2MMIO_CMD_TOKEN_LSB        _STREAM2MMIO_CMD_TOKEN_CMD_LSB
-#define _IBUF_CNTRL_STREAM2MMIO_NUM_ITEMS_BITS       _STREAM2MMIO_PACK_NUM_ITEMS_BITS
-#define _IBUF_CNTRL_STREAM2MMIO_ACK_EOF_BIT          _STREAM2MMIO_PACK_ACK_EOF_BIT
-#define _IBUF_CNTRL_STREAM2MMIO_ACK_TOKEN_VALID_BIT  _STREAM2MMIO_ACK_TOKEN_VALID_BIT
+#define _IBUF_CNTRL_STREAM2MMIO_CMD_TOKEN_MSB _STREAM2MMIO_CMD_TOKEN_CMD_MSB
+#define _IBUF_CNTRL_STREAM2MMIO_CMD_TOKEN_LSB _STREAM2MMIO_CMD_TOKEN_CMD_LSB
+#define _IBUF_CNTRL_STREAM2MMIO_NUM_ITEMS_BITS _STREAM2MMIO_PACK_NUM_ITEMS_BITS
+#define _IBUF_CNTRL_STREAM2MMIO_ACK_EOF_BIT _STREAM2MMIO_PACK_ACK_EOF_BIT
+#define _IBUF_CNTRL_STREAM2MMIO_ACK_TOKEN_VALID_BIT \
+	_STREAM2MMIO_ACK_TOKEN_VALID_BIT
 
 /* acknowledge token definition */
-#define _IBUF_CNTRL_ACK_TOKEN_STORES_IDX    0
-#define _IBUF_CNTRL_ACK_TOKEN_STORES_BITS   15
-#define _IBUF_CNTRL_ACK_TOKEN_ITEMS_IDX     (_IBUF_CNTRL_ACK_TOKEN_STORES_BITS + _IBUF_CNTRL_ACK_TOKEN_STORES_IDX)
-#define _IBUF_CNTRL_ACK_TOKEN_ITEMS_BITS    _STREAM2MMIO_PACK_NUM_ITEMS_BITS
-#define _IBUF_CNTRL_ACK_TOKEN_LSB          _IBUF_CNTRL_ACK_TOKEN_STORES_IDX
-#define _IBUF_CNTRL_ACK_TOKEN_MSB          (_IBUF_CNTRL_ACK_TOKEN_ITEMS_BITS + _IBUF_CNTRL_ACK_TOKEN_ITEMS_IDX - 1)
+#define _IBUF_CNTRL_ACK_TOKEN_STORES_IDX 0
+#define _IBUF_CNTRL_ACK_TOKEN_STORES_BITS 15
+#define _IBUF_CNTRL_ACK_TOKEN_ITEMS_IDX \
+	(_IBUF_CNTRL_ACK_TOKEN_STORES_BITS + _IBUF_CNTRL_ACK_TOKEN_STORES_IDX)
+#define _IBUF_CNTRL_ACK_TOKEN_ITEMS_BITS _STREAM2MMIO_PACK_NUM_ITEMS_BITS
+#define _IBUF_CNTRL_ACK_TOKEN_LSB _IBUF_CNTRL_ACK_TOKEN_STORES_IDX
+#define _IBUF_CNTRL_ACK_TOKEN_MSB \
+	(_IBUF_CNTRL_ACK_TOKEN_ITEMS_BITS + _IBUF_CNTRL_ACK_TOKEN_ITEMS_IDX - 1)
 /* bit 31 indicates a valid ack: */
-#define _IBUF_CNTRL_ACK_TOKEN_VALID_BIT    (_IBUF_CNTRL_ACK_TOKEN_ITEMS_BITS + _IBUF_CNTRL_ACK_TOKEN_ITEMS_IDX)
+#define _IBUF_CNTRL_ACK_TOKEN_VALID_BIT \
+	(_IBUF_CNTRL_ACK_TOKEN_ITEMS_BITS + _IBUF_CNTRL_ACK_TOKEN_ITEMS_IDX)
 
 /*shared registers:*/
-#define _IBUF_CNTRL_RECALC_WORDS_STATUS     0
-#define _IBUF_CNTRL_ARBITERS_STATUS         1
+#define _IBUF_CNTRL_RECALC_WORDS_STATUS 0
+#define _IBUF_CNTRL_ARBITERS_STATUS 1
 
-#define _IBUF_CNTRL_SET_CRUN                2 /* NO PHYSICAL REGISTER!! Only used in HSS model */
+#define _IBUF_CNTRL_SET_CRUN \
+	2 /* NO PHYSICAL REGISTER!! Only used in HSS model */
 
 /*register addresses for each proc: */
-#define _IBUF_CNTRL_CMD                   0
-#define _IBUF_CNTRL_ACK                   1
+#define _IBUF_CNTRL_CMD 0
+#define _IBUF_CNTRL_ACK 1
 
 /* number of items (packets or words) per frame: */
-#define _IBUF_CNTRL_NUM_ITEMS_PER_STORE   2
+#define _IBUF_CNTRL_NUM_ITEMS_PER_STORE 2
 
 /* number of stores (packets or words) per store/buffer: */
-#define _IBUF_CNTRL_NUM_STORES_PER_FRAME  3
+#define _IBUF_CNTRL_NUM_STORES_PER_FRAME 3
 
 /* the channel and command in the DMA */
-#define _IBUF_CNTRL_DMA_CHANNEL           4
-#define _IBUF_CNTRL_DMA_CMD               5
+#define _IBUF_CNTRL_DMA_CHANNEL 4
+#define _IBUF_CNTRL_DMA_CMD 5
 
 /* the start address and stride of the buffers */
-#define _IBUF_CNTRL_BUFFER_START_ADDRESS  6
-#define _IBUF_CNTRL_BUFFER_STRIDE         7
-#define _IBUF_CNTRL_BUFFER_END_ADDRESS    8
+#define _IBUF_CNTRL_BUFFER_START_ADDRESS 6
+#define _IBUF_CNTRL_BUFFER_STRIDE 7
+#define _IBUF_CNTRL_BUFFER_END_ADDRESS 8
 
 /* destination start address, stride and end address; should be the same as in the DMA */
-#define _IBUF_CNTRL_DEST_START_ADDRESS    9
-#define _IBUF_CNTRL_DEST_STRIDE           10
-#define _IBUF_CNTRL_DEST_END_ADDRESS      11
+#define _IBUF_CNTRL_DEST_START_ADDRESS 9
+#define _IBUF_CNTRL_DEST_STRIDE 10
+#define _IBUF_CNTRL_DEST_END_ADDRESS 11
 
 /* send a frame sync or not, default 1 */
-#define _IBUF_CNTRL_SYNC_FRAME            12
+#define _IBUF_CNTRL_SYNC_FRAME 12
 
 /* str2mmio cmds */
-#define _IBUF_CNTRL_STR2MMIO_SYNC_CMD     13
-#define _IBUF_CNTRL_STR2MMIO_STORE_CMD    14
+#define _IBUF_CNTRL_STR2MMIO_SYNC_CMD 13
+#define _IBUF_CNTRL_STR2MMIO_STORE_CMD 14
 
 /* num elems p word*/
-#define _IBUF_CNTRL_SHIFT_ITEMS           15
-#define _IBUF_CNTRL_ELEMS_P_WORD_IBUF     16
-#define _IBUF_CNTRL_ELEMS_P_WORD_DEST     17
+#define _IBUF_CNTRL_SHIFT_ITEMS 15
+#define _IBUF_CNTRL_ELEMS_P_WORD_IBUF 16
+#define _IBUF_CNTRL_ELEMS_P_WORD_DEST 17
 
 /* STATUS */
 /* current frame and stores in buffer */
-#define _IBUF_CNTRL_CUR_STORES            18
-#define _IBUF_CNTRL_CUR_ACKS              19
+#define _IBUF_CNTRL_CUR_STORES 18
+#define _IBUF_CNTRL_CUR_ACKS 19
 
 /* current buffer and destination address for DMA cmd's */
-#define _IBUF_CNTRL_CUR_S2M_IBUF_ADDR     20
-#define _IBUF_CNTRL_CUR_DMA_IBUF_ADDR     21
-#define _IBUF_CNTRL_CUR_DMA_DEST_ADDR     22
-#define _IBUF_CNTRL_CUR_ISP_DEST_ADDR     23
+#define _IBUF_CNTRL_CUR_S2M_IBUF_ADDR 20
+#define _IBUF_CNTRL_CUR_DMA_IBUF_ADDR 21
+#define _IBUF_CNTRL_CUR_DMA_DEST_ADDR 22
+#define _IBUF_CNTRL_CUR_ISP_DEST_ADDR 23
 
-#define _IBUF_CNTRL_CUR_NR_DMA_CMDS_SEND  24
+#define _IBUF_CNTRL_CUR_NR_DMA_CMDS_SEND 24
 
-#define _IBUF_CNTRL_MAIN_CNTRL_STATE      25
-#define _IBUF_CNTRL_DMA_SYNC_STATE        26
-#define _IBUF_CNTRL_ISP_SYNC_STATE        27
+#define _IBUF_CNTRL_MAIN_CNTRL_STATE 25
+#define _IBUF_CNTRL_DMA_SYNC_STATE 26
+#define _IBUF_CNTRL_ISP_SYNC_STATE 27
 
 /*Commands: */
-#define _IBUF_CNTRL_CMD_STORE_FRAME_IDX     0
-#define _IBUF_CNTRL_CMD_ONLINE_IDX          1
+#define _IBUF_CNTRL_CMD_STORE_FRAME_IDX 0
+#define _IBUF_CNTRL_CMD_ONLINE_IDX 1
 
 /* initialize, copy st_addr to cur_addr etc */
-#define _IBUF_CNTRL_CMD_INITIALIZE          0
+#define _IBUF_CNTRL_CMD_INITIALIZE 0
 
 /* store an online frame (sync with ISP, use end cfg start, stride and end address: */
-#define _IBUF_CNTRL_CMD_STORE_ONLINE_FRAME  ((1 << _IBUF_CNTRL_CMD_STORE_FRAME_IDX) | (1 << _IBUF_CNTRL_CMD_ONLINE_IDX))
+#define _IBUF_CNTRL_CMD_STORE_ONLINE_FRAME        \
+	((1 << _IBUF_CNTRL_CMD_STORE_FRAME_IDX) | \
+	 (1 << _IBUF_CNTRL_CMD_ONLINE_IDX))
 
 /* store an offline frame (don't sync with ISP, requires start address as 2nd token, no end address: */
-#define _IBUF_CNTRL_CMD_STORE_OFFLINE_FRAME  BIT(_IBUF_CNTRL_CMD_STORE_FRAME_IDX)
+#define _IBUF_CNTRL_CMD_STORE_OFFLINE_FRAME BIT(_IBUF_CNTRL_CMD_STORE_FRAME_IDX)
 
 /* false command token, should be different then commands. Use online bit, not store frame: */
-#define _IBUF_CNTRL_FALSE_ACK               2
+#define _IBUF_CNTRL_FALSE_ACK 2
 
 #endif
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/mipi_backend_common_defs.h b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/mipi_backend_common_defs.h
index bc7639adcd8dadb873d945fa025852e37b6276cf..a79753fb53683f83e1be7d1a7f4451a5b0b17e35 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/mipi_backend_common_defs.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/mipi_backend_common_defs.h
@@ -9,149 +9,195 @@
 #ifndef _mipi_backend_common_defs_h_
 #define _mipi_backend_common_defs_h_
 
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH     16
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH     2
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH  3
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_REAL_WIDTH (_HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH + _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH + _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH)
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_WIDTH      32 /* use 32 to be compatibel with streaming monitor !, MSB's of interface are tied to '0' */
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH 16
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH 2
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH 3
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_REAL_WIDTH \
+	(_HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH +  \
+	 _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH + \
+	 _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_WIDTH \
+	32 /* use 32 to be compatibel with streaming monitor !, MSB's of interface are tied to '0' */
 
 /* Definition of data format ID at the interface CSS_receiver capture/acquisition units */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8          24   /* 01 1000 YUV420 8-bit                                        */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10         25   /* 01 1001  YUV420 10-bit                                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8L         26   /* 01 1010   YUV420 8-bit legacy                               */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_8          30   /* 01 1110   YUV422 8-bit                                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_10         31   /* 01 1111   YUV422 10-bit                                     */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB444            32   /* 10 0000   RGB444                                            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB555            33   /* 10 0001   RGB555                                            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB565            34   /* 10 0010   RGB565                                            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB666            35   /* 10 0011   RGB666                                            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB888            36   /* 10 0100   RGB888                                            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW6              40   /* 10 1000   RAW6                                              */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW7              41   /* 10 1001   RAW7                                              */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW8              42   /* 10 1010   RAW8                                              */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW10             43   /* 10 1011   RAW10                                             */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW12             44   /* 10 1100   RAW12                                             */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW14             45   /* 10 1101   RAW14                                             */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_1         48   /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_2         49   /* 11 0001    User Defined 8-bit Data Type 2                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_3         50   /* 11 0010    User Defined 8-bit Data Type 3                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_4         51   /* 11 0011    User Defined 8-bit Data Type 4                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_5         52   /* 11 0100    User Defined 8-bit Data Type 5                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_6         53   /* 11 0101    User Defined 8-bit Data Type 6                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_7         54   /* 11 0110    User Defined 8-bit Data Type 7                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_8         55   /* 11 0111    User Defined 8-bit Data Type 8                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_Emb               18   /* 01 0010    embedded eight bit non image data                */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOF                0   /* 00 0000    frame start                                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOF                1   /* 00 0001    frame end                                        */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOL                2   /* 00 0010    line start                                       */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOL                3   /* 00 0011    line end                                         */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH1            8   /* 00 1000  Generic Short Packet Code 1                        */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH2            9   /* 00 1001    Generic Short Packet Code 2                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH3           10   /* 00 1010    Generic Short Packet Code 3                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH4           11   /* 00 1011    Generic Short Packet Code 4                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH5           12   /* 00 1100    Generic Short Packet Code 5                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH6           13   /* 00 1101    Generic Short Packet Code 6                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH7           14   /* 00 1110    Generic Short Packet Code 7                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH8           15   /* 00 1111    Generic Short Packet Code 8                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8_CSPS     28   /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10_CSPS    29   /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8 \
+	24 /* 01 1000 YUV420 8-bit                                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10 \
+	25 /* 01 1001  YUV420 10-bit                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8L \
+	26 /* 01 1010   YUV420 8-bit legacy                               */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_8 \
+	30 /* 01 1110   YUV422 8-bit                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_10 \
+	31 /* 01 1111   YUV422 10-bit                                     */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB444 \
+	32 /* 10 0000   RGB444                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB555 \
+	33 /* 10 0001   RGB555                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB565 \
+	34 /* 10 0010   RGB565                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB666 \
+	35 /* 10 0011   RGB666                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB888 \
+	36 /* 10 0100   RGB888                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW6 \
+	40 /* 10 1000   RAW6                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW7 \
+	41 /* 10 1001   RAW7                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW8 \
+	42 /* 10 1010   RAW8                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW10 \
+	43 /* 10 1011   RAW10                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW12 \
+	44 /* 10 1100   RAW12                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW14 \
+	45 /* 10 1101   RAW14                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_1 \
+	48 /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_2 \
+	49 /* 11 0001    User Defined 8-bit Data Type 2                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_3 \
+	50 /* 11 0010    User Defined 8-bit Data Type 3                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_4 \
+	51 /* 11 0011    User Defined 8-bit Data Type 4                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_5 \
+	52 /* 11 0100    User Defined 8-bit Data Type 5                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_6 \
+	53 /* 11 0101    User Defined 8-bit Data Type 6                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_7 \
+	54 /* 11 0110    User Defined 8-bit Data Type 7                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_8 \
+	55 /* 11 0111    User Defined 8-bit Data Type 8                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_Emb \
+	18 /* 01 0010    embedded eight bit non image data                */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOF \
+	0 /* 00 0000    frame start                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOF \
+	1 /* 00 0001    frame end                                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOL \
+	2 /* 00 0010    line start                                       */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOL \
+	3 /* 00 0011    line end                                         */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH1 \
+	8 /* 00 1000  Generic Short Packet Code 1                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH2 \
+	9 /* 00 1001    Generic Short Packet Code 2                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH3 \
+	10 /* 00 1010    Generic Short Packet Code 3                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH4 \
+	11 /* 00 1011    Generic Short Packet Code 4                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH5 \
+	12 /* 00 1100    Generic Short Packet Code 5                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH6 \
+	13 /* 00 1101    Generic Short Packet Code 6                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH7 \
+	14 /* 00 1110    Generic Short Packet Code 7                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH8 \
+	15 /* 00 1111    Generic Short Packet Code 8                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8_CSPS \
+	28 /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10_CSPS \
+	29 /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
 /* used reserved mipi positions for these */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW16             46
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18             47
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_2           37
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_3           38
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW16 46
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18 47
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_2 37
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_3 38
 
 //_HRT_CSS_RECEIVER_2400_FMT_TYPE_CUSTOM 63
-#define _HRT_MIPI_BACKEND_FMT_TYPE_CUSTOM                       63
+#define _HRT_MIPI_BACKEND_FMT_TYPE_CUSTOM 63
 
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_WIDTH              6
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_WIDTH 6
 
 /* Definition of format_types at the interface CSS --> input_selector*/
 /* !! Changes here should be copied to systems/isp/isp_css/bin/conv_transmitter_cmd.tcl !! */
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB888           0  // 36 'h24
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB555           1  // 33 'h
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB444           2  // 32
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB565           3  // 34
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB666           4  // 35
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW8             5  // 42
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW10            6  // 43
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW6             7  // 40
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW7             8  // 41
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW12            9  // 43
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW14           10  // 45
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8        11  // 30
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10       12  // 25
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_8        13  // 30
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_10       14  // 31
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_1       15  // 48
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8L       16  // 26
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_Emb             17  // 18
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_2       18  // 49
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_3       19  // 50
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_4       20  // 51
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_5       21  // 52
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_6       22  // 53
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_7       23  // 54
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_8       24  // 55
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8_CSPS   25  // 28
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10_CSPS  26  // 29
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW16           27  // ?
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18           28  // ?
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_2         29  // ? Option 2 for depacketiser
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_3         30  // ? Option 3 for depacketiser
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_CUSTOM          31  // to signal custom decoding
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB888 0 // 36 'h24
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB555 1 // 33 'h
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB444 2 // 32
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB565 3 // 34
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB666 4 // 35
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW8 5 // 42
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW10 6 // 43
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW6 7 // 40
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW7 8 // 41
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW12 9 // 43
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW14 10 // 45
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8 11 // 30
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10 12 // 25
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_8 13 // 30
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_10 14 // 31
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_1 15 // 48
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8L 16 // 26
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_Emb 17 // 18
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_2 18 // 49
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_3 19 // 50
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_4 20 // 51
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_5 21 // 52
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_6 22 // 53
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_7 23 // 54
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_8 24 // 55
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8_CSPS 25 // 28
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10_CSPS 26 // 29
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW16 27 // ?
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18 28 // ?
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_2 \
+	29 // ? Option 2 for depacketiser
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_3 \
+	30 // ? Option 3 for depacketiser
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_CUSTOM 31 // to signal custom decoding
 
 /* definition for state machine of data FIFO for decode different type of data */
-#define _HRT_CSS_RECEIVER_2400_YUV420_8_REPEAT_PTN                 1
-#define _HRT_CSS_RECEIVER_2400_YUV420_10_REPEAT_PTN                5
-#define _HRT_CSS_RECEIVER_2400_YUV420_8L_REPEAT_PTN                1
-#define _HRT_CSS_RECEIVER_2400_YUV422_8_REPEAT_PTN                 1
-#define _HRT_CSS_RECEIVER_2400_YUV422_10_REPEAT_PTN                5
-#define _HRT_CSS_RECEIVER_2400_RGB444_REPEAT_PTN                   2
-#define _HRT_CSS_RECEIVER_2400_RGB555_REPEAT_PTN                   2
-#define _HRT_CSS_RECEIVER_2400_RGB565_REPEAT_PTN                   2
-#define _HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN                   9
-#define _HRT_CSS_RECEIVER_2400_RGB888_REPEAT_PTN                   3
-#define _HRT_CSS_RECEIVER_2400_RAW6_REPEAT_PTN                     3
-#define _HRT_CSS_RECEIVER_2400_RAW7_REPEAT_PTN                     7
-#define _HRT_CSS_RECEIVER_2400_RAW8_REPEAT_PTN                     1
-#define _HRT_CSS_RECEIVER_2400_RAW10_REPEAT_PTN                    5
-#define _HRT_CSS_RECEIVER_2400_RAW12_REPEAT_PTN                    3
-#define _HRT_CSS_RECEIVER_2400_RAW14_REPEAT_PTN                    7
-
-#define _HRT_CSS_RECEIVER_2400_MAX_REPEAT_PTN                      _HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN
-
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_IDX                     0
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_WIDTH                   3
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_IDX                    3
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_WIDTH                  1
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_USD_BITS                    4  /* bits per USD type */
-
-#define _HRT_CSS_RECEIVER_2400_BE_RAW16_DATAID_IDX                 0
-#define _HRT_CSS_RECEIVER_2400_BE_RAW16_EN_IDX                     6
-#define _HRT_CSS_RECEIVER_2400_BE_RAW18_DATAID_IDX                 0
-#define _HRT_CSS_RECEIVER_2400_BE_RAW18_OPTION_IDX                 6
-#define _HRT_CSS_RECEIVER_2400_BE_RAW18_EN_IDX                     8
-
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_NO_COMP                     0
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_6_10                     1
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_7_10                     2
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_8_10                     3
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_6_12                     4
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_7_12                     5
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_8_12                     6
+#define _HRT_CSS_RECEIVER_2400_YUV420_8_REPEAT_PTN 1
+#define _HRT_CSS_RECEIVER_2400_YUV420_10_REPEAT_PTN 5
+#define _HRT_CSS_RECEIVER_2400_YUV420_8L_REPEAT_PTN 1
+#define _HRT_CSS_RECEIVER_2400_YUV422_8_REPEAT_PTN 1
+#define _HRT_CSS_RECEIVER_2400_YUV422_10_REPEAT_PTN 5
+#define _HRT_CSS_RECEIVER_2400_RGB444_REPEAT_PTN 2
+#define _HRT_CSS_RECEIVER_2400_RGB555_REPEAT_PTN 2
+#define _HRT_CSS_RECEIVER_2400_RGB565_REPEAT_PTN 2
+#define _HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN 9
+#define _HRT_CSS_RECEIVER_2400_RGB888_REPEAT_PTN 3
+#define _HRT_CSS_RECEIVER_2400_RAW6_REPEAT_PTN 3
+#define _HRT_CSS_RECEIVER_2400_RAW7_REPEAT_PTN 7
+#define _HRT_CSS_RECEIVER_2400_RAW8_REPEAT_PTN 1
+#define _HRT_CSS_RECEIVER_2400_RAW10_REPEAT_PTN 5
+#define _HRT_CSS_RECEIVER_2400_RAW12_REPEAT_PTN 3
+#define _HRT_CSS_RECEIVER_2400_RAW14_REPEAT_PTN 7
+
+#define _HRT_CSS_RECEIVER_2400_MAX_REPEAT_PTN \
+	_HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN
+
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_IDX 0
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_WIDTH 3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_IDX 3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_WIDTH 1
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_USD_BITS 4 /* bits per USD type */
+
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_DATAID_IDX 0
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_EN_IDX 6
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_DATAID_IDX 0
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_OPTION_IDX 6
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_EN_IDX 8
+
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_NO_COMP 0
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_6_10 1
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_7_10 2
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_8_10 3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_6_12 4
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_7_12 5
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_8_12 6
 
 /* packet bit definition */
-#define _HRT_CSS_RECEIVER_2400_PKT_SOP_IDX                        32
-#define _HRT_CSS_RECEIVER_2400_PKT_SOP_BITS                        1
-#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_IDX                      22
-#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_BITS                      2
-#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_IDX                     16
-#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_BITS                     6
-#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_IDX                   0
-#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_BITS                 16
-#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_IDX                     0
-#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_BITS                   32
+#define _HRT_CSS_RECEIVER_2400_PKT_SOP_IDX 32
+#define _HRT_CSS_RECEIVER_2400_PKT_SOP_BITS 1
+#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_IDX 22
+#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_BITS 2
+#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_IDX 16
+#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_BITS 6
+#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_IDX 0
+#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_BITS 16
+#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_IDX 0
+#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_BITS 32
 
 /*************************************************************************************************/
 /* Custom Decoding                                                                               */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/mipi_backend_defs.h b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/mipi_backend_defs.h
index 91747af997c57c642d0b8e9c9f149388f26607d8..1882a631614a3a65cd35ec0a63d024defbb2faaa 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/mipi_backend_defs.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/mipi_backend_defs.h
@@ -9,64 +9,64 @@
 
 #include "mipi_backend_common_defs.h"
 
-#define MIPI_BACKEND_REG_ALIGN                    4 // assuming 32 bit control bus width
+#define MIPI_BACKEND_REG_ALIGN 4 // assuming 32 bit control bus width
 
-#define _HRT_MIPI_BACKEND_NOF_IRQS                         3 // sid_lut
+#define _HRT_MIPI_BACKEND_NOF_IRQS 3 // sid_lut
 
 // SH Backend Register IDs
-#define _HRT_MIPI_BACKEND_ENABLE_REG_IDX                   0
-#define _HRT_MIPI_BACKEND_STATUS_REG_IDX                   1
+#define _HRT_MIPI_BACKEND_ENABLE_REG_IDX 0
+#define _HRT_MIPI_BACKEND_STATUS_REG_IDX 1
 //#define _HRT_MIPI_BACKEND_HIGH_PREC_REG_IDX                2
-#define _HRT_MIPI_BACKEND_COMP_FORMAT_REG0_IDX             2
-#define _HRT_MIPI_BACKEND_COMP_FORMAT_REG1_IDX             3
-#define _HRT_MIPI_BACKEND_COMP_FORMAT_REG2_IDX             4
-#define _HRT_MIPI_BACKEND_COMP_FORMAT_REG3_IDX             5
-#define _HRT_MIPI_BACKEND_RAW16_CONFIG_REG_IDX             6
-#define _HRT_MIPI_BACKEND_RAW18_CONFIG_REG_IDX             7
-#define _HRT_MIPI_BACKEND_FORCE_RAW8_REG_IDX               8
-#define _HRT_MIPI_BACKEND_IRQ_STATUS_REG_IDX               9
-#define _HRT_MIPI_BACKEND_IRQ_CLEAR_REG_IDX               10
+#define _HRT_MIPI_BACKEND_COMP_FORMAT_REG0_IDX 2
+#define _HRT_MIPI_BACKEND_COMP_FORMAT_REG1_IDX 3
+#define _HRT_MIPI_BACKEND_COMP_FORMAT_REG2_IDX 4
+#define _HRT_MIPI_BACKEND_COMP_FORMAT_REG3_IDX 5
+#define _HRT_MIPI_BACKEND_RAW16_CONFIG_REG_IDX 6
+#define _HRT_MIPI_BACKEND_RAW18_CONFIG_REG_IDX 7
+#define _HRT_MIPI_BACKEND_FORCE_RAW8_REG_IDX 8
+#define _HRT_MIPI_BACKEND_IRQ_STATUS_REG_IDX 9
+#define _HRT_MIPI_BACKEND_IRQ_CLEAR_REG_IDX 10
 ////
-#define _HRT_MIPI_BACKEND_CUST_EN_REG_IDX                 11
-#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_REG_IDX         12
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S0P0_REG_IDX       13
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S0P1_REG_IDX       14
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S0P2_REG_IDX       15
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S0P3_REG_IDX       16
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S1P0_REG_IDX       17
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S1P1_REG_IDX       18
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S1P2_REG_IDX       19
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S1P3_REG_IDX       20
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S2P0_REG_IDX       21
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S2P1_REG_IDX       22
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S2P2_REG_IDX       23
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S2P3_REG_IDX       24
-#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_REG_IDX      25
+#define _HRT_MIPI_BACKEND_CUST_EN_REG_IDX 11
+#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_REG_IDX 12
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S0P0_REG_IDX 13
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S0P1_REG_IDX 14
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S0P2_REG_IDX 15
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S0P3_REG_IDX 16
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S1P0_REG_IDX 17
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S1P1_REG_IDX 18
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S1P2_REG_IDX 19
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S1P3_REG_IDX 20
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S2P0_REG_IDX 21
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S2P1_REG_IDX 22
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S2P2_REG_IDX 23
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_S2P3_REG_IDX 24
+#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_REG_IDX 25
 ////
-#define _HRT_MIPI_BACKEND_GLOBAL_LUT_DISREGARD_REG_IDX    26
-#define _HRT_MIPI_BACKEND_PKT_STALL_STATUS_REG_IDX        27
+#define _HRT_MIPI_BACKEND_GLOBAL_LUT_DISREGARD_REG_IDX 26
+#define _HRT_MIPI_BACKEND_PKT_STALL_STATUS_REG_IDX 27
 //#define _HRT_MIPI_BACKEND_SP_LUT_ENABLE_REG_IDX           28
-#define _HRT_MIPI_BACKEND_SP_LUT_ENTRY_0_REG_IDX          28
-#define _HRT_MIPI_BACKEND_SP_LUT_ENTRY_1_REG_IDX          29
-#define _HRT_MIPI_BACKEND_SP_LUT_ENTRY_2_REG_IDX          30
-#define _HRT_MIPI_BACKEND_SP_LUT_ENTRY_3_REG_IDX          31
+#define _HRT_MIPI_BACKEND_SP_LUT_ENTRY_0_REG_IDX 28
+#define _HRT_MIPI_BACKEND_SP_LUT_ENTRY_1_REG_IDX 29
+#define _HRT_MIPI_BACKEND_SP_LUT_ENTRY_2_REG_IDX 30
+#define _HRT_MIPI_BACKEND_SP_LUT_ENTRY_3_REG_IDX 31
 
-#define _HRT_MIPI_BACKEND_NOF_REGISTERS                   32 // excluding the LP LUT entries
+#define _HRT_MIPI_BACKEND_NOF_REGISTERS 32 // excluding the LP LUT entries
 
-#define _HRT_MIPI_BACKEND_LP_LUT_ENTRY_0_REG_IDX          32
+#define _HRT_MIPI_BACKEND_LP_LUT_ENTRY_0_REG_IDX 32
 
 /////////////////////////////////////////////////////////////////////////////////////////////////////
-#define _HRT_MIPI_BACKEND_ENABLE_REG_WIDTH                 1
-#define _HRT_MIPI_BACKEND_STATUS_REG_WIDTH                 1
+#define _HRT_MIPI_BACKEND_ENABLE_REG_WIDTH 1
+#define _HRT_MIPI_BACKEND_STATUS_REG_WIDTH 1
 //#define _HRT_MIPI_BACKEND_HIGH_PREC_REG_WIDTH              1
-#define _HRT_MIPI_BACKEND_COMP_FORMAT_REG_WIDTH           32
-#define _HRT_MIPI_BACKEND_RAW16_CONFIG_REG_WIDTH           7
-#define _HRT_MIPI_BACKEND_RAW18_CONFIG_REG_WIDTH           9
-#define _HRT_MIPI_BACKEND_FORCE_RAW8_REG_WIDTH             8
-#define _HRT_MIPI_BACKEND_IRQ_STATUS_REG_WIDTH            _HRT_MIPI_BACKEND_NOF_IRQS
-#define _HRT_MIPI_BACKEND_IRQ_CLEAR_REG_WIDTH              0
-#define _HRT_MIPI_BACKEND_GLOBAL_LUT_DISREGARD_REG_WIDTH   1
-#define _HRT_MIPI_BACKEND_PKT_STALL_STATUS_REG_WIDTH       1 + 2 + 6
+#define _HRT_MIPI_BACKEND_COMP_FORMAT_REG_WIDTH 32
+#define _HRT_MIPI_BACKEND_RAW16_CONFIG_REG_WIDTH 7
+#define _HRT_MIPI_BACKEND_RAW18_CONFIG_REG_WIDTH 9
+#define _HRT_MIPI_BACKEND_FORCE_RAW8_REG_WIDTH 8
+#define _HRT_MIPI_BACKEND_IRQ_STATUS_REG_WIDTH _HRT_MIPI_BACKEND_NOF_IRQS
+#define _HRT_MIPI_BACKEND_IRQ_CLEAR_REG_WIDTH 0
+#define _HRT_MIPI_BACKEND_GLOBAL_LUT_DISREGARD_REG_WIDTH 1
+#define _HRT_MIPI_BACKEND_PKT_STALL_STATUS_REG_WIDTH (1 + 2 + 6)
 //#define _HRT_MIPI_BACKEND_SP_LUT_ENABLE_REG_WIDTH          1
 //#define _HRT_MIPI_BACKEND_SP_LUT_ENTRY_0_REG_WIDTH         7
 //#define _HRT_MIPI_BACKEND_SP_LUT_ENTRY_1_REG_WIDTH         7
@@ -75,63 +75,78 @@
 
 /////////////////////////////////////////////////////////////////////////////////////////////////////
 
-#define _HRT_MIPI_BACKEND_NOF_SP_LUT_ENTRIES               4
+#define _HRT_MIPI_BACKEND_NOF_SP_LUT_ENTRIES 4
 
 //#define _HRT_MIPI_BACKEND_MAX_NOF_LP_LUT_ENTRIES           16  // to satisfy hss model static array declaration
 
-#define _HRT_MIPI_BACKEND_CHANNEL_ID_WIDTH                 2
-#define _HRT_MIPI_BACKEND_FORMAT_TYPE_WIDTH                6
-#define _HRT_MIPI_BACKEND_PACKET_ID_WIDTH                  _HRT_MIPI_BACKEND_CHANNEL_ID_WIDTH + _HRT_MIPI_BACKEND_FORMAT_TYPE_WIDTH
-
-#define _HRT_MIPI_BACKEND_STREAMING_PIX_A_LSB                 0
-#define _HRT_MIPI_BACKEND_STREAMING_PIX_A_MSB(pix_width)     (_HRT_MIPI_BACKEND_STREAMING_PIX_A_LSB + (pix_width) - 1)
-#define _HRT_MIPI_BACKEND_STREAMING_PIX_A_VAL_BIT(pix_width) (_HRT_MIPI_BACKEND_STREAMING_PIX_A_MSB(pix_width) + 1)
-#define _HRT_MIPI_BACKEND_STREAMING_PIX_B_LSB(pix_width)     (_HRT_MIPI_BACKEND_STREAMING_PIX_A_VAL_BIT(pix_width) + 1)
-#define _HRT_MIPI_BACKEND_STREAMING_PIX_B_MSB(pix_width)     (_HRT_MIPI_BACKEND_STREAMING_PIX_B_LSB(pix_width) + (pix_width) - 1)
-#define _HRT_MIPI_BACKEND_STREAMING_PIX_B_VAL_BIT(pix_width) (_HRT_MIPI_BACKEND_STREAMING_PIX_B_MSB(pix_width) + 1)
-#define _HRT_MIPI_BACKEND_STREAMING_SOP_BIT(pix_width)       (_HRT_MIPI_BACKEND_STREAMING_PIX_B_VAL_BIT(pix_width) + 1)
-#define _HRT_MIPI_BACKEND_STREAMING_EOP_BIT(pix_width)       (_HRT_MIPI_BACKEND_STREAMING_SOP_BIT(pix_width) + 1)
-#define _HRT_MIPI_BACKEND_STREAMING_WIDTH(pix_width)         (_HRT_MIPI_BACKEND_STREAMING_EOP_BIT(pix_width) + 1)
+#define _HRT_MIPI_BACKEND_CHANNEL_ID_WIDTH 2
+#define _HRT_MIPI_BACKEND_FORMAT_TYPE_WIDTH 6
+#define _HRT_MIPI_BACKEND_PACKET_ID_WIDTH ( \
+	_HRT_MIPI_BACKEND_CHANNEL_ID_WIDTH + _HRT_MIPI_BACKEND_FORMAT_TYPE_WIDTH)
+
+#define _HRT_MIPI_BACKEND_STREAMING_PIX_A_LSB 0
+#define _HRT_MIPI_BACKEND_STREAMING_PIX_A_MSB(pix_width) \
+	(_HRT_MIPI_BACKEND_STREAMING_PIX_A_LSB + (pix_width)-1)
+#define _HRT_MIPI_BACKEND_STREAMING_PIX_A_VAL_BIT(pix_width) \
+	(_HRT_MIPI_BACKEND_STREAMING_PIX_A_MSB(pix_width) + 1)
+#define _HRT_MIPI_BACKEND_STREAMING_PIX_B_LSB(pix_width) \
+	(_HRT_MIPI_BACKEND_STREAMING_PIX_A_VAL_BIT(pix_width) + 1)
+#define _HRT_MIPI_BACKEND_STREAMING_PIX_B_MSB(pix_width) \
+	(_HRT_MIPI_BACKEND_STREAMING_PIX_B_LSB(pix_width) + (pix_width)-1)
+#define _HRT_MIPI_BACKEND_STREAMING_PIX_B_VAL_BIT(pix_width) \
+	(_HRT_MIPI_BACKEND_STREAMING_PIX_B_MSB(pix_width) + 1)
+#define _HRT_MIPI_BACKEND_STREAMING_SOP_BIT(pix_width) \
+	(_HRT_MIPI_BACKEND_STREAMING_PIX_B_VAL_BIT(pix_width) + 1)
+#define _HRT_MIPI_BACKEND_STREAMING_EOP_BIT(pix_width) \
+	(_HRT_MIPI_BACKEND_STREAMING_SOP_BIT(pix_width) + 1)
+#define _HRT_MIPI_BACKEND_STREAMING_WIDTH(pix_width) \
+	(_HRT_MIPI_BACKEND_STREAMING_EOP_BIT(pix_width) + 1)
 
 /*************************************************************************************************/
 /* Custom Decoding                                                                               */
 /* These Custom Defs are defined based on design-time config in "mipi_backend_pixel_formatter.chdl" !! */
 /*************************************************************************************************/
-#define _HRT_MIPI_BACKEND_CUST_EN_IDX                     0     /* 2bits */
-#define _HRT_MIPI_BACKEND_CUST_EN_DATAID_IDX              2     /* 6bits MIPI DATA ID */
-#define _HRT_MIPI_BACKEND_CUST_EN_HIGH_PREC_IDX           8     // 1 bit
-#define _HRT_MIPI_BACKEND_CUST_EN_WIDTH                   9
-#define _HRT_MIPI_BACKEND_CUST_MODE_ALL                   1     /* Enable Custom Decoding for all DATA IDs */
-#define _HRT_MIPI_BACKEND_CUST_MODE_ONE                   3     /* Enable Custom Decoding for ONE DATA ID, programmed in CUST_EN_DATA_ID */
+#define _HRT_MIPI_BACKEND_CUST_EN_IDX 0 /* 2bits */
+#define _HRT_MIPI_BACKEND_CUST_EN_DATAID_IDX 2 /* 6bits MIPI DATA ID */
+#define _HRT_MIPI_BACKEND_CUST_EN_HIGH_PREC_IDX 8 // 1 bit
+#define _HRT_MIPI_BACKEND_CUST_EN_WIDTH 9
+#define _HRT_MIPI_BACKEND_CUST_MODE_ALL \
+	1 /* Enable Custom Decoding for all DATA IDs */
+#define _HRT_MIPI_BACKEND_CUST_MODE_ONE \
+	3 /* Enable Custom Decoding for ONE DATA ID, programmed in CUST_EN_DATA_ID */
 
-#define _HRT_MIPI_BACKEND_CUST_EN_OPTION_IDX              1
+#define _HRT_MIPI_BACKEND_CUST_EN_OPTION_IDX 1
 
 /* Data State config = {get_bits(6bits), valid(1bit)}  */
-#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_S0_IDX          0     /* 7bits */
-#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_S1_IDX          8     /* 7bits */
-#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_S2_IDX          16    /* was 14 7bits */
-#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_WIDTH           24    /* was 21*/
-#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_VALID_IDX       0     /* 1bits */
-#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_GETBITS_IDX     1     /* 6bits */
+#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_S0_IDX 0 /* 7bits */
+#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_S1_IDX 8 /* 7bits */
+#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_S2_IDX 16 /* was 14 7bits */
+#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_WIDTH 24 /* was 21*/
+#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_VALID_IDX 0 /* 1bits */
+#define _HRT_MIPI_BACKEND_CUST_DATA_STATE_GETBITS_IDX 1 /* 6bits */
 
 /* Pixel Extractor config */
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_DATA_ALIGN_IDX     0     /* 6bits */
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_PIX_ALIGN_IDX      6     /* 5bits */
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_PIX_MASK_IDX       11    /* was 10 18bits */
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_PIX_EN_IDX         29    /* was 28 1bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_DATA_ALIGN_IDX 0 /* 6bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_PIX_ALIGN_IDX 6 /* 5bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_PIX_MASK_IDX 11 /* was 10 18bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_PIX_EN_IDX 29 /* was 28 1bits */
 
-#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_WIDTH              30    /* was 29 */
+#define _HRT_MIPI_BACKEND_CUST_PIX_EXT_WIDTH 30 /* was 29 */
 
 /* Pixel Valid & EoP config = {[eop,valid](especial), [eop,valid](normal)} */
-#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_P0_IDX        0    /* 4bits */
-#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_P1_IDX        4    /* 4bits */
-#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_P2_IDX        8    /* 4bits */
-#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_P3_IDX        12   /* 4bits */
-#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_WIDTH         16
-#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_NOR_VALID_IDX 0    /* Normal (NO less get_bits case) Valid - 1bits */
-#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_NOR_EOP_IDX   1    /* Normal (NO less get_bits case) EoP - 1bits */
-#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_ESP_VALID_IDX 2    /* Especial (less get_bits case) Valid - 1bits */
-#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_ESP_EOP_IDX   3    /* Especial (less get_bits case) EoP - 1bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_P0_IDX 0 /* 4bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_P1_IDX 4 /* 4bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_P2_IDX 8 /* 4bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_P3_IDX 12 /* 4bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_WIDTH 16
+#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_NOR_VALID_IDX \
+	0 /* Normal (NO less get_bits case) Valid - 1bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_NOR_EOP_IDX \
+	1 /* Normal (NO less get_bits case) EoP - 1bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_ESP_VALID_IDX \
+	2 /* Especial (less get_bits case) Valid - 1bits */
+#define _HRT_MIPI_BACKEND_CUST_PIX_VALID_EOP_ESP_EOP_IDX \
+	3 /* Especial (less get_bits case) EoP - 1bits */
 
 /*************************************************************************************************/
 /* MIPI backend output streaming interface definition                                            */
@@ -146,16 +161,21 @@
 /* In order to keep this configurability, below Macro's have these as a parameter                */
 /*************************************************************************************************/
 
-#define HRT_MIPI_BACKEND_STREAM_EOP_BIT                      0
-#define HRT_MIPI_BACKEND_STREAM_SOP_BIT                      1
-#define HRT_MIPI_BACKEND_STREAM_EOF_BIT                      2
-#define HRT_MIPI_BACKEND_STREAM_SOF_BIT                      3
-#define HRT_MIPI_BACKEND_STREAM_CHID_LS_BIT                  4
-#define HRT_MIPI_BACKEND_STREAM_CHID_MS_BIT(sid_width)      (HRT_MIPI_BACKEND_STREAM_CHID_LS_BIT + (sid_width) - 1)
-#define HRT_MIPI_BACKEND_STREAM_PIX_VAL_BIT(sid_width, p)    (HRT_MIPI_BACKEND_STREAM_CHID_MS_BIT(sid_width) + 1 + p)
-
-#define HRT_MIPI_BACKEND_STREAM_PIX_LS_BIT(sid_width, ppc, pix_width, p) (HRT_MIPI_BACKEND_STREAM_PIX_VAL_BIT(sid_width, ppc) + ((pix_width) * p))
-#define HRT_MIPI_BACKEND_STREAM_PIX_MS_BIT(sid_width, ppc, pix_width, p) (HRT_MIPI_BACKEND_STREAM_PIX_LS_BIT(sid_width, ppc, pix_width, p) + (pix_width) - 1)
+#define HRT_MIPI_BACKEND_STREAM_EOP_BIT 0
+#define HRT_MIPI_BACKEND_STREAM_SOP_BIT 1
+#define HRT_MIPI_BACKEND_STREAM_EOF_BIT 2
+#define HRT_MIPI_BACKEND_STREAM_SOF_BIT 3
+#define HRT_MIPI_BACKEND_STREAM_CHID_LS_BIT 4
+#define HRT_MIPI_BACKEND_STREAM_CHID_MS_BIT(sid_width) \
+	(HRT_MIPI_BACKEND_STREAM_CHID_LS_BIT + (sid_width)-1)
+#define HRT_MIPI_BACKEND_STREAM_PIX_VAL_BIT(sid_width, p) \
+	(HRT_MIPI_BACKEND_STREAM_CHID_MS_BIT(sid_width) + 1 + p)
+
+#define HRT_MIPI_BACKEND_STREAM_PIX_LS_BIT(sid_width, ppc, pix_width, p) \
+	(HRT_MIPI_BACKEND_STREAM_PIX_VAL_BIT(sid_width, ppc) + ((pix_width)*p))
+#define HRT_MIPI_BACKEND_STREAM_PIX_MS_BIT(sid_width, ppc, pix_width, p)    \
+	(HRT_MIPI_BACKEND_STREAM_PIX_LS_BIT(sid_width, ppc, pix_width, p) + \
+	 (pix_width)-1)
 
 #if 0
 //#define HRT_MIPI_BACKEND_STREAM_PIX_BITS                    14
@@ -163,21 +183,34 @@
 //#define HRT_MIPI_BACKEND_STREAM_PPC                          4
 #endif
 
-#define HRT_MIPI_BACKEND_STREAM_BITS(sid_width, ppc, pix_width)         (HRT_MIPI_BACKEND_STREAM_PIX_MS_BIT(sid_width, ppc, pix_width, (ppc - 1)) + 1)
+#define HRT_MIPI_BACKEND_STREAM_BITS(sid_width, ppc, pix_width)        \
+	(HRT_MIPI_BACKEND_STREAM_PIX_MS_BIT(sid_width, ppc, pix_width, \
+					    (ppc - 1)) +               \
+	 1)
 
 /* SP and LP LUT BIT POSITIONS */
-#define HRT_MIPI_BACKEND_LUT_PKT_DISREGARD_BIT              0                                                                                           // 0
-#define HRT_MIPI_BACKEND_LUT_SID_LS_BIT                     HRT_MIPI_BACKEND_LUT_PKT_DISREGARD_BIT + 1                                                  // 1
-#define HRT_MIPI_BACKEND_LUT_SID_MS_BIT(sid_width)          (HRT_MIPI_BACKEND_LUT_SID_LS_BIT + (sid_width) - 1)                                             // 1 + (4) - 1 = 4
-#define HRT_MIPI_BACKEND_LUT_MIPI_CH_ID_LS_BIT(sid_width)   HRT_MIPI_BACKEND_LUT_SID_MS_BIT(sid_width) + 1                                              // 5
-#define HRT_MIPI_BACKEND_LUT_MIPI_CH_ID_MS_BIT(sid_width)   HRT_MIPI_BACKEND_LUT_MIPI_CH_ID_LS_BIT(sid_width) + _HRT_MIPI_BACKEND_CHANNEL_ID_WIDTH - 1  // 6
-#define HRT_MIPI_BACKEND_LUT_MIPI_FMT_LS_BIT(sid_width)     HRT_MIPI_BACKEND_LUT_MIPI_CH_ID_MS_BIT(sid_width) + 1                                       // 7
-#define HRT_MIPI_BACKEND_LUT_MIPI_FMT_MS_BIT(sid_width)     HRT_MIPI_BACKEND_LUT_MIPI_FMT_LS_BIT(sid_width) + _HRT_MIPI_BACKEND_FORMAT_TYPE_WIDTH - 1   // 12
+#define HRT_MIPI_BACKEND_LUT_PKT_DISREGARD_BIT 0 // 0
+#define HRT_MIPI_BACKEND_LUT_SID_LS_BIT ( \
+	HRT_MIPI_BACKEND_LUT_PKT_DISREGARD_BIT + 1) // 1
+#define HRT_MIPI_BACKEND_LUT_SID_MS_BIT(sid_width) \
+	(HRT_MIPI_BACKEND_LUT_SID_LS_BIT + (sid_width)-1) // 1 + (4) - 1 = 4
+#define HRT_MIPI_BACKEND_LUT_MIPI_CH_ID_LS_BIT(sid_width) ( \
+	HRT_MIPI_BACKEND_LUT_SID_MS_BIT(sid_width) + 1) // 5
+#define HRT_MIPI_BACKEND_LUT_MIPI_CH_ID_MS_BIT(sid_width)   ( \
+	HRT_MIPI_BACKEND_LUT_MIPI_CH_ID_LS_BIT(sid_width) + \
+		_HRT_MIPI_BACKEND_CHANNEL_ID_WIDTH - 1) // 6
+#define HRT_MIPI_BACKEND_LUT_MIPI_FMT_LS_BIT(sid_width) ( \
+	HRT_MIPI_BACKEND_LUT_MIPI_CH_ID_MS_BIT(sid_width) + 1) // 7
+#define HRT_MIPI_BACKEND_LUT_MIPI_FMT_MS_BIT(sid_width)   ( \
+	HRT_MIPI_BACKEND_LUT_MIPI_FMT_LS_BIT(sid_width) + \
+		_HRT_MIPI_BACKEND_FORMAT_TYPE_WIDTH - 1) // 12
 
 /* #define HRT_MIPI_BACKEND_SP_LUT_BITS(sid_width)             HRT_MIPI_BACKEND_LUT_MIPI_CH_ID_MS_BIT(sid_width) + 1                                       // 7          */
 
-#define HRT_MIPI_BACKEND_SP_LUT_BITS(sid_width)             HRT_MIPI_BACKEND_LUT_SID_MS_BIT(sid_width) + 1
-#define HRT_MIPI_BACKEND_LP_LUT_BITS(sid_width)             HRT_MIPI_BACKEND_LUT_MIPI_FMT_MS_BIT(sid_width) + 1                                         // 13
+#define HRT_MIPI_BACKEND_SP_LUT_BITS(sid_width) ( \
+	HRT_MIPI_BACKEND_LUT_SID_MS_BIT(sid_width) + 1)
+#define HRT_MIPI_BACKEND_LP_LUT_BITS(sid_width) ( \
+	HRT_MIPI_BACKEND_LUT_MIPI_FMT_MS_BIT(sid_width) + 1) // 13
 
 // temp solution
 //#define HRT_MIPI_BACKEND_STREAM_PIXA_VAL_BIT                HRT_MIPI_BACKEND_STREAM_CHID_MS_BIT  + 1                                    // 8
@@ -194,7 +227,10 @@
 //#define HRT_MIPI_BACKEND_STREAM_PIXD_MS_BIT                 HRT_MIPI_BACKEND_STREAM_PIXD_LS_BIT  + HRT_MIPI_BACKEND_STREAM_PIX_BITS - 1 // 67
 
 // vc hidden in pixb data (passed as raw12 the pipe)
-#define HRT_MIPI_BACKEND_STREAM_VC_LS_BIT(sid_width, ppc, pix_width)  HRT_MIPI_BACKEND_STREAM_PIX_LS_BIT(sid_width, ppc, pix_width, 1) + 10  //HRT_MIPI_BACKEND_STREAM_PIXB_LS_BIT + 10 // 36
-#define HRT_MIPI_BACKEND_STREAM_VC_MS_BIT(sid_width, ppc, pix_width)  HRT_MIPI_BACKEND_STREAM_VC_LS_BIT(sid_width, ppc, pix_width) + 1    // 37
+#define HRT_MIPI_BACKEND_STREAM_VC_LS_BIT(sid_width, ppc, pix_width)       ( \
+	HRT_MIPI_BACKEND_STREAM_PIX_LS_BIT(sid_width, ppc, pix_width, 1) + \
+		10) //HRT_MIPI_BACKEND_STREAM_PIXB_LS_BIT + 10 // 36
+#define HRT_MIPI_BACKEND_STREAM_VC_MS_BIT(sid_width, ppc, pix_width) ( \
+	HRT_MIPI_BACKEND_STREAM_VC_LS_BIT(sid_width, ppc, pix_width) + 1) // 37
 
 #endif /* _mipi_backend_defs_h */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/rx_csi_defs.h b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/rx_csi_defs.h
index 12df1ab491a0d8356eb8b39ec08d384a460e521a..6766585f0c3ea28a84a29dbc5f96709f42e89b67 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/rx_csi_defs.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/rx_csi_defs.h
@@ -9,74 +9,76 @@
 
 //#include "rx_csi_common_defs.h"
 
-#define MIPI_PKT_DATA_WIDTH                         32
+#define MIPI_PKT_DATA_WIDTH 32
 //#define CLK_CROSSING_FIFO_DEPTH                     16
-#define _CSI_RX_REG_ALIGN                            4
+#define _CSI_RX_REG_ALIGN 4
 
 //define number of IRQ (see below for definition of each IRQ bits)
-#define CSI_RX_NOF_IRQS_BYTE_DOMAIN                11
-#define CSI_RX_NOF_IRQS_ISP_DOMAIN                 15 // CSI_RX_NOF_IRQS_BYTE_DOMAIN + remaining from Dphy_rx already on ISP clock domain
+#define CSI_RX_NOF_IRQS_BYTE_DOMAIN 11
+#define CSI_RX_NOF_IRQS_ISP_DOMAIN \
+	15 // CSI_RX_NOF_IRQS_BYTE_DOMAIN + remaining from Dphy_rx already on ISP clock domain
 
 // REGISTER DESCRIPTION
 //#define _HRT_CSI_RX_SOFTRESET_REG_IDX                0
-#define _HRT_CSI_RX_ENABLE_REG_IDX                   0
-#define _HRT_CSI_RX_NOF_ENABLED_LANES_REG_IDX        1
-#define _HRT_CSI_RX_ERROR_HANDLING_REG_IDX           2
-#define _HRT_CSI_RX_STATUS_REG_IDX                   3
-#define _HRT_CSI_RX_STATUS_DLANE_HS_REG_IDX          4
-#define _HRT_CSI_RX_STATUS_DLANE_LP_REG_IDX          5
+#define _HRT_CSI_RX_ENABLE_REG_IDX 0
+#define _HRT_CSI_RX_NOF_ENABLED_LANES_REG_IDX 1
+#define _HRT_CSI_RX_ERROR_HANDLING_REG_IDX 2
+#define _HRT_CSI_RX_STATUS_REG_IDX 3
+#define _HRT_CSI_RX_STATUS_DLANE_HS_REG_IDX 4
+#define _HRT_CSI_RX_STATUS_DLANE_LP_REG_IDX 5
 //#define _HRT_CSI_RX_IRQ_CONFIG_REG_IDX               6
-#define _HRT_CSI_RX_DLY_CNT_TERMEN_CLANE_REG_IDX     6
-#define _HRT_CSI_RX_DLY_CNT_SETTLE_CLANE_REG_IDX     7
-#define _HRT_CSI_RX_DLY_CNT_TERMEN_DLANE_REG_IDX(lane_idx)    (8 + (2 * lane_idx))
-#define _HRT_CSI_RX_DLY_CNT_SETTLE_DLANE_REG_IDX(lane_idx)    (8 + (2 * lane_idx) + 1)
+#define _HRT_CSI_RX_DLY_CNT_TERMEN_CLANE_REG_IDX 6
+#define _HRT_CSI_RX_DLY_CNT_SETTLE_CLANE_REG_IDX 7
+#define _HRT_CSI_RX_DLY_CNT_TERMEN_DLANE_REG_IDX(lane_idx) (8 + (2 * lane_idx))
+#define _HRT_CSI_RX_DLY_CNT_SETTLE_DLANE_REG_IDX(lane_idx) \
+	(8 + (2 * lane_idx) + 1)
 
-#define _HRT_CSI_RX_NOF_REGISTERS(nof_dlanes)      (8 + 2 * (nof_dlanes))
+#define _HRT_CSI_RX_NOF_REGISTERS(nof_dlanes) (8 + 2 * (nof_dlanes))
 
 //#define _HRT_CSI_RX_SOFTRESET_REG_WIDTH              1
-#define _HRT_CSI_RX_ENABLE_REG_WIDTH                 1
-#define _HRT_CSI_RX_NOF_ENABLED_LANES_REG_WIDTH      3
-#define _HRT_CSI_RX_ERROR_HANDLING_REG_WIDTH         4
-#define _HRT_CSI_RX_STATUS_REG_WIDTH                 1
-#define _HRT_CSI_RX_STATUS_DLANE_HS_REG_WIDTH        8
-#define _HRT_CSI_RX_STATUS_DLANE_LP_REG_WIDTH        24
-#define _HRT_CSI_RX_IRQ_CONFIG_REG_WIDTH             (CSI_RX_NOF_IRQS_ISP_DOMAIN)
-#define _HRT_CSI_RX_DLY_CNT_REG_WIDTH                24
+#define _HRT_CSI_RX_ENABLE_REG_WIDTH 1
+#define _HRT_CSI_RX_NOF_ENABLED_LANES_REG_WIDTH 3
+#define _HRT_CSI_RX_ERROR_HANDLING_REG_WIDTH 4
+#define _HRT_CSI_RX_STATUS_REG_WIDTH 1
+#define _HRT_CSI_RX_STATUS_DLANE_HS_REG_WIDTH 8
+#define _HRT_CSI_RX_STATUS_DLANE_LP_REG_WIDTH 24
+#define _HRT_CSI_RX_IRQ_CONFIG_REG_WIDTH (CSI_RX_NOF_IRQS_ISP_DOMAIN)
+#define _HRT_CSI_RX_DLY_CNT_REG_WIDTH 24
 //#define _HRT_CSI_RX_IRQ_STATUS_REG_WIDTH            NOF_IRQS
 //#define _HRT_CSI_RX_IRQ_CLEAR_REG_WIDTH             0
 
-#define ONE_LANE_ENABLED                             0
-#define TWO_LANES_ENABLED                            1
-#define THREE_LANES_ENABLED                          2
-#define FOUR_LANES_ENABLED                           3
+#define ONE_LANE_ENABLED 0
+#define TWO_LANES_ENABLED 1
+#define THREE_LANES_ENABLED 2
+#define FOUR_LANES_ENABLED 3
 
 // Error handling reg bit positions
-#define ERR_DECISION_BIT      0
-#define DISC_RESERVED_SP_BIT  1
-#define DISC_RESERVED_LP_BIT  2
-#define DIS_INCOMP_PKT_CHK_BIT	3
+#define ERR_DECISION_BIT 0
+#define DISC_RESERVED_SP_BIT 1
+#define DISC_RESERVED_LP_BIT 2
+#define DIS_INCOMP_PKT_CHK_BIT 3
 
-#define _HRT_CSI_RX_IRQ_CONFIG_REG_VAL_POSEDGE      0
-#define _HRT_CSI_RX_IRQ_CONFIG_REG_VAL_ORIGINAL     1
+#define _HRT_CSI_RX_IRQ_CONFIG_REG_VAL_POSEDGE 0
+#define _HRT_CSI_RX_IRQ_CONFIG_REG_VAL_ORIGINAL 1
 
 // Interrupt bits
-#define _HRT_RX_CSI_IRQ_SINGLE_PH_ERROR_CORRECTED   0
-#define _HRT_RX_CSI_IRQ_MULTIPLE_PH_ERROR_DETECTED  1
-#define _HRT_RX_CSI_IRQ_PAYLOAD_CHECKSUM_ERROR      2
-#define _HRT_RX_CSI_IRQ_FIFO_FULL_ERROR             3
-#define _HRT_RX_CSI_IRQ_RESERVED_SP_DETECTED        4
-#define _HRT_RX_CSI_IRQ_RESERVED_LP_DETECTED        5
+#define _HRT_RX_CSI_IRQ_SINGLE_PH_ERROR_CORRECTED 0
+#define _HRT_RX_CSI_IRQ_MULTIPLE_PH_ERROR_DETECTED 1
+#define _HRT_RX_CSI_IRQ_PAYLOAD_CHECKSUM_ERROR 2
+#define _HRT_RX_CSI_IRQ_FIFO_FULL_ERROR 3
+#define _HRT_RX_CSI_IRQ_RESERVED_SP_DETECTED 4
+#define _HRT_RX_CSI_IRQ_RESERVED_LP_DETECTED 5
 //#define _HRT_RX_CSI_IRQ_PREMATURE_SOP               6
-#define _HRT_RX_CSI_IRQ_INCOMPLETE_PACKET           6
-#define _HRT_RX_CSI_IRQ_FRAME_SYNC_ERROR            7
-#define _HRT_RX_CSI_IRQ_LINE_SYNC_ERROR             8
-#define _HRT_RX_CSI_IRQ_DLANE_HS_SOT_ERROR          9
-#define _HRT_RX_CSI_IRQ_DLANE_HS_SOT_SYNC_ERROR    10
+#define _HRT_RX_CSI_IRQ_INCOMPLETE_PACKET 6
+#define _HRT_RX_CSI_IRQ_FRAME_SYNC_ERROR 7
+#define _HRT_RX_CSI_IRQ_LINE_SYNC_ERROR 8
+#define _HRT_RX_CSI_IRQ_DLANE_HS_SOT_ERROR 9
+#define _HRT_RX_CSI_IRQ_DLANE_HS_SOT_SYNC_ERROR 10
 
-#define _HRT_RX_CSI_IRQ_DLANE_ESC_ERROR            11
-#define _HRT_RX_CSI_IRQ_DLANE_TRIGGERESC           12
-#define _HRT_RX_CSI_IRQ_DLANE_ULPSESC              13
-#define _HRT_RX_CSI_IRQ_CLANE_ULPSCLKNOT           14
+#define _HRT_RX_CSI_IRQ_DLANE_ESC_ERROR 11
+#define _HRT_RX_CSI_IRQ_DLANE_TRIGGERESC 12
+#define _HRT_RX_CSI_IRQ_DLANE_ULPSESC 13
+#define _HRT_RX_CSI_IRQ_CLANE_ULPSCLKNOT 14
 
 /* OLD ARASAN FRONTEND IRQs
 #define _HRT_RX_CSI_IRQ_OVERRUN_BIT                0
@@ -99,63 +101,67 @@
 */
 
 ////Bit Description for reg _HRT_CSI_RX_STATUS_DLANE_HS_REG_IDX
-#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_ERR_LANE0        0
-#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_ERR_LANE1        1
-#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_ERR_LANE2        2
-#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_ERR_LANE3        3
-#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_SYNC_ERR_LANE0   4
-#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_SYNC_ERR_LANE1   5
-#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_SYNC_ERR_LANE2   6
-#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_SYNC_ERR_LANE3   7
+#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_ERR_LANE0 0
+#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_ERR_LANE1 1
+#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_ERR_LANE2 2
+#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_ERR_LANE3 3
+#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_SYNC_ERR_LANE0 4
+#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_SYNC_ERR_LANE1 5
+#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_SYNC_ERR_LANE2 6
+#define _HRT_CSI_RX_STATUS_DLANE_HS_SOT_SYNC_ERR_LANE3 7
 
 ////Bit Description for reg _HRT_CSI_RX_STATUS_DLANE_LP_REG_IDX
-#define _HRT_CSI_RX_STATUS_DLANE_LP_ESC_ERR_LANE0        0
-#define _HRT_CSI_RX_STATUS_DLANE_LP_ESC_ERR_LANE1        1
-#define _HRT_CSI_RX_STATUS_DLANE_LP_ESC_ERR_LANE2        2
-#define _HRT_CSI_RX_STATUS_DLANE_LP_ESC_ERR_LANE3        3
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC0_LANE0    4
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC1_LANE0    5
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC2_LANE0    6
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC3_LANE0    7
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC0_LANE1    8
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC1_LANE1    9
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC2_LANE1    10
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC3_LANE1    11
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC0_LANE2    12
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC1_LANE2    13
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC2_LANE2    14
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC3_LANE2    15
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC0_LANE3    16
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC1_LANE3    17
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC2_LANE3    18
-#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC3_LANE3    19
-#define _HRT_CSI_RX_STATUS_DLANE_LP_ULPSESC_LANE0        20
-#define _HRT_CSI_RX_STATUS_DLANE_LP_ULPSESC_LANE1        21
-#define _HRT_CSI_RX_STATUS_DLANE_LP_ULPSESC_LANE2        22
-#define _HRT_CSI_RX_STATUS_DLANE_LP_ULPSESC_LANE3        23
+#define _HRT_CSI_RX_STATUS_DLANE_LP_ESC_ERR_LANE0 0
+#define _HRT_CSI_RX_STATUS_DLANE_LP_ESC_ERR_LANE1 1
+#define _HRT_CSI_RX_STATUS_DLANE_LP_ESC_ERR_LANE2 2
+#define _HRT_CSI_RX_STATUS_DLANE_LP_ESC_ERR_LANE3 3
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC0_LANE0 4
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC1_LANE0 5
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC2_LANE0 6
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC3_LANE0 7
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC0_LANE1 8
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC1_LANE1 9
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC2_LANE1 10
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC3_LANE1 11
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC0_LANE2 12
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC1_LANE2 13
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC2_LANE2 14
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC3_LANE2 15
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC0_LANE3 16
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC1_LANE3 17
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC2_LANE3 18
+#define _HRT_CSI_RX_STATUS_DLANE_LP_TRIGGERESC3_LANE3 19
+#define _HRT_CSI_RX_STATUS_DLANE_LP_ULPSESC_LANE0 20
+#define _HRT_CSI_RX_STATUS_DLANE_LP_ULPSESC_LANE1 21
+#define _HRT_CSI_RX_STATUS_DLANE_LP_ULPSESC_LANE2 22
+#define _HRT_CSI_RX_STATUS_DLANE_LP_ULPSESC_LANE3 23
 
 /*********************************************************/
 /*** Relevant declarations from rx_csi_common_defs.h *****/
 /*********************************************************/
 /* packet bit definition */
-#define _HRT_RX_CSI_PKT_SOP_BITPOS                       32
-#define _HRT_RX_CSI_PKT_EOP_BITPOS                       33
-#define _HRT_RX_CSI_PKT_PAYLOAD_BITPOS                    0
-#define _HRT_RX_CSI_PH_CH_ID_BITPOS                      22
-#define _HRT_RX_CSI_PH_FMT_ID_BITPOS                     16
-#define _HRT_RX_CSI_PH_DATA_FIELD_BITPOS                  0
-
-#define _HRT_RX_CSI_PKT_SOP_BITS                          1
-#define _HRT_RX_CSI_PKT_EOP_BITS                          1
-#define _HRT_RX_CSI_PKT_PAYLOAD_BITS                     32
-#define _HRT_RX_CSI_PH_CH_ID_BITS                         2
-#define _HRT_RX_CSI_PH_FMT_ID_BITS                        6
-#define _HRT_RX_CSI_PH_DATA_FIELD_BITS                   16
+#define _HRT_RX_CSI_PKT_SOP_BITPOS 32
+#define _HRT_RX_CSI_PKT_EOP_BITPOS 33
+#define _HRT_RX_CSI_PKT_PAYLOAD_BITPOS 0
+#define _HRT_RX_CSI_PH_CH_ID_BITPOS 22
+#define _HRT_RX_CSI_PH_FMT_ID_BITPOS 16
+#define _HRT_RX_CSI_PH_DATA_FIELD_BITPOS 0
+
+#define _HRT_RX_CSI_PKT_SOP_BITS 1
+#define _HRT_RX_CSI_PKT_EOP_BITS 1
+#define _HRT_RX_CSI_PKT_PAYLOAD_BITS 32
+#define _HRT_RX_CSI_PH_CH_ID_BITS 2
+#define _HRT_RX_CSI_PH_FMT_ID_BITS 6
+#define _HRT_RX_CSI_PH_DATA_FIELD_BITS 16
 
 /* Definition of data format ID at the interface CSS_receiver units */
-#define _HRT_RX_CSI_DATA_FORMAT_ID_SOF                0   /* 00 0000    frame start                                      */
-#define _HRT_RX_CSI_DATA_FORMAT_ID_EOF                1   /* 00 0001    frame end                                        */
-#define _HRT_RX_CSI_DATA_FORMAT_ID_SOL                2   /* 00 0010    line start                                       */
-#define _HRT_RX_CSI_DATA_FORMAT_ID_EOL                3   /* 00 0011    line end                                         */
+#define _HRT_RX_CSI_DATA_FORMAT_ID_SOF \
+	0 /* 00 0000    frame start                                      */
+#define _HRT_RX_CSI_DATA_FORMAT_ID_EOF \
+	1 /* 00 0001    frame end                                        */
+#define _HRT_RX_CSI_DATA_FORMAT_ID_SOL \
+	2 /* 00 0010    line start                                       */
+#define _HRT_RX_CSI_DATA_FORMAT_ID_EOL \
+	3 /* 00 0011    line end                                         */
 
 #endif /* _csi_rx_defs_h */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/stream2mmio_defs.h b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/stream2mmio_defs.h
index 495db4770e84c95afaa072531598ddc9330b8c07..0eb69b25c2f17804f3a033d8212dc741474bac80 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/hrt/stream2mmio_defs.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/hrt/stream2mmio_defs.h
@@ -9,52 +9,63 @@
 
 #include <mipi_backend_defs.h>
 
-#define _STREAM2MMIO_REG_ALIGN                  4
+#define _STREAM2MMIO_REG_ALIGN 4
 
-#define _STREAM2MMIO_COMMAND_REG_ID             0
-#define _STREAM2MMIO_ACKNOWLEDGE_REG_ID         1
-#define _STREAM2MMIO_PIX_WIDTH_ID_REG_ID        2
-#define _STREAM2MMIO_START_ADDR_REG_ID          3      /* master port address,NOT Byte */
-#define _STREAM2MMIO_END_ADDR_REG_ID            4      /* master port address,NOT Byte */
-#define _STREAM2MMIO_STRIDE_REG_ID              5      /* stride in master port words, increment is per packet for long sids, stride is not used for short sid's*/
-#define _STREAM2MMIO_NUM_ITEMS_REG_ID           6      /* number of packets for store packets cmd, number of words for store_words cmd */
-#define _STREAM2MMIO_BLOCK_WHEN_NO_CMD_REG_ID   7      /* if this register is 1, input will be stalled if there is no pending command for this sid */
-#define _STREAM2MMIO_REGS_PER_SID               8
+#define _STREAM2MMIO_COMMAND_REG_ID 0
+#define _STREAM2MMIO_ACKNOWLEDGE_REG_ID 1
+#define _STREAM2MMIO_PIX_WIDTH_ID_REG_ID 2
+#define _STREAM2MMIO_START_ADDR_REG_ID 3 /* master port address,NOT Byte */
+#define _STREAM2MMIO_END_ADDR_REG_ID 4 /* master port address,NOT Byte */
+#define _STREAM2MMIO_STRIDE_REG_ID \
+	5 /* stride in master port words, increment is per packet for long sids, stride is not used for short sid's*/
+#define _STREAM2MMIO_NUM_ITEMS_REG_ID \
+	6 /* number of packets for store packets cmd, number of words for store_words cmd */
+#define _STREAM2MMIO_BLOCK_WHEN_NO_CMD_REG_ID \
+	7 /* if this register is 1, input will be stalled if there is no pending command for this sid */
+#define _STREAM2MMIO_REGS_PER_SID 8
 
-#define _STREAM2MMIO_SID_REG_OFFSET             8
-#define _STREAM2MMIO_MAX_NOF_SIDS              64      /* value used in hss model */
+#define _STREAM2MMIO_SID_REG_OFFSET 8
+#define _STREAM2MMIO_MAX_NOF_SIDS 64 /* value used in hss model */
 
 /* command token definition     */
-#define _STREAM2MMIO_CMD_TOKEN_CMD_LSB          0      /* bits 1-0 is for the command field */
-#define _STREAM2MMIO_CMD_TOKEN_CMD_MSB          1
+#define _STREAM2MMIO_CMD_TOKEN_CMD_LSB 0 /* bits 1-0 is for the command field */
+#define _STREAM2MMIO_CMD_TOKEN_CMD_MSB 1
 
-#define _STREAM2MMIO_CMD_TOKEN_WIDTH           (_STREAM2MMIO_CMD_TOKEN_CMD_MSB + 1 - _STREAM2MMIO_CMD_TOKEN_CMD_LSB)
+#define _STREAM2MMIO_CMD_TOKEN_WIDTH \
+	(_STREAM2MMIO_CMD_TOKEN_CMD_MSB + 1 - _STREAM2MMIO_CMD_TOKEN_CMD_LSB)
 
-#define _STREAM2MMIO_CMD_TOKEN_STORE_WORDS              0      /* command for storing a number of output words indicated by reg _STREAM2MMIO_NUM_ITEMS */
-#define _STREAM2MMIO_CMD_TOKEN_STORE_PACKETS            1      /* command for storing a number of packets indicated by reg _STREAM2MMIO_NUM_ITEMS      */
-#define _STREAM2MMIO_CMD_TOKEN_SYNC_FRAME               2      /* command for waiting for a frame start                                                */
+#define _STREAM2MMIO_CMD_TOKEN_STORE_WORDS \
+	0 /* command for storing a number of output words indicated by reg _STREAM2MMIO_NUM_ITEMS */
+#define _STREAM2MMIO_CMD_TOKEN_STORE_PACKETS \
+	1 /* command for storing a number of packets indicated by reg _STREAM2MMIO_NUM_ITEMS      */
+#define _STREAM2MMIO_CMD_TOKEN_SYNC_FRAME \
+	2 /* command for waiting for a frame start                                                */
 
 /* acknowledges from packer module */
 /* fields: eof   - indicates whether last (short) packet received was an eof packet */
 /*         eop   - indicates whether command has ended due to packet end or due to no of words requested has been received */
 /*         count - indicates number of words stored */
-#define _STREAM2MMIO_PACK_NUM_ITEMS_BITS        16
-#define _STREAM2MMIO_PACK_ACK_EOP_BIT           _STREAM2MMIO_PACK_NUM_ITEMS_BITS
-#define _STREAM2MMIO_PACK_ACK_EOF_BIT           (_STREAM2MMIO_PACK_ACK_EOP_BIT + 1)
+#define _STREAM2MMIO_PACK_NUM_ITEMS_BITS 16
+#define _STREAM2MMIO_PACK_ACK_EOP_BIT _STREAM2MMIO_PACK_NUM_ITEMS_BITS
+#define _STREAM2MMIO_PACK_ACK_EOF_BIT (_STREAM2MMIO_PACK_ACK_EOP_BIT + 1)
 
 /* acknowledge token definition */
-#define _STREAM2MMIO_ACK_TOKEN_NUM_ITEMS_LSB    0      /* bits 3-0 is for the command field */
-#define _STREAM2MMIO_ACK_TOKEN_NUM_ITEMS_MSB   (_STREAM2MMIO_PACK_NUM_ITEMS_BITS - 1)
-#define _STREAM2MMIO_ACK_TOKEN_EOP_BIT         _STREAM2MMIO_PACK_ACK_EOP_BIT
-#define _STREAM2MMIO_ACK_TOKEN_EOF_BIT         _STREAM2MMIO_PACK_ACK_EOF_BIT
-#define _STREAM2MMIO_ACK_TOKEN_VALID_BIT       (_STREAM2MMIO_ACK_TOKEN_EOF_BIT + 1)      /* this bit indicates a valid ack    */
+#define _STREAM2MMIO_ACK_TOKEN_NUM_ITEMS_LSB \
+	0 /* bits 3-0 is for the command field */
+#define _STREAM2MMIO_ACK_TOKEN_NUM_ITEMS_MSB \
+	(_STREAM2MMIO_PACK_NUM_ITEMS_BITS - 1)
+#define _STREAM2MMIO_ACK_TOKEN_EOP_BIT _STREAM2MMIO_PACK_ACK_EOP_BIT
+#define _STREAM2MMIO_ACK_TOKEN_EOF_BIT _STREAM2MMIO_PACK_ACK_EOF_BIT
+#define _STREAM2MMIO_ACK_TOKEN_VALID_BIT  \
+	(_STREAM2MMIO_ACK_TOKEN_EOF_BIT + \
+	 1) /* this bit indicates a valid ack    */
 /* if there is no valid ack, a read  */
 /* on the ack register returns 0     */
-#define _STREAM2MMIO_ACK_TOKEN_WIDTH           (_STREAM2MMIO_ACK_TOKEN_VALID_BIT + 1)
+#define _STREAM2MMIO_ACK_TOKEN_WIDTH (_STREAM2MMIO_ACK_TOKEN_VALID_BIT + 1)
 
 /* commands for packer module */
-#define _STREAM2MMIO_PACK_CMD_STORE_WORDS        0
-#define _STREAM2MMIO_PACK_CMD_STORE_LONG_PACKET  1
+#define _STREAM2MMIO_PACK_CMD_STORE_WORDS 0
+#define _STREAM2MMIO_PACK_CMD_STORE_LONG_PACKET 1
 #define _STREAM2MMIO_PACK_CMD_STORE_SHORT_PACKET 2
 
 #endif /* _STREAM2MMIO_DEFS_H */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/ibuf_ctrl_global.h b/drivers/staging/media/atomisp/pci/css_2401_system/ibuf_ctrl_global.h
index cab7236dc292dd4570ecf48c83352648a54f1e8e..d57abddf6cf148bb19eed484181e9106b95df7ce 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/ibuf_ctrl_global.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/ibuf_ctrl_global.h
@@ -9,7 +9,7 @@
 
 #include <type_support.h>
 
-#include <ibuf_cntrl_defs.h>	/* _IBUF_CNTRL_RECALC_WORDS_STATUS,
+#include <ibuf_cntrl_defs.h> /* _IBUF_CNTRL_RECALC_WORDS_STATUS,
 				 * _IBUF_CNTRL_ARBITERS_STATUS,
 				 * _IBUF_CNTRL_PROC_REG_ALIGN,
 				 * etc.
@@ -18,21 +18,21 @@
 /* Definition of contents of main controller state register is lacking
  * in ibuf_cntrl_defs.h, so define these here:
  */
-#define _IBUF_CNTRL_MAIN_CNTRL_FSM_MASK			0xf
-#define _IBUF_CNTRL_MAIN_CNTRL_FSM_NEXT_COMMAND_CHECK	0x9
-#define _IBUF_CNTRL_MAIN_CNTRL_MEM_INP_BUF_ALLOC	BIT(8)
-#define _IBUF_CNTRL_DMA_SYNC_WAIT_FOR_SYNC		1
-#define _IBUF_CNTRL_DMA_SYNC_FSM_WAIT_FOR_ACK		(0x3 << 1)
+#define _IBUF_CNTRL_MAIN_CNTRL_FSM_MASK 0xf
+#define _IBUF_CNTRL_MAIN_CNTRL_FSM_NEXT_COMMAND_CHECK 0x9
+#define _IBUF_CNTRL_MAIN_CNTRL_MEM_INP_BUF_ALLOC BIT(8)
+#define _IBUF_CNTRL_DMA_SYNC_WAIT_FOR_SYNC 1
+#define _IBUF_CNTRL_DMA_SYNC_FSM_WAIT_FOR_ACK (0x3 << 1)
 
-struct	isp2401_ib_buffer_s {
-	u32	start_addr;	/* start address of the buffer in the
+struct isp2401_ib_buffer_s {
+	u32 start_addr; /* start address of the buffer in the
 					 * "input-buffer hardware block"
 					 */
 
-	u32	stride;		/* stride per buffer line (in bytes) */
-	u32	lines;		/* lines in the buffer */
+	u32 stride; /* stride per buffer line (in bytes) */
+	u32 lines; /* lines in the buffer */
 };
-typedef struct isp2401_ib_buffer_s	isp2401_ib_buffer_t;
+typedef struct isp2401_ib_buffer_s isp2401_ib_buffer_t;
 
 typedef struct ibuf_ctrl_cfg_s ibuf_ctrl_cfg_t;
 struct ibuf_ctrl_cfg_s {
@@ -61,8 +61,8 @@ struct ibuf_ctrl_cfg_s {
 	u32 stores_per_frame;
 
 	struct {
-		u32 sync_cmd;	/* must be _STREAM2MMIO_CMD_TOKEN_SYNC_FRAME */
-		u32 store_cmd;	/* must be _STREAM2MMIO_CMD_TOKEN_STORE_PACKETS */
+		u32 sync_cmd; /* must be _STREAM2MMIO_CMD_TOKEN_SYNC_FRAME */
+		u32 store_cmd; /* must be _STREAM2MMIO_CMD_TOKEN_STORE_PACKETS */
 	} stream2mmio_cfg;
 };
 
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/isys_dma_global.h b/drivers/staging/media/atomisp/pci/css_2401_system/isys_dma_global.h
index de89bc4829f03f2c858c4a11254ec1d4df8d0058..bda655ab3540b9a034b3cfd2899e3e1bed7d096b 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/isys_dma_global.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/isys_dma_global.h
@@ -9,13 +9,13 @@
 
 #include <type_support.h>
 
-#define HIVE_ISYS2401_DMA_IBUF_DDR_CONN	0
-#define HIVE_ISYS2401_DMA_IBUF_VMEM_CONN	1
-#define _DMA_V2_ZERO_EXTEND		0
-#define _DMA_V2_SIGN_EXTEND		1
+#define HIVE_ISYS2401_DMA_IBUF_DDR_CONN 0
+#define HIVE_ISYS2401_DMA_IBUF_VMEM_CONN 1
+#define _DMA_V2_ZERO_EXTEND 0
+#define _DMA_V2_SIGN_EXTEND 1
 
-#define _DMA_ZERO_EXTEND     _DMA_V2_ZERO_EXTEND
-#define _DMA_SIGN_EXTEND     _DMA_V2_SIGN_EXTEND
+#define _DMA_ZERO_EXTEND _DMA_V2_ZERO_EXTEND
+#define _DMA_SIGN_EXTEND _DMA_V2_SIGN_EXTEND
 
 /********************************************************
  *
@@ -56,8 +56,8 @@ struct isys2401_dma_port_cfg_s {
  *
  ************************************************/
 typedef enum {
-	isys2401_dma_ibuf_to_ddr_connection	= HIVE_ISYS2401_DMA_IBUF_DDR_CONN,
-	isys2401_dma_ibuf_to_vmem_connection	= HIVE_ISYS2401_DMA_IBUF_VMEM_CONN
+	isys2401_dma_ibuf_to_ddr_connection = HIVE_ISYS2401_DMA_IBUF_DDR_CONN,
+	isys2401_dma_ibuf_to_vmem_connection = HIVE_ISYS2401_DMA_IBUF_VMEM_CONN
 } isys2401_dma_connection;
 
 typedef enum {
@@ -67,16 +67,16 @@ typedef enum {
 
 typedef struct isys2401_dma_cfg_s isys2401_dma_cfg_t;
 struct isys2401_dma_cfg_s {
-	isys2401_dma_channel	channel;
-	isys2401_dma_connection	connection;
-	isys2401_dma_extension	extension;
-	u32		height;
+	isys2401_dma_channel channel;
+	isys2401_dma_connection connection;
+	isys2401_dma_extension extension;
+	u32 height;
 };
 
 /* end of DMA Device */
 
 /* isys2401_dma_channel limits per DMA ID */
 extern const isys2401_dma_channel
-N_ISYS2401_DMA_CHANNEL_PROCS[N_ISYS2401_DMA_ID];
+	N_ISYS2401_DMA_CHANNEL_PROCS[N_ISYS2401_DMA_ID];
 
 #endif /* __ISYS_DMA_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/isys_irq_global.h b/drivers/staging/media/atomisp/pci/css_2401_system/isys_irq_global.h
index bd584ccc1a9ab632aa3727949a3b562e689a9b34..8926f4f303e40444d492d7bf3577d7aa147db624 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/isys_irq_global.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/isys_irq_global.h
@@ -7,19 +7,17 @@
 #ifndef __ISYS_IRQ_GLOBAL_H__
 #define __ISYS_IRQ_GLOBAL_H__
 
-
 /* Register offset/index from base location */
-#define ISYS_IRQ_EDGE_REG_IDX		(0)
-#define ISYS_IRQ_MASK_REG_IDX		(ISYS_IRQ_EDGE_REG_IDX + 1)
-#define ISYS_IRQ_STATUS_REG_IDX		(ISYS_IRQ_EDGE_REG_IDX + 2)
-#define ISYS_IRQ_CLEAR_REG_IDX		(ISYS_IRQ_EDGE_REG_IDX + 3)
-#define ISYS_IRQ_ENABLE_REG_IDX		(ISYS_IRQ_EDGE_REG_IDX + 4)
-#define ISYS_IRQ_LEVEL_NO_REG_IDX	(ISYS_IRQ_EDGE_REG_IDX + 5)
+#define ISYS_IRQ_EDGE_REG_IDX (0)
+#define ISYS_IRQ_MASK_REG_IDX (ISYS_IRQ_EDGE_REG_IDX + 1)
+#define ISYS_IRQ_STATUS_REG_IDX (ISYS_IRQ_EDGE_REG_IDX + 2)
+#define ISYS_IRQ_CLEAR_REG_IDX (ISYS_IRQ_EDGE_REG_IDX + 3)
+#define ISYS_IRQ_ENABLE_REG_IDX (ISYS_IRQ_EDGE_REG_IDX + 4)
+#define ISYS_IRQ_LEVEL_NO_REG_IDX (ISYS_IRQ_EDGE_REG_IDX + 5)
 
 /* Register values */
-#define ISYS_IRQ_MASK_REG_VALUE		(0xFFFF)
-#define ISYS_IRQ_CLEAR_REG_VALUE	(0xFFFF)
-#define ISYS_IRQ_ENABLE_REG_VALUE	(0xFFFF)
-
+#define ISYS_IRQ_MASK_REG_VALUE (0xFFFF)
+#define ISYS_IRQ_CLEAR_REG_VALUE (0xFFFF)
+#define ISYS_IRQ_ENABLE_REG_VALUE (0xFFFF)
 
-#endif	/* __ISYS_IRQ_GLOBAL_H__ */
+#endif /* __ISYS_IRQ_GLOBAL_H__ */
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/isys_stream2mmio_global.h b/drivers/staging/media/atomisp/pci/css_2401_system/isys_stream2mmio_global.h
index c6d8d9e729810e260978816dd0e2993c13420a09..9b3904babdac07d3fe2d66ecb0f927dcfe087559 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/isys_stream2mmio_global.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/isys_stream2mmio_global.h
@@ -11,8 +11,8 @@
 
 typedef struct stream2mmio_cfg_s stream2mmio_cfg_t;
 struct stream2mmio_cfg_s {
-	u32				bits_per_pixel;
-	u32				enable_blocking;
+	u32 bits_per_pixel;
+	u32 enable_blocking;
 };
 
 /* Stream2MMIO limits  per ID*/
diff --git a/drivers/staging/media/atomisp/pci/css_2401_system/pixelgen_global.h b/drivers/staging/media/atomisp/pci/css_2401_system/pixelgen_global.h
index 59e0b44bfdc3d4fce81fe4dd038cb8455b2a574b..9eb599a9c8ec9ecc45d374223669ed8e95ec5d2f 100644
--- a/drivers/staging/media/atomisp/pci/css_2401_system/pixelgen_global.h
+++ b/drivers/staging/media/atomisp/pci/css_2401_system/pixelgen_global.h
@@ -17,12 +17,12 @@
  */
 typedef struct isp2401_sync_generator_cfg_s isp2401_sync_generator_cfg_t;
 struct isp2401_sync_generator_cfg_s {
-	u32	hblank_cycles;
-	u32	vblank_cycles;
-	u32	pixels_per_clock;
-	u32	nr_of_frames;
-	u32	pixels_per_line;
-	u32	lines_per_frame;
+	u32 hblank_cycles;
+	u32 vblank_cycles;
+	u32 pixels_per_clock;
+	u32 nr_of_frames;
+	u32 pixels_per_line;
+	u32 lines_per_frame;
 };
 
 typedef enum {
@@ -38,7 +38,7 @@ typedef enum {
  */
 typedef struct pixelgen_tpg_cfg_s pixelgen_tpg_cfg_t;
 struct pixelgen_tpg_cfg_s {
-	pixelgen_tpg_mode_t	mode;	/* CHBO, MONO */
+	pixelgen_tpg_mode_t mode; /* CHBO, MONO */
 
 	struct {
 		/* be used by CHBO and MON */
@@ -53,17 +53,17 @@ struct pixelgen_tpg_cfg_s {
 	} color_cfg;
 
 	struct {
-		u32	h_mask;		/* horizontal mask */
-		u32	v_mask;		/* vertical mask */
-		u32	hv_mask;	/* horizontal+vertical mask? */
+		u32 h_mask; /* horizontal mask */
+		u32 v_mask; /* vertical mask */
+		u32 hv_mask; /* horizontal+vertical mask? */
 	} mask_cfg;
 
 	struct {
-		s32	h_delta;	/* horizontal delta? */
-		s32	v_delta;	/* vertical delta? */
+		s32 h_delta; /* horizontal delta? */
+		s32 v_delta; /* vertical delta? */
 	} delta_cfg;
 
-	isp2401_sync_generator_cfg_t	 sync_gen_cfg;
+	isp2401_sync_generator_cfg_t sync_gen_cfg;
 };
 
 /*
@@ -72,10 +72,10 @@ struct pixelgen_tpg_cfg_s {
  */
 typedef struct pixelgen_prbs_cfg_s pixelgen_prbs_cfg_t;
 struct pixelgen_prbs_cfg_s {
-	s32	seed0;
-	s32	seed1;
+	s32 seed0;
+	s32 seed1;
 
-	isp2401_sync_generator_cfg_t	sync_gen_cfg;
+	isp2401_sync_generator_cfg_t sync_gen_cfg;
 };
 
 /* end of Pixel-generator: TPG. ("pixelgen_global.h") */
diff --git a/drivers/staging/media/atomisp/pci/css_receiver_2400_common_defs.h b/drivers/staging/media/atomisp/pci/css_receiver_2400_common_defs.h
index fc733a72d1e381c3a54406d1d84e62bbaf70d3b2..6e7fb20e762a1f786b0faf60a8b36aefa17ef44f 100644
--- a/drivers/staging/media/atomisp/pci/css_receiver_2400_common_defs.h
+++ b/drivers/staging/media/atomisp/pci/css_receiver_2400_common_defs.h
@@ -9,182 +9,233 @@
 #ifndef _mipi_backend_common_defs_h_
 #define _mipi_backend_common_defs_h_
 
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH     16
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH     2
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH  3
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_REAL_WIDTH (_HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH + _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH + _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH)
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_WIDTH      32 /* use 32 to be compatibel with streaming monitor !, MSB's of interface are tied to '0' */
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH 16
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH 2
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH 3
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_REAL_WIDTH \
+	(_HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH +  \
+	 _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH + \
+	 _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_WIDTH \
+	32 /* use 32 to be compatibel with streaming monitor !, MSB's of interface are tied to '0' */
 
 /* Definition of data format ID at the interface CSS_receiver capture/acquisition units */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8          24   /* 01 1000 YUV420 8-bit                                        */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10         25   /* 01 1001  YUV420 10-bit                                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8L         26   /* 01 1010   YUV420 8-bit legacy                               */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_8          30   /* 01 1110   YUV422 8-bit                                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_10         31   /* 01 1111   YUV422 10-bit                                     */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB444            32   /* 10 0000   RGB444                                            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB555            33   /* 10 0001   RGB555                                            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB565            34   /* 10 0010   RGB565                                            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB666            35   /* 10 0011   RGB666                                            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB888            36   /* 10 0100   RGB888                                            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW6              40   /* 10 1000   RAW6                                              */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW7              41   /* 10 1001   RAW7                                              */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW8              42   /* 10 1010   RAW8                                              */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW10             43   /* 10 1011   RAW10                                             */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW12             44   /* 10 1100   RAW12                                             */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW14             45   /* 10 1101   RAW14                                             */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_1         48   /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_2         49   /* 11 0001    User Defined 8-bit Data Type 2                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_3         50   /* 11 0010    User Defined 8-bit Data Type 3                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_4         51   /* 11 0011    User Defined 8-bit Data Type 4                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_5         52   /* 11 0100    User Defined 8-bit Data Type 5                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_6         53   /* 11 0101    User Defined 8-bit Data Type 6                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_7         54   /* 11 0110    User Defined 8-bit Data Type 7                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_8         55   /* 11 0111    User Defined 8-bit Data Type 8                   */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_Emb               18   /* 01 0010    embedded eight bit non image data                */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOF                0   /* 00 0000    frame start                                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOF                1   /* 00 0001    frame end                                        */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOL                2   /* 00 0010    line start                                       */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOL                3   /* 00 0011    line end                                         */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH1            8   /* 00 1000  Generic Short Packet Code 1                        */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH2            9   /* 00 1001    Generic Short Packet Code 2                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH3           10   /* 00 1010    Generic Short Packet Code 3                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH4           11   /* 00 1011    Generic Short Packet Code 4                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH5           12   /* 00 1100    Generic Short Packet Code 5                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH6           13   /* 00 1101    Generic Short Packet Code 6                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH7           14   /* 00 1110    Generic Short Packet Code 7                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH8           15   /* 00 1111    Generic Short Packet Code 8                      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8_CSPS     28   /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10_CSPS    29   /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8 \
+	24 /* 01 1000 YUV420 8-bit                                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10 \
+	25 /* 01 1001  YUV420 10-bit                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8L \
+	26 /* 01 1010   YUV420 8-bit legacy                               */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_8 \
+	30 /* 01 1110   YUV422 8-bit                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_10 \
+	31 /* 01 1111   YUV422 10-bit                                     */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB444 \
+	32 /* 10 0000   RGB444                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB555 \
+	33 /* 10 0001   RGB555                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB565 \
+	34 /* 10 0010   RGB565                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB666 \
+	35 /* 10 0011   RGB666                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB888 \
+	36 /* 10 0100   RGB888                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW6 \
+	40 /* 10 1000   RAW6                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW7 \
+	41 /* 10 1001   RAW7                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW8 \
+	42 /* 10 1010   RAW8                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW10 \
+	43 /* 10 1011   RAW10                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW12 \
+	44 /* 10 1100   RAW12                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW14 \
+	45 /* 10 1101   RAW14                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_1 \
+	48 /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_2 \
+	49 /* 11 0001    User Defined 8-bit Data Type 2                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_3 \
+	50 /* 11 0010    User Defined 8-bit Data Type 3                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_4 \
+	51 /* 11 0011    User Defined 8-bit Data Type 4                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_5 \
+	52 /* 11 0100    User Defined 8-bit Data Type 5                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_6 \
+	53 /* 11 0101    User Defined 8-bit Data Type 6                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_7 \
+	54 /* 11 0110    User Defined 8-bit Data Type 7                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_8 \
+	55 /* 11 0111    User Defined 8-bit Data Type 8                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_Emb \
+	18 /* 01 0010    embedded eight bit non image data                */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOF \
+	0 /* 00 0000    frame start                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOF \
+	1 /* 00 0001    frame end                                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOL \
+	2 /* 00 0010    line start                                       */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOL \
+	3 /* 00 0011    line end                                         */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH1 \
+	8 /* 00 1000  Generic Short Packet Code 1                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH2 \
+	9 /* 00 1001    Generic Short Packet Code 2                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH3 \
+	10 /* 00 1010    Generic Short Packet Code 3                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH4 \
+	11 /* 00 1011    Generic Short Packet Code 4                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH5 \
+	12 /* 00 1100    Generic Short Packet Code 5                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH6 \
+	13 /* 00 1101    Generic Short Packet Code 6                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH7 \
+	14 /* 00 1110    Generic Short Packet Code 7                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH8 \
+	15 /* 00 1111    Generic Short Packet Code 8                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8_CSPS \
+	28 /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10_CSPS \
+	29 /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
 /* used reserved mipi positions for these */
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW16             46
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18             47
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_2           37
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_3           38
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW16 46
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18 47
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_2 37
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_3 38
 
-#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_WIDTH              6
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_WIDTH 6
 
 /* Definition of format_types at the interface CSS --> input_selector*/
 /* !! Changes here should be copied to systems/isp/isp_css/bin/conv_transmitter_cmd.tcl !! */
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB888           0  // 36 'h24
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB555           1  // 33 'h
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB444           2  // 32
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB565           3  // 34
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB666           4  // 35
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW8             5  // 42
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW10            6  // 43
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW6             7  // 40
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW7             8  // 41
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW12            9  // 43
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW14           10  // 45
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8        11  // 30
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10       12  // 25
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_8        13  // 30
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_10       14  // 31
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_1       15  // 48
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8L       16  // 26
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_Emb             17  // 18
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_2       18  // 49
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_3       19  // 50
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_4       20  // 51
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_5       21  // 52
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_6       22  // 53
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_7       23  // 54
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_8       24  // 55
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8_CSPS   25  // 28
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10_CSPS  26  // 29
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW16           27  // ?
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18           28  // ?
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_2         29  // ? Option 2 for depacketiser
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_3         30  // ? Option 3 for depacketiser
-#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_CUSTOM          31  // to signal custom decoding
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB888 0 // 36 'h24
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB555 1 // 33 'h
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB444 2 // 32
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB565 3 // 34
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB666 4 // 35
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW8 5 // 42
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW10 6 // 43
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW6 7 // 40
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW7 8 // 41
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW12 9 // 43
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW14 10 // 45
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8 11 // 30
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10 12 // 25
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_8 13 // 30
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_10 14 // 31
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_1 15 // 48
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8L 16 // 26
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_Emb 17 // 18
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_2 18 // 49
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_3 19 // 50
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_4 20 // 51
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_5 21 // 52
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_6 22 // 53
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_7 23 // 54
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_8 24 // 55
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8_CSPS 25 // 28
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10_CSPS 26 // 29
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW16 27 // ?
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18 28 // ?
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_2 \
+	29 // ? Option 2 for depacketiser
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_3 \
+	30 // ? Option 3 for depacketiser
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_CUSTOM 31 // to signal custom decoding
 
 /* definition for state machine of data FIFO for decode different type of data */
-#define _HRT_CSS_RECEIVER_2400_YUV420_8_REPEAT_PTN                 1
-#define _HRT_CSS_RECEIVER_2400_YUV420_10_REPEAT_PTN                5
-#define _HRT_CSS_RECEIVER_2400_YUV420_8L_REPEAT_PTN                1
-#define _HRT_CSS_RECEIVER_2400_YUV422_8_REPEAT_PTN                 1
-#define _HRT_CSS_RECEIVER_2400_YUV422_10_REPEAT_PTN                5
-#define _HRT_CSS_RECEIVER_2400_RGB444_REPEAT_PTN                   2
-#define _HRT_CSS_RECEIVER_2400_RGB555_REPEAT_PTN                   2
-#define _HRT_CSS_RECEIVER_2400_RGB565_REPEAT_PTN                   2
-#define _HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN                   9
-#define _HRT_CSS_RECEIVER_2400_RGB888_REPEAT_PTN                   3
-#define _HRT_CSS_RECEIVER_2400_RAW6_REPEAT_PTN                     3
-#define _HRT_CSS_RECEIVER_2400_RAW7_REPEAT_PTN                     7
-#define _HRT_CSS_RECEIVER_2400_RAW8_REPEAT_PTN                     1
-#define _HRT_CSS_RECEIVER_2400_RAW10_REPEAT_PTN                    5
-#define _HRT_CSS_RECEIVER_2400_RAW12_REPEAT_PTN                    3
-#define _HRT_CSS_RECEIVER_2400_RAW14_REPEAT_PTN                    7
-
-#define _HRT_CSS_RECEIVER_2400_MAX_REPEAT_PTN                      _HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN
-
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_IDX                     0
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_WIDTH                   3
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_IDX                    3
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_WIDTH                  1
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_USD_BITS                    4  /* bits per USD type */
-
-#define _HRT_CSS_RECEIVER_2400_BE_RAW16_DATAID_IDX                 0
-#define _HRT_CSS_RECEIVER_2400_BE_RAW16_EN_IDX                     6
-#define _HRT_CSS_RECEIVER_2400_BE_RAW18_DATAID_IDX                 0
-#define _HRT_CSS_RECEIVER_2400_BE_RAW18_OPTION_IDX                 6
-#define _HRT_CSS_RECEIVER_2400_BE_RAW18_EN_IDX                     8
-
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_NO_COMP                     0
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_6_10                     1
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_7_10                     2
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_8_10                     3
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_6_12                     4
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_7_12                     5
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_8_12                     6
+#define _HRT_CSS_RECEIVER_2400_YUV420_8_REPEAT_PTN 1
+#define _HRT_CSS_RECEIVER_2400_YUV420_10_REPEAT_PTN 5
+#define _HRT_CSS_RECEIVER_2400_YUV420_8L_REPEAT_PTN 1
+#define _HRT_CSS_RECEIVER_2400_YUV422_8_REPEAT_PTN 1
+#define _HRT_CSS_RECEIVER_2400_YUV422_10_REPEAT_PTN 5
+#define _HRT_CSS_RECEIVER_2400_RGB444_REPEAT_PTN 2
+#define _HRT_CSS_RECEIVER_2400_RGB555_REPEAT_PTN 2
+#define _HRT_CSS_RECEIVER_2400_RGB565_REPEAT_PTN 2
+#define _HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN 9
+#define _HRT_CSS_RECEIVER_2400_RGB888_REPEAT_PTN 3
+#define _HRT_CSS_RECEIVER_2400_RAW6_REPEAT_PTN 3
+#define _HRT_CSS_RECEIVER_2400_RAW7_REPEAT_PTN 7
+#define _HRT_CSS_RECEIVER_2400_RAW8_REPEAT_PTN 1
+#define _HRT_CSS_RECEIVER_2400_RAW10_REPEAT_PTN 5
+#define _HRT_CSS_RECEIVER_2400_RAW12_REPEAT_PTN 3
+#define _HRT_CSS_RECEIVER_2400_RAW14_REPEAT_PTN 7
+
+#define _HRT_CSS_RECEIVER_2400_MAX_REPEAT_PTN \
+	_HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN
+
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_IDX 0
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_WIDTH 3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_IDX 3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_WIDTH 1
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_USD_BITS 4 /* bits per USD type */
+
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_DATAID_IDX 0
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_EN_IDX 6
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_DATAID_IDX 0
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_OPTION_IDX 6
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_EN_IDX 8
+
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_NO_COMP 0
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_6_10 1
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_7_10 2
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_8_10 3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_6_12 4
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_7_12 5
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_8_12 6
 
 /* packet bit definition */
-#define _HRT_CSS_RECEIVER_2400_PKT_SOP_IDX                        32
-#define _HRT_CSS_RECEIVER_2400_PKT_SOP_BITS                        1
-#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_IDX                      22
-#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_BITS                      2
-#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_IDX                     16
-#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_BITS                     6
-#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_IDX                   0
-#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_BITS                 16
-#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_IDX                     0
-#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_BITS                   32
+#define _HRT_CSS_RECEIVER_2400_PKT_SOP_IDX 32
+#define _HRT_CSS_RECEIVER_2400_PKT_SOP_BITS 1
+#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_IDX 22
+#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_BITS 2
+#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_IDX 16
+#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_BITS 6
+#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_IDX 0
+#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_BITS 16
+#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_IDX 0
+#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_BITS 32
 
 /*************************************************************************************************/
 /* Custom Decoding                                                                               */
 /* These Custom Defs are defined based on design-time config in "csi_be_pixel_formatter.chdl" !! */
 /*************************************************************************************************/
-#define BE_CUST_EN_IDX                     0     /* 2bits */
-#define BE_CUST_EN_DATAID_IDX              2     /* 6bits MIPI DATA ID */
-#define BE_CUST_EN_WIDTH                   8
-#define BE_CUST_MODE_ALL                   1     /* Enable Custom Decoding for all DATA IDs */
-#define BE_CUST_MODE_ONE                   3     /* Enable Custom Decoding for ONE DATA ID, programmed in CUST_EN_DATA_ID */
+#define BE_CUST_EN_IDX 0 /* 2bits */
+#define BE_CUST_EN_DATAID_IDX 2 /* 6bits MIPI DATA ID */
+#define BE_CUST_EN_WIDTH 8
+#define BE_CUST_MODE_ALL 1 /* Enable Custom Decoding for all DATA IDs */
+#define BE_CUST_MODE_ONE \
+	3 /* Enable Custom Decoding for ONE DATA ID, programmed in CUST_EN_DATA_ID */
 
 /* Data State config = {get_bits(6bits), valid(1bit)}  */
-#define BE_CUST_DATA_STATE_S0_IDX          0     /* 7bits */
-#define BE_CUST_DATA_STATE_S1_IDX          7     /* 7bits */
-#define BE_CUST_DATA_STATE_S2_IDX          14    /* 7bits */
-#define BE_CUST_DATA_STATE_WIDTH           21
-#define BE_CUST_DATA_STATE_VALID_IDX       0     /* 1bits */
-#define BE_CUST_DATA_STATE_GETBITS_IDX     1     /* 6bits */
+#define BE_CUST_DATA_STATE_S0_IDX 0 /* 7bits */
+#define BE_CUST_DATA_STATE_S1_IDX 7 /* 7bits */
+#define BE_CUST_DATA_STATE_S2_IDX 14 /* 7bits */
+#define BE_CUST_DATA_STATE_WIDTH 21
+#define BE_CUST_DATA_STATE_VALID_IDX 0 /* 1bits */
+#define BE_CUST_DATA_STATE_GETBITS_IDX 1 /* 6bits */
 
 /* Pixel Extractor config */
-#define BE_CUST_PIX_EXT_DATA_ALIGN_IDX     0     /* 5bits */
-#define BE_CUST_PIX_EXT_PIX_ALIGN_IDX      5     /* 5bits */
-#define BE_CUST_PIX_EXT_PIX_MASK_IDX       10    /* 18bits */
-#define BE_CUST_PIX_EXT_PIX_EN_IDX         28    /* 1bits */
-#define BE_CUST_PIX_EXT_WIDTH              29
+#define BE_CUST_PIX_EXT_DATA_ALIGN_IDX 0 /* 5bits */
+#define BE_CUST_PIX_EXT_PIX_ALIGN_IDX 5 /* 5bits */
+#define BE_CUST_PIX_EXT_PIX_MASK_IDX 10 /* 18bits */
+#define BE_CUST_PIX_EXT_PIX_EN_IDX 28 /* 1bits */
+#define BE_CUST_PIX_EXT_WIDTH 29
 
 /* Pixel Valid & EoP config = {[eop,valid](especial), [eop,valid](normal)} */
-#define BE_CUST_PIX_VALID_EOP_P0_IDX        0    /* 4bits */
-#define BE_CUST_PIX_VALID_EOP_P1_IDX        4    /* 4bits */
-#define BE_CUST_PIX_VALID_EOP_P2_IDX        8    /* 4bits */
-#define BE_CUST_PIX_VALID_EOP_P3_IDX        12   /* 4bits */
-#define BE_CUST_PIX_VALID_EOP_WIDTH         16
-#define BE_CUST_PIX_VALID_EOP_NOR_VALID_IDX 0    /* Normal (NO less get_bits case) Valid - 1bits */
-#define BE_CUST_PIX_VALID_EOP_NOR_EOP_IDX   1    /* Normal (NO less get_bits case) EoP - 1bits */
-#define BE_CUST_PIX_VALID_EOP_ESP_VALID_IDX 2    /* Especial (less get_bits case) Valid - 1bits */
-#define BE_CUST_PIX_VALID_EOP_ESP_EOP_IDX   3    /* Especial (less get_bits case) EoP - 1bits */
+#define BE_CUST_PIX_VALID_EOP_P0_IDX 0 /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_P1_IDX 4 /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_P2_IDX 8 /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_P3_IDX 12 /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_WIDTH 16
+#define BE_CUST_PIX_VALID_EOP_NOR_VALID_IDX \
+	0 /* Normal (NO less get_bits case) Valid - 1bits */
+#define BE_CUST_PIX_VALID_EOP_NOR_EOP_IDX \
+	1 /* Normal (NO less get_bits case) EoP - 1bits */
+#define BE_CUST_PIX_VALID_EOP_ESP_VALID_IDX \
+	2 /* Especial (less get_bits case) Valid - 1bits */
+#define BE_CUST_PIX_VALID_EOP_ESP_EOP_IDX \
+	3 /* Especial (less get_bits case) EoP - 1bits */
 
 #endif /* _mipi_backend_common_defs_h_ */
 #endif /* _css_receiver_2400_common_defs_h_ */
diff --git a/drivers/staging/media/atomisp/pci/css_receiver_2400_defs.h b/drivers/staging/media/atomisp/pci/css_receiver_2400_defs.h
index 6dd6e7290eb821226161273e73dadd453dbb3260..c21e65b244024a040cada9b2aa476f54af8f3a73 100644
--- a/drivers/staging/media/atomisp/pci/css_receiver_2400_defs.h
+++ b/drivers/staging/media/atomisp/pci/css_receiver_2400_defs.h
@@ -9,63 +9,70 @@
 
 #include "css_receiver_2400_common_defs.h"
 
-#define CSS_RECEIVER_DATA_WIDTH                8
-#define CSS_RECEIVER_RX_TRIG                   4
-#define CSS_RECEIVER_RF_WORD                  32
-#define CSS_RECEIVER_IMG_PROC_RF_ADDR         10
-#define CSS_RECEIVER_CSI_RF_ADDR               4
-#define CSS_RECEIVER_DATA_OUT                 12
-#define CSS_RECEIVER_CHN_NO                    2
-#define CSS_RECEIVER_DWORD_CNT                11
-#define CSS_RECEIVER_FORMAT_TYP                5
-#define CSS_RECEIVER_HRESPONSE                 2
-#define CSS_RECEIVER_STATE_WIDTH               3
-#define CSS_RECEIVER_FIFO_DAT                 32
-#define CSS_RECEIVER_CNT_VAL                   2
-#define CSS_RECEIVER_PRED10_VAL               10
-#define CSS_RECEIVER_PRED12_VAL               12
-#define CSS_RECEIVER_CNT_WIDTH                 8
-#define CSS_RECEIVER_WORD_CNT                 16
-#define CSS_RECEIVER_PIXEL_LEN                 6
-#define CSS_RECEIVER_PIXEL_CNT                 5
-#define CSS_RECEIVER_COMP_8_BIT                8
-#define CSS_RECEIVER_COMP_7_BIT                7
-#define CSS_RECEIVER_COMP_6_BIT                6
-
-#define CSI_CONFIG_WIDTH                       4
+#define CSS_RECEIVER_DATA_WIDTH 8
+#define CSS_RECEIVER_RX_TRIG 4
+#define CSS_RECEIVER_RF_WORD 32
+#define CSS_RECEIVER_IMG_PROC_RF_ADDR 10
+#define CSS_RECEIVER_CSI_RF_ADDR 4
+#define CSS_RECEIVER_DATA_OUT 12
+#define CSS_RECEIVER_CHN_NO 2
+#define CSS_RECEIVER_DWORD_CNT 11
+#define CSS_RECEIVER_FORMAT_TYP 5
+#define CSS_RECEIVER_HRESPONSE 2
+#define CSS_RECEIVER_STATE_WIDTH 3
+#define CSS_RECEIVER_FIFO_DAT 32
+#define CSS_RECEIVER_CNT_VAL 2
+#define CSS_RECEIVER_PRED10_VAL 10
+#define CSS_RECEIVER_PRED12_VAL 12
+#define CSS_RECEIVER_CNT_WIDTH 8
+#define CSS_RECEIVER_WORD_CNT 16
+#define CSS_RECEIVER_PIXEL_LEN 6
+#define CSS_RECEIVER_PIXEL_CNT 5
+#define CSS_RECEIVER_COMP_8_BIT 8
+#define CSS_RECEIVER_COMP_7_BIT 7
+#define CSS_RECEIVER_COMP_6_BIT 6
+
+#define CSI_CONFIG_WIDTH 4
 
 /* division of gen_short data, ch_id and fmt_type over streaming data interface */
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_LSB     0
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_LSB     + _HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH)
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_LSB    (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB + _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH)
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_MSB     (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB - 1)
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_MSB (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_LSB    - 1)
-#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_MSB    (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_REAL_WIDTH       - 1)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_LSB 0
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB \
+	(_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_LSB +  \
+	 _HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_LSB       \
+	(_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB + \
+	 _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_MSB \
+	(_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB - 1)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_MSB \
+	(_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_LSB - 1)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_MSB \
+	(_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_REAL_WIDTH - 1)
 
 #define _HRT_CSS_RECEIVER_2400_REG_ALIGN 4
-#define _HRT_CSS_RECEIVER_2400_BYTES_PER_PKT             4
+#define _HRT_CSS_RECEIVER_2400_BYTES_PER_PKT 4
 
-#define hrt_css_receiver_2400_4_lane_port_offset  0x100
-#define hrt_css_receiver_2400_1_lane_port_offset  0x200
-#define hrt_css_receiver_2400_2_lane_port_offset  0x300
+#define hrt_css_receiver_2400_4_lane_port_offset 0x100
+#define hrt_css_receiver_2400_1_lane_port_offset 0x200
+#define hrt_css_receiver_2400_2_lane_port_offset 0x300
 #define hrt_css_receiver_2400_backend_port_offset 0x100
 
-#define _HRT_CSS_RECEIVER_2400_DEVICE_READY_REG_IDX      0
-#define _HRT_CSS_RECEIVER_2400_IRQ_STATUS_REG_IDX        1
-#define _HRT_CSS_RECEIVER_2400_IRQ_ENABLE_REG_IDX        2
-#define _HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX    3
-#define _HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX        4
-#define _HRT_CSS_RECEIVER_2400_FS_TO_LS_DELAY_REG_IDX    7
-#define _HRT_CSS_RECEIVER_2400_LS_TO_DATA_DELAY_REG_IDX  8
-#define _HRT_CSS_RECEIVER_2400_DATA_TO_LE_DELAY_REG_IDX  9
-#define _HRT_CSS_RECEIVER_2400_LE_TO_FE_DELAY_REG_IDX   10
-#define _HRT_CSS_RECEIVER_2400_FE_TO_FS_DELAY_REG_IDX   11
-#define _HRT_CSS_RECEIVER_2400_LE_TO_LS_DELAY_REG_IDX   12
-#define _HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX     13
-#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_REG_IDX  14
-#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX       15
-#define _HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX         16
-#define _HRT_CSS_RECEIVER_2400_BACKEND_RST_REG_IDX      17
+#define _HRT_CSS_RECEIVER_2400_DEVICE_READY_REG_IDX 0
+#define _HRT_CSS_RECEIVER_2400_IRQ_STATUS_REG_IDX 1
+#define _HRT_CSS_RECEIVER_2400_IRQ_ENABLE_REG_IDX 2
+#define _HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX 3
+#define _HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX 4
+#define _HRT_CSS_RECEIVER_2400_FS_TO_LS_DELAY_REG_IDX 7
+#define _HRT_CSS_RECEIVER_2400_LS_TO_DATA_DELAY_REG_IDX 8
+#define _HRT_CSS_RECEIVER_2400_DATA_TO_LE_DELAY_REG_IDX 9
+#define _HRT_CSS_RECEIVER_2400_LE_TO_FE_DELAY_REG_IDX 10
+#define _HRT_CSS_RECEIVER_2400_FE_TO_FS_DELAY_REG_IDX 11
+#define _HRT_CSS_RECEIVER_2400_LE_TO_LS_DELAY_REG_IDX 12
+#define _HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX 13
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_REG_IDX 14
+#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX 15
+#define _HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX 16
+#define _HRT_CSS_RECEIVER_2400_BACKEND_RST_REG_IDX 17
 #define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX 18
 #define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX 19
 #define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX 20
@@ -74,175 +81,204 @@
 #define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX 23
 #define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX 24
 #define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX 25
-#define _HRT_CSS_RECEIVER_2400_RAW18_REG_IDX            26
-#define _HRT_CSS_RECEIVER_2400_FORCE_RAW8_REG_IDX       27
-#define _HRT_CSS_RECEIVER_2400_RAW16_REG_IDX            28
+#define _HRT_CSS_RECEIVER_2400_RAW18_REG_IDX 26
+#define _HRT_CSS_RECEIVER_2400_FORCE_RAW8_REG_IDX 27
+#define _HRT_CSS_RECEIVER_2400_RAW16_REG_IDX 28
 
 /* Interrupt bits for IRQ_STATUS and IRQ_ENABLE registers */
-#define _HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_BIT                0
-#define _HRT_CSS_RECEIVER_2400_IRQ_RESERVED_BIT               1
-#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_BIT       2
-#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_BIT        3
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_BIT             4
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_BIT        5
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_BIT            6
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_BIT         7
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_BIT      8
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_BIT  9
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_BIT               10
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_BIT                11
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_BIT        12
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_BIT        13
-#define _HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_BIT          14
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_BIT            15
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_BIT         16
-
-#define _HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_CAUSE_                  "Fifo Overrun"
-#define _HRT_CSS_RECEIVER_2400_IRQ_RESERVED_CAUSE_                 "Reserved"
-#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_CAUSE_         "Sleep mode entry"
-#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_CAUSE_          "Sleep mode exit"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_CAUSE_               "Error high speed SOT"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_CAUSE_          "Error high speed sync SOT"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_CAUSE_              "Error control"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_CAUSE_           "Error correction double bit"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_CAUSE_        "Error correction single bit"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_CAUSE_    "No error"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_CAUSE_                  "Error cyclic redundancy check"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_CAUSE_                   "Error id"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_CAUSE_           "Error frame sync"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_CAUSE_           "Error frame data"
-#define _HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_CAUSE_             "Data time-out"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_CAUSE_               "Error escape"
-#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_CAUSE_            "Error line sync"
+#define _HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_BIT 0
+#define _HRT_CSS_RECEIVER_2400_IRQ_RESERVED_BIT 1
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_BIT 2
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_BIT 3
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_BIT 4
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_BIT 5
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_BIT 6
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_BIT 7
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_BIT 8
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_BIT 9
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_BIT 10
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_BIT 11
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_BIT 12
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_BIT 13
+#define _HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_BIT 14
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_BIT 15
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_BIT 16
+
+#define _HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_CAUSE_ "Fifo Overrun"
+#define _HRT_CSS_RECEIVER_2400_IRQ_RESERVED_CAUSE_ "Reserved"
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_CAUSE_ "Sleep mode entry"
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_CAUSE_ "Sleep mode exit"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_CAUSE_ "Error high speed SOT"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_CAUSE_ \
+	"Error high speed sync SOT"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_CAUSE_ "Error control"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_CAUSE_ \
+	"Error correction double bit"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_CAUSE_ \
+	"Error correction single bit"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_CAUSE_ "No error"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_CAUSE_ \
+	"Error cyclic redundancy check"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_CAUSE_ "Error id"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_CAUSE_ "Error frame sync"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_CAUSE_ "Error frame data"
+#define _HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_CAUSE_ "Data time-out"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_CAUSE_ "Error escape"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_CAUSE_ "Error line sync"
 
 /* Bits for CSI2_DEVICE_READY register */
-#define _HRT_CSS_RECEIVER_2400_CSI2_DEVICE_READY_IDX                          0
-#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_INIT_TIME_OUT_ERR_IDX                2
-#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_OVER_RUN_ERR_IDX                     3
-#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_SOT_SYNC_ERR_IDX                     4
-#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_RECEIVE_DATA_TIME_OUT_ERR_IDX        5
-#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_ECC_TWO_BIT_ERR_IDX                  6
-#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_DATA_ID_ERR_IDX                      7
+#define _HRT_CSS_RECEIVER_2400_CSI2_DEVICE_READY_IDX 0
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_INIT_TIME_OUT_ERR_IDX 2
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_OVER_RUN_ERR_IDX 3
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_SOT_SYNC_ERR_IDX 4
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_RECEIVE_DATA_TIME_OUT_ERR_IDX 5
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_ECC_TWO_BIT_ERR_IDX 6
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_DATA_ID_ERR_IDX 7
 
 /* Bits for CSI2_FUNC_PROG register */
-#define _HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_IDX    0
-#define _HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_BITS   19
+#define _HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_IDX 0
+#define _HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_BITS 19
 
 /* Bits for INIT_COUNT register */
-#define _HRT_CSS_RECEIVER_2400_INIT_TIMER_IDX  0
+#define _HRT_CSS_RECEIVER_2400_INIT_TIMER_IDX 0
 #define _HRT_CSS_RECEIVER_2400_INIT_TIMER_BITS 16
 
 /* Bits for COUNT registers */
-#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_IDX     0
-#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_BITS    8
-#define _HRT_CSS_RECEIVER_2400_RX_COUNT_IDX       0
-#define _HRT_CSS_RECEIVER_2400_RX_COUNT_BITS      8
+#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_IDX 0
+#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_BITS 8
+#define _HRT_CSS_RECEIVER_2400_RX_COUNT_IDX 0
+#define _HRT_CSS_RECEIVER_2400_RX_COUNT_BITS 8
 
 /* Bits for RAW116_18_DATAID register */
-#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW16_BITS_IDX   0
-#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW16_BITS_BITS  6
-#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW18_BITS_IDX   8
-#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW18_BITS_BITS  6
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW16_BITS_IDX 0
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW16_BITS_BITS 6
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW18_BITS_IDX 8
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW18_BITS_BITS 6
 
 /* Bits for COMP_FORMAT register, this selects the compression data format */
-#define _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_IDX  0
+#define _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_IDX 0
 #define _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_BITS 8
-#define _HRT_CSS_RECEIVER_2400_COMP_NUM_BITS_IDX  (_HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_IDX + _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_BITS)
+#define _HRT_CSS_RECEIVER_2400_COMP_NUM_BITS_IDX    \
+	(_HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_IDX + \
+	 _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_BITS)
 #define _HRT_CSS_RECEIVER_2400_COMP_NUM_BITS_BITS 8
 
 /* Bits for COMP_PREDICT register, this selects the predictor algorithm */
 #define _HRT_CSS_RECEIVER_2400_PREDICT_NO_COMP 0
-#define _HRT_CSS_RECEIVER_2400_PREDICT_1       1
-#define _HRT_CSS_RECEIVER_2400_PREDICT_2       2
+#define _HRT_CSS_RECEIVER_2400_PREDICT_1 1
+#define _HRT_CSS_RECEIVER_2400_PREDICT_2 2
 
 /* Number of bits used for the delay registers */
 #define _HRT_CSS_RECEIVER_2400_DELAY_BITS 8
 
 /* Bits for COMP_SCHEME register, this  selects the compression scheme for a VC */
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD1_BITS_IDX  0
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD2_BITS_IDX  5
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD3_BITS_IDX  10
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD4_BITS_IDX  15
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD5_BITS_IDX  20
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD6_BITS_IDX  25
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD7_BITS_IDX  0
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD8_BITS_IDX  5
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_BITS_BITS  5
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_FMT_BITS_IDX   0
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_FMT_BITS_BITS  3
-#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_PRED_BITS_IDX  3
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD1_BITS_IDX 0
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD2_BITS_IDX 5
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD3_BITS_IDX 10
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD4_BITS_IDX 15
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD5_BITS_IDX 20
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD6_BITS_IDX 25
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD7_BITS_IDX 0
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD8_BITS_IDX 5
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_BITS_BITS 5
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_FMT_BITS_IDX 0
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_FMT_BITS_BITS 3
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_PRED_BITS_IDX 3
 #define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_PRED_BITS_BITS 2
 
 /* BITS for backend RAW16 and RAW 18 registers */
 
-#define _HRT_CSS_RECEIVER_2400_RAW18_DATAID_IDX    0
-#define _HRT_CSS_RECEIVER_2400_RAW18_DATAID_BITS   6
-#define _HRT_CSS_RECEIVER_2400_RAW18_OPTION_IDX    6
-#define _HRT_CSS_RECEIVER_2400_RAW18_OPTION_BITS   2
-#define _HRT_CSS_RECEIVER_2400_RAW18_EN_IDX        8
-#define _HRT_CSS_RECEIVER_2400_RAW18_EN_BITS       1
+#define _HRT_CSS_RECEIVER_2400_RAW18_DATAID_IDX 0
+#define _HRT_CSS_RECEIVER_2400_RAW18_DATAID_BITS 6
+#define _HRT_CSS_RECEIVER_2400_RAW18_OPTION_IDX 6
+#define _HRT_CSS_RECEIVER_2400_RAW18_OPTION_BITS 2
+#define _HRT_CSS_RECEIVER_2400_RAW18_EN_IDX 8
+#define _HRT_CSS_RECEIVER_2400_RAW18_EN_BITS 1
 
-#define _HRT_CSS_RECEIVER_2400_RAW16_DATAID_IDX    0
-#define _HRT_CSS_RECEIVER_2400_RAW16_DATAID_BITS   6
-#define _HRT_CSS_RECEIVER_2400_RAW16_OPTION_IDX    6
-#define _HRT_CSS_RECEIVER_2400_RAW16_OPTION_BITS   2
-#define _HRT_CSS_RECEIVER_2400_RAW16_EN_IDX        8
-#define _HRT_CSS_RECEIVER_2400_RAW16_EN_BITS       1
+#define _HRT_CSS_RECEIVER_2400_RAW16_DATAID_IDX 0
+#define _HRT_CSS_RECEIVER_2400_RAW16_DATAID_BITS 6
+#define _HRT_CSS_RECEIVER_2400_RAW16_OPTION_IDX 6
+#define _HRT_CSS_RECEIVER_2400_RAW16_OPTION_BITS 2
+#define _HRT_CSS_RECEIVER_2400_RAW16_EN_IDX 8
+#define _HRT_CSS_RECEIVER_2400_RAW16_EN_BITS 1
 
 /* These hsync and vsync values are for HSS simulation only */
 #define _HRT_CSS_RECEIVER_2400_HSYNC_VAL BIT(16)
 #define _HRT_CSS_RECEIVER_2400_VSYNC_VAL BIT(17)
 
-#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_WIDTH                 28
-#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_LSB              0
-#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_MSB             (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_LSB + CSS_RECEIVER_DATA_OUT - 1)
-#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_VAL_BIT         (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_MSB + 1)
-#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_LSB             (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_VAL_BIT + 1)
-#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_MSB             (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_LSB + CSS_RECEIVER_DATA_OUT - 1)
-#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_VAL_BIT         (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_MSB + 1)
-#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_SOP_BIT               (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_VAL_BIT + 1)
-#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_EOP_BIT               (_HRT_CSS_RECEIVER_2400_BE_STREAMING_SOP_BIT + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_WIDTH 28
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_LSB 0
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_MSB    \
+	(_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_LSB + \
+	 CSS_RECEIVER_DATA_OUT - 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_VAL_BIT \
+	(_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_MSB + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_LSB \
+	(_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_VAL_BIT + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_MSB    \
+	(_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_LSB + \
+	 CSS_RECEIVER_DATA_OUT - 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_VAL_BIT \
+	(_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_MSB + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_SOP_BIT \
+	(_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_VAL_BIT + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_EOP_BIT \
+	(_HRT_CSS_RECEIVER_2400_BE_STREAMING_SOP_BIT + 1)
 
 // SH Backend Register IDs
-#define _HRT_CSS_RECEIVER_2400_BE_GSP_ACC_OVL_REG_IDX              0
-#define _HRT_CSS_RECEIVER_2400_BE_SRST_REG_IDX                     1
-#define _HRT_CSS_RECEIVER_2400_BE_TWO_PPC_REG_IDX                  2
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG0_IDX             3
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG1_IDX             4
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG2_IDX             5
-#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG3_IDX             6
-#define _HRT_CSS_RECEIVER_2400_BE_SEL_REG_IDX                      7
-#define _HRT_CSS_RECEIVER_2400_BE_RAW16_CONFIG_REG_IDX             8
-#define _HRT_CSS_RECEIVER_2400_BE_RAW18_CONFIG_REG_IDX             9
-#define _HRT_CSS_RECEIVER_2400_BE_FORCE_RAW8_REG_IDX              10
-#define _HRT_CSS_RECEIVER_2400_BE_IRQ_STATUS_REG_IDX              11
-#define _HRT_CSS_RECEIVER_2400_BE_IRQ_CLEAR_REG_IDX               12
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_EN_REG_IDX                 13
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_DATA_STATE_REG_IDX         14    /* Data State 0,1,2 config */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P0_REG_IDX       15    /* Pixel Extractor config for Data State 0 & Pix 0 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P1_REG_IDX       16    /* Pixel Extractor config for Data State 0 & Pix 1 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P2_REG_IDX       17    /* Pixel Extractor config for Data State 0 & Pix 2 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P3_REG_IDX       18    /* Pixel Extractor config for Data State 0 & Pix 3 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P0_REG_IDX       19    /* Pixel Extractor config for Data State 1 & Pix 0 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P1_REG_IDX       20    /* Pixel Extractor config for Data State 1 & Pix 1 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P2_REG_IDX       21    /* Pixel Extractor config for Data State 1 & Pix 2 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P3_REG_IDX       22    /* Pixel Extractor config for Data State 1 & Pix 3 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P0_REG_IDX       23    /* Pixel Extractor config for Data State 2 & Pix 0 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P1_REG_IDX       24    /* Pixel Extractor config for Data State 2 & Pix 1 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P2_REG_IDX       25    /* Pixel Extractor config for Data State 2 & Pix 2 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P3_REG_IDX       26    /* Pixel Extractor config for Data State 2 & Pix 3 */
-#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_VALID_EOP_REG_IDX      27    /* Pixel Valid & EoP config for Pix 0,1,2,3 */
-
-#define _HRT_CSS_RECEIVER_2400_BE_NOF_REGISTERS                   28
-
-#define _HRT_CSS_RECEIVER_2400_BE_SRST_HE                          0
-#define _HRT_CSS_RECEIVER_2400_BE_SRST_RCF                         1
-#define _HRT_CSS_RECEIVER_2400_BE_SRST_PF                          2
-#define _HRT_CSS_RECEIVER_2400_BE_SRST_SM                          3
-#define _HRT_CSS_RECEIVER_2400_BE_SRST_PD                          4
-#define _HRT_CSS_RECEIVER_2400_BE_SRST_SD                          5
-#define _HRT_CSS_RECEIVER_2400_BE_SRST_OT                          6
-#define _HRT_CSS_RECEIVER_2400_BE_SRST_BC                          7
-#define _HRT_CSS_RECEIVER_2400_BE_SRST_WIDTH                       8
+#define _HRT_CSS_RECEIVER_2400_BE_GSP_ACC_OVL_REG_IDX 0
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_REG_IDX 1
+#define _HRT_CSS_RECEIVER_2400_BE_TWO_PPC_REG_IDX 2
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG0_IDX 3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG1_IDX 4
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG2_IDX 5
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG3_IDX 6
+#define _HRT_CSS_RECEIVER_2400_BE_SEL_REG_IDX 7
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_CONFIG_REG_IDX 8
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_CONFIG_REG_IDX 9
+#define _HRT_CSS_RECEIVER_2400_BE_FORCE_RAW8_REG_IDX 10
+#define _HRT_CSS_RECEIVER_2400_BE_IRQ_STATUS_REG_IDX 11
+#define _HRT_CSS_RECEIVER_2400_BE_IRQ_CLEAR_REG_IDX 12
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_EN_REG_IDX 13
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_DATA_STATE_REG_IDX \
+	14 /* Data State 0,1,2 config */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P0_REG_IDX \
+	15 /* Pixel Extractor config for Data State 0 & Pix 0 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P1_REG_IDX \
+	16 /* Pixel Extractor config for Data State 0 & Pix 1 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P2_REG_IDX \
+	17 /* Pixel Extractor config for Data State 0 & Pix 2 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P3_REG_IDX \
+	18 /* Pixel Extractor config for Data State 0 & Pix 3 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P0_REG_IDX \
+	19 /* Pixel Extractor config for Data State 1 & Pix 0 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P1_REG_IDX \
+	20 /* Pixel Extractor config for Data State 1 & Pix 1 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P2_REG_IDX \
+	21 /* Pixel Extractor config for Data State 1 & Pix 2 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P3_REG_IDX \
+	22 /* Pixel Extractor config for Data State 1 & Pix 3 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P0_REG_IDX \
+	23 /* Pixel Extractor config for Data State 2 & Pix 0 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P1_REG_IDX \
+	24 /* Pixel Extractor config for Data State 2 & Pix 1 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P2_REG_IDX \
+	25 /* Pixel Extractor config for Data State 2 & Pix 2 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P3_REG_IDX \
+	26 /* Pixel Extractor config for Data State 2 & Pix 3 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_VALID_EOP_REG_IDX \
+	27 /* Pixel Valid & EoP config for Pix 0,1,2,3 */
+
+#define _HRT_CSS_RECEIVER_2400_BE_NOF_REGISTERS 28
+
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_HE 0
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_RCF 1
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_PF 2
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_SM 3
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_PD 4
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_SD 5
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_OT 6
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_BC 7
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_WIDTH 8
 
 #endif /* _css_receiver_2400_defs_h_ */
diff --git a/drivers/staging/media/atomisp/pci/css_trace.h b/drivers/staging/media/atomisp/pci/css_trace.h
index 5b878a6735a13d2b9b9d8265d53d0bc4ba075550..01171947254cc99e7dd9707f472547b86faa2cf6 100644
--- a/drivers/staging/media/atomisp/pci/css_trace.h
+++ b/drivers/staging/media/atomisp/pci/css_trace.h
@@ -8,7 +8,7 @@
 #define __CSS_TRACE_H_
 
 #include <type_support.h>
-#include "sh_css_internal.h"	/* for SH_CSS_MAX_SP_THREADS */
+#include "sh_css_internal.h" /* for SH_CSS_MAX_SP_THREADS */
 
 /*
 	structs and constants for tracing
@@ -16,47 +16,50 @@
 
 /* one tracer item: major, minor and counter. The counter value can be used for GP data */
 struct trace_item_t {
-	u8   major;
-	u8   minor;
-	u16  counter;
+	u8 major;
+	u8 minor;
+	u16 counter;
 };
 
-#define MAX_SCRATCH_DATA	4
-#define MAX_CMD_DATA		2
+#define MAX_SCRATCH_DATA 4
+#define MAX_CMD_DATA 2
 
 /* trace header: holds the version and the topology of the tracer. */
 struct trace_header_t {
 	/* 1st dword: descriptor */
-	u8   version;
-	u8   max_threads;
-	u16  max_tracer_points;
+	u8 version;
+	u8 max_threads;
+	u16 max_tracer_points;
 	/* 2nd field: command + data */
 	/* 2nd dword */
-	u32  command;
+	u32 command;
 	/* 3rd & 4th dword */
-	u32  data[MAX_CMD_DATA];
+	u32 data[MAX_CMD_DATA];
 	/* 3rd field: debug pointer */
 	/* 5th & 6th dword: debug pointer mechanism */
-	u32  debug_ptr_signature;
-	u32  debug_ptr_value;
+	u32 debug_ptr_signature;
+	u32 debug_ptr_value;
 	/* Rest of the header: status & scratch data */
-	u8   thr_status_byte[SH_CSS_MAX_SP_THREADS];
-	u16  thr_status_word[SH_CSS_MAX_SP_THREADS];
-	u32  thr_status_dword[SH_CSS_MAX_SP_THREADS];
-	u32  scratch_debug[MAX_SCRATCH_DATA];
+	u8 thr_status_byte[SH_CSS_MAX_SP_THREADS];
+	u16 thr_status_word[SH_CSS_MAX_SP_THREADS];
+	u32 thr_status_dword[SH_CSS_MAX_SP_THREADS];
+	u32 scratch_debug[MAX_SCRATCH_DATA];
 };
 
 /* offsets for master_port read/write */
-#define HDR_HDR_OFFSET              0	/* offset of the header */
-#define HDR_COMMAND_OFFSET          offsetof(struct trace_header_t, command)
-#define HDR_DATA_OFFSET             offsetof(struct trace_header_t, data)
-#define HDR_DEBUG_SIGNATURE_OFFSET  offsetof(struct trace_header_t, debug_ptr_signature)
-#define HDR_DEBUG_POINTER_OFFSET    offsetof(struct trace_header_t, debug_ptr_value)
-#define HDR_STATUS_OFFSET           offsetof(struct trace_header_t, thr_status_byte)
-#define HDR_STATUS_OFFSET_BYTE      offsetof(struct trace_header_t, thr_status_byte)
-#define HDR_STATUS_OFFSET_WORD      offsetof(struct trace_header_t, thr_status_word)
-#define HDR_STATUS_OFFSET_DWORD     offsetof(struct trace_header_t, thr_status_dword)
-#define HDR_STATUS_OFFSET_SCRATCH   offsetof(struct trace_header_t, scratch_debug)
+#define HDR_HDR_OFFSET 0 /* offset of the header */
+#define HDR_COMMAND_OFFSET offsetof(struct trace_header_t, command)
+#define HDR_DATA_OFFSET offsetof(struct trace_header_t, data)
+#define HDR_DEBUG_SIGNATURE_OFFSET \
+	offsetof(struct trace_header_t, debug_ptr_signature)
+#define HDR_DEBUG_POINTER_OFFSET \
+	offsetof(struct trace_header_t, debug_ptr_value)
+#define HDR_STATUS_OFFSET offsetof(struct trace_header_t, thr_status_byte)
+#define HDR_STATUS_OFFSET_BYTE offsetof(struct trace_header_t, thr_status_byte)
+#define HDR_STATUS_OFFSET_WORD offsetof(struct trace_header_t, thr_status_word)
+#define HDR_STATUS_OFFSET_DWORD \
+	offsetof(struct trace_header_t, thr_status_dword)
+#define HDR_STATUS_OFFSET_SCRATCH offsetof(struct trace_header_t, scratch_debug)
 
 /*
 Trace version history:
@@ -65,20 +68,16 @@ Trace version history:
  3: added thread ID.
  4: added status in header.
 */
-#define TRACER_VER			4
+#define TRACER_VER 4
 
-#define TRACE_BUFF_ADDR       0xA000
-#define TRACE_BUFF_SIZE       0x1000	/* 4K allocated */
+#define TRACE_BUFF_ADDR 0xA000
+#define TRACE_BUFF_SIZE 0x1000 /* 4K allocated */
 
 #define TRACE_ENABLE_SP0 0
 #define TRACE_ENABLE_SP1 0
 #define TRACE_ENABLE_ISP 0
 
-enum TRACE_CORE_ID {
-	TRACE_SP0_ID,
-	TRACE_SP1_ID,
-	TRACE_ISP_ID
-};
+enum TRACE_CORE_ID { TRACE_SP0_ID, TRACE_SP1_ID, TRACE_ISP_ID };
 
 /* TODO: add timing format? */
 enum TRACE_DUMP_FORMAT {
@@ -144,53 +143,57 @@ enum TRACE_DUMP_FORMAT {
 
 #define TRACE_SP0_HEADER_ADDR (TRACE_SP0_ADDR)
 #define TRACE_SP0_HEADER_SIZE (sizeof(struct trace_header_t))
-#define TRACE_SP0_ITEM_SIZE   (sizeof(struct trace_item_t))
-#define TRACE_SP0_DATA_ADDR   (TRACE_SP0_HEADER_ADDR + TRACE_SP0_HEADER_SIZE)
-#define TRACE_SP0_DATA_SIZE   (TRACE_SP0_SIZE - TRACE_SP0_HEADER_SIZE)
-#define TRACE_SP0_MAX_POINTS  (TRACE_SP0_DATA_SIZE / TRACE_SP0_ITEM_SIZE)
+#define TRACE_SP0_ITEM_SIZE (sizeof(struct trace_item_t))
+#define TRACE_SP0_DATA_ADDR (TRACE_SP0_HEADER_ADDR + TRACE_SP0_HEADER_SIZE)
+#define TRACE_SP0_DATA_SIZE (TRACE_SP0_SIZE - TRACE_SP0_HEADER_SIZE)
+#define TRACE_SP0_MAX_POINTS (TRACE_SP0_DATA_SIZE / TRACE_SP0_ITEM_SIZE)
 
 #define TRACE_SP1_HEADER_ADDR (TRACE_SP1_ADDR)
 #define TRACE_SP1_HEADER_SIZE (sizeof(struct trace_header_t))
-#define TRACE_SP1_ITEM_SIZE   (sizeof(struct trace_item_t))
-#define TRACE_SP1_DATA_ADDR   (TRACE_SP1_HEADER_ADDR + TRACE_SP1_HEADER_SIZE)
-#define TRACE_SP1_DATA_SIZE   (TRACE_SP1_SIZE - TRACE_SP1_HEADER_SIZE)
-#define TRACE_SP1_MAX_POINTS  (TRACE_SP1_DATA_SIZE / TRACE_SP1_ITEM_SIZE)
+#define TRACE_SP1_ITEM_SIZE (sizeof(struct trace_item_t))
+#define TRACE_SP1_DATA_ADDR (TRACE_SP1_HEADER_ADDR + TRACE_SP1_HEADER_SIZE)
+#define TRACE_SP1_DATA_SIZE (TRACE_SP1_SIZE - TRACE_SP1_HEADER_SIZE)
+#define TRACE_SP1_MAX_POINTS (TRACE_SP1_DATA_SIZE / TRACE_SP1_ITEM_SIZE)
 
 #define TRACE_ISP_HEADER_ADDR (TRACE_ISP_ADDR)
 #define TRACE_ISP_HEADER_SIZE (sizeof(struct trace_header_t))
-#define TRACE_ISP_ITEM_SIZE   (sizeof(struct trace_item_t))
-#define TRACE_ISP_DATA_ADDR   (TRACE_ISP_HEADER_ADDR + TRACE_ISP_HEADER_SIZE)
-#define TRACE_ISP_DATA_SIZE   (TRACE_ISP_SIZE - TRACE_ISP_HEADER_SIZE)
-#define TRACE_ISP_MAX_POINTS  (TRACE_ISP_DATA_SIZE / TRACE_ISP_ITEM_SIZE)
+#define TRACE_ISP_ITEM_SIZE (sizeof(struct trace_item_t))
+#define TRACE_ISP_DATA_ADDR (TRACE_ISP_HEADER_ADDR + TRACE_ISP_HEADER_SIZE)
+#define TRACE_ISP_DATA_SIZE (TRACE_ISP_SIZE - TRACE_ISP_HEADER_SIZE)
+#define TRACE_ISP_MAX_POINTS (TRACE_ISP_DATA_SIZE / TRACE_ISP_ITEM_SIZE)
 
 /* common majors */
 /* SP0 */
-#define MAJOR_MAIN              1
-#define MAJOR_ISP_STAGE_ENTRY   2
-#define MAJOR_DMA_PRXY          3
-#define MAJOR_START_ISP         4
+#define MAJOR_MAIN 1
+#define MAJOR_ISP_STAGE_ENTRY 2
+#define MAJOR_DMA_PRXY 3
+#define MAJOR_START_ISP 4
 /* SP1 */
-#define MAJOR_OBSERVER_ISP0_EVENT          21
-#define MAJOR_OBSERVER_OUTPUT_FORM_EVENT   22
-#define MAJOR_OBSERVER_OUTPUT_SCAL_EVENT   23
-#define MAJOR_OBSERVER_IF_ACK              24
-#define MAJOR_OBSERVER_SP0_EVENT           25
-#define MAJOR_OBSERVER_SP_TERMINATE_EVENT  26
-#define MAJOR_OBSERVER_DMA_ACK             27
-#define MAJOR_OBSERVER_ACC_ACK             28
-
-#define DEBUG_PTR_SIGNATURE     0xABCD	/* signature for the debug parameter pointer */
+#define MAJOR_OBSERVER_ISP0_EVENT 21
+#define MAJOR_OBSERVER_OUTPUT_FORM_EVENT 22
+#define MAJOR_OBSERVER_OUTPUT_SCAL_EVENT 23
+#define MAJOR_OBSERVER_IF_ACK 24
+#define MAJOR_OBSERVER_SP0_EVENT 25
+#define MAJOR_OBSERVER_SP_TERMINATE_EVENT 26
+#define MAJOR_OBSERVER_DMA_ACK 27
+#define MAJOR_OBSERVER_ACC_ACK 28
+
+#define DEBUG_PTR_SIGNATURE \
+	0xABCD /* signature for the debug parameter pointer */
 
 /* command codes (1st byte) */
 typedef enum {
-	CMD_SET_ONE_MAJOR = 1,		/* mask in one major. 2nd byte in the command is the major code */
-	CMD_UNSET_ONE_MAJOR = 2,	/* mask out one major. 2nd byte in the command is the major code */
-	CMD_SET_ALL_MAJORS = 3,		/* set the major print mask. the full mask is in the data DWORD */
-	CMD_SET_VERBOSITY = 4		/* set verbosity level */
+	CMD_SET_ONE_MAJOR =
+		1, /* mask in one major. 2nd byte in the command is the major code */
+	CMD_UNSET_ONE_MAJOR =
+		2, /* mask out one major. 2nd byte in the command is the major code */
+	CMD_SET_ALL_MAJORS =
+		3, /* set the major print mask. the full mask is in the data DWORD */
+	CMD_SET_VERBOSITY = 4 /* set verbosity level */
 } DBG_commands;
 
 /* command signature */
-#define CMD_SIGNATURE	0xAABBCC00
+#define CMD_SIGNATURE 0xAABBCC00
 
 /* shared macros in traces infrastructure */
 /* increment the pointer cyclicly */
@@ -201,69 +204,83 @@ typedef enum {
 #define FIELD_PACK(value, mask, offset) (((value) & (mask)) << (offset))
 #define FIELD_UNPACK(value, mask, offset) (((value) >> (offset)) & (mask))
 
-#define FIELD_VALUE_OFFSET		(0)
-#define FIELD_VALUE_WIDTH		(16)
-#define FIELD_VALUE_MASK		FIELD_MASK(FIELD_VALUE_WIDTH)
-#define FIELD_VALUE_PACK(f)		FIELD_PACK(f, FIELD_VALUE_MASK, FIELD_VALUE_OFFSET)
-#define FIELD_VALUE_UNPACK(f)		FIELD_UNPACK(f, FIELD_VALUE_MASK, FIELD_VALUE_OFFSET)
-
-#define FIELD_MINOR_OFFSET		(FIELD_VALUE_OFFSET + FIELD_VALUE_WIDTH)
-#define FIELD_MINOR_WIDTH		(8)
-#define FIELD_MINOR_MASK		FIELD_MASK(FIELD_MINOR_WIDTH)
-#define FIELD_MINOR_PACK(f)		FIELD_PACK(f, FIELD_MINOR_MASK, FIELD_MINOR_OFFSET)
-#define FIELD_MINOR_UNPACK(f)		FIELD_UNPACK(f, FIELD_MINOR_MASK, FIELD_MINOR_OFFSET)
-
-#define FIELD_MAJOR_OFFSET		(FIELD_MINOR_OFFSET + FIELD_MINOR_WIDTH)
-#define FIELD_MAJOR_WIDTH		(5)
-#define FIELD_MAJOR_MASK		FIELD_MASK(FIELD_MAJOR_WIDTH)
-#define FIELD_MAJOR_PACK(f)		FIELD_PACK(f, FIELD_MAJOR_MASK, FIELD_MAJOR_OFFSET)
-#define FIELD_MAJOR_UNPACK(f)		FIELD_UNPACK(f, FIELD_MAJOR_MASK, FIELD_MAJOR_OFFSET)
+#define FIELD_VALUE_OFFSET (0)
+#define FIELD_VALUE_WIDTH (16)
+#define FIELD_VALUE_MASK FIELD_MASK(FIELD_VALUE_WIDTH)
+#define FIELD_VALUE_PACK(f) FIELD_PACK(f, FIELD_VALUE_MASK, FIELD_VALUE_OFFSET)
+#define FIELD_VALUE_UNPACK(f) \
+	FIELD_UNPACK(f, FIELD_VALUE_MASK, FIELD_VALUE_OFFSET)
+
+#define FIELD_MINOR_OFFSET (FIELD_VALUE_OFFSET + FIELD_VALUE_WIDTH)
+#define FIELD_MINOR_WIDTH (8)
+#define FIELD_MINOR_MASK FIELD_MASK(FIELD_MINOR_WIDTH)
+#define FIELD_MINOR_PACK(f) FIELD_PACK(f, FIELD_MINOR_MASK, FIELD_MINOR_OFFSET)
+#define FIELD_MINOR_UNPACK(f) \
+	FIELD_UNPACK(f, FIELD_MINOR_MASK, FIELD_MINOR_OFFSET)
+
+#define FIELD_MAJOR_OFFSET (FIELD_MINOR_OFFSET + FIELD_MINOR_WIDTH)
+#define FIELD_MAJOR_WIDTH (5)
+#define FIELD_MAJOR_MASK FIELD_MASK(FIELD_MAJOR_WIDTH)
+#define FIELD_MAJOR_PACK(f) FIELD_PACK(f, FIELD_MAJOR_MASK, FIELD_MAJOR_OFFSET)
+#define FIELD_MAJOR_UNPACK(f) \
+	FIELD_UNPACK(f, FIELD_MAJOR_MASK, FIELD_MAJOR_OFFSET)
 
 /* for quick traces - only insertion, compatible with the regular point */
-#define FIELD_FULL_MAJOR_WIDTH		(8)
-#define FIELD_FULL_MAJOR_MASK		FIELD_MASK(FIELD_FULL_MAJOR_WIDTH)
-#define FIELD_FULL_MAJOR_PACK(f)	FIELD_PACK(f, FIELD_FULL_MAJOR_MASK, FIELD_MAJOR_OFFSET)
+#define FIELD_FULL_MAJOR_WIDTH (8)
+#define FIELD_FULL_MAJOR_MASK FIELD_MASK(FIELD_FULL_MAJOR_WIDTH)
+#define FIELD_FULL_MAJOR_PACK(f) \
+	FIELD_PACK(f, FIELD_FULL_MAJOR_MASK, FIELD_MAJOR_OFFSET)
 
 /* The following 2 fields are used only when FIELD_TID value is 111b.
  * it means we don't want to use thread id, but format. In this case,
  * the last 2 MSB bits of the major field will indicates the format
  */
-#define FIELD_MAJOR_W_FMT_OFFSET	FIELD_MAJOR_OFFSET
-#define FIELD_MAJOR_W_FMT_WIDTH		(3)
-#define FIELD_MAJOR_W_FMT_MASK		FIELD_MASK(FIELD_MAJOR_W_FMT_WIDTH)
-#define FIELD_MAJOR_W_FMT_PACK(f)	FIELD_PACK(f, FIELD_MAJOR_W_FMT_MASK, FIELD_MAJOR_W_FMT_OFFSET)
-#define FIELD_MAJOR_W_FMT_UNPACK(f)	FIELD_UNPACK(f, FIELD_MAJOR_W_FMT_MASK, FIELD_MAJOR_W_FMT_OFFSET)
-
-#define FIELD_FORMAT_OFFSET		(FIELD_MAJOR_OFFSET + FIELD_MAJOR_W_FMT_WIDTH)
-#define FIELD_FORMAT_WIDTH		(2)
-#define FIELD_FORMAT_MASK		FIELD_MASK(FIELD_MAJOR_W_FMT_WIDTH)
-#define FIELD_FORMAT_PACK(f)		FIELD_PACK(f, FIELD_FORMAT_MASK, FIELD_FORMAT_OFFSET)
-#define FIELD_FORMAT_UNPACK(f)		FIELD_UNPACK(f, FIELD_FORMAT_MASK, FIELD_FORMAT_OFFSET)
-
-#define FIELD_TID_SEL_FORMAT_PAT	(7)
-
-#define FIELD_TID_OFFSET		(FIELD_MAJOR_OFFSET + FIELD_MAJOR_WIDTH)
-#define FIELD_TID_WIDTH			(3)
-#define FIELD_TID_MASK			FIELD_MASK(FIELD_TID_WIDTH)
-#define FIELD_TID_PACK(f)		FIELD_PACK(f, FIELD_TID_MASK, FIELD_TID_OFFSET)
-#define FIELD_TID_UNPACK(f)		FIELD_UNPACK(f, FIELD_TID_MASK, FIELD_TID_OFFSET)
-
-#define FIELD_VALUE_24_OFFSET		(0)
-#define FIELD_VALUE_24_WIDTH		(24)
-#define FIELD_VALUE_24_MASK		FIELD_MASK(FIELD_VALUE_24_WIDTH)
-#define FIELD_VALUE_24_PACK(f)		FIELD_PACK(f, FIELD_VALUE_24_MASK, FIELD_VALUE_24_OFFSET)
-#define FIELD_VALUE_24_UNPACK(f)	FIELD_UNPACK(f, FIELD_VALUE_24_MASK, FIELD_VALUE_24_OFFSET)
-
-#define PACK_TRACEPOINT(tid, major, minor, value)	\
-	(FIELD_TID_PACK(tid) | FIELD_MAJOR_PACK(major) | FIELD_MINOR_PACK(minor) | FIELD_VALUE_PACK(value))
-
-#define PACK_QUICK_TRACEPOINT(major, minor)	\
+#define FIELD_MAJOR_W_FMT_OFFSET FIELD_MAJOR_OFFSET
+#define FIELD_MAJOR_W_FMT_WIDTH (3)
+#define FIELD_MAJOR_W_FMT_MASK FIELD_MASK(FIELD_MAJOR_W_FMT_WIDTH)
+#define FIELD_MAJOR_W_FMT_PACK(f) \
+	FIELD_PACK(f, FIELD_MAJOR_W_FMT_MASK, FIELD_MAJOR_W_FMT_OFFSET)
+#define FIELD_MAJOR_W_FMT_UNPACK(f) \
+	FIELD_UNPACK(f, FIELD_MAJOR_W_FMT_MASK, FIELD_MAJOR_W_FMT_OFFSET)
+
+#define FIELD_FORMAT_OFFSET (FIELD_MAJOR_OFFSET + FIELD_MAJOR_W_FMT_WIDTH)
+#define FIELD_FORMAT_WIDTH (2)
+#define FIELD_FORMAT_MASK FIELD_MASK(FIELD_MAJOR_W_FMT_WIDTH)
+#define FIELD_FORMAT_PACK(f) \
+	FIELD_PACK(f, FIELD_FORMAT_MASK, FIELD_FORMAT_OFFSET)
+#define FIELD_FORMAT_UNPACK(f) \
+	FIELD_UNPACK(f, FIELD_FORMAT_MASK, FIELD_FORMAT_OFFSET)
+
+#define FIELD_TID_SEL_FORMAT_PAT (7)
+
+#define FIELD_TID_OFFSET (FIELD_MAJOR_OFFSET + FIELD_MAJOR_WIDTH)
+#define FIELD_TID_WIDTH (3)
+#define FIELD_TID_MASK FIELD_MASK(FIELD_TID_WIDTH)
+#define FIELD_TID_PACK(f) FIELD_PACK(f, FIELD_TID_MASK, FIELD_TID_OFFSET)
+#define FIELD_TID_UNPACK(f) FIELD_UNPACK(f, FIELD_TID_MASK, FIELD_TID_OFFSET)
+
+#define FIELD_VALUE_24_OFFSET (0)
+#define FIELD_VALUE_24_WIDTH (24)
+#define FIELD_VALUE_24_MASK FIELD_MASK(FIELD_VALUE_24_WIDTH)
+#define FIELD_VALUE_24_PACK(f) \
+	FIELD_PACK(f, FIELD_VALUE_24_MASK, FIELD_VALUE_24_OFFSET)
+#define FIELD_VALUE_24_UNPACK(f) \
+	FIELD_UNPACK(f, FIELD_VALUE_24_MASK, FIELD_VALUE_24_OFFSET)
+
+#define PACK_TRACEPOINT(tid, major, minor, value)        \
+	(FIELD_TID_PACK(tid) | FIELD_MAJOR_PACK(major) | \
+	 FIELD_MINOR_PACK(minor) | FIELD_VALUE_PACK(value))
+
+#define PACK_QUICK_TRACEPOINT(major, minor) \
 	(FIELD_FULL_MAJOR_PACK(major) | FIELD_MINOR_PACK(minor))
 
-#define PACK_FORMATTED_TRACEPOINT(format, major, minor, value)	\
-	(FIELD_TID_PACK(FIELD_TID_SEL_FORMAT_PAT) | FIELD_FORMAT_PACK(format) | FIELD_MAJOR_PACK(major) | FIELD_MINOR_PACK(minor) | FIELD_VALUE_PACK(value))
+#define PACK_FORMATTED_TRACEPOINT(format, major, minor, value) \
+	(FIELD_TID_PACK(FIELD_TID_SEL_FORMAT_PAT) |            \
+	 FIELD_FORMAT_PACK(format) | FIELD_MAJOR_PACK(major) | \
+	 FIELD_MINOR_PACK(minor) | FIELD_VALUE_PACK(value))
 
-#define PACK_TRACE_VALUE24(major, value)	\
-	(FIELD_TID_PACK(FIELD_TID_SEL_FORMAT_PAT) | FIELD_MAJOR_PACK(major) | FIELD_VALUE_24_PACK(value))
+#define PACK_TRACE_VALUE24(major, value)                                      \
+	(FIELD_TID_PACK(FIELD_TID_SEL_FORMAT_PAT) | FIELD_MAJOR_PACK(major) | \
+	 FIELD_VALUE_24_PACK(value))
 
 #endif /* __CSS_TRACE_H_ */
diff --git a/drivers/staging/media/atomisp/pci/dma_v2_defs.h b/drivers/staging/media/atomisp/pci/dma_v2_defs.h
index 79cbdc7242d572dc6f369d9ddfa76f8551c4ce10..f120b632b6f0d6dde104c445ae0aae960b89c6c4 100644
--- a/drivers/staging/media/atomisp/pci/dma_v2_defs.h
+++ b/drivers/staging/media/atomisp/pci/dma_v2_defs.h
@@ -7,185 +7,201 @@
 #ifndef _dma_v2_defs_h
 #define _dma_v2_defs_h
 
-#define _DMA_V2_NUM_CHANNELS_ID               MaxNumChannels
-#define _DMA_V2_CONNECTIONS_ID                Connections
-#define _DMA_V2_DEV_ELEM_WIDTHS_ID            DevElemWidths
-#define _DMA_V2_DEV_FIFO_DEPTH_ID             DevFifoDepth
-#define _DMA_V2_DEV_FIFO_RD_LAT_ID            DevFifoRdLat
-#define _DMA_V2_DEV_FIFO_LAT_BYPASS_ID        DevFifoRdLatBypass
-#define _DMA_V2_DEV_NO_BURST_ID               DevNoBurst
-#define _DMA_V2_DEV_RD_ACCEPT_ID              DevRdAccept
-#define _DMA_V2_DEV_SRMD_ID                   DevSRMD
-#define _DMA_V2_DEV_HAS_CRUN_ID               CRunMasters
-#define _DMA_V2_CTRL_ACK_FIFO_DEPTH_ID        CtrlAckFifoDepth
-#define _DMA_V2_CMD_FIFO_DEPTH_ID             CommandFifoDepth
-#define _DMA_V2_CMD_FIFO_RD_LAT_ID            CommandFifoRdLat
-#define _DMA_V2_CMD_FIFO_LAT_BYPASS_ID        CommandFifoRdLatBypass
-#define _DMA_V2_NO_PACK_ID                    has_no_pack
-
-#define _DMA_V2_REG_ALIGN                4
-#define _DMA_V2_REG_ADDR_BITS            2
+#define _DMA_V2_NUM_CHANNELS_ID MaxNumChannels
+#define _DMA_V2_CONNECTIONS_ID Connections
+#define _DMA_V2_DEV_ELEM_WIDTHS_ID DevElemWidths
+#define _DMA_V2_DEV_FIFO_DEPTH_ID DevFifoDepth
+#define _DMA_V2_DEV_FIFO_RD_LAT_ID DevFifoRdLat
+#define _DMA_V2_DEV_FIFO_LAT_BYPASS_ID DevFifoRdLatBypass
+#define _DMA_V2_DEV_NO_BURST_ID DevNoBurst
+#define _DMA_V2_DEV_RD_ACCEPT_ID DevRdAccept
+#define _DMA_V2_DEV_SRMD_ID DevSRMD
+#define _DMA_V2_DEV_HAS_CRUN_ID CRunMasters
+#define _DMA_V2_CTRL_ACK_FIFO_DEPTH_ID CtrlAckFifoDepth
+#define _DMA_V2_CMD_FIFO_DEPTH_ID CommandFifoDepth
+#define _DMA_V2_CMD_FIFO_RD_LAT_ID CommandFifoRdLat
+#define _DMA_V2_CMD_FIFO_LAT_BYPASS_ID CommandFifoRdLatBypass
+#define _DMA_V2_NO_PACK_ID has_no_pack
+
+#define _DMA_V2_REG_ALIGN 4
+#define _DMA_V2_REG_ADDR_BITS 2
 
 /* Command word */
-#define _DMA_V2_CMD_IDX            0
-#define _DMA_V2_CMD_BITS           6
-#define _DMA_V2_CHANNEL_IDX        (_DMA_V2_CMD_IDX + _DMA_V2_CMD_BITS)
-#define _DMA_V2_CHANNEL_BITS       5
+#define _DMA_V2_CMD_IDX 0
+#define _DMA_V2_CMD_BITS 6
+#define _DMA_V2_CHANNEL_IDX (_DMA_V2_CMD_IDX + _DMA_V2_CMD_BITS)
+#define _DMA_V2_CHANNEL_BITS 5
 
 /* The command to set a parameter contains the PARAM field next */
-#define _DMA_V2_PARAM_IDX          (_DMA_V2_CHANNEL_IDX + _DMA_V2_CHANNEL_BITS)
-#define _DMA_V2_PARAM_BITS         4
+#define _DMA_V2_PARAM_IDX (_DMA_V2_CHANNEL_IDX + _DMA_V2_CHANNEL_BITS)
+#define _DMA_V2_PARAM_BITS 4
 
 /* Commands to read, write or init specific blocks contain these
    three values */
-#define _DMA_V2_SPEC_DEV_A_XB_IDX  (_DMA_V2_CHANNEL_IDX + _DMA_V2_CHANNEL_BITS)
+#define _DMA_V2_SPEC_DEV_A_XB_IDX (_DMA_V2_CHANNEL_IDX + _DMA_V2_CHANNEL_BITS)
 #define _DMA_V2_SPEC_DEV_A_XB_BITS 8
-#define _DMA_V2_SPEC_DEV_B_XB_IDX  (_DMA_V2_SPEC_DEV_A_XB_IDX + _DMA_V2_SPEC_DEV_A_XB_BITS)
+#define _DMA_V2_SPEC_DEV_B_XB_IDX \
+	(_DMA_V2_SPEC_DEV_A_XB_IDX + _DMA_V2_SPEC_DEV_A_XB_BITS)
 #define _DMA_V2_SPEC_DEV_B_XB_BITS 8
-#define _DMA_V2_SPEC_YB_IDX        (_DMA_V2_SPEC_DEV_B_XB_IDX + _DMA_V2_SPEC_DEV_B_XB_BITS)
-#define _DMA_V2_SPEC_YB_BITS       (32 - _DMA_V2_SPEC_DEV_B_XB_BITS - _DMA_V2_SPEC_DEV_A_XB_BITS - _DMA_V2_CMD_BITS - _DMA_V2_CHANNEL_BITS)
+#define _DMA_V2_SPEC_YB_IDX \
+	(_DMA_V2_SPEC_DEV_B_XB_IDX + _DMA_V2_SPEC_DEV_B_XB_BITS)
+#define _DMA_V2_SPEC_YB_BITS                                            \
+	(32 - _DMA_V2_SPEC_DEV_B_XB_BITS - _DMA_V2_SPEC_DEV_A_XB_BITS - \
+	 _DMA_V2_CMD_BITS - _DMA_V2_CHANNEL_BITS)
 
 /* */
-#define _DMA_V2_CMD_CTRL_IDX       4
-#define _DMA_V2_CMD_CTRL_BITS      4
+#define _DMA_V2_CMD_CTRL_IDX 4
+#define _DMA_V2_CMD_CTRL_BITS 4
 
 /* Packing setup word */
-#define _DMA_V2_CONNECTION_IDX     0
-#define _DMA_V2_CONNECTION_BITS    4
-#define _DMA_V2_EXTENSION_IDX      (_DMA_V2_CONNECTION_IDX + _DMA_V2_CONNECTION_BITS)
-#define _DMA_V2_EXTENSION_BITS     1
+#define _DMA_V2_CONNECTION_IDX 0
+#define _DMA_V2_CONNECTION_BITS 4
+#define _DMA_V2_EXTENSION_IDX (_DMA_V2_CONNECTION_IDX + _DMA_V2_CONNECTION_BITS)
+#define _DMA_V2_EXTENSION_BITS 1
 
 /* Elements packing word */
-#define _DMA_V2_ELEMENTS_IDX        0
-#define _DMA_V2_ELEMENTS_BITS       8
-#define _DMA_V2_LEFT_CROPPING_IDX  (_DMA_V2_ELEMENTS_IDX + _DMA_V2_ELEMENTS_BITS)
-#define _DMA_V2_LEFT_CROPPING_BITS  8
+#define _DMA_V2_ELEMENTS_IDX 0
+#define _DMA_V2_ELEMENTS_BITS 8
+#define _DMA_V2_LEFT_CROPPING_IDX (_DMA_V2_ELEMENTS_IDX + _DMA_V2_ELEMENTS_BITS)
+#define _DMA_V2_LEFT_CROPPING_BITS 8
 
-#define _DMA_V2_WIDTH_IDX           0
-#define _DMA_V2_WIDTH_BITS         16
+#define _DMA_V2_WIDTH_IDX 0
+#define _DMA_V2_WIDTH_BITS 16
 
-#define _DMA_V2_HEIGHT_IDX          0
-#define _DMA_V2_HEIGHT_BITS        16
+#define _DMA_V2_HEIGHT_IDX 0
+#define _DMA_V2_HEIGHT_BITS 16
 
-#define _DMA_V2_STRIDE_IDX          0
-#define _DMA_V2_STRIDE_BITS        32
+#define _DMA_V2_STRIDE_IDX 0
+#define _DMA_V2_STRIDE_BITS 32
 
 /* Command IDs */
-#define _DMA_V2_MOVE_B2A_COMMAND                             0
-#define _DMA_V2_MOVE_B2A_BLOCK_COMMAND                       1
-#define _DMA_V2_MOVE_B2A_NO_SYNC_CHK_COMMAND                 2
-#define _DMA_V2_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND           3
-#define _DMA_V2_MOVE_A2B_COMMAND                             4
-#define _DMA_V2_MOVE_A2B_BLOCK_COMMAND                       5
-#define _DMA_V2_MOVE_A2B_NO_SYNC_CHK_COMMAND                 6
-#define _DMA_V2_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND           7
-#define _DMA_V2_INIT_A_COMMAND                               8
-#define _DMA_V2_INIT_A_BLOCK_COMMAND                         9
-#define _DMA_V2_INIT_A_NO_SYNC_CHK_COMMAND                  10
-#define _DMA_V2_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND            11
-#define _DMA_V2_INIT_B_COMMAND                              12
-#define _DMA_V2_INIT_B_BLOCK_COMMAND                        13
-#define _DMA_V2_INIT_B_NO_SYNC_CHK_COMMAND                  14
-#define _DMA_V2_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND            15
-#define _DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND         (_DMA_V2_MOVE_B2A_NO_SYNC_CHK_COMMAND       + 16)
-#define _DMA_V2_NO_ACK_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND   (_DMA_V2_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND + 16)
-#define _DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND         (_DMA_V2_MOVE_A2B_NO_SYNC_CHK_COMMAND       + 16)
-#define _DMA_V2_NO_ACK_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND   (_DMA_V2_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND + 16)
-#define _DMA_V2_NO_ACK_INIT_A_NO_SYNC_CHK_COMMAND           (_DMA_V2_INIT_A_NO_SYNC_CHK_COMMAND         + 16)
-#define _DMA_V2_NO_ACK_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND     (_DMA_V2_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND   + 16)
-#define _DMA_V2_NO_ACK_INIT_B_NO_SYNC_CHK_COMMAND           (_DMA_V2_INIT_B_NO_SYNC_CHK_COMMAND         + 16)
-#define _DMA_V2_NO_ACK_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND     (_DMA_V2_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND   + 16)
-#define _DMA_V2_CONFIG_CHANNEL_COMMAND                      32
-#define _DMA_V2_SET_CHANNEL_PARAM_COMMAND                   33
-#define _DMA_V2_SET_CRUN_COMMAND                            62
+#define _DMA_V2_MOVE_B2A_COMMAND 0
+#define _DMA_V2_MOVE_B2A_BLOCK_COMMAND 1
+#define _DMA_V2_MOVE_B2A_NO_SYNC_CHK_COMMAND 2
+#define _DMA_V2_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND 3
+#define _DMA_V2_MOVE_A2B_COMMAND 4
+#define _DMA_V2_MOVE_A2B_BLOCK_COMMAND 5
+#define _DMA_V2_MOVE_A2B_NO_SYNC_CHK_COMMAND 6
+#define _DMA_V2_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND 7
+#define _DMA_V2_INIT_A_COMMAND 8
+#define _DMA_V2_INIT_A_BLOCK_COMMAND 9
+#define _DMA_V2_INIT_A_NO_SYNC_CHK_COMMAND 10
+#define _DMA_V2_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND 11
+#define _DMA_V2_INIT_B_COMMAND 12
+#define _DMA_V2_INIT_B_BLOCK_COMMAND 13
+#define _DMA_V2_INIT_B_NO_SYNC_CHK_COMMAND 14
+#define _DMA_V2_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND 15
+#define _DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND \
+	(_DMA_V2_MOVE_B2A_NO_SYNC_CHK_COMMAND + 16)
+#define _DMA_V2_NO_ACK_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND \
+	(_DMA_V2_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND + 16)
+#define _DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND \
+	(_DMA_V2_MOVE_A2B_NO_SYNC_CHK_COMMAND + 16)
+#define _DMA_V2_NO_ACK_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND \
+	(_DMA_V2_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND + 16)
+#define _DMA_V2_NO_ACK_INIT_A_NO_SYNC_CHK_COMMAND \
+	(_DMA_V2_INIT_A_NO_SYNC_CHK_COMMAND + 16)
+#define _DMA_V2_NO_ACK_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND \
+	(_DMA_V2_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND + 16)
+#define _DMA_V2_NO_ACK_INIT_B_NO_SYNC_CHK_COMMAND \
+	(_DMA_V2_INIT_B_NO_SYNC_CHK_COMMAND + 16)
+#define _DMA_V2_NO_ACK_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND \
+	(_DMA_V2_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND + 16)
+#define _DMA_V2_CONFIG_CHANNEL_COMMAND 32
+#define _DMA_V2_SET_CHANNEL_PARAM_COMMAND 33
+#define _DMA_V2_SET_CRUN_COMMAND 62
 
 /* Channel Parameter IDs */
-#define _DMA_V2_PACKING_SETUP_PARAM                     0
-#define _DMA_V2_STRIDE_A_PARAM                          1
-#define _DMA_V2_ELEM_CROPPING_A_PARAM                   2
-#define _DMA_V2_WIDTH_A_PARAM                           3
-#define _DMA_V2_STRIDE_B_PARAM                          4
-#define _DMA_V2_ELEM_CROPPING_B_PARAM                   5
-#define _DMA_V2_WIDTH_B_PARAM                           6
-#define _DMA_V2_HEIGHT_PARAM                            7
-#define _DMA_V2_QUEUED_CMDS                             8
+#define _DMA_V2_PACKING_SETUP_PARAM 0
+#define _DMA_V2_STRIDE_A_PARAM 1
+#define _DMA_V2_ELEM_CROPPING_A_PARAM 2
+#define _DMA_V2_WIDTH_A_PARAM 3
+#define _DMA_V2_STRIDE_B_PARAM 4
+#define _DMA_V2_ELEM_CROPPING_B_PARAM 5
+#define _DMA_V2_WIDTH_B_PARAM 6
+#define _DMA_V2_HEIGHT_PARAM 7
+#define _DMA_V2_QUEUED_CMDS 8
 
 /* Parameter Constants */
-#define _DMA_V2_ZERO_EXTEND                             0
-#define _DMA_V2_SIGN_EXTEND                             1
+#define _DMA_V2_ZERO_EXTEND 0
+#define _DMA_V2_SIGN_EXTEND 1
 
 /* SLAVE address map */
-#define _DMA_V2_SEL_FSM_CMD                             0
-#define _DMA_V2_SEL_CH_REG                              1
-#define _DMA_V2_SEL_CONN_GROUP                          2
-#define _DMA_V2_SEL_DEV_INTERF                          3
-
-#define _DMA_V2_ADDR_SEL_COMP_IDX                      12
-#define _DMA_V2_ADDR_SEL_COMP_BITS                      4
-#define _DMA_V2_ADDR_SEL_CH_REG_IDX                     2
-#define _DMA_V2_ADDR_SEL_CH_REG_BITS                    6
-#define _DMA_V2_ADDR_SEL_PARAM_IDX                      (_DMA_V2_ADDR_SEL_CH_REG_BITS + _DMA_V2_ADDR_SEL_CH_REG_IDX)
-#define _DMA_V2_ADDR_SEL_PARAM_BITS                     4
-
-#define _DMA_V2_ADDR_SEL_GROUP_COMP_IDX                 2
-#define _DMA_V2_ADDR_SEL_GROUP_COMP_BITS                6
-#define _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_IDX            (_DMA_V2_ADDR_SEL_GROUP_COMP_BITS + _DMA_V2_ADDR_SEL_GROUP_COMP_IDX)
-#define _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_BITS           4
-
-#define _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX             2
-#define _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS            6
-#define _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_IDX            (_DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX + _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS)
-#define _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_BITS           4
-
-#define _DMA_V2_FSM_GROUP_CMD_IDX                       0
-#define _DMA_V2_FSM_GROUP_ADDR_SRC_IDX                  1
-#define _DMA_V2_FSM_GROUP_ADDR_DEST_IDX                 2
-#define _DMA_V2_FSM_GROUP_CMD_CTRL_IDX                  3
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_IDX                  4
-#define _DMA_V2_FSM_GROUP_FSM_PACK_IDX                  5
-#define _DMA_V2_FSM_GROUP_FSM_REQ_IDX                   6
-#define _DMA_V2_FSM_GROUP_FSM_WR_IDX                    7
-
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_STATE_IDX            0
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX          1
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX         2
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX       3
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_XB_IDX           4
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_YB_IDX           5
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX     6
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX      7
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX          8
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX        9
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX     10
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX      11
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX      12
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX   13
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX    14
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX        15
-#define _DMA_V2_FSM_GROUP_FSM_CTRL_CMD_CTRL_IDX        15
-
-#define _DMA_V2_FSM_GROUP_FSM_PACK_STATE_IDX            0
-#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_YB_IDX           1
-#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX       2
-#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX        3
-
-#define _DMA_V2_FSM_GROUP_FSM_REQ_STATE_IDX             0
-#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_YB_IDX            1
-#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_XB_IDX            2
-#define _DMA_V2_FSM_GROUP_FSM_REQ_XB_REMAINING_IDX      3
-#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_BURST_IDX         4
-
-#define _DMA_V2_FSM_GROUP_FSM_WR_STATE_IDX              0
-#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_YB_IDX             1
-#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_XB_IDX             2
-#define _DMA_V2_FSM_GROUP_FSM_WR_XB_REMAINING_IDX       3
-#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_BURST_IDX          4
-
-#define _DMA_V2_DEV_INTERF_REQ_SIDE_STATUS_IDX          0
-#define _DMA_V2_DEV_INTERF_SEND_SIDE_STATUS_IDX         1
-#define _DMA_V2_DEV_INTERF_FIFO_STATUS_IDX              2
-#define _DMA_V2_DEV_INTERF_REQ_ONLY_COMPLETE_BURST_IDX  3
-#define _DMA_V2_DEV_INTERF_MAX_BURST_IDX                4
-#define _DMA_V2_DEV_INTERF_CHK_ADDR_ALIGN               5
+#define _DMA_V2_SEL_FSM_CMD 0
+#define _DMA_V2_SEL_CH_REG 1
+#define _DMA_V2_SEL_CONN_GROUP 2
+#define _DMA_V2_SEL_DEV_INTERF 3
+
+#define _DMA_V2_ADDR_SEL_COMP_IDX 12
+#define _DMA_V2_ADDR_SEL_COMP_BITS 4
+#define _DMA_V2_ADDR_SEL_CH_REG_IDX 2
+#define _DMA_V2_ADDR_SEL_CH_REG_BITS 6
+#define _DMA_V2_ADDR_SEL_PARAM_IDX \
+	(_DMA_V2_ADDR_SEL_CH_REG_BITS + _DMA_V2_ADDR_SEL_CH_REG_IDX)
+#define _DMA_V2_ADDR_SEL_PARAM_BITS 4
+
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_IDX 2
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_BITS 6
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_IDX \
+	(_DMA_V2_ADDR_SEL_GROUP_COMP_BITS + _DMA_V2_ADDR_SEL_GROUP_COMP_IDX)
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_BITS 4
+
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX 2
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS 6
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_IDX   \
+	(_DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX + \
+	 _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS)
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_BITS 4
+
+#define _DMA_V2_FSM_GROUP_CMD_IDX 0
+#define _DMA_V2_FSM_GROUP_ADDR_SRC_IDX 1
+#define _DMA_V2_FSM_GROUP_ADDR_DEST_IDX 2
+#define _DMA_V2_FSM_GROUP_CMD_CTRL_IDX 3
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_IDX 4
+#define _DMA_V2_FSM_GROUP_FSM_PACK_IDX 5
+#define _DMA_V2_FSM_GROUP_FSM_REQ_IDX 6
+#define _DMA_V2_FSM_GROUP_FSM_WR_IDX 7
+
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_STATE_IDX 0
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX 1
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX 2
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX 3
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_XB_IDX 4
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_YB_IDX 5
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX 6
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX 7
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX 8
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX 9
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX 10
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX 11
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX 12
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX 13
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX 14
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX 15
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_CMD_CTRL_IDX 15
+
+#define _DMA_V2_FSM_GROUP_FSM_PACK_STATE_IDX 0
+#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_YB_IDX 1
+#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX 2
+#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX 3
+
+#define _DMA_V2_FSM_GROUP_FSM_REQ_STATE_IDX 0
+#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_YB_IDX 1
+#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_XB_IDX 2
+#define _DMA_V2_FSM_GROUP_FSM_REQ_XB_REMAINING_IDX 3
+#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_BURST_IDX 4
+
+#define _DMA_V2_FSM_GROUP_FSM_WR_STATE_IDX 0
+#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_YB_IDX 1
+#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_XB_IDX 2
+#define _DMA_V2_FSM_GROUP_FSM_WR_XB_REMAINING_IDX 3
+#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_BURST_IDX 4
+
+#define _DMA_V2_DEV_INTERF_REQ_SIDE_STATUS_IDX 0
+#define _DMA_V2_DEV_INTERF_SEND_SIDE_STATUS_IDX 1
+#define _DMA_V2_DEV_INTERF_FIFO_STATUS_IDX 2
+#define _DMA_V2_DEV_INTERF_REQ_ONLY_COMPLETE_BURST_IDX 3
+#define _DMA_V2_DEV_INTERF_MAX_BURST_IDX 4
+#define _DMA_V2_DEV_INTERF_CHK_ADDR_ALIGN 5
 
 #endif /* _dma_v2_defs_h */
diff --git a/drivers/staging/media/atomisp/pci/gdc_v2_defs.h b/drivers/staging/media/atomisp/pci/gdc_v2_defs.h
index ca2fee141f7660f1caf3f16fce7900ef642260f8..427b5f5b1362f447c54261d231176a917fa25784 100644
--- a/drivers/staging/media/atomisp/pci/gdc_v2_defs.h
+++ b/drivers/staging/media/atomisp/pci/gdc_v2_defs.h
@@ -9,25 +9,32 @@
 
 #define HRT_GDC_IS_V2
 
-#define HRT_GDC_N                     1024 /* Top-level design constant, equal to the number of entries in the LUT      */
-#define HRT_GDC_FRAC_BITS               10 /* Number of fractional bits in the GDC block, driven by the size of the LUT */
-
-#define HRT_GDC_BLI_FRAC_BITS            4 /* Number of fractional bits for the bi-linear interpolation type            */
-#define HRT_GDC_BLI_COEF_ONE             BIT(HRT_GDC_BLI_FRAC_BITS)
-
-#define HRT_GDC_BCI_COEF_BITS           14 /* 14 bits per coefficient                                                   */
-#define HRT_GDC_BCI_COEF_ONE             (1 << (HRT_GDC_BCI_COEF_BITS - 2))  /* We represent signed 10 bit coefficients.  */
+#define HRT_GDC_N \
+	1024 /* Top-level design constant, equal to the number of entries in the LUT      */
+#define HRT_GDC_FRAC_BITS \
+	10 /* Number of fractional bits in the GDC block, driven by the size of the LUT */
+
+#define HRT_GDC_BLI_FRAC_BITS \
+	4 /* Number of fractional bits for the bi-linear interpolation type            */
+#define HRT_GDC_BLI_COEF_ONE BIT(HRT_GDC_BLI_FRAC_BITS)
+
+#define HRT_GDC_BCI_COEF_BITS \
+	14 /* 14 bits per coefficient                                                   */
+#define HRT_GDC_BCI_COEF_ONE           \
+	(1 << (HRT_GDC_BCI_COEF_BITS - \
+	       2)) /* We represent signed 10 bit coefficients.  */
 /* The supported range is [-256, .., +256]      */
 /* in 14-bit signed notation,                   */
 /* We need all ten bits (MSB must be zero).     */
 /* -s is inserted to solve this issue, and      */
 /* therefore "1" is equal to +256.              */
-#define HRT_GDC_BCI_COEF_MASK            ((1 << HRT_GDC_BCI_COEF_BITS) - 1)
+#define HRT_GDC_BCI_COEF_MASK ((1 << HRT_GDC_BCI_COEF_BITS) - 1)
 
-#define HRT_GDC_LUT_BYTES                (HRT_GDC_N * 4 * 2)                /* 1024 addresses, 4 coefficients per address,  */
+#define HRT_GDC_LUT_BYTES \
+	(HRT_GDC_N * 4 * 2) /* 1024 addresses, 4 coefficients per address,  */
 /* 2 bytes per coefficient                      */
 
-#define _HRT_GDC_REG_ALIGN               4
+#define _HRT_GDC_REG_ALIGN 4
 
 //     31  30  29    25 24                     0
 //  |-----|---|--------|------------------------|
@@ -55,50 +62,50 @@
 //   1. two  tokens: SRC address ; DST address
 //   2. nine tokens: P0'Y, .., P3'Y ; SRC address ; DST address
 
-#define HRT_GDC_CONFIG_CMD             1
-#define HRT_GDC_DATA_CMD               0
+#define HRT_GDC_CONFIG_CMD 1
+#define HRT_GDC_DATA_CMD 0
 
-#define HRT_GDC_CMD_POS               31
-#define HRT_GDC_CMD_BITS               1
-#define HRT_GDC_CRUN_POS              30
-#define HRT_GDC_REG_ID_POS            25
-#define HRT_GDC_REG_ID_BITS            5
-#define HRT_GDC_DATA_POS               0
-#define HRT_GDC_DATA_BITS             25
+#define HRT_GDC_CMD_POS 31
+#define HRT_GDC_CMD_BITS 1
+#define HRT_GDC_CRUN_POS 30
+#define HRT_GDC_REG_ID_POS 25
+#define HRT_GDC_REG_ID_BITS 5
+#define HRT_GDC_DATA_POS 0
+#define HRT_GDC_DATA_BITS 25
 
-#define HRT_GDC_FRYIPXFRX_BITS        26
-#define HRT_GDC_P0X_BITS              23
+#define HRT_GDC_FRYIPXFRX_BITS 26
+#define HRT_GDC_P0X_BITS 23
 
-#define HRT_GDC_MAX_OXDIM           (8192 - 64)
-#define HRT_GDC_MAX_OYDIM           4095
-#define HRT_GDC_MAX_IXDIM           (8192 - 64)
-#define HRT_GDC_MAX_IYDIM           4095
-#define HRT_GDC_MAX_DS_FAC            16
-#define HRT_GDC_MAX_DX                 (HRT_GDC_MAX_DS_FAC * HRT_GDC_N - 1)
-#define HRT_GDC_MAX_DY                 HRT_GDC_MAX_DX
+#define HRT_GDC_MAX_OXDIM (8192 - 64)
+#define HRT_GDC_MAX_OYDIM 4095
+#define HRT_GDC_MAX_IXDIM (8192 - 64)
+#define HRT_GDC_MAX_IYDIM 4095
+#define HRT_GDC_MAX_DS_FAC 16
+#define HRT_GDC_MAX_DX (HRT_GDC_MAX_DS_FAC * HRT_GDC_N - 1)
+#define HRT_GDC_MAX_DY HRT_GDC_MAX_DX
 
 /* GDC lookup tables entries are 10 bits values, but they're
    stored 2 by 2 as 32 bit values, yielding 16 bits per entry.
    A GDC lookup table contains 64 * 4 elements */
 
-#define HRT_GDC_PERF_1_1_pix          0
-#define HRT_GDC_PERF_2_1_pix          1
-#define HRT_GDC_PERF_1_2_pix          2
-#define HRT_GDC_PERF_2_2_pix          3
+#define HRT_GDC_PERF_1_1_pix 0
+#define HRT_GDC_PERF_2_1_pix 1
+#define HRT_GDC_PERF_1_2_pix 2
+#define HRT_GDC_PERF_2_2_pix 3
 
-#define HRT_GDC_NND_MODE              0
-#define HRT_GDC_BLI_MODE              1
-#define HRT_GDC_BCI_MODE              2
-#define HRT_GDC_LUT_MODE              3
+#define HRT_GDC_NND_MODE 0
+#define HRT_GDC_BLI_MODE 1
+#define HRT_GDC_BCI_MODE 2
+#define HRT_GDC_LUT_MODE 3
 
-#define HRT_GDC_SCAN_STB              0
-#define HRT_GDC_SCAN_STR              1
+#define HRT_GDC_SCAN_STB 0
+#define HRT_GDC_SCAN_STR 1
 
-#define HRT_GDC_MODE_SCALING          0
-#define HRT_GDC_MODE_TETRAGON         1
+#define HRT_GDC_MODE_SCALING 0
+#define HRT_GDC_MODE_TETRAGON 1
 
-#define HRT_GDC_LUT_COEFF_OFFSET     16
-#define HRT_GDC_FRY_BIT_OFFSET       16
+#define HRT_GDC_LUT_COEFF_OFFSET 16
+#define HRT_GDC_FRY_BIT_OFFSET 16
 // FRYIPXFRX is the only register where we store two values in one field,
 // to save one token in the scaling protocol.
 // Like this, we have three tokens in the scaling protocol,
@@ -108,12 +115,12 @@
 //  |------|----------|------|----------|
 //  | XXXX |   FRY    |  IPX |   FRX    |
 
-#define HRT_GDC_CE_FSM0_POS           0
-#define HRT_GDC_CE_FSM0_LEN           2
-#define HRT_GDC_CE_OPY_POS            2
-#define HRT_GDC_CE_OPY_LEN           14
-#define HRT_GDC_CE_OPX_POS           16
-#define HRT_GDC_CE_OPX_LEN           16
+#define HRT_GDC_CE_FSM0_POS 0
+#define HRT_GDC_CE_FSM0_LEN 2
+#define HRT_GDC_CE_OPY_POS 2
+#define HRT_GDC_CE_OPY_LEN 14
+#define HRT_GDC_CE_OPX_POS 16
+#define HRT_GDC_CE_OPX_LEN 16
 // CHK_ENGINE register bit-map:
 //   31            16 15        2 1  0
 //  |----------------|-----------|----|
@@ -122,34 +129,35 @@
 // this implementation is meaningless in hss model,
 // So, we just return 0
 
-#define HRT_GDC_CHK_ENGINE_IDX        0
-#define HRT_GDC_WOIX_IDX              1
-#define HRT_GDC_WOIY_IDX              2
-#define HRT_GDC_BPP_IDX               3
-#define HRT_GDC_FRYIPXFRX_IDX         4
-#define HRT_GDC_OXDIM_IDX             5
-#define HRT_GDC_OYDIM_IDX             6
-#define HRT_GDC_SRC_ADDR_IDX          7
-#define HRT_GDC_SRC_END_ADDR_IDX      8
-#define HRT_GDC_SRC_WRAP_ADDR_IDX     9
-#define HRT_GDC_SRC_STRIDE_IDX       10
-#define HRT_GDC_DST_ADDR_IDX         11
-#define HRT_GDC_DST_STRIDE_IDX       12
-#define HRT_GDC_DX_IDX               13
-#define HRT_GDC_DY_IDX               14
-#define HRT_GDC_P0X_IDX              15
-#define HRT_GDC_P0Y_IDX              16
-#define HRT_GDC_P1X_IDX              17
-#define HRT_GDC_P1Y_IDX              18
-#define HRT_GDC_P2X_IDX              19
-#define HRT_GDC_P2Y_IDX              20
-#define HRT_GDC_P3X_IDX              21
-#define HRT_GDC_P3Y_IDX              22
-#define HRT_GDC_PERF_POINT_IDX       23  // 1x1 ; 1x2 ; 2x1 ; 2x2 pixels per cc
-#define HRT_GDC_INTERP_TYPE_IDX      24  // NND ; BLI ; BCI ; LUT
-#define HRT_GDC_SCAN_IDX             25  // 0 = STB (Slide To Bottom) ; 1 = STR (Slide To Right)
-#define HRT_GDC_PROC_MODE_IDX        26  // 0 = Scaling ; 1 = Tetragon
-
-#define HRT_GDC_LUT_IDX              32
+#define HRT_GDC_CHK_ENGINE_IDX 0
+#define HRT_GDC_WOIX_IDX 1
+#define HRT_GDC_WOIY_IDX 2
+#define HRT_GDC_BPP_IDX 3
+#define HRT_GDC_FRYIPXFRX_IDX 4
+#define HRT_GDC_OXDIM_IDX 5
+#define HRT_GDC_OYDIM_IDX 6
+#define HRT_GDC_SRC_ADDR_IDX 7
+#define HRT_GDC_SRC_END_ADDR_IDX 8
+#define HRT_GDC_SRC_WRAP_ADDR_IDX 9
+#define HRT_GDC_SRC_STRIDE_IDX 10
+#define HRT_GDC_DST_ADDR_IDX 11
+#define HRT_GDC_DST_STRIDE_IDX 12
+#define HRT_GDC_DX_IDX 13
+#define HRT_GDC_DY_IDX 14
+#define HRT_GDC_P0X_IDX 15
+#define HRT_GDC_P0Y_IDX 16
+#define HRT_GDC_P1X_IDX 17
+#define HRT_GDC_P1Y_IDX 18
+#define HRT_GDC_P2X_IDX 19
+#define HRT_GDC_P2Y_IDX 20
+#define HRT_GDC_P3X_IDX 21
+#define HRT_GDC_P3Y_IDX 22
+#define HRT_GDC_PERF_POINT_IDX 23 // 1x1 ; 1x2 ; 2x1 ; 2x2 pixels per cc
+#define HRT_GDC_INTERP_TYPE_IDX 24 // NND ; BLI ; BCI ; LUT
+#define HRT_GDC_SCAN_IDX \
+	25 // 0 = STB (Slide To Bottom) ; 1 = STR (Slide To Right)
+#define HRT_GDC_PROC_MODE_IDX 26 // 0 = Scaling ; 1 = Tetragon
+
+#define HRT_GDC_LUT_IDX 32
 
 #endif /* HRT_GDC_v2_defs_h_ */
diff --git a/drivers/staging/media/atomisp/pci/gp_timer_defs.h b/drivers/staging/media/atomisp/pci/gp_timer_defs.h
index 4b1b8ae1c194d1bf418e08b2d32d2ec4f7e73c12..b19371265d8effa9abe27b1579bc86117870e564 100644
--- a/drivers/staging/media/atomisp/pci/gp_timer_defs.h
+++ b/drivers/staging/media/atomisp/pci/gp_timer_defs.h
@@ -9,20 +9,27 @@
 
 #define _HRT_GP_TIMER_REG_ALIGN 4
 
-#define HIVE_GP_TIMER_RESET_REG_IDX                              0
-#define HIVE_GP_TIMER_OVERALL_ENABLE_REG_IDX                     1
-#define HIVE_GP_TIMER_ENABLE_REG_IDX(timer)                     (HIVE_GP_TIMER_OVERALL_ENABLE_REG_IDX + 1 + timer)
-#define HIVE_GP_TIMER_VALUE_REG_IDX(timer, timers)               (HIVE_GP_TIMER_ENABLE_REG_IDX(timers) + timer)
-#define HIVE_GP_TIMER_COUNT_TYPE_REG_IDX(timer, timers)          (HIVE_GP_TIMER_VALUE_REG_IDX(timers, timers) + timer)
-#define HIVE_GP_TIMER_SIGNAL_SELECT_REG_IDX(timer, timers)       (HIVE_GP_TIMER_COUNT_TYPE_REG_IDX(timers, timers) + timer)
-#define HIVE_GP_TIMER_IRQ_TRIGGER_VALUE_REG_IDX(irq, timers)     (HIVE_GP_TIMER_SIGNAL_SELECT_REG_IDX(timers, timers) + irq)
-#define HIVE_GP_TIMER_IRQ_TIMER_SELECT_REG_IDX(irq, timers, irqs) (HIVE_GP_TIMER_IRQ_TRIGGER_VALUE_REG_IDX(irqs, timers) + irq)
-#define HIVE_GP_TIMER_IRQ_ENABLE_REG_IDX(irq, timers, irqs)       (HIVE_GP_TIMER_IRQ_TIMER_SELECT_REG_IDX(irqs, timers, irqs) + irq)
+#define HIVE_GP_TIMER_RESET_REG_IDX 0
+#define HIVE_GP_TIMER_OVERALL_ENABLE_REG_IDX 1
+#define HIVE_GP_TIMER_ENABLE_REG_IDX(timer) \
+	(HIVE_GP_TIMER_OVERALL_ENABLE_REG_IDX + 1 + timer)
+#define HIVE_GP_TIMER_VALUE_REG_IDX(timer, timers) \
+	(HIVE_GP_TIMER_ENABLE_REG_IDX(timers) + timer)
+#define HIVE_GP_TIMER_COUNT_TYPE_REG_IDX(timer, timers) \
+	(HIVE_GP_TIMER_VALUE_REG_IDX(timers, timers) + timer)
+#define HIVE_GP_TIMER_SIGNAL_SELECT_REG_IDX(timer, timers) \
+	(HIVE_GP_TIMER_COUNT_TYPE_REG_IDX(timers, timers) + timer)
+#define HIVE_GP_TIMER_IRQ_TRIGGER_VALUE_REG_IDX(irq, timers) \
+	(HIVE_GP_TIMER_SIGNAL_SELECT_REG_IDX(timers, timers) + irq)
+#define HIVE_GP_TIMER_IRQ_TIMER_SELECT_REG_IDX(irq, timers, irqs) \
+	(HIVE_GP_TIMER_IRQ_TRIGGER_VALUE_REG_IDX(irqs, timers) + irq)
+#define HIVE_GP_TIMER_IRQ_ENABLE_REG_IDX(irq, timers, irqs) \
+	(HIVE_GP_TIMER_IRQ_TIMER_SELECT_REG_IDX(irqs, timers, irqs) + irq)
 
-#define HIVE_GP_TIMER_COUNT_TYPE_HIGH                            0
-#define HIVE_GP_TIMER_COUNT_TYPE_LOW                             1
-#define HIVE_GP_TIMER_COUNT_TYPE_POSEDGE                         2
-#define HIVE_GP_TIMER_COUNT_TYPE_NEGEDGE                         3
-#define HIVE_GP_TIMER_COUNT_TYPES                                4
+#define HIVE_GP_TIMER_COUNT_TYPE_HIGH 0
+#define HIVE_GP_TIMER_COUNT_TYPE_LOW 1
+#define HIVE_GP_TIMER_COUNT_TYPE_POSEDGE 2
+#define HIVE_GP_TIMER_COUNT_TYPE_NEGEDGE 3
+#define HIVE_GP_TIMER_COUNT_TYPES 4
 
 #endif /* _gp_timer_defs_h */
diff --git a/drivers/staging/media/atomisp/pci/gpio_block_defs.h b/drivers/staging/media/atomisp/pci/gpio_block_defs.h
index a4ce5a6dbd93de249c25a0db5a30194bccd43061..0e46caca4b51fa2c8d5b2feb2bd8f10578afc7f2 100644
--- a/drivers/staging/media/atomisp/pci/gpio_block_defs.h
+++ b/drivers/staging/media/atomisp/pci/gpio_block_defs.h
@@ -8,9 +8,9 @@
 #define _gpio_block_defs_h_
 
 /* R/W registers */
-#define _gpio_block_reg_do_e				 0
-#define _gpio_block_reg_do_select		       1
-#define _gpio_block_reg_do_0				 2
-#define _gpio_block_reg_do_1				 3
+#define _gpio_block_reg_do_e 0
+#define _gpio_block_reg_do_select 1
+#define _gpio_block_reg_do_0 2
+#define _gpio_block_reg_do_1 3
 
 #endif /* _gpio_block_defs_h_ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/debug_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/debug_global.h
index 15fb0ad4a5f0ed9cc519e8ad83608ba5a4c87d93..5d983ebbf36a5c64be1f5318b0018f24d0fcdf1f 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/debug_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/debug_global.h
@@ -9,22 +9,22 @@
 
 #include <type_support.h>
 
-#define DEBUG_BUF_SIZE	1024
-#define DEBUG_BUF_MASK	(DEBUG_BUF_SIZE - 1)
+#define DEBUG_BUF_SIZE 1024
+#define DEBUG_BUF_MASK (DEBUG_BUF_SIZE - 1)
 
-#define DEBUG_DATA_ENABLE_ADDR		0x00
-#define DEBUG_DATA_BUF_MODE_ADDR	0x04
-#define DEBUG_DATA_HEAD_ADDR		0x08
-#define DEBUG_DATA_TAIL_ADDR		0x0C
-#define DEBUG_DATA_BUF_ADDR			0x10
+#define DEBUG_DATA_ENABLE_ADDR 0x00
+#define DEBUG_DATA_BUF_MODE_ADDR 0x04
+#define DEBUG_DATA_HEAD_ADDR 0x08
+#define DEBUG_DATA_TAIL_ADDR 0x0C
+#define DEBUG_DATA_BUF_ADDR 0x10
 
-#define DEBUG_DATA_ENABLE_DDR_ADDR		0x00
-#define DEBUG_DATA_BUF_MODE_DDR_ADDR	HIVE_ISP_DDR_WORD_BYTES
-#define DEBUG_DATA_HEAD_DDR_ADDR		(2 * HIVE_ISP_DDR_WORD_BYTES)
-#define DEBUG_DATA_TAIL_DDR_ADDR		(3 * HIVE_ISP_DDR_WORD_BYTES)
-#define DEBUG_DATA_BUF_DDR_ADDR			(4 * HIVE_ISP_DDR_WORD_BYTES)
+#define DEBUG_DATA_ENABLE_DDR_ADDR 0x00
+#define DEBUG_DATA_BUF_MODE_DDR_ADDR HIVE_ISP_DDR_WORD_BYTES
+#define DEBUG_DATA_HEAD_DDR_ADDR (2 * HIVE_ISP_DDR_WORD_BYTES)
+#define DEBUG_DATA_TAIL_DDR_ADDR (3 * HIVE_ISP_DDR_WORD_BYTES)
+#define DEBUG_DATA_BUF_DDR_ADDR (4 * HIVE_ISP_DDR_WORD_BYTES)
 
-#define DEBUG_BUFFER_ISP_DMEM_ADDR       0x0
+#define DEBUG_BUFFER_ISP_DMEM_ADDR 0x0
 
 /*
  * The linear buffer mode will accept data until the first
@@ -39,11 +39,11 @@ typedef enum {
 } debug_buf_mode_t;
 
 struct debug_data_s {
-	u32			enable;
-	u32			bufmode;
-	u32			head;
-	u32			tail;
-	u32			buf[DEBUG_BUF_SIZE];
+	u32 enable;
+	u32 bufmode;
+	u32 head;
+	u32 tail;
+	u32 buf[DEBUG_BUF_SIZE];
 };
 
 /* thread.sp.c doesn't have a notion of HIVE_ISP_DDR_WORD_BYTES
@@ -51,15 +51,15 @@ struct debug_data_s {
 
 #ifdef HIVE_ISP_DDR_WORD_BYTES
 struct debug_data_ddr_s {
-	u32			enable;
-	s8				padding1[HIVE_ISP_DDR_WORD_BYTES - sizeof(uint32_t)];
-	u32			bufmode;
-	s8				padding2[HIVE_ISP_DDR_WORD_BYTES - sizeof(uint32_t)];
-	u32			head;
-	s8				padding3[HIVE_ISP_DDR_WORD_BYTES - sizeof(uint32_t)];
-	u32			tail;
-	s8				padding4[HIVE_ISP_DDR_WORD_BYTES - sizeof(uint32_t)];
-	u32			buf[DEBUG_BUF_SIZE];
+	u32 enable;
+	s8 padding1[HIVE_ISP_DDR_WORD_BYTES - sizeof(uint32_t)];
+	u32 bufmode;
+	s8 padding2[HIVE_ISP_DDR_WORD_BYTES - sizeof(uint32_t)];
+	u32 head;
+	s8 padding3[HIVE_ISP_DDR_WORD_BYTES - sizeof(uint32_t)];
+	u32 tail;
+	s8 padding4[HIVE_ISP_DDR_WORD_BYTES - sizeof(uint32_t)];
+	u32 buf[DEBUG_BUF_SIZE];
 };
 #endif
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/dma_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/dma_global.h
index 05b10e3d19dc95b131785f2920597a7a5b9c70f5..381ac826262b9f0053e08308580c4aefe8573a82 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/dma_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/dma_global.h
@@ -11,10 +11,10 @@
 
 #define IS_DMA_VERSION_2
 
-#define HIVE_ISP_NUM_DMA_CONNS		3
-#define HIVE_ISP_NUM_DMA_CHANNELS	32
+#define HIVE_ISP_NUM_DMA_CONNS 3
+#define HIVE_ISP_NUM_DMA_CHANNELS 32
 
-#define N_DMA_CHANNEL_ID	HIVE_ISP_NUM_DMA_CHANNELS
+#define N_DMA_CHANNEL_ID HIVE_ISP_NUM_DMA_CHANNELS
 
 #include "dma_v2_defs.h"
 
@@ -31,17 +31,17 @@
  *
  */
 
-#define _DMA_PACKING_SETUP_PARAM	_DMA_V2_PACKING_SETUP_PARAM
-#define _DMA_HEIGHT_PARAM			_DMA_V2_HEIGHT_PARAM
-#define _DMA_STRIDE_A_PARAM			_DMA_V2_STRIDE_A_PARAM
-#define _DMA_ELEM_CROPPING_A_PARAM	_DMA_V2_ELEM_CROPPING_A_PARAM
-#define _DMA_WIDTH_A_PARAM			_DMA_V2_WIDTH_A_PARAM
-#define _DMA_STRIDE_B_PARAM			_DMA_V2_STRIDE_B_PARAM
-#define _DMA_ELEM_CROPPING_B_PARAM	_DMA_V2_ELEM_CROPPING_B_PARAM
-#define _DMA_WIDTH_B_PARAM			_DMA_V2_WIDTH_B_PARAM
+#define _DMA_PACKING_SETUP_PARAM _DMA_V2_PACKING_SETUP_PARAM
+#define _DMA_HEIGHT_PARAM _DMA_V2_HEIGHT_PARAM
+#define _DMA_STRIDE_A_PARAM _DMA_V2_STRIDE_A_PARAM
+#define _DMA_ELEM_CROPPING_A_PARAM _DMA_V2_ELEM_CROPPING_A_PARAM
+#define _DMA_WIDTH_A_PARAM _DMA_V2_WIDTH_A_PARAM
+#define _DMA_STRIDE_B_PARAM _DMA_V2_STRIDE_B_PARAM
+#define _DMA_ELEM_CROPPING_B_PARAM _DMA_V2_ELEM_CROPPING_B_PARAM
+#define _DMA_WIDTH_B_PARAM _DMA_V2_WIDTH_B_PARAM
 
-#define _DMA_ZERO_EXTEND     _DMA_V2_ZERO_EXTEND
-#define _DMA_SIGN_EXTEND     _DMA_V2_SIGN_EXTEND
+#define _DMA_ZERO_EXTEND _DMA_V2_ZERO_EXTEND
+#define _DMA_SIGN_EXTEND _DMA_V2_SIGN_EXTEND
 
 typedef unsigned int dma_channel;
 
@@ -56,131 +56,162 @@ typedef enum {
 	dma_sign_extension = _DMA_SIGN_EXTEND
 } dma_extension;
 
-#define DMA_PROP_SHIFT(val, param)       ((val) << _DMA_V2_ ## param ## _IDX)
-#define DMA_PROP_MASK(param)             ((1U << _DMA_V2_ ## param ## _BITS) - 1)
-#define DMA_PACK(val, param)             DMA_PROP_SHIFT((val) & DMA_PROP_MASK(param), param)
-
-#define DMA_PACK_COMMAND(cmd)            DMA_PACK(cmd, CMD)
-#define DMA_PACK_CHANNEL(ch)             DMA_PACK(ch,  CHANNEL)
-#define DMA_PACK_PARAM(par)              DMA_PACK(par, PARAM)
-#define DMA_PACK_EXTENSION(ext)          DMA_PACK(ext, EXTENSION)
-#define DMA_PACK_LEFT_CROPPING(lc)       DMA_PACK(lc,  LEFT_CROPPING)
-#define DMA_PACK_WIDTH_A(w)              DMA_PACK(w,   SPEC_DEV_A_XB)
-#define DMA_PACK_WIDTH_B(w)              DMA_PACK(w,   SPEC_DEV_B_XB)
-#define DMA_PACK_HEIGHT(h)               DMA_PACK(h,   SPEC_YB)
-
-#define DMA_PACK_CMD_CHANNEL(cmd, ch)	 (DMA_PACK_COMMAND(cmd) | DMA_PACK_CHANNEL(ch))
-#define DMA_PACK_SETUP(conn, ext)        ((conn) | DMA_PACK_EXTENSION(ext))
-#define DMA_PACK_CROP_ELEMS(elems, crop) ((elems) | DMA_PACK_LEFT_CROPPING(crop))
+#define DMA_PROP_SHIFT(val, param) ((val) << _DMA_V2_##param##_IDX)
+#define DMA_PROP_MASK(param) ((1U << _DMA_V2_##param##_BITS) - 1)
+#define DMA_PACK(val, param) DMA_PROP_SHIFT((val)&DMA_PROP_MASK(param), param)
+
+#define DMA_PACK_COMMAND(cmd) DMA_PACK(cmd, CMD)
+#define DMA_PACK_CHANNEL(ch) DMA_PACK(ch, CHANNEL)
+#define DMA_PACK_PARAM(par) DMA_PACK(par, PARAM)
+#define DMA_PACK_EXTENSION(ext) DMA_PACK(ext, EXTENSION)
+#define DMA_PACK_LEFT_CROPPING(lc) DMA_PACK(lc, LEFT_CROPPING)
+#define DMA_PACK_WIDTH_A(w) DMA_PACK(w, SPEC_DEV_A_XB)
+#define DMA_PACK_WIDTH_B(w) DMA_PACK(w, SPEC_DEV_B_XB)
+#define DMA_PACK_HEIGHT(h) DMA_PACK(h, SPEC_YB)
+
+#define DMA_PACK_CMD_CHANNEL(cmd, ch) \
+	(DMA_PACK_COMMAND(cmd) | DMA_PACK_CHANNEL(ch))
+#define DMA_PACK_SETUP(conn, ext) ((conn) | DMA_PACK_EXTENSION(ext))
+#define DMA_PACK_CROP_ELEMS(elems, crop) \
+	((elems) | DMA_PACK_LEFT_CROPPING(crop))
 
 #define hive_dma_snd(dma_id, token) OP_std_snd(dma_id, (unsigned int)(token))
 
-#define DMA_PACK_BLOCK_CMD(cmd, ch, width_a, width_b, height) \
-  (DMA_PACK_COMMAND(cmd)     | \
-   DMA_PACK_CHANNEL(ch)      | \
-   DMA_PACK_WIDTH_A(width_a) | \
-   DMA_PACK_WIDTH_B(width_b) | \
-   DMA_PACK_HEIGHT(height))
-
-#define hive_dma_move_data(dma_id, read, channel, addr_a, addr_b, to_is_var, from_is_var) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read ? _DMA_V2_MOVE_B2A_COMMAND : _DMA_V2_MOVE_A2B_COMMAND, channel)); \
-  hive_dma_snd(dma_id, read ? (unsigned int)(addr_b) : (unsigned int)(addr_a)); \
-  hive_dma_snd(dma_id, read ? (unsigned int)(addr_a) : (unsigned int)(addr_b)); \
-  hive_dma_snd(dma_id, to_is_var); \
-  hive_dma_snd(dma_id, from_is_var); \
-}
-
-#define hive_dma_move_data_no_ack(dma_id, read, channel, addr_a, addr_b, to_is_var, from_is_var) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read ? _DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND : _DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND, channel)); \
-  hive_dma_snd(dma_id, read ? (unsigned int)(addr_b) : (unsigned int)(addr_a)); \
-  hive_dma_snd(dma_id, read ? (unsigned int)(addr_a) : (unsigned int)(addr_b)); \
-  hive_dma_snd(dma_id, to_is_var); \
-  hive_dma_snd(dma_id, from_is_var); \
-}
-
-#define hive_dma_move_b2a_data(dma_id, channel, to_addr, from_addr, to_is_var, from_is_var) \
-{ \
-  hive_dma_move_data(dma_id, true, channel, to_addr, from_addr, to_is_var, from_is_var) \
-}
-
-#define hive_dma_move_a2b_data(dma_id, channel, from_addr, to_addr, from_is_var, to_is_var) \
-{ \
-  hive_dma_move_data(dma_id, false, channel, from_addr, to_addr, from_is_var, to_is_var) \
-}
-
-#define hive_dma_set_data(dma_id, channel, address, value, is_var) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_INIT_A_COMMAND, channel)); \
-  hive_dma_snd(dma_id, value); \
-  hive_dma_snd(dma_id, address); \
-  hive_dma_snd(dma_id, is_var); \
-}
-
-#define hive_dma_clear_data(dma_id, channel, address, is_var) hive_dma_set_data(dma_id, channel, address, 0, is_var)
-
-#define hive_dma_configure(dma_id, channel, connection, extension, height, \
-	stride_A, elems_A, cropping_A, width_A, \
-	stride_B, elems_B, cropping_B, width_B) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_CONFIG_CHANNEL_COMMAND, channel)); \
-  hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension)); \
-  hive_dma_snd(dma_id, stride_A); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, cropping_A)); \
-  hive_dma_snd(dma_id, width_A); \
-  hive_dma_snd(dma_id, stride_B); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, cropping_B)); \
-  hive_dma_snd(dma_id, width_B); \
-  hive_dma_snd(dma_id, height); \
-}
-
-#define hive_dma_execute(dma_id, channel, cmd, to_addr, from_addr_value, to_is_var, from_is_var) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(cmd, channel)); \
-  hive_dma_snd(dma_id, to_addr); \
-  hive_dma_snd(dma_id, from_addr_value); \
-  hive_dma_snd(dma_id, to_is_var); \
-  if ((cmd & DMA_CLEAR_CMDBIT) == 0) { \
-	hive_dma_snd(dma_id, from_is_var); \
-  } \
-}
-
-#define hive_dma_configure_fast(dma_id, channel, connection, extension, elems_A, elems_B) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_CONFIG_CHANNEL_COMMAND, channel)); \
-  hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension)); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, 0)); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, 0)); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, 1); \
-}
-
-#define hive_dma_set_parameter(dma_id, channel, param, value) \
-{ \
-  hive_dma_snd(dma_id, _DMA_V2_SET_CHANNEL_PARAM_COMMAND | DMA_PACK_CHANNEL(channel) | DMA_PACK_PARAM(param)); \
-  hive_dma_snd(dma_id, value); \
-}
-
-#define	DMA_SPECIFIC_CMDBIT	0x01
-#define	DMA_CHECK_CMDBIT	0x02
-#define	DMA_RW_CMDBIT		0x04
-#define	DMA_CLEAR_CMDBIT	0x08
-#define	DMA_ACK_CMDBIT		0x10
-#define	DMA_CFG_CMDBIT		0x20
-#define	DMA_PARAM_CMDBIT	0x01
+#define DMA_PACK_BLOCK_CMD(cmd, ch, width_a, width_b, height)    \
+	(DMA_PACK_COMMAND(cmd) | DMA_PACK_CHANNEL(ch) |          \
+	 DMA_PACK_WIDTH_A(width_a) | DMA_PACK_WIDTH_B(width_b) | \
+	 DMA_PACK_HEIGHT(height))
+
+#define hive_dma_move_data(dma_id, read, channel, addr_a, addr_b, to_is_var,   \
+			   from_is_var)                                        \
+	{                                                                      \
+		hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+		hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(                     \
+					     read ? _DMA_V2_MOVE_B2A_COMMAND : \
+						    _DMA_V2_MOVE_A2B_COMMAND,  \
+					     channel));                        \
+		hive_dma_snd(dma_id, read ? (unsigned int)(addr_b) :           \
+					    (unsigned int)(addr_a));           \
+		hive_dma_snd(dma_id, read ? (unsigned int)(addr_a) :           \
+					    (unsigned int)(addr_b));           \
+		hive_dma_snd(dma_id, to_is_var);                               \
+		hive_dma_snd(dma_id, from_is_var);                             \
+	}
+
+#define hive_dma_move_data_no_ack(dma_id, read, channel, addr_a, addr_b,             \
+				  to_is_var, from_is_var)                            \
+	{                                                                            \
+		hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD));       \
+		hive_dma_snd(                                                        \
+			dma_id,                                                      \
+			DMA_PACK_CMD_CHANNEL(                                        \
+				read ? _DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND : \
+				       _DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND,  \
+				channel));                                           \
+		hive_dma_snd(dma_id, read ? (unsigned int)(addr_b) :                 \
+					    (unsigned int)(addr_a));                 \
+		hive_dma_snd(dma_id, read ? (unsigned int)(addr_a) :                 \
+					    (unsigned int)(addr_b));                 \
+		hive_dma_snd(dma_id, to_is_var);                                     \
+		hive_dma_snd(dma_id, from_is_var);                                   \
+	}
+
+#define hive_dma_move_b2a_data(dma_id, channel, to_addr, from_addr, to_is_var, \
+			       from_is_var)                                    \
+	{                                                                      \
+		hive_dma_move_data(dma_id, true, channel, to_addr, from_addr,  \
+				   to_is_var, from_is_var)                     \
+	}
+
+#define hive_dma_move_a2b_data(dma_id, channel, from_addr, to_addr,            \
+			       from_is_var, to_is_var)                         \
+	{                                                                      \
+		hive_dma_move_data(dma_id, false, channel, from_addr, to_addr, \
+				   from_is_var, to_is_var)                     \
+	}
+
+#define hive_dma_set_data(dma_id, channel, address, value, is_var)             \
+	{                                                                      \
+		hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+		hive_dma_snd(dma_id,                                           \
+			     DMA_PACK_CMD_CHANNEL(_DMA_V2_INIT_A_COMMAND,      \
+						  channel));                   \
+		hive_dma_snd(dma_id, value);                                   \
+		hive_dma_snd(dma_id, address);                                 \
+		hive_dma_snd(dma_id, is_var);                                  \
+	}
+
+#define hive_dma_clear_data(dma_id, channel, address, is_var) \
+	hive_dma_set_data(dma_id, channel, address, 0, is_var)
+
+#define hive_dma_configure(dma_id, channel, connection, extension, height,   \
+			   stride_A, elems_A, cropping_A, width_A, stride_B, \
+			   elems_B, cropping_B, width_B)                     \
+	{                                                                    \
+		hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(                   \
+					     _DMA_V2_CONFIG_CHANNEL_COMMAND, \
+					     channel));                      \
+		hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension)); \
+		hive_dma_snd(dma_id, stride_A);                              \
+		hive_dma_snd(dma_id,                                         \
+			     DMA_PACK_CROP_ELEMS(elems_A, cropping_A));      \
+		hive_dma_snd(dma_id, width_A);                               \
+		hive_dma_snd(dma_id, stride_B);                              \
+		hive_dma_snd(dma_id,                                         \
+			     DMA_PACK_CROP_ELEMS(elems_B, cropping_B));      \
+		hive_dma_snd(dma_id, width_B);                               \
+		hive_dma_snd(dma_id, height);                                \
+	}
+
+#define hive_dma_execute(dma_id, channel, cmd, to_addr, from_addr_value,       \
+			 to_is_var, from_is_var)                               \
+	{                                                                      \
+		hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+		hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(cmd, channel));      \
+		hive_dma_snd(dma_id, to_addr);                                 \
+		hive_dma_snd(dma_id, from_addr_value);                         \
+		hive_dma_snd(dma_id, to_is_var);                               \
+		if ((cmd & DMA_CLEAR_CMDBIT) == 0) {                           \
+			hive_dma_snd(dma_id, from_is_var);                     \
+		}                                                              \
+	}
+
+#define hive_dma_configure_fast(dma_id, channel, connection, extension,      \
+				elems_A, elems_B)                            \
+	{                                                                    \
+		hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(                   \
+					     _DMA_V2_CONFIG_CHANNEL_COMMAND, \
+					     channel));                      \
+		hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension)); \
+		hive_dma_snd(dma_id, 0);                                     \
+		hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, 0));       \
+		hive_dma_snd(dma_id, 0);                                     \
+		hive_dma_snd(dma_id, 0);                                     \
+		hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, 0));       \
+		hive_dma_snd(dma_id, 0);                                     \
+		hive_dma_snd(dma_id, 1);                                     \
+	}
+
+#define hive_dma_set_parameter(dma_id, channel, param, value)            \
+	{                                                                \
+		hive_dma_snd(dma_id, _DMA_V2_SET_CHANNEL_PARAM_COMMAND | \
+					     DMA_PACK_CHANNEL(channel) | \
+					     DMA_PACK_PARAM(param));     \
+		hive_dma_snd(dma_id, value);                             \
+	}
+
+#define DMA_SPECIFIC_CMDBIT 0x01
+#define DMA_CHECK_CMDBIT 0x02
+#define DMA_RW_CMDBIT 0x04
+#define DMA_CLEAR_CMDBIT 0x08
+#define DMA_ACK_CMDBIT 0x10
+#define DMA_CFG_CMDBIT 0x20
+#define DMA_PARAM_CMDBIT 0x01
 
 /* Write complete check not necessary if there's no ack */
-#define	DMA_NOACK_CMD		(DMA_ACK_CMDBIT | DMA_CHECK_CMDBIT)
-#define	DMA_CFG_CMD			(DMA_CFG_CMDBIT)
-#define	DMA_CFGPARAM_CMD	(DMA_CFG_CMDBIT | DMA_PARAM_CMDBIT)
+#define DMA_NOACK_CMD (DMA_ACK_CMDBIT | DMA_CHECK_CMDBIT)
+#define DMA_CFG_CMD (DMA_CFG_CMDBIT)
+#define DMA_CFGPARAM_CMD (DMA_CFG_CMDBIT | DMA_PARAM_CMDBIT)
 
 #define DMA_CMD_NEEDS_ACK(cmd) ((cmd & DMA_NOACK_CMD) == 0)
 #define DMA_CMD_IS_TRANSFER(cmd) ((cmd & DMA_CFG_CMDBIT) == 0)
@@ -191,29 +222,34 @@ typedef enum {
 #define DMA_CMD_IS_PARAMCFG(cmd) ((cmd & DMA_CFGPARAM_CMD) == DMA_CFGPARAM_CMD)
 
 /* As a matter of convention */
-#define DMA_TRANSFER_READ		DMA_TRANSFER_B2A
-#define DMA_TRANSFER_WRITE		DMA_TRANSFER_A2B
+#define DMA_TRANSFER_READ DMA_TRANSFER_B2A
+#define DMA_TRANSFER_WRITE DMA_TRANSFER_A2B
 /* store/load from the PoV of the system(memory) */
-#define DMA_TRANSFER_STORE		DMA_TRANSFER_B2A
-#define DMA_TRANSFER_LOAD		DMA_TRANSFER_A2B
-#define DMA_TRANSFER_CLEAR		DMA_TRANSFER_CLEAR_A
+#define DMA_TRANSFER_STORE DMA_TRANSFER_B2A
+#define DMA_TRANSFER_LOAD DMA_TRANSFER_A2B
+#define DMA_TRANSFER_CLEAR DMA_TRANSFER_CLEAR_A
 
 typedef enum {
-	DMA_TRANSFER_CLEAR_A = DMA_CLEAR_CMDBIT,                                       /* 8 */
-	DMA_TRANSFER_CLEAR_B = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT,                       /* 12 */
-	DMA_TRANSFER_A2B = DMA_RW_CMDBIT,                                              /* 4 */
-	DMA_TRANSFER_B2A = 0,                                                          /* 0 */
-	DMA_TRANSFER_CLEAR_A_NOACK = DMA_CLEAR_CMDBIT | DMA_NOACK_CMD,                 /* 26 */
-	DMA_TRANSFER_CLEAR_B_NOACK = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT | DMA_NOACK_CMD, /* 30 */
-	DMA_TRANSFER_A2B_NOACK = DMA_RW_CMDBIT | DMA_NOACK_CMD,                        /* 22 */
-	DMA_TRANSFER_B2A_NOACK = DMA_NOACK_CMD,                                        /* 18 */
+	DMA_TRANSFER_CLEAR_A = DMA_CLEAR_CMDBIT, /* 8 */
+	DMA_TRANSFER_CLEAR_B = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT, /* 12 */
+	DMA_TRANSFER_A2B = DMA_RW_CMDBIT, /* 4 */
+	DMA_TRANSFER_B2A = 0, /* 0 */
+	DMA_TRANSFER_CLEAR_A_NOACK = DMA_CLEAR_CMDBIT | DMA_NOACK_CMD, /* 26 */
+	DMA_TRANSFER_CLEAR_B_NOACK = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT |
+				     DMA_NOACK_CMD, /* 30 */
+	DMA_TRANSFER_A2B_NOACK = DMA_RW_CMDBIT | DMA_NOACK_CMD, /* 22 */
+	DMA_TRANSFER_B2A_NOACK = DMA_NOACK_CMD, /* 18 */
 	DMA_FASTTRANSFER_CLEAR_A = DMA_CLEAR_CMDBIT | DMA_SPECIFIC_CMDBIT,
-	DMA_FASTTRANSFER_CLEAR_B = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_CLEAR_B = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT |
+				   DMA_SPECIFIC_CMDBIT,
 	DMA_FASTTRANSFER_A2B = DMA_RW_CMDBIT | DMA_SPECIFIC_CMDBIT,
 	DMA_FASTTRANSFER_B2A = DMA_SPECIFIC_CMDBIT,
-	DMA_FASTTRANSFER_CLEAR_A_NOACK = DMA_CLEAR_CMDBIT | DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
-	DMA_FASTTRANSFER_CLEAR_B_NOACK = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT | DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
-	DMA_FASTTRANSFER_A2B_NOACK = DMA_RW_CMDBIT | DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_CLEAR_A_NOACK = DMA_CLEAR_CMDBIT | DMA_NOACK_CMD |
+					 DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_CLEAR_B_NOACK = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT |
+					 DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_A2B_NOACK = DMA_RW_CMDBIT | DMA_NOACK_CMD |
+				     DMA_SPECIFIC_CMDBIT,
 	DMA_FASTTRANSFER_B2A_NOACK = DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
 } dma_transfer_type_t;
 
@@ -229,16 +265,16 @@ typedef enum {
 } dma_config_type_t;
 
 struct dma_port_config {
-	u8  crop, elems;
+	u8 crop, elems;
 	u16 width;
 	u32 stride;
 };
 
 /* Descriptor for dma configuration */
 struct dma_channel_config {
-	u8  connection;
-	u8  extension;
-	u8  height;
+	u8 connection;
+	u8 extension;
+	u8 height;
 	struct dma_port_config a, b;
 };
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/fifo_monitor_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/fifo_monitor_global.h
index 6ac588579b9dfe3af08873759b50457066760b71..b666f4df911a99b384ef80b60f8c741511de9b91 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/fifo_monitor_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/fifo_monitor_global.h
@@ -17,8 +17,8 @@
  * Actually, "HIVE_ISP_CSS_STREAM_SWITCH_SP = 1", "HIVE_ISP_CSS_STREAM_SWITCH_ISP = 0"
  * "hive_isp_css_stream_switch_hrt.h"
  */
-#define HIVE_ISP_CSS_STREAM_SWITCH_ISP       0
-#define HIVE_ISP_CSS_STREAM_SWITCH_SP        1
-#define HIVE_ISP_CSS_STREAM_SWITCH_NONE      2
+#define HIVE_ISP_CSS_STREAM_SWITCH_ISP 0
+#define HIVE_ISP_CSS_STREAM_SWITCH_SP 1
+#define HIVE_ISP_CSS_STREAM_SWITCH_NONE 2
 
 #endif /* __FIFO_MONITOR_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/gdc_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/gdc_global.h
index 06f88305e18b9eedc81470a75986ceebfea48c89..d4e719ffe6e97f4d7b3a928c1ad358aa683e7722 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/gdc_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/gdc_global.h
@@ -15,67 +15,64 @@
 /*
  * Storage addresses for packed data transfer
  */
-#define GDC_PARAM_ICX_LEFT_ROUNDED_IDX            0
-#define GDC_PARAM_OXDIM_FLOORED_IDX               1
-#define GDC_PARAM_OXDIM_LAST_IDX                  2
-#define GDC_PARAM_WOIX_LAST_IDX                   3
-#define GDC_PARAM_IY_TOPLEFT_IDX                  4
-#define GDC_PARAM_CHUNK_CNT_IDX                   5
-/*#define GDC_PARAM_ELEMENTS_PER_XMEM_ADDR_IDX    6 */		/* Derived from bpp */
-#define GDC_PARAM_BPP_IDX                         6
-#define GDC_PARAM_BLOCK_HEIGHT_IDX                7
-/*#define GDC_PARAM_DMA_CHANNEL_STRIDE_A_IDX      8*/		/* The DMA stride == the GDC buffer stride */
-#define GDC_PARAM_WOIX_IDX                        8
-#define GDC_PARAM_DMA_CHANNEL_STRIDE_B_IDX        9
-#define GDC_PARAM_DMA_CHANNEL_WIDTH_A_IDX        10
-#define GDC_PARAM_DMA_CHANNEL_WIDTH_B_IDX        11
-#define GDC_PARAM_VECTORS_PER_LINE_IN_IDX        12
-#define GDC_PARAM_VECTORS_PER_LINE_OUT_IDX       13
-#define GDC_PARAM_VMEM_IN_DIMY_IDX               14
-#define GDC_PARAM_COMMAND_IDX                    15
-#define N_GDC_PARAM                              16
+#define GDC_PARAM_ICX_LEFT_ROUNDED_IDX 0
+#define GDC_PARAM_OXDIM_FLOORED_IDX 1
+#define GDC_PARAM_OXDIM_LAST_IDX 2
+#define GDC_PARAM_WOIX_LAST_IDX 3
+#define GDC_PARAM_IY_TOPLEFT_IDX 4
+#define GDC_PARAM_CHUNK_CNT_IDX 5
+/*#define GDC_PARAM_ELEMENTS_PER_XMEM_ADDR_IDX    6 */ /* Derived from bpp */
+#define GDC_PARAM_BPP_IDX 6
+#define GDC_PARAM_BLOCK_HEIGHT_IDX 7
+/*#define GDC_PARAM_DMA_CHANNEL_STRIDE_A_IDX      8*/ /* The DMA stride == the GDC buffer stride */
+#define GDC_PARAM_WOIX_IDX 8
+#define GDC_PARAM_DMA_CHANNEL_STRIDE_B_IDX 9
+#define GDC_PARAM_DMA_CHANNEL_WIDTH_A_IDX 10
+#define GDC_PARAM_DMA_CHANNEL_WIDTH_B_IDX 11
+#define GDC_PARAM_VECTORS_PER_LINE_IN_IDX 12
+#define GDC_PARAM_VECTORS_PER_LINE_OUT_IDX 13
+#define GDC_PARAM_VMEM_IN_DIMY_IDX 14
+#define GDC_PARAM_COMMAND_IDX 15
+#define N_GDC_PARAM 16
 
 /* Because of the packed parameter transfer max(params) == max(fragments) */
-#define	N_GDC_FRAGMENTS		N_GDC_PARAM
+#define N_GDC_FRAGMENTS N_GDC_PARAM
 
 /* The GDC is capable of higher internal precision than the parameter data structures */
-#define HRT_GDC_COORD_SCALE_BITS	6
-#define HRT_GDC_COORD_SCALE			BIT(HRT_GDC_COORD_SCALE_BITS)
+#define HRT_GDC_COORD_SCALE_BITS 6
+#define HRT_GDC_COORD_SCALE BIT(HRT_GDC_COORD_SCALE_BITS)
 
-typedef enum {
-	GDC_CH0_ID = 0,
-	N_GDC_CHANNEL_ID
-} gdc_channel_ID_t;
+typedef enum { GDC_CH0_ID = 0, N_GDC_CHANNEL_ID } gdc_channel_ID_t;
 
 typedef enum {
-	gdc_8_bpp  = 8,
+	gdc_8_bpp = 8,
 	gdc_10_bpp = 10,
 	gdc_12_bpp = 12,
 	gdc_14_bpp = 14
 } gdc_bits_per_pixel_t;
 
 typedef struct gdc_scale_param_mem_s {
-	u16  params[N_GDC_PARAM];
-	u16  ipx_start_array[N_GDC_PARAM];
-	u16  ibuf_offset[N_GDC_PARAM];
-	u16  obuf_offset[N_GDC_PARAM];
+	u16 params[N_GDC_PARAM];
+	u16 ipx_start_array[N_GDC_PARAM];
+	u16 ibuf_offset[N_GDC_PARAM];
+	u16 obuf_offset[N_GDC_PARAM];
 } gdc_scale_param_mem_t;
 
 typedef struct gdc_warp_param_mem_s {
-	u32      origin_x;
-	u32      origin_y;
-	u32      in_addr_offset;
-	u32      in_block_width;
-	u32      in_block_height;
-	u32      p0_x;
-	u32      p0_y;
-	u32      p1_x;
-	u32      p1_y;
-	u32      p2_x;
-	u32      p2_y;
-	u32      p3_x;
-	u32      p3_y;
-	u32      padding[3];
+	u32 origin_x;
+	u32 origin_y;
+	u32 in_addr_offset;
+	u32 in_block_width;
+	u32 in_block_height;
+	u32 p0_x;
+	u32 p0_y;
+	u32 p1_x;
+	u32 p1_y;
+	u32 p2_x;
+	u32 p2_y;
+	u32 p3_x;
+	u32 p3_y;
+	u32 padding[3];
 } gdc_warp_param_mem_t;
 
 #endif /* __GDC_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/gp_device_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/gp_device_global.h
index 958837a40feb6633a2276837a4ef1b45a26fa154..34b787cbb25ea5cf46bfd4fa67c3bcaf6062a4db 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/gp_device_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/gp_device_global.h
@@ -9,68 +9,68 @@
 
 #define IS_GP_DEVICE_VERSION_2
 
-#define _REG_GP_IRQ_REQ0_ADDR				0x08
-#define _REG_GP_IRQ_REQ1_ADDR				0x0C
+#define _REG_GP_IRQ_REQ0_ADDR 0x08
+#define _REG_GP_IRQ_REQ1_ADDR 0x0C
 /* The SP sends SW interrupt info to this register */
-#define _REG_GP_IRQ_REQUEST0_ADDR			_REG_GP_IRQ_REQ0_ADDR
-#define _REG_GP_IRQ_REQUEST1_ADDR			_REG_GP_IRQ_REQ1_ADDR
+#define _REG_GP_IRQ_REQUEST0_ADDR _REG_GP_IRQ_REQ0_ADDR
+#define _REG_GP_IRQ_REQUEST1_ADDR _REG_GP_IRQ_REQ1_ADDR
 
 /* The SP configures FIFO switches in these registers */
-#define _REG_GP_SWITCH_IF_ADDR						0x40
-#define _REG_GP_SWITCH_GDC1_ADDR					0x44
-#define _REG_GP_SWITCH_GDC2_ADDR					0x48
+#define _REG_GP_SWITCH_IF_ADDR 0x40
+#define _REG_GP_SWITCH_GDC1_ADDR 0x44
+#define _REG_GP_SWITCH_GDC2_ADDR 0x48
 /* @ INPUT_FORMATTER_BASE -> GP_DEVICE_BASE */
-#define _REG_GP_IFMT_input_switch_lut_reg0			0x00030800
-#define _REG_GP_IFMT_input_switch_lut_reg1			0x00030804
-#define _REG_GP_IFMT_input_switch_lut_reg2			0x00030808
-#define _REG_GP_IFMT_input_switch_lut_reg3			0x0003080C
-#define _REG_GP_IFMT_input_switch_lut_reg4			0x00030810
-#define _REG_GP_IFMT_input_switch_lut_reg5			0x00030814
-#define _REG_GP_IFMT_input_switch_lut_reg6			0x00030818
-#define _REG_GP_IFMT_input_switch_lut_reg7			0x0003081C
-#define _REG_GP_IFMT_input_switch_fsync_lut			0x00030820
-#define _REG_GP_IFMT_srst							0x00030824
-#define _REG_GP_IFMT_slv_reg_srst					0x00030828
-#define _REG_GP_IFMT_input_switch_ch_id_fmt_type	0x0003082C
+#define _REG_GP_IFMT_input_switch_lut_reg0 0x00030800
+#define _REG_GP_IFMT_input_switch_lut_reg1 0x00030804
+#define _REG_GP_IFMT_input_switch_lut_reg2 0x00030808
+#define _REG_GP_IFMT_input_switch_lut_reg3 0x0003080C
+#define _REG_GP_IFMT_input_switch_lut_reg4 0x00030810
+#define _REG_GP_IFMT_input_switch_lut_reg5 0x00030814
+#define _REG_GP_IFMT_input_switch_lut_reg6 0x00030818
+#define _REG_GP_IFMT_input_switch_lut_reg7 0x0003081C
+#define _REG_GP_IFMT_input_switch_fsync_lut 0x00030820
+#define _REG_GP_IFMT_srst 0x00030824
+#define _REG_GP_IFMT_slv_reg_srst 0x00030828
+#define _REG_GP_IFMT_input_switch_ch_id_fmt_type 0x0003082C
 
 /* @ GP_DEVICE_BASE */
-#define _REG_GP_SYNCGEN_ENABLE_ADDR					0x00090000
-#define _REG_GP_SYNCGEN_FREE_RUNNING_ADDR			0x00090004
-#define _REG_GP_SYNCGEN_PAUSE_ADDR					0x00090008
-#define _REG_GP_NR_FRAMES_ADDR						0x0009000C
-#define _REG_GP_SYNGEN_NR_PIX_ADDR					0x00090010
-#define _REG_GP_SYNGEN_NR_LINES_ADDR				0x00090014
-#define _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR			0x00090018
-#define _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR			0x0009001C
-#define _REG_GP_ISEL_SOF_ADDR						0x00090020
-#define _REG_GP_ISEL_EOF_ADDR						0x00090024
-#define _REG_GP_ISEL_SOL_ADDR						0x00090028
-#define _REG_GP_ISEL_EOL_ADDR						0x0009002C
-#define _REG_GP_ISEL_LFSR_ENABLE_ADDR				0x00090030
-#define _REG_GP_ISEL_LFSR_ENABLE_B_ADDR				0x00090034
-#define _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR			0x00090038
-#define _REG_GP_ISEL_TPG_ENABLE_ADDR				0x0009003C
-#define _REG_GP_ISEL_TPG_ENABLE_B_ADDR				0x00090040
-#define _REG_GP_ISEL_HOR_CNT_MASK_ADDR				0x00090044
-#define _REG_GP_ISEL_VER_CNT_MASK_ADDR				0x00090048
-#define _REG_GP_ISEL_XY_CNT_MASK_ADDR				0x0009004C
-#define _REG_GP_ISEL_HOR_CNT_DELTA_ADDR				0x00090050
-#define _REG_GP_ISEL_VER_CNT_DELTA_ADDR				0x00090054
-#define _REG_GP_ISEL_TPG_MODE_ADDR					0x00090058
-#define _REG_GP_ISEL_TPG_RED1_ADDR					0x0009005C
-#define _REG_GP_ISEL_TPG_GREEN1_ADDR				0x00090060
-#define _REG_GP_ISEL_TPG_BLUE1_ADDR					0x00090064
-#define _REG_GP_ISEL_TPG_RED2_ADDR					0x00090068
-#define _REG_GP_ISEL_TPG_GREEN2_ADDR				0x0009006C
-#define _REG_GP_ISEL_TPG_BLUE2_ADDR					0x00090070
-#define _REG_GP_ISEL_CH_ID_ADDR						0x00090074
-#define _REG_GP_ISEL_FMT_TYPE_ADDR					0x00090078
-#define _REG_GP_ISEL_DATA_SEL_ADDR					0x0009007C
-#define _REG_GP_ISEL_SBAND_SEL_ADDR					0x00090080
-#define _REG_GP_ISEL_SYNC_SEL_ADDR					0x00090084
-#define _REG_GP_SYNCGEN_HOR_CNT_ADDR				0x00090088
-#define _REG_GP_SYNCGEN_VER_CNT_ADDR				0x0009008C
-#define _REG_GP_SYNCGEN_FRAME_CNT_ADDR				0x00090090
-#define _REG_GP_SOFT_RESET_ADDR						0x00090094
+#define _REG_GP_SYNCGEN_ENABLE_ADDR 0x00090000
+#define _REG_GP_SYNCGEN_FREE_RUNNING_ADDR 0x00090004
+#define _REG_GP_SYNCGEN_PAUSE_ADDR 0x00090008
+#define _REG_GP_NR_FRAMES_ADDR 0x0009000C
+#define _REG_GP_SYNGEN_NR_PIX_ADDR 0x00090010
+#define _REG_GP_SYNGEN_NR_LINES_ADDR 0x00090014
+#define _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR 0x00090018
+#define _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR 0x0009001C
+#define _REG_GP_ISEL_SOF_ADDR 0x00090020
+#define _REG_GP_ISEL_EOF_ADDR 0x00090024
+#define _REG_GP_ISEL_SOL_ADDR 0x00090028
+#define _REG_GP_ISEL_EOL_ADDR 0x0009002C
+#define _REG_GP_ISEL_LFSR_ENABLE_ADDR 0x00090030
+#define _REG_GP_ISEL_LFSR_ENABLE_B_ADDR 0x00090034
+#define _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR 0x00090038
+#define _REG_GP_ISEL_TPG_ENABLE_ADDR 0x0009003C
+#define _REG_GP_ISEL_TPG_ENABLE_B_ADDR 0x00090040
+#define _REG_GP_ISEL_HOR_CNT_MASK_ADDR 0x00090044
+#define _REG_GP_ISEL_VER_CNT_MASK_ADDR 0x00090048
+#define _REG_GP_ISEL_XY_CNT_MASK_ADDR 0x0009004C
+#define _REG_GP_ISEL_HOR_CNT_DELTA_ADDR 0x00090050
+#define _REG_GP_ISEL_VER_CNT_DELTA_ADDR 0x00090054
+#define _REG_GP_ISEL_TPG_MODE_ADDR 0x00090058
+#define _REG_GP_ISEL_TPG_RED1_ADDR 0x0009005C
+#define _REG_GP_ISEL_TPG_GREEN1_ADDR 0x00090060
+#define _REG_GP_ISEL_TPG_BLUE1_ADDR 0x00090064
+#define _REG_GP_ISEL_TPG_RED2_ADDR 0x00090068
+#define _REG_GP_ISEL_TPG_GREEN2_ADDR 0x0009006C
+#define _REG_GP_ISEL_TPG_BLUE2_ADDR 0x00090070
+#define _REG_GP_ISEL_CH_ID_ADDR 0x00090074
+#define _REG_GP_ISEL_FMT_TYPE_ADDR 0x00090078
+#define _REG_GP_ISEL_DATA_SEL_ADDR 0x0009007C
+#define _REG_GP_ISEL_SBAND_SEL_ADDR 0x00090080
+#define _REG_GP_ISEL_SYNC_SEL_ADDR 0x00090084
+#define _REG_GP_SYNCGEN_HOR_CNT_ADDR 0x00090088
+#define _REG_GP_SYNCGEN_VER_CNT_ADDR 0x0009008C
+#define _REG_GP_SYNCGEN_FRAME_CNT_ADDR 0x00090090
+#define _REG_GP_SOFT_RESET_ADDR 0x00090094
 
 #endif /* __GP_DEVICE_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/gp_timer_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/gp_timer_global.h
index 1bc698530e4c9c3af5c675e8305d68588a6c3d9e..ce6ed7cfbe83549c9c514047f56ba868882451f9 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/gp_timer_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/gp_timer_global.h
@@ -10,16 +10,16 @@
 #include "hive_isp_css_defs.h" /*HIVE_GP_TIMER_SP_DMEM_ERROR_IRQ */
 
 /* from gp_timer_defs.h*/
-#define GP_TIMER_COUNT_TYPE_HIGH             0
-#define GP_TIMER_COUNT_TYPE_LOW              1
-#define GP_TIMER_COUNT_TYPE_POSEDGE          2
-#define GP_TIMER_COUNT_TYPE_NEGEDGE          3
-#define GP_TIMER_COUNT_TYPE_TYPES            4
+#define GP_TIMER_COUNT_TYPE_HIGH 0
+#define GP_TIMER_COUNT_TYPE_LOW 1
+#define GP_TIMER_COUNT_TYPE_POSEDGE 2
+#define GP_TIMER_COUNT_TYPE_NEGEDGE 3
+#define GP_TIMER_COUNT_TYPE_TYPES 4
 
 /* timer - 3 is selected */
-#define GP_TIMER_SEL                         3
+#define GP_TIMER_SEL 3
 
 /*HIVE_GP_TIMER_SP_DMEM_ERROR_IRQ is selected*/
-#define GP_TIMER_SIGNAL_SELECT  HIVE_GP_TIMER_SP_DMEM_ERROR_IRQ
+#define GP_TIMER_SIGNAL_SELECT HIVE_GP_TIMER_SP_DMEM_ERROR_IRQ
 
 #endif /* __GP_TIMER_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/gpio_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/gpio_global.h
index a756f175362d2428abc7aeca08b82dd7dba3fd24..75bf3977beb1138ad9a90f4871a1ceb87fe2da3b 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/gpio_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/gpio_global.h
@@ -9,6 +9,6 @@
 
 #include <gpio_block_defs.h>
 
-#define HIVE_GPIO_STROBE_TRIGGER_PIN		2
+#define HIVE_GPIO_STROBE_TRIGGER_PIN 2
 
 #endif /* __GPIO_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/hmem_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/hmem_global.h
index 0cbd06b50bbad5926cf0784ca3ed13d21bc1e71a..59477d5a039df4c2930e3025ebacdf6f74ba9794 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/hmem_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/hmem_global.h
@@ -21,17 +21,17 @@
 #define ISP_HIST_WIDTH                         24
 #define ISP_HIST_COMPONENTS                    4
 */
-#define ISP_HIST_ALIGNMENT_LOG2		2
+#define ISP_HIST_ALIGNMENT_LOG2 2
 
-#define HMEM_SIZE_LOG2		(ISP_HIST_ADDRESS_BITS - ISP_HIST_ALIGNMENT_LOG2)
-#define HMEM_SIZE			ISP_HIST_DEPTH
+#define HMEM_SIZE_LOG2 (ISP_HIST_ADDRESS_BITS - ISP_HIST_ALIGNMENT_LOG2)
+#define HMEM_SIZE ISP_HIST_DEPTH
 
-#define HMEM_UNIT_SIZE		(HMEM_SIZE / ISP_HIST_COMPONENTS)
-#define HMEM_UNIT_COUNT		ISP_HIST_COMPONENTS
+#define HMEM_UNIT_SIZE (HMEM_SIZE / ISP_HIST_COMPONENTS)
+#define HMEM_UNIT_COUNT ISP_HIST_COMPONENTS
 
-#define HMEM_RANGE_LOG2		ISP_HIST_WIDTH
-#define HMEM_RANGE			BIT(HMEM_RANGE_LOG2)
+#define HMEM_RANGE_LOG2 ISP_HIST_WIDTH
+#define HMEM_RANGE BIT(HMEM_RANGE_LOG2)
 
-typedef u32			hmem_data_t;
+typedef u32 hmem_data_t;
 
 #endif /* __HMEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/debug.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/debug.c
index 8513e78856b2b94220a2af01b1f45ce09897f741..839e527b3ea548f185bec5c0b97b17dc98f1edbd 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/debug.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/debug.c
@@ -18,11 +18,11 @@
 #include "assert_support.h"
 
 /* The address of the remote copy */
-hrt_address	debug_buffer_address = (hrt_address) - 1;
-ia_css_ptr	debug_buffer_ddr_address = (ia_css_ptr)-1;
+hrt_address debug_buffer_address = (hrt_address)-1;
+ia_css_ptr debug_buffer_ddr_address = (ia_css_ptr)-1;
 /* The local copy */
-static debug_data_t		debug_data;
-debug_data_t		*debug_data_ptr = &debug_data;
+static debug_data_t debug_data;
+debug_data_t *debug_data_ptr = &debug_data;
 
 void debug_buffer_init(const hrt_address addr)
 {
@@ -40,14 +40,11 @@ void debug_buffer_ddr_init(const ia_css_ptr addr)
 	u32 tail = 0;
 	/* set the ddr queue */
 	debug_buffer_ddr_address = addr;
-	hmm_store(addr + DEBUG_DATA_BUF_MODE_DDR_ADDR,
-		   &mode, sizeof(debug_buf_mode_t));
-	hmm_store(addr + DEBUG_DATA_HEAD_DDR_ADDR,
-		   &head, sizeof(uint32_t));
-	hmm_store(addr + DEBUG_DATA_TAIL_DDR_ADDR,
-		   &tail, sizeof(uint32_t));
-	hmm_store(addr + DEBUG_DATA_ENABLE_DDR_ADDR,
-		   &enable, sizeof(uint32_t));
+	hmm_store(addr + DEBUG_DATA_BUF_MODE_DDR_ADDR, &mode,
+		  sizeof(debug_buf_mode_t));
+	hmm_store(addr + DEBUG_DATA_HEAD_DDR_ADDR, &head, sizeof(uint32_t));
+	hmm_store(addr + DEBUG_DATA_TAIL_DDR_ADDR, &tail, sizeof(uint32_t));
+	hmm_store(addr + DEBUG_DATA_ENABLE_DDR_ADDR, &enable, sizeof(uint32_t));
 
 	/* set the local copy */
 	debug_data.head = 0;
@@ -58,6 +55,6 @@ void debug_buffer_setmode(const debug_buf_mode_t mode)
 {
 	assert(debug_buffer_address != ((hrt_address)-1));
 
-	sp_dmem_store_uint32(SP0_ID,
-			     debug_buffer_address + DEBUG_DATA_BUF_MODE_ADDR, mode);
+	sp_dmem_store_uint32(
+		SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_MODE_ADDR, mode);
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/debug_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/debug_private.h
index 568f9bf92ad82f97e23eef6f6596707e5a066214..26493361808748955fcf07d44638d5114345ff0a 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/debug_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/debug_private.h
@@ -25,15 +25,17 @@ STORAGE_CLASS_DEBUG_C hrt_data debug_dequeue(void)
 {
 	hrt_data value = 0;
 
-	assert(debug_buffer_address != ((hrt_address) - 1));
+	assert(debug_buffer_address != ((hrt_address)-1));
 
 	debug_synch_queue();
 
 	if (!is_debug_buffer_empty()) {
 		value = debug_data_ptr->buf[debug_data_ptr->head];
-		debug_data_ptr->head = (debug_data_ptr->head + 1) & DEBUG_BUF_MASK;
-		sp_dmem_store_uint32(SP0_ID, debug_buffer_address + DEBUG_DATA_HEAD_ADDR,
-				     debug_data_ptr->head);
+		debug_data_ptr->head = (debug_data_ptr->head + 1) &
+				       DEBUG_BUF_MASK;
+		sp_dmem_store_uint32(
+			SP0_ID, debug_buffer_address + DEBUG_DATA_HEAD_ADDR,
+			debug_data_ptr->head);
 	}
 
 	return value;
@@ -41,21 +43,25 @@ STORAGE_CLASS_DEBUG_C hrt_data debug_dequeue(void)
 
 STORAGE_CLASS_DEBUG_C void debug_synch_queue(void)
 {
-	u32 remote_tail = sp_dmem_load_uint32(SP0_ID,
-					      debug_buffer_address + DEBUG_DATA_TAIL_ADDR);
+	u32 remote_tail = sp_dmem_load_uint32(
+		SP0_ID, debug_buffer_address + DEBUG_DATA_TAIL_ADDR);
 	/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
 	if (remote_tail > debug_data_ptr->tail) {
-		size_t	delta = remote_tail - debug_data_ptr->tail;
+		size_t delta = remote_tail - debug_data_ptr->tail;
 
-		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR +
-			     debug_data_ptr->tail * sizeof(uint32_t),
-			     (void *)&debug_data_ptr->buf[debug_data_ptr->tail], delta * sizeof(uint32_t));
+		sp_dmem_load(SP0_ID,
+			     debug_buffer_address + DEBUG_DATA_BUF_ADDR +
+				     debug_data_ptr->tail * sizeof(uint32_t),
+			     (void *)&debug_data_ptr->buf[debug_data_ptr->tail],
+			     delta * sizeof(uint32_t));
 	} else if (remote_tail < debug_data_ptr->tail) {
-		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
+		size_t delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
 
-		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR +
-			     debug_data_ptr->tail * sizeof(uint32_t),
-			     (void *)&debug_data_ptr->buf[debug_data_ptr->tail], delta * sizeof(uint32_t));
+		sp_dmem_load(SP0_ID,
+			     debug_buffer_address + DEBUG_DATA_BUF_ADDR +
+				     debug_data_ptr->tail * sizeof(uint32_t),
+			     (void *)&debug_data_ptr->buf[debug_data_ptr->tail],
+			     delta * sizeof(uint32_t));
 		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR,
 			     (void *)&debug_data_ptr->buf[0],
 			     remote_tail * sizeof(uint32_t));
@@ -65,22 +71,29 @@ STORAGE_CLASS_DEBUG_C void debug_synch_queue(void)
 
 STORAGE_CLASS_DEBUG_C void debug_synch_queue_isp(void)
 {
-	u32 remote_tail = isp_dmem_load_uint32(ISP0_ID,
-					       DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_TAIL_ADDR);
+	u32 remote_tail = isp_dmem_load_uint32(
+		ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_TAIL_ADDR);
 	/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
 	if (remote_tail > debug_data_ptr->tail) {
-		size_t	delta = remote_tail - debug_data_ptr->tail;
-
-		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR +
-			      debug_data_ptr->tail * sizeof(uint32_t),
-			      (void *)&debug_data_ptr->buf[debug_data_ptr->tail], delta * sizeof(uint32_t));
+		size_t delta = remote_tail - debug_data_ptr->tail;
+
+		isp_dmem_load(
+			ISP0_ID,
+			DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR +
+				debug_data_ptr->tail * sizeof(uint32_t),
+			(void *)&debug_data_ptr->buf[debug_data_ptr->tail],
+			delta * sizeof(uint32_t));
 	} else if (remote_tail < debug_data_ptr->tail) {
-		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
-
-		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR +
-			      debug_data_ptr->tail * sizeof(uint32_t),
-			      (void *)&debug_data_ptr->buf[debug_data_ptr->tail], delta * sizeof(uint32_t));
-		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR,
+		size_t delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
+
+		isp_dmem_load(
+			ISP0_ID,
+			DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR +
+				debug_data_ptr->tail * sizeof(uint32_t),
+			(void *)&debug_data_ptr->buf[debug_data_ptr->tail],
+			delta * sizeof(uint32_t));
+		isp_dmem_load(ISP0_ID,
+			      DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR,
 			      (void *)&debug_data_ptr->buf[0],
 			      remote_tail * sizeof(uint32_t));
 	} /* else we are up to date */
@@ -89,26 +102,28 @@ STORAGE_CLASS_DEBUG_C void debug_synch_queue_isp(void)
 
 STORAGE_CLASS_DEBUG_C void debug_synch_queue_ddr(void)
 {
-	u32	remote_tail;
+	u32 remote_tail;
 
-	hmm_load(debug_buffer_ddr_address + DEBUG_DATA_TAIL_DDR_ADDR, &remote_tail,
-		  sizeof(uint32_t));
+	hmm_load(debug_buffer_ddr_address + DEBUG_DATA_TAIL_DDR_ADDR,
+		 &remote_tail, sizeof(uint32_t));
 	/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
 	if (remote_tail > debug_data_ptr->tail) {
-		size_t	delta = remote_tail - debug_data_ptr->tail;
+		size_t delta = remote_tail - debug_data_ptr->tail;
 
 		hmm_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR +
-			  debug_data_ptr->tail * sizeof(uint32_t),
-			  (void *)&debug_data_ptr->buf[debug_data_ptr->tail], delta * sizeof(uint32_t));
+				 debug_data_ptr->tail * sizeof(uint32_t),
+			 (void *)&debug_data_ptr->buf[debug_data_ptr->tail],
+			 delta * sizeof(uint32_t));
 	} else if (remote_tail < debug_data_ptr->tail) {
-		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
+		size_t delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
 
 		hmm_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR +
-			  debug_data_ptr->tail * sizeof(uint32_t),
-			  (void *)&debug_data_ptr->buf[debug_data_ptr->tail], delta * sizeof(uint32_t));
+				 debug_data_ptr->tail * sizeof(uint32_t),
+			 (void *)&debug_data_ptr->buf[debug_data_ptr->tail],
+			 delta * sizeof(uint32_t));
 		hmm_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR,
-			  (void *)&debug_data_ptr->buf[0],
-			  remote_tail * sizeof(uint32_t));
+			 (void *)&debug_data_ptr->buf[0],
+			 remote_tail * sizeof(uint32_t));
 	} /* else we are up to date */
 	debug_data_ptr->tail = remote_tail;
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma.c
index f7a8cb38d068dcb5444179e01e6d5ca44e25cecc..8172cb2775c2f32c206b7bc362b05e4853045771 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma.c
@@ -14,12 +14,12 @@
 #include "dma_private.h"
 #endif /* __INLINE_DMA__ */
 
-void
-dma_set_max_burst_size(const dma_ID_t ID, dma_connection conn,
-		       uint32_t max_burst_size)
+void dma_set_max_burst_size(const dma_ID_t ID, dma_connection conn,
+			    uint32_t max_burst_size)
 {
 	assert(ID < N_DMA_ID);
 	assert(max_burst_size > 0);
-	dma_reg_store(ID, DMA_DEV_INFO_REG_IDX(_DMA_DEV_INTERF_MAX_BURST_IDX, conn),
+	dma_reg_store(ID,
+		      DMA_DEV_INFO_REG_IDX(_DMA_DEV_INTERF_MAX_BURST_IDX, conn),
 		      max_burst_size - 1);
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma_local.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma_local.h
index 7e51dea39b1af19c8c70203e8fe6156bd41b1877..a9cce9b33ab360b89c60037a2a2bf6d81db00f0a 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma_local.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma_local.h
@@ -10,73 +10,116 @@
 #include <type_support.h>
 #include "dma_global.h"
 
-#include <bits.h>				/* _hrt_get_bits() */
-#include <hive_isp_css_defs.h>		/* HIVE_DMA_NUM_CHANNELS */
+#include <bits.h> /* _hrt_get_bits() */
+#include <hive_isp_css_defs.h> /* HIVE_DMA_NUM_CHANNELS */
 #include <dma_v2_defs.h>
 
-#define _DMA_FSM_GROUP_CMD_IDX						_DMA_V2_FSM_GROUP_CMD_IDX
-#define _DMA_FSM_GROUP_ADDR_A_IDX					_DMA_V2_FSM_GROUP_ADDR_SRC_IDX
-#define _DMA_FSM_GROUP_ADDR_B_IDX					_DMA_V2_FSM_GROUP_ADDR_DEST_IDX
+#define _DMA_FSM_GROUP_CMD_IDX _DMA_V2_FSM_GROUP_CMD_IDX
+#define _DMA_FSM_GROUP_ADDR_A_IDX _DMA_V2_FSM_GROUP_ADDR_SRC_IDX
+#define _DMA_FSM_GROUP_ADDR_B_IDX _DMA_V2_FSM_GROUP_ADDR_DEST_IDX
 
-#define _DMA_FSM_GROUP_CMD_CTRL_IDX					_DMA_V2_FSM_GROUP_CMD_CTRL_IDX
+#define _DMA_FSM_GROUP_CMD_CTRL_IDX _DMA_V2_FSM_GROUP_CMD_CTRL_IDX
 
-#define _DMA_FSM_GROUP_FSM_CTRL_IDX					_DMA_V2_FSM_GROUP_FSM_CTRL_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_STATE_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_STATE_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_REQ_XB_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_XB_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_REQ_YB_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_YB_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_IDX _DMA_V2_FSM_GROUP_FSM_CTRL_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_STATE_IDX _DMA_V2_FSM_GROUP_FSM_CTRL_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_XB_IDX _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_XB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_YB_IDX _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_YB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX \
+	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX
 
-#define _DMA_FSM_GROUP_FSM_PACK_IDX					_DMA_V2_FSM_GROUP_FSM_PACK_IDX
-#define _DMA_FSM_GROUP_FSM_PACK_STATE_IDX			_DMA_V2_FSM_GROUP_FSM_PACK_STATE_IDX
-#define _DMA_FSM_GROUP_FSM_PACK_CNT_YB_IDX			_DMA_V2_FSM_GROUP_FSM_PACK_CNT_YB_IDX
-#define _DMA_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX		_DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX
-#define _DMA_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX		_DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_IDX _DMA_V2_FSM_GROUP_FSM_PACK_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_STATE_IDX _DMA_V2_FSM_GROUP_FSM_PACK_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_CNT_YB_IDX _DMA_V2_FSM_GROUP_FSM_PACK_CNT_YB_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX \
+	_DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX \
+	_DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX
 
-#define _DMA_FSM_GROUP_FSM_REQ_IDX					_DMA_V2_FSM_GROUP_FSM_REQ_IDX
-#define _DMA_FSM_GROUP_FSM_REQ_STATE_IDX			_DMA_V2_FSM_GROUP_FSM_REQ_STATE_IDX
-#define _DMA_FSM_GROUP_FSM_REQ_CNT_YB_IDX			_DMA_V2_FSM_GROUP_FSM_REQ_CNT_YB_IDX
-#define _DMA_FSM_GROUP_FSM_REQ_CNT_XB_IDX			_DMA_V2_FSM_GROUP_FSM_REQ_CNT_XB_IDX
+#define _DMA_FSM_GROUP_FSM_REQ_IDX _DMA_V2_FSM_GROUP_FSM_REQ_IDX
+#define _DMA_FSM_GROUP_FSM_REQ_STATE_IDX _DMA_V2_FSM_GROUP_FSM_REQ_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_REQ_CNT_YB_IDX _DMA_V2_FSM_GROUP_FSM_REQ_CNT_YB_IDX
+#define _DMA_FSM_GROUP_FSM_REQ_CNT_XB_IDX _DMA_V2_FSM_GROUP_FSM_REQ_CNT_XB_IDX
 
-#define _DMA_FSM_GROUP_FSM_WR_IDX					_DMA_V2_FSM_GROUP_FSM_WR_IDX
-#define _DMA_FSM_GROUP_FSM_WR_STATE_IDX				_DMA_V2_FSM_GROUP_FSM_WR_STATE_IDX
-#define _DMA_FSM_GROUP_FSM_WR_CNT_YB_IDX			_DMA_V2_FSM_GROUP_FSM_WR_CNT_YB_IDX
-#define _DMA_FSM_GROUP_FSM_WR_CNT_XB_IDX			_DMA_V2_FSM_GROUP_FSM_WR_CNT_XB_IDX
+#define _DMA_FSM_GROUP_FSM_WR_IDX _DMA_V2_FSM_GROUP_FSM_WR_IDX
+#define _DMA_FSM_GROUP_FSM_WR_STATE_IDX _DMA_V2_FSM_GROUP_FSM_WR_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_WR_CNT_YB_IDX _DMA_V2_FSM_GROUP_FSM_WR_CNT_YB_IDX
+#define _DMA_FSM_GROUP_FSM_WR_CNT_XB_IDX _DMA_V2_FSM_GROUP_FSM_WR_CNT_XB_IDX
 
-#define _DMA_DEV_INTERF_MAX_BURST_IDX			_DMA_V2_DEV_INTERF_MAX_BURST_IDX
+#define _DMA_DEV_INTERF_MAX_BURST_IDX _DMA_V2_DEV_INTERF_MAX_BURST_IDX
 
 /*
  * Macro's to compute the DMA parameter register indices
  */
-#define DMA_SEL_COMP(comp)     (((comp)  & _hrt_ones(_DMA_V2_ADDR_SEL_COMP_BITS))            << _DMA_V2_ADDR_SEL_COMP_IDX)
-#define DMA_SEL_CH(ch)         (((ch)    & _hrt_ones(_DMA_V2_ADDR_SEL_CH_REG_BITS))          << _DMA_V2_ADDR_SEL_CH_REG_IDX)
-#define DMA_SEL_PARAM(param)   (((param) & _hrt_ones(_DMA_V2_ADDR_SEL_PARAM_BITS))           << _DMA_V2_ADDR_SEL_PARAM_IDX)
+#define DMA_SEL_COMP(comp)                              \
+	(((comp)&_hrt_ones(_DMA_V2_ADDR_SEL_COMP_BITS)) \
+	 << _DMA_V2_ADDR_SEL_COMP_IDX)
+#define DMA_SEL_CH(ch)                                  \
+	(((ch)&_hrt_ones(_DMA_V2_ADDR_SEL_CH_REG_BITS)) \
+	 << _DMA_V2_ADDR_SEL_CH_REG_IDX)
+#define DMA_SEL_PARAM(param)                              \
+	(((param)&_hrt_ones(_DMA_V2_ADDR_SEL_PARAM_BITS)) \
+	 << _DMA_V2_ADDR_SEL_PARAM_IDX)
 /* CG = Connection Group */
-#define DMA_SEL_CG_INFO(info)  (((info)  & _hrt_ones(_DMA_V2_ADDR_SEL_GROUP_COMP_INFO_BITS)) << _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_IDX)
-#define DMA_SEL_CG_COMP(comp)  (((comp)  & _hrt_ones(_DMA_V2_ADDR_SEL_GROUP_COMP_BITS))      << _DMA_V2_ADDR_SEL_GROUP_COMP_IDX)
-#define DMA_SEL_DEV_INFO(info) (((info)  & _hrt_ones(_DMA_V2_ADDR_SEL_DEV_INTERF_INFO_BITS)) << _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_IDX)
-#define DMA_SEL_DEV_ID(dev)    (((dev)   & _hrt_ones(_DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS))  << _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX)
+#define DMA_SEL_CG_INFO(info)                                      \
+	(((info)&_hrt_ones(_DMA_V2_ADDR_SEL_GROUP_COMP_INFO_BITS)) \
+	 << _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_IDX)
+#define DMA_SEL_CG_COMP(comp)                                 \
+	(((comp)&_hrt_ones(_DMA_V2_ADDR_SEL_GROUP_COMP_BITS)) \
+	 << _DMA_V2_ADDR_SEL_GROUP_COMP_IDX)
+#define DMA_SEL_DEV_INFO(info)                                     \
+	(((info)&_hrt_ones(_DMA_V2_ADDR_SEL_DEV_INTERF_INFO_BITS)) \
+	 << _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_IDX)
+#define DMA_SEL_DEV_ID(dev)                                      \
+	(((dev)&_hrt_ones(_DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS)) \
+	 << _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX)
 
-#define DMA_COMMAND_FSM_REG_IDX					(DMA_SEL_COMP(_DMA_V2_SEL_FSM_CMD) >> 2)
-#define DMA_CHANNEL_PARAM_REG_IDX(ch, param)	((DMA_SEL_COMP(_DMA_V2_SEL_CH_REG) | DMA_SEL_CH(ch) | DMA_SEL_PARAM(param)) >> 2)
-#define DMA_CG_INFO_REG_IDX(info_id, comp_id)	((DMA_SEL_COMP(_DMA_V2_SEL_CONN_GROUP) | DMA_SEL_CG_INFO(info_id) | DMA_SEL_CG_COMP(comp_id)) >> 2)
-#define DMA_DEV_INFO_REG_IDX(info_id, dev_id)	((DMA_SEL_COMP(_DMA_V2_SEL_DEV_INTERF) | DMA_SEL_DEV_INFO(info_id) | DMA_SEL_DEV_ID(dev_id)) >> 2)
-#define DMA_RST_REG_IDX							(DMA_SEL_COMP(_DMA_V2_SEL_RESET) >> 2)
+#define DMA_COMMAND_FSM_REG_IDX (DMA_SEL_COMP(_DMA_V2_SEL_FSM_CMD) >> 2)
+#define DMA_CHANNEL_PARAM_REG_IDX(ch, param)                  \
+	((DMA_SEL_COMP(_DMA_V2_SEL_CH_REG) | DMA_SEL_CH(ch) | \
+	  DMA_SEL_PARAM(param)) >>                            \
+	 2)
+#define DMA_CG_INFO_REG_IDX(info_id, comp_id)                               \
+	((DMA_SEL_COMP(_DMA_V2_SEL_CONN_GROUP) | DMA_SEL_CG_INFO(info_id) | \
+	  DMA_SEL_CG_COMP(comp_id)) >>                                      \
+	 2)
+#define DMA_DEV_INFO_REG_IDX(info_id, dev_id)                                \
+	((DMA_SEL_COMP(_DMA_V2_SEL_DEV_INTERF) | DMA_SEL_DEV_INFO(info_id) | \
+	  DMA_SEL_DEV_ID(dev_id)) >>                                         \
+	 2)
+#define DMA_RST_REG_IDX (DMA_SEL_COMP(_DMA_V2_SEL_RESET) >> 2)
 
-#define DMA_GET_CONNECTION(val)    _hrt_get_bits(val, _DMA_V2_CONNECTION_IDX,    _DMA_V2_CONNECTION_BITS)
-#define DMA_GET_EXTENSION(val)     _hrt_get_bits(val, _DMA_V2_EXTENSION_IDX,     _DMA_V2_EXTENSION_BITS)
-#define DMA_GET_ELEMENTS(val)      _hrt_get_bits(val, _DMA_V2_ELEMENTS_IDX,      _DMA_V2_ELEMENTS_BITS)
-#define DMA_GET_CROPPING(val)      _hrt_get_bits(val, _DMA_V2_LEFT_CROPPING_IDX, _DMA_V2_LEFT_CROPPING_BITS)
+#define DMA_GET_CONNECTION(val) \
+	_hrt_get_bits(val, _DMA_V2_CONNECTION_IDX, _DMA_V2_CONNECTION_BITS)
+#define DMA_GET_EXTENSION(val) \
+	_hrt_get_bits(val, _DMA_V2_EXTENSION_IDX, _DMA_V2_EXTENSION_BITS)
+#define DMA_GET_ELEMENTS(val) \
+	_hrt_get_bits(val, _DMA_V2_ELEMENTS_IDX, _DMA_V2_ELEMENTS_BITS)
+#define DMA_GET_CROPPING(val)                         \
+	_hrt_get_bits(val, _DMA_V2_LEFT_CROPPING_IDX, \
+		      _DMA_V2_LEFT_CROPPING_BITS)
 
 #endif /* __DMA_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma_private.h
index 02553f2d9375e7ff64ae5c70a9531a8e8f96ae32..adb54dd163d7942b4fdb4aeb0953add9f431312c 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/dma_private.h
@@ -13,20 +13,20 @@
 
 #include "assert_support.h"
 
-STORAGE_CLASS_DMA_C void dma_reg_store(const dma_ID_t ID,
-				       const unsigned int reg,
-				       const hrt_data value)
+STORAGE_CLASS_DMA_C void
+dma_reg_store(const dma_ID_t ID, const unsigned int reg, const hrt_data value)
 {
 	assert(ID < N_DMA_ID);
-	assert(DMA_BASE[ID] != (hrt_address) - 1);
-	ia_css_device_store_uint32(DMA_BASE[ID] + reg * sizeof(hrt_data), value);
+	assert(DMA_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(DMA_BASE[ID] + reg * sizeof(hrt_data),
+				   value);
 }
 
 STORAGE_CLASS_DMA_C hrt_data dma_reg_load(const dma_ID_t ID,
-	const unsigned int reg)
+					  const unsigned int reg)
 {
 	assert(ID < N_DMA_ID);
-	assert(DMA_BASE[ID] != (hrt_address) - 1);
+	assert(DMA_BASE[ID] != (hrt_address)-1);
 	return ia_css_device_load_uint32(DMA_BASE[ID] + reg * sizeof(hrt_data));
 }
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/event_fifo_local.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/event_fifo_local.h
index ce1916637a92069b0da9e2f915244878739cd1ed..df3e0c429ce780880e55fd9bff740ba5fc9bc986 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/event_fifo_local.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/event_fifo_local.h
@@ -20,34 +20,26 @@ typedef enum {
 	N_EVENT_ID
 } event_ID_t;
 
-#define	EVENT_QUERY_BIT		0
+#define EVENT_QUERY_BIT 0
 
 /* Events are read from FIFO */
 static const hrt_address event_source_addr[N_EVENT_ID] = {
-	0x0000000000380000ULL,
-	0x0000000000380004ULL,
-	0xffffffffffffffffULL
+	0x0000000000380000ULL, 0x0000000000380004ULL, 0xffffffffffffffffULL
 };
 
 /* Read from FIFO are blocking, query data availability */
 static const hrt_address event_source_query_addr[N_EVENT_ID] = {
-	0x0000000000380010ULL,
-	0x0000000000380014ULL,
-	0xffffffffffffffffULL
+	0x0000000000380010ULL, 0x0000000000380014ULL, 0xffffffffffffffffULL
 };
 
 /* Events are written to FIFO */
 static const hrt_address event_sink_addr[N_EVENT_ID] = {
-	0x0000000000380008ULL,
-	0x000000000038000CULL,
-	0x0000000000090104ULL
+	0x0000000000380008ULL, 0x000000000038000CULL, 0x0000000000090104ULL
 };
 
 /* Writes to FIFO are blocking, query data space */
 static const hrt_address event_sink_query_addr[N_EVENT_ID] = {
-	0x0000000000380018ULL,
-	0x000000000038001CULL,
-	0x000000000009010CULL
+	0x0000000000380018ULL, 0x000000000038001CULL, 0x000000000009010CULL
 };
 
 #endif /* _EVENT_FIFO_LOCAL_H */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/event_fifo_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/event_fifo_private.h
index 439c69444942e1c7beb598eb132907478324bb61..a0026f2cbeec016838a245ce3095d1246bf3b3c1 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/event_fifo_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/event_fifo_private.h
@@ -13,18 +13,18 @@
 
 #include "assert_support.h"
 
-#include <bits.h>			/* _hrt_get_bits() */
+#include <bits.h> /* _hrt_get_bits() */
 
 STORAGE_CLASS_EVENT_C void event_wait_for(const event_ID_t ID)
 {
 	assert(ID < N_EVENT_ID);
-	assert(event_source_addr[ID] != ((hrt_address) - 1));
+	assert(event_source_addr[ID] != ((hrt_address)-1));
 	(void)ia_css_device_load_uint32(event_source_addr[ID]);
 	return;
 }
 
 STORAGE_CLASS_EVENT_C void cnd_event_wait_for(const event_ID_t ID,
-	const bool cnd)
+					      const bool cnd)
 {
 	if (cnd) {
 		event_wait_for(ID);
@@ -34,34 +34,34 @@ STORAGE_CLASS_EVENT_C void cnd_event_wait_for(const event_ID_t ID,
 STORAGE_CLASS_EVENT_C hrt_data event_receive_token(const event_ID_t ID)
 {
 	assert(ID < N_EVENT_ID);
-	assert(event_source_addr[ID] != ((hrt_address) - 1));
+	assert(event_source_addr[ID] != ((hrt_address)-1));
 	return ia_css_device_load_uint32(event_source_addr[ID]);
 }
 
 STORAGE_CLASS_EVENT_C void event_send_token(const event_ID_t ID,
-	const hrt_data token)
+					    const hrt_data token)
 {
 	assert(ID < N_EVENT_ID);
-	assert(event_sink_addr[ID] != ((hrt_address) - 1));
+	assert(event_sink_addr[ID] != ((hrt_address)-1));
 	ia_css_device_store_uint32(event_sink_addr[ID], token);
 }
 
 STORAGE_CLASS_EVENT_C bool is_event_pending(const event_ID_t ID)
 {
-	hrt_data	value;
+	hrt_data value;
 
 	assert(ID < N_EVENT_ID);
-	assert(event_source_query_addr[ID] != ((hrt_address) - 1));
+	assert(event_source_query_addr[ID] != ((hrt_address)-1));
 	value = ia_css_device_load_uint32(event_source_query_addr[ID]);
 	return !_hrt_get_bit(value, EVENT_QUERY_BIT);
 }
 
 STORAGE_CLASS_EVENT_C bool can_event_send_token(const event_ID_t ID)
 {
-	hrt_data	value;
+	hrt_data value;
 
 	assert(ID < N_EVENT_ID);
-	assert(event_sink_query_addr[ID] != ((hrt_address) - 1));
+	assert(event_sink_query_addr[ID] != ((hrt_address)-1));
 	value = ia_css_device_load_uint32(event_sink_query_addr[ID]);
 	return !_hrt_get_bit(value, EVENT_QUERY_BIT);
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor.c
index f0de788154560d213de27e75ef5637cfcf3f7e2d..4e922291ebe59d80ce2bfbef20c9429f2045d0c2 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor.c
@@ -16,14 +16,13 @@
 #include "assert_support.h"
 
 #ifndef __INLINE_FIFO_MONITOR__
-#define STORAGE_CLASS_FIFO_MONITOR_DATA static const
+#define STORAGE_CLASS_FIFO_MONITOR_DATA (static const)
 #else
 #define STORAGE_CLASS_FIFO_MONITOR_DATA const
 #endif /* __INLINE_FIFO_MONITOR__ */
 
 STORAGE_CLASS_FIFO_MONITOR_DATA unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH] = {
-	_REG_GP_SWITCH_IF_ADDR,
-	_REG_GP_SWITCH_GDC1_ADDR,
+	_REG_GP_SWITCH_IF_ADDR, _REG_GP_SWITCH_GDC1_ADDR,
 	_REG_GP_SWITCH_GDC2_ADDR
 };
 
@@ -31,462 +30,463 @@ STORAGE_CLASS_FIFO_MONITOR_DATA unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH] = {
 #include "fifo_monitor_private.h"
 #endif /* __INLINE_FIFO_MONITOR__ */
 
-static inline bool fifo_monitor_status_valid(
-    const fifo_monitor_ID_t		ID,
-    const unsigned int			reg,
-    const unsigned int			port_id);
+static inline bool fifo_monitor_status_valid(const fifo_monitor_ID_t ID,
+					     const unsigned int reg,
+					     const unsigned int port_id);
 
-static inline bool fifo_monitor_status_accept(
-    const fifo_monitor_ID_t		ID,
-    const unsigned int			reg,
-    const unsigned int			port_id);
+static inline bool fifo_monitor_status_accept(const fifo_monitor_ID_t ID,
+					      const unsigned int reg,
+					      const unsigned int port_id);
 
-void fifo_channel_get_state(
-    const fifo_monitor_ID_t		ID,
-    const fifo_channel_t		channel_id,
-    fifo_channel_state_t		*state)
+void fifo_channel_get_state(const fifo_monitor_ID_t ID,
+			    const fifo_channel_t channel_id,
+			    fifo_channel_state_t *state)
 {
 	assert(channel_id < N_FIFO_CHANNEL);
 	assert(state);
 
 	switch (channel_id) {
 	case FIFO_CHANNEL_ISP0_TO_SP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_SP); /* ISP_STR_MON_PORT_ISP2SP */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_SP);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_ISP); /* ISP_STR_MON_PORT_SP2ISP */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_ISP);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_SP); /* ISP_STR_MON_PORT_ISP2SP */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_SP);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_ISP); /* ISP_STR_MON_PORT_SP2ISP */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_ISP);
 		break;
 	case FIFO_CHANNEL_SP0_TO_ISP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_ISP); /* ISP_STR_MON_PORT_SP2ISP */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_ISP);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_SP); /* ISP_STR_MON_PORT_ISP2SP */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_SP);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_ISP); /* ISP_STR_MON_PORT_SP2ISP */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_ISP);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_SP); /* ISP_STR_MON_PORT_ISP2SP */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_SP);
 		break;
 	case FIFO_CHANNEL_ISP0_TO_IF0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_PIF_A); /* ISP_STR_MON_PORT_ISP2PIFA */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_PIF_A);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_PIF_A); /* MOD_STR_MON_PORT_CELLS2PIFA */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_PIF_A);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_A); /* ISP_STR_MON_PORT_ISP2PIFA */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A); /* MOD_STR_MON_PORT_CELLS2PIFA */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A);
 		break;
 	case FIFO_CHANNEL_IF0_TO_ISP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_PIF_A); /* MOD_STR_MON_PORT_PIFA2CELLS */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_PIF_A);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_PIF_A); /* ISP_STR_MON_PORT_PIFA2ISP */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_PIF_A);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A); /* MOD_STR_MON_PORT_PIFA2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_A); /* ISP_STR_MON_PORT_PIFA2ISP */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_A);
 		break;
 	case FIFO_CHANNEL_ISP0_TO_IF1:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_PIF_B); /* ISP_STR_MON_PORT_ISP2PIFA */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_PIF_B);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_PIF_B); /* MOD_STR_MON_PORT_CELLS2PIFB */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_PIF_B);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_B); /* ISP_STR_MON_PORT_ISP2PIFA */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B); /* MOD_STR_MON_PORT_CELLS2PIFB */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B);
 		break;
 	case FIFO_CHANNEL_IF1_TO_ISP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_PIF_B); /* MOD_STR_MON_PORT_PIFB2CELLS */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_PIF_B);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_PIF_B); /* ISP_STR_MON_PORT_PIFB2ISP */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_PIF_B);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B); /* MOD_STR_MON_PORT_PIFB2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B); /* ISP_STR_MON_PORT_PIFB2ISP */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B);
 		break;
 	case FIFO_CHANNEL_ISP0_TO_DMA0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_DMA); /* ISP_STR_MON_PORT_ISP2DMA */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_DMA);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_DMA_FR_ISP); /* MOD_STR_MON_PORT_ISP2DMA */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_DMA_FR_ISP);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_DMA); /* ISP_STR_MON_PORT_ISP2DMA */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_DMA);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_ISP); /* MOD_STR_MON_PORT_ISP2DMA */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_ISP);
 		break;
 	case FIFO_CHANNEL_DMA0_TO_ISP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_DMA2ISP); /* MOD_STR_MON_PORT_DMA2ISP */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_DMA2ISP);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_DMA); /* ISP_STR_MON_PORT_DMA2ISP */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_DMA);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2ISP); /* MOD_STR_MON_PORT_DMA2ISP */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2ISP);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_DMA); /* ISP_STR_MON_PORT_DMA2ISP */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_DMA);
 		break;
 	case FIFO_CHANNEL_ISP0_TO_GDC0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_GDC); /* ISP_STR_MON_PORT_ISP2GDC1 */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_GDC);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_GDC); /* MOD_STR_MON_PORT_CELLS2GDC1 */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_GDC);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GDC); /* ISP_STR_MON_PORT_ISP2GDC1 */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GDC);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_GDC); /* MOD_STR_MON_PORT_CELLS2GDC1 */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_GDC);
 		break;
 	case FIFO_CHANNEL_GDC0_TO_ISP0:
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_GDC); /* MOD_STR_MON_PORT_GDC12CELLS */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_GDC);
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_GDC); /* ISP_STR_MON_PORT_GDC12ISP */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_GDC);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_GDC); /* MOD_STR_MON_PORT_GDC12CELLS */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_GDC);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GDC); /* ISP_STR_MON_PORT_GDC12ISP */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GDC);
 		break;
 	case FIFO_CHANNEL_ISP0_TO_GDC1:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_ISP2GDC2);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_ISP2GDC2);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_CELLS2GDC2);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_CELLS2GDC2);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_ISP2GDC2);
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_ISP2GDC2);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
 		break;
 	case FIFO_CHANNEL_GDC1_TO_ISP0:
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_GDC22CELLS);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_GDC22CELLS);
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_GDC22ISP);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_GDC22ISP);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_GDC22ISP);
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_GDC22ISP);
 		break;
 	case FIFO_CHANNEL_ISP0_TO_HOST0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_GPD); /* ISP_STR_MON_PORT_ISP2GPD */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_SND_GPD);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GPD); /* ISP_STR_MON_PORT_ISP2GPD */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GPD);
 		{
-			hrt_data	value = ia_css_device_load_uint32(0x0000000000380014ULL);
+			hrt_data value = ia_css_device_load_uint32(
+				0x0000000000380014ULL);
 
-			state->fifo_valid  = !_hrt_get_bit(value, 0);
+			state->fifo_valid = !_hrt_get_bit(value, 0);
 			state->sink_accept = false; /* no monitor connected */
 		}
 		break;
 	case FIFO_CHANNEL_HOST0_TO_ISP0: {
-		hrt_data	value = ia_css_device_load_uint32(0x000000000038001CULL);
+		hrt_data value =
+			ia_css_device_load_uint32(0x000000000038001CULL);
 
-		state->fifo_valid  = false; /* no monitor connected */
+		state->fifo_valid = false; /* no monitor connected */
 		state->sink_accept = !_hrt_get_bit(value, 0);
 	}
-	state->src_valid   = fifo_monitor_status_valid(ID,
-			     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_GPD); /* ISP_STR_MON_PORT_FA2ISP */
-	state->fifo_accept = fifo_monitor_status_accept(ID,
-			     HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			     ISP_STR_MON_PORT_RCV_GPD);
-	break;
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GPD); /* ISP_STR_MON_PORT_FA2ISP */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GPD);
+		break;
 	case FIFO_CHANNEL_SP0_TO_IF0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_PIF_A); /* SP_STR_MON_PORT_SP2PIFA */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_PIF_A);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_PIF_A); /* MOD_STR_MON_PORT_CELLS2PIFA */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_PIF_A);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_A); /* SP_STR_MON_PORT_SP2PIFA */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A); /* MOD_STR_MON_PORT_CELLS2PIFA */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A);
 		break;
 	case FIFO_CHANNEL_IF0_TO_SP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_PIF_A); /* MOD_STR_MON_PORT_PIFA2CELLS */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_PIF_A);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_PIF_A); /* SP_STR_MON_PORT_PIFA2SP */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_PIF_A);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A); /* MOD_STR_MON_PORT_PIFA2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_PIF_A); /* SP_STR_MON_PORT_PIFA2SP */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_PIF_A);
 		break;
 	case FIFO_CHANNEL_SP0_TO_IF1:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_PIF_B); /* SP_STR_MON_PORT_SP2PIFB */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_PIF_B);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_PIF_B); /* MOD_STR_MON_PORT_CELLS2PIFB */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_PIF_B);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_B); /* SP_STR_MON_PORT_SP2PIFB */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B); /* MOD_STR_MON_PORT_CELLS2PIFB */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B);
 		break;
 	case FIFO_CHANNEL_IF1_TO_SP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_PIF_B); /* MOD_STR_MON_PORT_PIFB2CELLS */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_PIF_B);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_PIF_B); /* SP_STR_MON_PORT_PIFB2SP */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     ISP_STR_MON_PORT_RCV_PIF_B);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B); /* MOD_STR_MON_PORT_PIFB2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B); /* SP_STR_MON_PORT_PIFB2SP */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B);
 		break;
 	case FIFO_CHANNEL_SP0_TO_IF2:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_SIF); /* SP_STR_MON_PORT_SP2SIF */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_SIF);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_SIF); /* MOD_STR_MON_PORT_SP2SIF */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_SIF);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_SIF); /* SP_STR_MON_PORT_SP2SIF */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_SIF);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_SIF); /* MOD_STR_MON_PORT_SP2SIF */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_SIF);
 		break;
 	case FIFO_CHANNEL_IF2_TO_SP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_SIF); /* MOD_STR_MON_PORT_SIF2SP */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_SIF);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_SIF); /* SP_STR_MON_PORT_SIF2SP */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_SIF);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_SIF); /* MOD_STR_MON_PORT_SIF2SP */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_SIF);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_SIF); /* SP_STR_MON_PORT_SIF2SP */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_SIF);
 		break;
 	case FIFO_CHANNEL_SP0_TO_DMA0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_DMA); /* SP_STR_MON_PORT_SP2DMA */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_DMA);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_DMA_FR_SP); /* MOD_STR_MON_PORT_SP2DMA */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_DMA_FR_SP);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_DMA); /* SP_STR_MON_PORT_SP2DMA */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_DMA);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_SP); /* MOD_STR_MON_PORT_SP2DMA */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_SP);
 		break;
 	case FIFO_CHANNEL_DMA0_TO_SP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_DMA2SP); /* MOD_STR_MON_PORT_DMA2SP */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_DMA2SP);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_DMA); /* SP_STR_MON_PORT_DMA2SP */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_DMA);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2SP); /* MOD_STR_MON_PORT_DMA2SP */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2SP);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_DMA); /* SP_STR_MON_PORT_DMA2SP */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_DMA);
 		break;
 	case FIFO_CHANNEL_SP0_TO_GDC0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
-				     SP_STR_MON_PORT_B_SP2GDC1);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
-				     SP_STR_MON_PORT_B_SP2GDC1);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_CELLS2GDC1);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_CELLS2GDC1);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC1);
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC1);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC1);
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC1);
 		break;
 	case FIFO_CHANNEL_GDC0_TO_SP0:
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_GDC12CELLS);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_GDC12CELLS);
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
-				     SP_STR_MON_PORT_B_GDC12SP);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
-				     SP_STR_MON_PORT_B_GDC12SP);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC12CELLS);
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC12CELLS);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC12SP);
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC12SP);
 		break;
 	case FIFO_CHANNEL_SP0_TO_GDC1:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
-				     SP_STR_MON_PORT_B_SP2GDC2);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
-				     SP_STR_MON_PORT_B_SP2GDC2);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_CELLS2GDC2);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_CELLS2GDC2);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC2);
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC2);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
 		break;
 	case FIFO_CHANNEL_GDC1_TO_SP0:
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_GDC22CELLS);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_GDC22CELLS);
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
-				     SP_STR_MON_PORT_B_GDC22SP);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
-				     SP_STR_MON_PORT_B_GDC22SP);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC22SP);
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC22SP);
 		break;
 	case FIFO_CHANNEL_SP0_TO_HOST0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_GPD); /* SP_STR_MON_PORT_SP2GPD */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_GPD);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_GPD); /* SP_STR_MON_PORT_SP2GPD */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_GPD);
 		{
-			hrt_data	value = ia_css_device_load_uint32(0x0000000000380010ULL);
+			hrt_data value = ia_css_device_load_uint32(
+				0x0000000000380010ULL);
 
-			state->fifo_valid  = !_hrt_get_bit(value, 0);
+			state->fifo_valid = !_hrt_get_bit(value, 0);
 			state->sink_accept = false; /* no monitor connected */
 		}
 		break;
 	case FIFO_CHANNEL_HOST0_TO_SP0: {
-		hrt_data	value = ia_css_device_load_uint32(0x0000000000380018ULL);
+		hrt_data value =
+			ia_css_device_load_uint32(0x0000000000380018ULL);
 
-		state->fifo_valid  = false; /* no monitor connected */
+		state->fifo_valid = false; /* no monitor connected */
 		state->sink_accept = !_hrt_get_bit(value, 0);
 	}
-	state->src_valid   = fifo_monitor_status_valid(ID,
-			     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_GPD); /* SP_STR_MON_PORT_FA2SP */
-	state->fifo_accept = fifo_monitor_status_accept(ID,
-			     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			     SP_STR_MON_PORT_RCV_GPD);
-	break;
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_GPD); /* SP_STR_MON_PORT_FA2SP */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_GPD);
+		break;
 	case FIFO_CHANNEL_SP0_TO_STREAM2MEM0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_MC); /* SP_STR_MON_PORT_SP2MC */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SND_MC);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_MC); /* MOD_STR_MON_PORT_SP2MC */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_RCV_MC);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_MC); /* SP_STR_MON_PORT_SP2MC */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_MC);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_MC); /* MOD_STR_MON_PORT_SP2MC */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_MC);
 		break;
 	case FIFO_CHANNEL_STREAM2MEM0_TO_SP0:
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_MC); /* SP_STR_MON_PORT_MC2SP */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-				     MOD_STR_MON_PORT_SND_MC);
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_MC); /* MOD_STR_MON_PORT_MC2SP */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_RCV_MC);
+		state->fifo_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_MC); /* SP_STR_MON_PORT_MC2SP */
+		state->sink_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_MC);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_MC); /* MOD_STR_MON_PORT_MC2SP */
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_MC);
 		break;
 	case FIFO_CHANNEL_SP0_TO_INPUT_SYSTEM0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SP2ISYS);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_SP2ISYS);
-		state->fifo_valid  = false;
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SP2ISYS);
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SP2ISYS);
+		state->fifo_valid = false;
 		state->sink_accept = false;
 		break;
 	case FIFO_CHANNEL_INPUT_SYSTEM0_TO_SP0:
-		state->fifo_valid  = false;
+		state->fifo_valid = false;
 		state->sink_accept = false;
-		state->src_valid   = fifo_monitor_status_valid(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_ISYS2SP);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-				     HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-				     SP_STR_MON_PORT_ISYS2SP);
+		state->src_valid = fifo_monitor_status_valid(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_ISYS2SP);
+		state->fifo_accept = fifo_monitor_status_accept(
+			ID, HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_ISYS2SP);
 		break;
 	default:
 		assert(0);
@@ -496,12 +496,11 @@ void fifo_channel_get_state(
 	return;
 }
 
-void fifo_switch_get_state(
-    const fifo_monitor_ID_t		ID,
-    const fifo_switch_t			switch_id,
-    fifo_switch_state_t			*state)
+void fifo_switch_get_state(const fifo_monitor_ID_t ID,
+			   const fifo_switch_t switch_id,
+			   fifo_switch_state_t *state)
 {
-	hrt_data		data = (hrt_data)-1;
+	hrt_data data = (hrt_data)-1;
 
 	assert(ID == FIFO_MONITOR0_ID);
 	assert(switch_id < N_FIFO_SWITCH);
@@ -518,44 +517,39 @@ void fifo_switch_get_state(
 	return;
 }
 
-void fifo_monitor_get_state(
-    const fifo_monitor_ID_t		ID,
-    fifo_monitor_state_t		*state)
+void fifo_monitor_get_state(const fifo_monitor_ID_t ID,
+			    fifo_monitor_state_t *state)
 {
-	fifo_channel_t	ch_id;
-	fifo_switch_t	sw_id;
+	fifo_channel_t ch_id;
+	fifo_switch_t sw_id;
 
 	assert(ID < N_FIFO_MONITOR_ID);
 	assert(state);
 
 	for (ch_id = 0; ch_id < N_FIFO_CHANNEL; ch_id++) {
-		fifo_channel_get_state(ID, ch_id,
-				       &state->fifo_channels[ch_id]);
+		fifo_channel_get_state(ID, ch_id, &state->fifo_channels[ch_id]);
 	}
 
 	for (sw_id = 0; sw_id < N_FIFO_SWITCH; sw_id++) {
-		fifo_switch_get_state(ID, sw_id,
-				      &state->fifo_switches[sw_id]);
+		fifo_switch_get_state(ID, sw_id, &state->fifo_switches[sw_id]);
 	}
 	return;
 }
 
-static inline bool fifo_monitor_status_valid(
-    const fifo_monitor_ID_t		ID,
-    const unsigned int			reg,
-    const unsigned int			port_id)
+static inline bool fifo_monitor_status_valid(const fifo_monitor_ID_t ID,
+					     const unsigned int reg,
+					     const unsigned int port_id)
 {
-	hrt_data	data = fifo_monitor_reg_load(ID, reg);
+	hrt_data data = fifo_monitor_reg_load(ID, reg);
 
 	return (data >> (((port_id * 2) + _hive_str_mon_valid_offset))) & 0x1;
 }
 
-static inline bool fifo_monitor_status_accept(
-    const fifo_monitor_ID_t		ID,
-    const unsigned int			reg,
-    const unsigned int			port_id)
+static inline bool fifo_monitor_status_accept(const fifo_monitor_ID_t ID,
+					      const unsigned int reg,
+					      const unsigned int port_id)
 {
-	hrt_data	data = fifo_monitor_reg_load(ID, reg);
+	hrt_data data = fifo_monitor_reg_load(ID, reg);
 
 	return (data >> (((port_id * 2) + _hive_str_mon_accept_offset))) & 0x1;
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor_local.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor_local.h
index e02ccaee34abbeead06e18f30c30649f32e19376..a8225267526573e764ce269a42a08aefdb018d7a 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor_local.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor_local.h
@@ -10,15 +10,15 @@
 #include <type_support.h>
 #include "fifo_monitor_global.h"
 
-#include "hive_isp_css_defs.h"	/* ISP_STR_MON_PORT_SND_SP, ... */
+#include "hive_isp_css_defs.h" /* ISP_STR_MON_PORT_SND_SP, ... */
 
-#define _hive_str_mon_valid_offset   0
-#define _hive_str_mon_accept_offset  1
+#define _hive_str_mon_valid_offset 0
+#define _hive_str_mon_accept_offset 1
 
-#define	FIFO_CHANNEL_SP_VALID_MASK		0x55555555
-#define	FIFO_CHANNEL_SP_VALID_B_MASK	0x00000055
-#define	FIFO_CHANNEL_ISP_VALID_MASK		0x15555555
-#define	FIFO_CHANNEL_MOD_VALID_MASK		0x55555555
+#define FIFO_CHANNEL_SP_VALID_MASK 0x55555555
+#define FIFO_CHANNEL_SP_VALID_B_MASK 0x00000055
+#define FIFO_CHANNEL_ISP_VALID_MASK 0x15555555
+#define FIFO_CHANNEL_MOD_VALID_MASK 0x55555555
 
 typedef enum fifo_switch {
 	FIFO_SWITCH_IF,
@@ -70,22 +70,22 @@ typedef enum fifo_channel {
 } fifo_channel_t;
 
 struct fifo_channel_state_s {
-	bool	src_valid;
-	bool	fifo_accept;
-	bool	fifo_valid;
-	bool	sink_accept;
+	bool src_valid;
+	bool fifo_accept;
+	bool fifo_valid;
+	bool sink_accept;
 };
 
 /* The switch is tri-state */
 struct fifo_switch_state_s {
-	bool	is_none;
-	bool	is_isp;
-	bool	is_sp;
+	bool is_none;
+	bool is_isp;
+	bool is_sp;
 };
 
 struct fifo_monitor_state_s {
-	struct fifo_channel_state_s	fifo_channels[N_FIFO_CHANNEL];
-	struct fifo_switch_state_s	fifo_switches[N_FIFO_SWITCH];
+	struct fifo_channel_state_s fifo_channels[N_FIFO_CHANNEL];
+	struct fifo_switch_state_s fifo_switches[N_FIFO_SWITCH];
 };
 
 #endif /* __FIFO_MONITOR_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor_private.h
index 53a3fb796aabfa1c17d2ed8ca4ec86768f9c4992..ffcbb1ad076d10248d10df8b973e8a8885cac3d3 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/fifo_monitor_private.h
@@ -20,13 +20,12 @@
 extern const unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH];
 #endif
 
-STORAGE_CLASS_FIFO_MONITOR_C void fifo_switch_set(
-    const fifo_monitor_ID_t		ID,
-    const fifo_switch_t			switch_id,
-    const hrt_data				sel)
+STORAGE_CLASS_FIFO_MONITOR_C void fifo_switch_set(const fifo_monitor_ID_t ID,
+						  const fifo_switch_t switch_id,
+						  const hrt_data sel)
 {
 	assert(ID == FIFO_MONITOR0_ID);
-	assert(FIFO_MONITOR_BASE[ID] != (hrt_address) - 1);
+	assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
 	assert(switch_id < N_FIFO_SWITCH);
 	(void)ID;
 
@@ -35,38 +34,35 @@ STORAGE_CLASS_FIFO_MONITOR_C void fifo_switch_set(
 	return;
 }
 
-STORAGE_CLASS_FIFO_MONITOR_C hrt_data fifo_switch_get(
-    const fifo_monitor_ID_t		ID,
-    const fifo_switch_t			switch_id)
+STORAGE_CLASS_FIFO_MONITOR_C hrt_data
+fifo_switch_get(const fifo_monitor_ID_t ID, const fifo_switch_t switch_id)
 {
 	assert(ID == FIFO_MONITOR0_ID);
-	assert(FIFO_MONITOR_BASE[ID] != (hrt_address) - 1);
+	assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
 	assert(switch_id < N_FIFO_SWITCH);
 	(void)ID;
 
 	return gp_device_reg_load(GP_DEVICE0_ID, FIFO_SWITCH_ADDR[switch_id]);
 }
 
-STORAGE_CLASS_FIFO_MONITOR_C void fifo_monitor_reg_store(
-    const fifo_monitor_ID_t		ID,
-    const unsigned int			reg,
-    const hrt_data				value)
+STORAGE_CLASS_FIFO_MONITOR_C void
+fifo_monitor_reg_store(const fifo_monitor_ID_t ID, const unsigned int reg,
+		       const hrt_data value)
 {
 	assert(ID < N_FIFO_MONITOR_ID);
-	assert(FIFO_MONITOR_BASE[ID] != (hrt_address) - 1);
-	ia_css_device_store_uint32(FIFO_MONITOR_BASE[ID] + reg * sizeof(hrt_data),
-				   value);
+	assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(
+		FIFO_MONITOR_BASE[ID] + reg * sizeof(hrt_data), value);
 	return;
 }
 
-STORAGE_CLASS_FIFO_MONITOR_C hrt_data fifo_monitor_reg_load(
-    const fifo_monitor_ID_t		ID,
-    const unsigned int			reg)
+STORAGE_CLASS_FIFO_MONITOR_C hrt_data
+fifo_monitor_reg_load(const fifo_monitor_ID_t ID, const unsigned int reg)
 {
 	assert(ID < N_FIFO_MONITOR_ID);
-	assert(FIFO_MONITOR_BASE[ID] != (hrt_address) - 1);
-	return ia_css_device_load_uint32(FIFO_MONITOR_BASE[ID] + reg * sizeof(
-					     hrt_data));
+	assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
+	return ia_css_device_load_uint32(FIFO_MONITOR_BASE[ID] +
+					 reg * sizeof(hrt_data));
 }
 
 #endif /* __FIFO_MONITOR_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gdc.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gdc.c
index 8bb78b4d7c677fe8b8d4f111e50bfa355d7ba75f..3ce3c93772b7dc614a18682114ba716b9c5c2811 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gdc.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gdc.c
@@ -14,10 +14,8 @@
 /*
  * Local function declarations
  */
-static inline void gdc_reg_store(
-    const gdc_ID_t		ID,
-    const unsigned int	reg,
-    const hrt_data		value);
+static inline void gdc_reg_store(const gdc_ID_t ID, const unsigned int reg,
+				 const hrt_data value);
 
 #ifndef __INLINE_GDC__
 #include "gdc_private.h"
@@ -26,9 +24,7 @@ static inline void gdc_reg_store(
 /*
  * Exported function implementations
  */
-void gdc_lut_store(
-    const gdc_ID_t		ID,
-    const int			data[4][HRT_GDC_N])
+void gdc_lut_store(const gdc_ID_t ID, const int data[4][HRT_GDC_N])
 {
 	unsigned int i, lut_offset = HRT_GDC_LUT_IDX;
 
@@ -36,15 +32,15 @@ void gdc_lut_store(
 	assert(HRT_GDC_LUT_COEFF_OFFSET <= (4 * sizeof(hrt_data)));
 
 	for (i = 0; i < HRT_GDC_N; i++) {
-		hrt_data	entry_0 = data[0][i] & HRT_GDC_BCI_COEF_MASK;
-		hrt_data	entry_1 = data[1][i] & HRT_GDC_BCI_COEF_MASK;
-		hrt_data	entry_2 = data[2][i] & HRT_GDC_BCI_COEF_MASK;
-		hrt_data	entry_3 = data[3][i] & HRT_GDC_BCI_COEF_MASK;
+		hrt_data entry_0 = data[0][i] & HRT_GDC_BCI_COEF_MASK;
+		hrt_data entry_1 = data[1][i] & HRT_GDC_BCI_COEF_MASK;
+		hrt_data entry_2 = data[2][i] & HRT_GDC_BCI_COEF_MASK;
+		hrt_data entry_3 = data[3][i] & HRT_GDC_BCI_COEF_MASK;
 
-		hrt_data	word_0 = entry_0 |
-				     (entry_1 << HRT_GDC_LUT_COEFF_OFFSET);
-		hrt_data	word_1 = entry_2 |
-				     (entry_3 << HRT_GDC_LUT_COEFF_OFFSET);
+		hrt_data word_0 = entry_0 |
+				  (entry_1 << HRT_GDC_LUT_COEFF_OFFSET);
+		hrt_data word_1 = entry_2 |
+				  (entry_3 << HRT_GDC_LUT_COEFF_OFFSET);
 
 		gdc_reg_store(ID, lut_offset++, word_0);
 		gdc_reg_store(ID, lut_offset++, word_1);
@@ -85,8 +81,7 @@ void gdc_lut_convert_to_isp_format(const int in_lut[4][HRT_GDC_N],
 	}
 }
 
-int gdc_get_unity(
-    const gdc_ID_t		ID)
+int gdc_get_unity(const gdc_ID_t ID)
 {
 	assert(ID < N_GDC_ID);
 	(void)ID;
@@ -96,11 +91,10 @@ int gdc_get_unity(
 /*
  * Local function implementations
  */
-static inline void gdc_reg_store(
-    const gdc_ID_t		ID,
-    const unsigned int	reg,
-    const hrt_data		value)
+static inline void gdc_reg_store(const gdc_ID_t ID, const unsigned int reg,
+				 const hrt_data value)
 {
-	ia_css_device_store_uint32(GDC_BASE[ID] + reg * sizeof(hrt_data), value);
+	ia_css_device_store_uint32(GDC_BASE[ID] + reg * sizeof(hrt_data),
+				   value);
 	return;
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device.c
index b934d20c88ea278458a2bd4d84a96ecbad2e5404..e1b84b112ea8d44bdd6a8aa5621c82724fa98128 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device.c
@@ -11,90 +11,81 @@
 #include "gp_device_private.h"
 #endif /* __INLINE_GP_DEVICE__ */
 
-void gp_device_get_state(
-    const gp_device_ID_t		ID,
-    gp_device_state_t			*state)
+void gp_device_get_state(const gp_device_ID_t ID, gp_device_state_t *state)
 {
 	assert(ID < N_GP_DEVICE_ID);
 	assert(state);
 
-	state->syncgen_enable = gp_device_reg_load(ID,
-				_REG_GP_SYNCGEN_ENABLE_ADDR);
-	state->syncgen_free_running = gp_device_reg_load(ID,
-				      _REG_GP_SYNCGEN_FREE_RUNNING_ADDR);
-	state->syncgen_pause = gp_device_reg_load(ID,
-			       _REG_GP_SYNCGEN_PAUSE_ADDR);
-	state->nr_frames = gp_device_reg_load(ID,
-					      _REG_GP_NR_FRAMES_ADDR);
-	state->syngen_nr_pix = gp_device_reg_load(ID,
-			       _REG_GP_SYNGEN_NR_PIX_ADDR);
-	state->syngen_nr_pix = gp_device_reg_load(ID,
-			       _REG_GP_SYNGEN_NR_PIX_ADDR);
-	state->syngen_nr_lines = gp_device_reg_load(ID,
-				 _REG_GP_SYNGEN_NR_LINES_ADDR);
-	state->syngen_hblank_cycles = gp_device_reg_load(ID,
-				      _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR);
-	state->syngen_vblank_cycles = gp_device_reg_load(ID,
-				      _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR);
-	state->isel_sof = gp_device_reg_load(ID,
-					     _REG_GP_ISEL_SOF_ADDR);
-	state->isel_eof = gp_device_reg_load(ID,
-					     _REG_GP_ISEL_EOF_ADDR);
-	state->isel_sol = gp_device_reg_load(ID,
-					     _REG_GP_ISEL_SOL_ADDR);
-	state->isel_eol = gp_device_reg_load(ID,
-					     _REG_GP_ISEL_EOL_ADDR);
-	state->isel_lfsr_enable = gp_device_reg_load(ID,
-				  _REG_GP_ISEL_LFSR_ENABLE_ADDR);
-	state->isel_lfsr_enable_b = gp_device_reg_load(ID,
-				    _REG_GP_ISEL_LFSR_ENABLE_B_ADDR);
-	state->isel_lfsr_reset_value = gp_device_reg_load(ID,
-				       _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR);
-	state->isel_tpg_enable = gp_device_reg_load(ID,
-				 _REG_GP_ISEL_TPG_ENABLE_ADDR);
-	state->isel_tpg_enable_b = gp_device_reg_load(ID,
-				   _REG_GP_ISEL_TPG_ENABLE_B_ADDR);
-	state->isel_hor_cnt_mask = gp_device_reg_load(ID,
-				   _REG_GP_ISEL_HOR_CNT_MASK_ADDR);
-	state->isel_ver_cnt_mask = gp_device_reg_load(ID,
-				   _REG_GP_ISEL_VER_CNT_MASK_ADDR);
-	state->isel_xy_cnt_mask = gp_device_reg_load(ID,
-				  _REG_GP_ISEL_XY_CNT_MASK_ADDR);
-	state->isel_hor_cnt_delta = gp_device_reg_load(ID,
-				    _REG_GP_ISEL_HOR_CNT_DELTA_ADDR);
-	state->isel_ver_cnt_delta = gp_device_reg_load(ID,
-				    _REG_GP_ISEL_VER_CNT_DELTA_ADDR);
-	state->isel_tpg_mode = gp_device_reg_load(ID,
-			       _REG_GP_ISEL_TPG_MODE_ADDR);
-	state->isel_tpg_red1 = gp_device_reg_load(ID,
-			       _REG_GP_ISEL_TPG_RED1_ADDR);
-	state->isel_tpg_green1 = gp_device_reg_load(ID,
-				 _REG_GP_ISEL_TPG_GREEN1_ADDR);
-	state->isel_tpg_blue1 = gp_device_reg_load(ID,
-				_REG_GP_ISEL_TPG_BLUE1_ADDR);
-	state->isel_tpg_red2 = gp_device_reg_load(ID,
-			       _REG_GP_ISEL_TPG_RED2_ADDR);
-	state->isel_tpg_green2 = gp_device_reg_load(ID,
-				 _REG_GP_ISEL_TPG_GREEN2_ADDR);
-	state->isel_tpg_blue2 = gp_device_reg_load(ID,
-				_REG_GP_ISEL_TPG_BLUE2_ADDR);
-	state->isel_ch_id = gp_device_reg_load(ID,
-					       _REG_GP_ISEL_CH_ID_ADDR);
-	state->isel_fmt_type = gp_device_reg_load(ID,
-			       _REG_GP_ISEL_FMT_TYPE_ADDR);
-	state->isel_data_sel = gp_device_reg_load(ID,
-			       _REG_GP_ISEL_DATA_SEL_ADDR);
-	state->isel_sband_sel = gp_device_reg_load(ID,
-				_REG_GP_ISEL_SBAND_SEL_ADDR);
-	state->isel_sync_sel = gp_device_reg_load(ID,
-			       _REG_GP_ISEL_SYNC_SEL_ADDR);
-	state->syncgen_hor_cnt = gp_device_reg_load(ID,
-				 _REG_GP_SYNCGEN_HOR_CNT_ADDR);
-	state->syncgen_ver_cnt = gp_device_reg_load(ID,
-				 _REG_GP_SYNCGEN_VER_CNT_ADDR);
-	state->syncgen_frame_cnt = gp_device_reg_load(ID,
-				   _REG_GP_SYNCGEN_FRAME_CNT_ADDR);
-	state->soft_reset = gp_device_reg_load(ID,
-					       _REG_GP_SOFT_RESET_ADDR);
+	state->syncgen_enable =
+		gp_device_reg_load(ID, _REG_GP_SYNCGEN_ENABLE_ADDR);
+	state->syncgen_free_running =
+		gp_device_reg_load(ID, _REG_GP_SYNCGEN_FREE_RUNNING_ADDR);
+	state->syncgen_pause =
+		gp_device_reg_load(ID, _REG_GP_SYNCGEN_PAUSE_ADDR);
+	state->nr_frames = gp_device_reg_load(ID, _REG_GP_NR_FRAMES_ADDR);
+	state->syngen_nr_pix =
+		gp_device_reg_load(ID, _REG_GP_SYNGEN_NR_PIX_ADDR);
+	state->syngen_nr_pix =
+		gp_device_reg_load(ID, _REG_GP_SYNGEN_NR_PIX_ADDR);
+	state->syngen_nr_lines =
+		gp_device_reg_load(ID, _REG_GP_SYNGEN_NR_LINES_ADDR);
+	state->syngen_hblank_cycles =
+		gp_device_reg_load(ID, _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR);
+	state->syngen_vblank_cycles =
+		gp_device_reg_load(ID, _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR);
+	state->isel_sof = gp_device_reg_load(ID, _REG_GP_ISEL_SOF_ADDR);
+	state->isel_eof = gp_device_reg_load(ID, _REG_GP_ISEL_EOF_ADDR);
+	state->isel_sol = gp_device_reg_load(ID, _REG_GP_ISEL_SOL_ADDR);
+	state->isel_eol = gp_device_reg_load(ID, _REG_GP_ISEL_EOL_ADDR);
+	state->isel_lfsr_enable =
+		gp_device_reg_load(ID, _REG_GP_ISEL_LFSR_ENABLE_ADDR);
+	state->isel_lfsr_enable_b =
+		gp_device_reg_load(ID, _REG_GP_ISEL_LFSR_ENABLE_B_ADDR);
+	state->isel_lfsr_reset_value =
+		gp_device_reg_load(ID, _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR);
+	state->isel_tpg_enable =
+		gp_device_reg_load(ID, _REG_GP_ISEL_TPG_ENABLE_ADDR);
+	state->isel_tpg_enable_b =
+		gp_device_reg_load(ID, _REG_GP_ISEL_TPG_ENABLE_B_ADDR);
+	state->isel_hor_cnt_mask =
+		gp_device_reg_load(ID, _REG_GP_ISEL_HOR_CNT_MASK_ADDR);
+	state->isel_ver_cnt_mask =
+		gp_device_reg_load(ID, _REG_GP_ISEL_VER_CNT_MASK_ADDR);
+	state->isel_xy_cnt_mask =
+		gp_device_reg_load(ID, _REG_GP_ISEL_XY_CNT_MASK_ADDR);
+	state->isel_hor_cnt_delta =
+		gp_device_reg_load(ID, _REG_GP_ISEL_HOR_CNT_DELTA_ADDR);
+	state->isel_ver_cnt_delta =
+		gp_device_reg_load(ID, _REG_GP_ISEL_VER_CNT_DELTA_ADDR);
+	state->isel_tpg_mode =
+		gp_device_reg_load(ID, _REG_GP_ISEL_TPG_MODE_ADDR);
+	state->isel_tpg_red1 =
+		gp_device_reg_load(ID, _REG_GP_ISEL_TPG_RED1_ADDR);
+	state->isel_tpg_green1 =
+		gp_device_reg_load(ID, _REG_GP_ISEL_TPG_GREEN1_ADDR);
+	state->isel_tpg_blue1 =
+		gp_device_reg_load(ID, _REG_GP_ISEL_TPG_BLUE1_ADDR);
+	state->isel_tpg_red2 =
+		gp_device_reg_load(ID, _REG_GP_ISEL_TPG_RED2_ADDR);
+	state->isel_tpg_green2 =
+		gp_device_reg_load(ID, _REG_GP_ISEL_TPG_GREEN2_ADDR);
+	state->isel_tpg_blue2 =
+		gp_device_reg_load(ID, _REG_GP_ISEL_TPG_BLUE2_ADDR);
+	state->isel_ch_id = gp_device_reg_load(ID, _REG_GP_ISEL_CH_ID_ADDR);
+	state->isel_fmt_type =
+		gp_device_reg_load(ID, _REG_GP_ISEL_FMT_TYPE_ADDR);
+	state->isel_data_sel =
+		gp_device_reg_load(ID, _REG_GP_ISEL_DATA_SEL_ADDR);
+	state->isel_sband_sel =
+		gp_device_reg_load(ID, _REG_GP_ISEL_SBAND_SEL_ADDR);
+	state->isel_sync_sel =
+		gp_device_reg_load(ID, _REG_GP_ISEL_SYNC_SEL_ADDR);
+	state->syncgen_hor_cnt =
+		gp_device_reg_load(ID, _REG_GP_SYNCGEN_HOR_CNT_ADDR);
+	state->syncgen_ver_cnt =
+		gp_device_reg_load(ID, _REG_GP_SYNCGEN_VER_CNT_ADDR);
+	state->syncgen_frame_cnt =
+		gp_device_reg_load(ID, _REG_GP_SYNCGEN_FRAME_CNT_ADDR);
+	state->soft_reset = gp_device_reg_load(ID, _REG_GP_SOFT_RESET_ADDR);
 	return;
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device_local.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device_local.h
index 2fcb95cf1b958fda876f47fd4005d7a174fdf9bc..891cd4f6b44d8a286ea5c337eb4d7bd367aafc3e 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device_local.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device_local.h
@@ -10,29 +10,29 @@
 #include "gp_device_global.h"
 
 /* @ GP_REGS_BASE -> GP_DEVICE_BASE */
-#define _REG_GP_SDRAM_WAKEUP_ADDR					0x00
-#define _REG_GP_IDLE_ADDR							0x04
+#define _REG_GP_SDRAM_WAKEUP_ADDR 0x00
+#define _REG_GP_IDLE_ADDR 0x04
 /* #define _REG_GP_IRQ_REQ0_ADDR					0x08 */
 /* #define _REG_GP_IRQ_REQ1_ADDR					0x0C */
-#define _REG_GP_SP_STREAM_STAT_ADDR					0x10
-#define _REG_GP_SP_STREAM_STAT_B_ADDR				0x14
-#define _REG_GP_ISP_STREAM_STAT_ADDR				0x18
-#define _REG_GP_MOD_STREAM_STAT_ADDR				0x1C
-#define _REG_GP_SP_STREAM_STAT_IRQ_COND_ADDR		0x20
-#define _REG_GP_SP_STREAM_STAT_B_IRQ_COND_ADDR		0x24
-#define _REG_GP_ISP_STREAM_STAT_IRQ_COND_ADDR		0x28
-#define _REG_GP_MOD_STREAM_STAT_IRQ_COND_ADDR		0x2C
-#define _REG_GP_SP_STREAM_STAT_IRQ_ENABLE_ADDR		0x30
-#define _REG_GP_SP_STREAM_STAT_B_IRQ_ENABLE_ADDR	0x34
-#define _REG_GP_ISP_STREAM_STAT_IRQ_ENABLE_ADDR		0x38
-#define _REG_GP_MOD_STREAM_STAT_IRQ_ENABLE_ADDR		0x3C
+#define _REG_GP_SP_STREAM_STAT_ADDR 0x10
+#define _REG_GP_SP_STREAM_STAT_B_ADDR 0x14
+#define _REG_GP_ISP_STREAM_STAT_ADDR 0x18
+#define _REG_GP_MOD_STREAM_STAT_ADDR 0x1C
+#define _REG_GP_SP_STREAM_STAT_IRQ_COND_ADDR 0x20
+#define _REG_GP_SP_STREAM_STAT_B_IRQ_COND_ADDR 0x24
+#define _REG_GP_ISP_STREAM_STAT_IRQ_COND_ADDR 0x28
+#define _REG_GP_MOD_STREAM_STAT_IRQ_COND_ADDR 0x2C
+#define _REG_GP_SP_STREAM_STAT_IRQ_ENABLE_ADDR 0x30
+#define _REG_GP_SP_STREAM_STAT_B_IRQ_ENABLE_ADDR 0x34
+#define _REG_GP_ISP_STREAM_STAT_IRQ_ENABLE_ADDR 0x38
+#define _REG_GP_MOD_STREAM_STAT_IRQ_ENABLE_ADDR 0x3C
 /*
 #define _REG_GP_SWITCH_IF_ADDR						0x40
 #define _REG_GP_SWITCH_GDC1_ADDR					0x44
 #define _REG_GP_SWITCH_GDC2_ADDR					0x48
 */
-#define _REG_GP_SLV_REG_RST_ADDR					0x50
-#define _REG_GP_SWITCH_ISYS2401_ADDR				0x54
+#define _REG_GP_SLV_REG_RST_ADDR 0x50
+#define _REG_GP_SWITCH_ISYS2401_ADDR 0x54
 
 /* @ INPUT_FORMATTER_BASE -> GP_DEVICE_BASE */
 /*
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device_private.h
index 71f20992ee9871232285450d514771730d390652..5ed7dac8b95e37a26a9b959f5c0cc51482b34b07 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_device_private.h
@@ -13,21 +13,19 @@
 
 #include "assert_support.h"
 
-STORAGE_CLASS_GP_DEVICE_C void gp_device_reg_store(
-    const gp_device_ID_t	ID,
-    const unsigned int		reg_addr,
-    const hrt_data			value)
+STORAGE_CLASS_GP_DEVICE_C void gp_device_reg_store(const gp_device_ID_t ID,
+						   const unsigned int reg_addr,
+						   const hrt_data value)
 {
 	assert(ID < N_GP_DEVICE_ID);
-	assert(GP_DEVICE_BASE[ID] != (hrt_address) - 1);
+	assert(GP_DEVICE_BASE[ID] != (hrt_address)-1);
 	assert((reg_addr % sizeof(hrt_data)) == 0);
 	ia_css_device_store_uint32(GP_DEVICE_BASE[ID] + reg_addr, value);
 	return;
 }
 
-STORAGE_CLASS_GP_DEVICE_C hrt_data gp_device_reg_load(
-    const gp_device_ID_t	ID,
-    const hrt_address	reg_addr)
+STORAGE_CLASS_GP_DEVICE_C hrt_data
+gp_device_reg_load(const gp_device_ID_t ID, const hrt_address reg_addr)
 {
 	assert(ID < N_GP_DEVICE_ID);
 	assert(GP_DEVICE_BASE[ID] != (hrt_address)-1);
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_timer.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_timer.c
index d04c179a5ecdf6ff0d6b0ef7cf0c4e6b83d534fd..e20d4c8346f134712e4c98e8f6a0fe215088aa58 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_timer.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_timer.c
@@ -5,35 +5,29 @@
  */
 
 #include <type_support.h> /*uint32_t */
-#include "gp_timer.h"   /*system_local.h,
+#include "gp_timer.h" /*system_local.h,
 			  gp_timer_public.h*/
 
 #ifndef __INLINE_GP_TIMER__
-#include "gp_timer_private.h"  /*device_access.h*/
+#include "gp_timer_private.h" /*device_access.h*/
 #endif /* __INLINE_GP_TIMER__ */
 #include "system_local.h"
 
 /* FIXME: not sure if reg_load(), reg_store() should be API.
  */
-static uint32_t
-gp_timer_reg_load(uint32_t reg);
+static uint32_t gp_timer_reg_load(uint32_t reg);
 
-static void
-gp_timer_reg_store(u32 reg, uint32_t value);
+static void gp_timer_reg_store(u32 reg, uint32_t value);
 
-static uint32_t
-gp_timer_reg_load(uint32_t reg)
+static uint32_t gp_timer_reg_load(uint32_t reg)
 {
-	return ia_css_device_load_uint32(
-		   GP_TIMER_BASE +
-		   (reg * sizeof(uint32_t)));
+	return ia_css_device_load_uint32(GP_TIMER_BASE +
+					 (reg * sizeof(uint32_t)));
 }
 
-static void
-gp_timer_reg_store(u32 reg, uint32_t value)
+static void gp_timer_reg_store(u32 reg, uint32_t value)
 {
-	ia_css_device_store_uint32((GP_TIMER_BASE +
-				    (reg * sizeof(uint32_t))),
+	ia_css_device_store_uint32((GP_TIMER_BASE + (reg * sizeof(uint32_t))),
 				   value);
 }
 
@@ -46,17 +40,18 @@ void gp_timer_init(gp_timer_ID_t ID)
 	gp_timer_reg_store(_REG_GP_TIMER_ENABLE_ID(ID), 1);
 
 	/* set signal select */
-	gp_timer_reg_store(_REG_GP_TIMER_SIGNAL_SELECT_ID(ID), GP_TIMER_SIGNAL_SELECT);
+	gp_timer_reg_store(_REG_GP_TIMER_SIGNAL_SELECT_ID(ID),
+			   GP_TIMER_SIGNAL_SELECT);
 
 	/*set count type */
-	gp_timer_reg_store(_REG_GP_TIMER_COUNT_TYPE_ID(ID), GP_TIMER_COUNT_TYPE_LOW);
+	gp_timer_reg_store(_REG_GP_TIMER_COUNT_TYPE_ID(ID),
+			   GP_TIMER_COUNT_TYPE_LOW);
 
 	/*reset gp timer */
 	gp_timer_reg_store(_REG_GP_TIMER_RESET_REG, 0xFF);
 }
 
-uint32_t
-gp_timer_read(gp_timer_ID_t ID)
+uint32_t gp_timer_read(gp_timer_ID_t ID)
 {
-	return	gp_timer_reg_load(_REG_GP_TIMER_VALUE_ID(ID));
+	return gp_timer_reg_load(_REG_GP_TIMER_VALUE_ID(ID));
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_timer_local.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_timer_local.h
index 779eeee650d4744139de43044d4cb98fa18c29e5..366299dcd1c7af679c6a334d440a0e91999382ce 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_timer_local.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gp_timer_local.h
@@ -5,12 +5,12 @@
  */
 
 #ifndef __GP_TIMER_LOCAL_H_INCLUDED__
-#define  __GP_TIMER_LOCAL_H_INCLUDED__
+#define __GP_TIMER_LOCAL_H_INCLUDED__
 
 #include "gp_timer_global.h" /*GP_TIMER_SEL
 				GP_TIMER_SIGNAL_SELECT*/
 
-#include "gp_timer_defs.h"    /*HIVE_GP_TIMER_xxx registers*/
+#include "gp_timer_defs.h" /*HIVE_GP_TIMER_xxx registers*/
 #include "hive_isp_css_defs.h" /*HIVE_GP_TIMER_NUM_COUNTERS
 				 HIVE_GP_TIMER_NUM_IRQS*/
 
@@ -19,17 +19,25 @@
 
 /*Register offsets for timers [1,7] can be obtained
  * by adding (GP_TIMERx_ID * sizeof(uint32_t))*/
-#define _REG_GP_TIMER_ENABLE_ID(timer_id)        HIVE_GP_TIMER_ENABLE_REG_IDX(timer_id)
-#define _REG_GP_TIMER_VALUE_ID(timer_id)	 HIVE_GP_TIMER_VALUE_REG_IDX(timer_id, HIVE_GP_TIMER_NUM_COUNTERS)
-#define _REG_GP_TIMER_COUNT_TYPE_ID(timer_id)    HIVE_GP_TIMER_COUNT_TYPE_REG_IDX(timer_id, HIVE_GP_TIMER_NUM_COUNTERS)
-#define _REG_GP_TIMER_SIGNAL_SELECT_ID(timer_id) HIVE_GP_TIMER_SIGNAL_SELECT_REG_IDX(timer_id, HIVE_GP_TIMER_NUM_COUNTERS)
-
-#define _REG_GP_TIMER_IRQ_TRIGGER_VALUE_ID(irq_id) HIVE_GP_TIMER_IRQ_TRIGGER_VALUE_REG_IDX(irq_id, HIVE_GP_TIMER_NUM_COUNTERS)
-
-#define _REG_GP_TIMER_IRQ_TIMER_SELECT_ID(irq_id)   \
-	HIVE_GP_TIMER_IRQ_TIMER_SELECT_REG_IDX(irq_id, HIVE_GP_TIMER_NUM_COUNTERS, HIVE_GP_TIMER_NUM_IRQS)
-
-#define _REG_GP_TIMER_IRQ_ENABLE_ID(irq_id) \
-	HIVE_GP_TIMER_IRQ_ENABLE_REG_IDX(irq_id, HIVE_GP_TIMER_NUM_COUNTERS, HIVE_GP_TIMER_NUM_IRQS)
-
-#endif  /*__GP_TIMER_LOCAL_H_INCLUDED__*/
+#define _REG_GP_TIMER_ENABLE_ID(timer_id) HIVE_GP_TIMER_ENABLE_REG_IDX(timer_id)
+#define _REG_GP_TIMER_VALUE_ID(timer_id) \
+	HIVE_GP_TIMER_VALUE_REG_IDX(timer_id, HIVE_GP_TIMER_NUM_COUNTERS)
+#define _REG_GP_TIMER_COUNT_TYPE_ID(timer_id) \
+	HIVE_GP_TIMER_COUNT_TYPE_REG_IDX(timer_id, HIVE_GP_TIMER_NUM_COUNTERS)
+#define _REG_GP_TIMER_SIGNAL_SELECT_ID(timer_id)      \
+	HIVE_GP_TIMER_SIGNAL_SELECT_REG_IDX(timer_id, \
+					    HIVE_GP_TIMER_NUM_COUNTERS)
+
+#define _REG_GP_TIMER_IRQ_TRIGGER_VALUE_ID(irq_id)      \
+	HIVE_GP_TIMER_IRQ_TRIGGER_VALUE_REG_IDX(irq_id, \
+						HIVE_GP_TIMER_NUM_COUNTERS)
+
+#define _REG_GP_TIMER_IRQ_TIMER_SELECT_ID(irq_id) \
+	HIVE_GP_TIMER_IRQ_TIMER_SELECT_REG_IDX(   \
+		irq_id, HIVE_GP_TIMER_NUM_COUNTERS, HIVE_GP_TIMER_NUM_IRQS)
+
+#define _REG_GP_TIMER_IRQ_ENABLE_ID(irq_id)                                  \
+	HIVE_GP_TIMER_IRQ_ENABLE_REG_IDX(irq_id, HIVE_GP_TIMER_NUM_COUNTERS, \
+					 HIVE_GP_TIMER_NUM_IRQS)
+
+#endif /*__GP_TIMER_LOCAL_H_INCLUDED__*/
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gpio_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gpio_private.h
index bcf6538ac0dc3031be850c3cff1d53d1d2b583cb..ca8b17e32c0e50408ae089a43d24d02ed761d3d7 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gpio_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/gpio_private.h
@@ -10,24 +10,22 @@
 #include "assert_support.h"
 #include "device_access.h"
 
-static inline void gpio_reg_store(
-    const gpio_ID_t	ID,
-    const unsigned int		reg,
-    const hrt_data			value)
+static inline void gpio_reg_store(const gpio_ID_t ID, const unsigned int reg,
+				  const hrt_data value)
 {
 	OP___assert(ID < N_GPIO_ID);
-	OP___assert(GPIO_BASE[ID] != (hrt_address) - 1);
-	ia_css_device_store_uint32(GPIO_BASE[ID] + reg * sizeof(hrt_data), value);
+	OP___assert(GPIO_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(GPIO_BASE[ID] + reg * sizeof(hrt_data),
+				   value);
 	return;
 }
 
-static inline hrt_data gpio_reg_load(
-    const gpio_ID_t	ID,
-    const unsigned int		reg)
+static inline hrt_data gpio_reg_load(const gpio_ID_t ID, const unsigned int reg)
 {
 	OP___assert(ID < N_GPIO_ID);
-	OP___assert(GPIO_BASE[ID] != (hrt_address) - 1);
-	return ia_css_device_load_uint32(GPIO_BASE[ID] + reg * sizeof(hrt_data));
+	OP___assert(GPIO_BASE[ID] != (hrt_address)-1);
+	return ia_css_device_load_uint32(GPIO_BASE[ID] +
+					 reg * sizeof(hrt_data));
 }
 
 #endif /* __GPIO_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/hmem_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/hmem_private.h
index 0d58b321552f25ae148c4eec0d4be226f7a74347..dc6e8cfa6f9084218388c5c36e7094a414092e93 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/hmem_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/hmem_private.h
@@ -11,8 +11,7 @@
 
 #include "assert_support.h"
 
-STORAGE_CLASS_HMEM_C size_t sizeof_hmem(
-    const hmem_ID_t		ID)
+STORAGE_CLASS_HMEM_C size_t sizeof_hmem(const hmem_ID_t ID)
 {
 	assert(ID < N_HMEM_ID);
 	(void)ID;
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter.c
index 40b3f1e48c5669f60cfed28d24e1adafa1dac1e7..b2943ea22c67a12f1aac81b2d6d2e9a594ef0c1d 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter.c
@@ -6,7 +6,6 @@
 
 #include "system_global.h"
 
-
 #include "input_formatter.h"
 #include <type_support.h>
 #include "gp_device.h"
@@ -22,36 +21,28 @@ static const unsigned int input_formatter_alignment[N_INPUT_FORMATTER_ID] = {
 };
 
 const hrt_address HIVE_IF_SRST_ADDRESS[N_INPUT_FORMATTER_ID] = {
-	INPUT_FORMATTER0_SRST_OFFSET,
-	INPUT_FORMATTER1_SRST_OFFSET,
-	INPUT_FORMATTER2_SRST_OFFSET,
-	INPUT_FORMATTER3_SRST_OFFSET
+	INPUT_FORMATTER0_SRST_OFFSET, INPUT_FORMATTER1_SRST_OFFSET,
+	INPUT_FORMATTER2_SRST_OFFSET, INPUT_FORMATTER3_SRST_OFFSET
 };
 
 const hrt_data HIVE_IF_SRST_MASK[N_INPUT_FORMATTER_ID] = {
-	INPUT_FORMATTER0_SRST_MASK,
-	INPUT_FORMATTER1_SRST_MASK,
-	INPUT_FORMATTER2_SRST_MASK,
-	INPUT_FORMATTER3_SRST_MASK
+	INPUT_FORMATTER0_SRST_MASK, INPUT_FORMATTER1_SRST_MASK,
+	INPUT_FORMATTER2_SRST_MASK, INPUT_FORMATTER3_SRST_MASK
 };
 
 const u8 HIVE_IF_SWITCH_CODE[N_INPUT_FORMATTER_ID] = {
-	HIVE_INPUT_SWITCH_SELECT_IF_PRIM,
-	HIVE_INPUT_SWITCH_SELECT_IF_PRIM,
-	HIVE_INPUT_SWITCH_SELECT_IF_SEC,
-	HIVE_INPUT_SWITCH_SELECT_STR_TO_MEM
+	HIVE_INPUT_SWITCH_SELECT_IF_PRIM, HIVE_INPUT_SWITCH_SELECT_IF_PRIM,
+	HIVE_INPUT_SWITCH_SELECT_IF_SEC, HIVE_INPUT_SWITCH_SELECT_STR_TO_MEM
 };
 
 /* MW Should be part of system_global.h, where we have the main enumeration */
-static const bool HIVE_IF_BIN_COPY[N_INPUT_FORMATTER_ID] = {
-	false, false, false, true
-};
+static const bool HIVE_IF_BIN_COPY[N_INPUT_FORMATTER_ID] = { false, false,
+							     false, true };
 
-void input_formatter_rst(
-    const input_formatter_ID_t		ID)
+void input_formatter_rst(const input_formatter_ID_t ID)
 {
-	hrt_address	addr;
-	hrt_data	rst;
+	hrt_address addr;
+	hrt_data rst;
 
 	assert(ID < N_INPUT_FORMATTER_ID);
 
@@ -69,31 +60,28 @@ void input_formatter_rst(
 	return;
 }
 
-unsigned int input_formatter_get_alignment(
-    const input_formatter_ID_t		ID)
+unsigned int input_formatter_get_alignment(const input_formatter_ID_t ID)
 {
 	assert(ID < N_INPUT_FORMATTER_ID);
 
 	return input_formatter_alignment[ID];
 }
 
-void input_formatter_set_fifo_blocking_mode(
-    const input_formatter_ID_t		ID,
-    const bool						enable)
+void input_formatter_set_fifo_blocking_mode(const input_formatter_ID_t ID,
+					    const bool enable)
 {
 	assert(ID < N_INPUT_FORMATTER_ID);
 
 	/* cnd_input_formatter_reg_store() */
 	if (!HIVE_IF_BIN_COPY[ID]) {
-		input_formatter_reg_store(ID,
-					  HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS, enable);
+		input_formatter_reg_store(ID, HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS,
+					  enable);
 	}
 	return;
 }
 
-void input_formatter_get_switch_state(
-    const input_formatter_ID_t		ID,
-    input_formatter_switch_state_t	*state)
+void input_formatter_get_switch_state(const input_formatter_ID_t ID,
+				      input_formatter_switch_state_t *state)
 {
 	assert(ID < N_INPUT_FORMATTER_ID);
 	assert(state);
@@ -101,33 +89,32 @@ void input_formatter_get_switch_state(
 	/* We'll change this into an intelligent function to get switch info per IF */
 	(void)ID;
 
-	state->if_input_switch_lut_reg[0] = gp_device_reg_load(GP_DEVICE0_ID,
-					    _REG_GP_IFMT_input_switch_lut_reg0);
-	state->if_input_switch_lut_reg[1] = gp_device_reg_load(GP_DEVICE0_ID,
-					    _REG_GP_IFMT_input_switch_lut_reg1);
-	state->if_input_switch_lut_reg[2] = gp_device_reg_load(GP_DEVICE0_ID,
-					    _REG_GP_IFMT_input_switch_lut_reg2);
-	state->if_input_switch_lut_reg[3] = gp_device_reg_load(GP_DEVICE0_ID,
-					    _REG_GP_IFMT_input_switch_lut_reg3);
-	state->if_input_switch_lut_reg[4] = gp_device_reg_load(GP_DEVICE0_ID,
-					    _REG_GP_IFMT_input_switch_lut_reg4);
-	state->if_input_switch_lut_reg[5] = gp_device_reg_load(GP_DEVICE0_ID,
-					    _REG_GP_IFMT_input_switch_lut_reg5);
-	state->if_input_switch_lut_reg[6] = gp_device_reg_load(GP_DEVICE0_ID,
-					    _REG_GP_IFMT_input_switch_lut_reg6);
-	state->if_input_switch_lut_reg[7] = gp_device_reg_load(GP_DEVICE0_ID,
-					    _REG_GP_IFMT_input_switch_lut_reg7);
-	state->if_input_switch_fsync_lut = gp_device_reg_load(GP_DEVICE0_ID,
-					   _REG_GP_IFMT_input_switch_fsync_lut);
-	state->if_input_switch_ch_id_fmt_type = gp_device_reg_load(GP_DEVICE0_ID,
-						_REG_GP_IFMT_input_switch_ch_id_fmt_type);
+	state->if_input_switch_lut_reg[0] = gp_device_reg_load(
+		GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg0);
+	state->if_input_switch_lut_reg[1] = gp_device_reg_load(
+		GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg1);
+	state->if_input_switch_lut_reg[2] = gp_device_reg_load(
+		GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg2);
+	state->if_input_switch_lut_reg[3] = gp_device_reg_load(
+		GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg3);
+	state->if_input_switch_lut_reg[4] = gp_device_reg_load(
+		GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg4);
+	state->if_input_switch_lut_reg[5] = gp_device_reg_load(
+		GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg5);
+	state->if_input_switch_lut_reg[6] = gp_device_reg_load(
+		GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg6);
+	state->if_input_switch_lut_reg[7] = gp_device_reg_load(
+		GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg7);
+	state->if_input_switch_fsync_lut = gp_device_reg_load(
+		GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_fsync_lut);
+	state->if_input_switch_ch_id_fmt_type = gp_device_reg_load(
+		GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_ch_id_fmt_type);
 
 	return;
 }
 
-void input_formatter_get_state(
-    const input_formatter_ID_t		ID,
-    input_formatter_state_t			*state)
+void input_formatter_get_state(const input_formatter_ID_t ID,
+			       input_formatter_state_t *state)
 {
 	assert(ID < N_INPUT_FORMATTER_ID);
 	assert(state);
@@ -135,101 +122,100 @@ void input_formatter_get_state(
 		state->reset = input_formatter_reg_load(ID,
 			HIVE_IF_RESET_ADDRESS);
 	 */
-	state->start_line = input_formatter_reg_load(ID,
-			    HIVE_IF_START_LINE_ADDRESS);
-	state->start_column = input_formatter_reg_load(ID,
-			      HIVE_IF_START_COLUMN_ADDRESS);
-	state->cropped_height = input_formatter_reg_load(ID,
-				HIVE_IF_CROPPED_HEIGHT_ADDRESS);
-	state->cropped_width = input_formatter_reg_load(ID,
-			       HIVE_IF_CROPPED_WIDTH_ADDRESS);
-	state->ver_decimation = input_formatter_reg_load(ID,
-				HIVE_IF_VERTICAL_DECIMATION_ADDRESS);
-	state->hor_decimation = input_formatter_reg_load(ID,
-				HIVE_IF_HORIZONTAL_DECIMATION_ADDRESS);
-	state->hor_deinterleaving = input_formatter_reg_load(ID,
-				    HIVE_IF_H_DEINTERLEAVING_ADDRESS);
-	state->left_padding = input_formatter_reg_load(ID,
-			      HIVE_IF_LEFTPADDING_WIDTH_ADDRESS);
-	state->eol_offset = input_formatter_reg_load(ID,
-			    HIVE_IF_END_OF_LINE_OFFSET_ADDRESS);
-	state->vmem_start_address = input_formatter_reg_load(ID,
-				    HIVE_IF_VMEM_START_ADDRESS_ADDRESS);
-	state->vmem_end_address = input_formatter_reg_load(ID,
-				  HIVE_IF_VMEM_END_ADDRESS_ADDRESS);
-	state->vmem_increment = input_formatter_reg_load(ID,
-				HIVE_IF_VMEM_INCREMENT_ADDRESS);
-	state->is_yuv420 = input_formatter_reg_load(ID,
-			   HIVE_IF_YUV_420_FORMAT_ADDRESS);
-	state->vsync_active_low = input_formatter_reg_load(ID,
-				  HIVE_IF_VSYNCK_ACTIVE_LOW_ADDRESS);
-	state->hsync_active_low = input_formatter_reg_load(ID,
-				  HIVE_IF_HSYNCK_ACTIVE_LOW_ADDRESS);
-	state->allow_fifo_overflow = input_formatter_reg_load(ID,
-				     HIVE_IF_ALLOW_FIFO_OVERFLOW_ADDRESS);
-	state->block_fifo_when_no_req = input_formatter_reg_load(ID,
-					HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS);
-	state->ver_deinterleaving = input_formatter_reg_load(ID,
-				    HIVE_IF_V_DEINTERLEAVING_ADDRESS);
+	state->start_line =
+		input_formatter_reg_load(ID, HIVE_IF_START_LINE_ADDRESS);
+	state->start_column =
+		input_formatter_reg_load(ID, HIVE_IF_START_COLUMN_ADDRESS);
+	state->cropped_height =
+		input_formatter_reg_load(ID, HIVE_IF_CROPPED_HEIGHT_ADDRESS);
+	state->cropped_width =
+		input_formatter_reg_load(ID, HIVE_IF_CROPPED_WIDTH_ADDRESS);
+	state->ver_decimation = input_formatter_reg_load(
+		ID, HIVE_IF_VERTICAL_DECIMATION_ADDRESS);
+	state->hor_decimation = input_formatter_reg_load(
+		ID, HIVE_IF_HORIZONTAL_DECIMATION_ADDRESS);
+	state->hor_deinterleaving =
+		input_formatter_reg_load(ID, HIVE_IF_H_DEINTERLEAVING_ADDRESS);
+	state->left_padding =
+		input_formatter_reg_load(ID, HIVE_IF_LEFTPADDING_WIDTH_ADDRESS);
+	state->eol_offset = input_formatter_reg_load(
+		ID, HIVE_IF_END_OF_LINE_OFFSET_ADDRESS);
+	state->vmem_start_address = input_formatter_reg_load(
+		ID, HIVE_IF_VMEM_START_ADDRESS_ADDRESS);
+	state->vmem_end_address =
+		input_formatter_reg_load(ID, HIVE_IF_VMEM_END_ADDRESS_ADDRESS);
+	state->vmem_increment =
+		input_formatter_reg_load(ID, HIVE_IF_VMEM_INCREMENT_ADDRESS);
+	state->is_yuv420 =
+		input_formatter_reg_load(ID, HIVE_IF_YUV_420_FORMAT_ADDRESS);
+	state->vsync_active_low =
+		input_formatter_reg_load(ID, HIVE_IF_VSYNCK_ACTIVE_LOW_ADDRESS);
+	state->hsync_active_low =
+		input_formatter_reg_load(ID, HIVE_IF_HSYNCK_ACTIVE_LOW_ADDRESS);
+	state->allow_fifo_overflow = input_formatter_reg_load(
+		ID, HIVE_IF_ALLOW_FIFO_OVERFLOW_ADDRESS);
+	state->block_fifo_when_no_req =
+		input_formatter_reg_load(ID, HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS);
+	state->ver_deinterleaving =
+		input_formatter_reg_load(ID, HIVE_IF_V_DEINTERLEAVING_ADDRESS);
 	/* FSM */
-	state->fsm_sync_status = input_formatter_reg_load(ID,
-				 HIVE_IF_FSM_SYNC_STATUS);
-	state->fsm_sync_counter = input_formatter_reg_load(ID,
-				  HIVE_IF_FSM_SYNC_COUNTER);
-	state->fsm_crop_status = input_formatter_reg_load(ID,
-				 HIVE_IF_FSM_CROP_STATUS);
-	state->fsm_crop_line_counter = input_formatter_reg_load(ID,
-				       HIVE_IF_FSM_CROP_LINE_COUNTER);
-	state->fsm_crop_pixel_counter = input_formatter_reg_load(ID,
-					HIVE_IF_FSM_CROP_PIXEL_COUNTER);
-	state->fsm_deinterleaving_index = input_formatter_reg_load(ID,
-					  HIVE_IF_FSM_DEINTERLEAVING_IDX);
-	state->fsm_dec_h_counter = input_formatter_reg_load(ID,
-				   HIVE_IF_FSM_DECIMATION_H_COUNTER);
-	state->fsm_dec_v_counter = input_formatter_reg_load(ID,
-				   HIVE_IF_FSM_DECIMATION_V_COUNTER);
-	state->fsm_dec_block_v_counter = input_formatter_reg_load(ID,
-					 HIVE_IF_FSM_DECIMATION_BLOCK_V_COUNTER);
-	state->fsm_padding_status = input_formatter_reg_load(ID,
-				    HIVE_IF_FSM_PADDING_STATUS);
-	state->fsm_padding_elem_counter = input_formatter_reg_load(ID,
-					  HIVE_IF_FSM_PADDING_ELEMENT_COUNTER);
-	state->fsm_vector_support_error = input_formatter_reg_load(ID,
-					  HIVE_IF_FSM_VECTOR_SUPPORT_ERROR);
-	state->fsm_vector_buffer_full = input_formatter_reg_load(ID,
-					HIVE_IF_FSM_VECTOR_SUPPORT_BUFF_FULL);
-	state->vector_support = input_formatter_reg_load(ID,
-				HIVE_IF_FSM_VECTOR_SUPPORT);
-	state->sensor_data_lost = input_formatter_reg_load(ID,
-				  HIVE_IF_FIFO_SENSOR_STATUS);
+	state->fsm_sync_status =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_SYNC_STATUS);
+	state->fsm_sync_counter =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_SYNC_COUNTER);
+	state->fsm_crop_status =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_CROP_STATUS);
+	state->fsm_crop_line_counter =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_CROP_LINE_COUNTER);
+	state->fsm_crop_pixel_counter =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_CROP_PIXEL_COUNTER);
+	state->fsm_deinterleaving_index =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_DEINTERLEAVING_IDX);
+	state->fsm_dec_h_counter =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_DECIMATION_H_COUNTER);
+	state->fsm_dec_v_counter =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_DECIMATION_V_COUNTER);
+	state->fsm_dec_block_v_counter = input_formatter_reg_load(
+		ID, HIVE_IF_FSM_DECIMATION_BLOCK_V_COUNTER);
+	state->fsm_padding_status =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_PADDING_STATUS);
+	state->fsm_padding_elem_counter = input_formatter_reg_load(
+		ID, HIVE_IF_FSM_PADDING_ELEMENT_COUNTER);
+	state->fsm_vector_support_error =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_VECTOR_SUPPORT_ERROR);
+	state->fsm_vector_buffer_full = input_formatter_reg_load(
+		ID, HIVE_IF_FSM_VECTOR_SUPPORT_BUFF_FULL);
+	state->vector_support =
+		input_formatter_reg_load(ID, HIVE_IF_FSM_VECTOR_SUPPORT);
+	state->sensor_data_lost =
+		input_formatter_reg_load(ID, HIVE_IF_FIFO_SENSOR_STATUS);
 
 	return;
 }
 
-void input_formatter_bin_get_state(
-    const input_formatter_ID_t		ID,
-    input_formatter_bin_state_t		*state)
+void input_formatter_bin_get_state(const input_formatter_ID_t ID,
+				   input_formatter_bin_state_t *state)
 {
 	assert(ID < N_INPUT_FORMATTER_ID);
 	assert(state);
 
-	state->reset = input_formatter_reg_load(ID,
-						HIVE_STR2MEM_SOFT_RESET_REG_ADDRESS);
-	state->input_endianness = input_formatter_reg_load(ID,
-				  HIVE_STR2MEM_INPUT_ENDIANNESS_REG_ADDRESS);
-	state->output_endianness = input_formatter_reg_load(ID,
-				   HIVE_STR2MEM_OUTPUT_ENDIANNESS_REG_ADDRESS);
-	state->bitswap = input_formatter_reg_load(ID,
-			 HIVE_STR2MEM_BIT_SWAPPING_REG_ADDRESS);
-	state->block_synch = input_formatter_reg_load(ID,
-			     HIVE_STR2MEM_BLOCK_SYNC_LEVEL_REG_ADDRESS);
-	state->packet_synch = input_formatter_reg_load(ID,
-			      HIVE_STR2MEM_PACKET_SYNC_LEVEL_REG_ADDRESS);
-	state->readpostwrite_synch = input_formatter_reg_load(ID,
-				     HIVE_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ADDRESS);
-	state->is_2ppc = input_formatter_reg_load(ID,
-			 HIVE_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ADDRESS);
-	state->en_status_update = input_formatter_reg_load(ID,
-				  HIVE_STR2MEM_EN_STAT_UPDATE_ADDRESS);
+	state->reset = input_formatter_reg_load(
+		ID, HIVE_STR2MEM_SOFT_RESET_REG_ADDRESS);
+	state->input_endianness = input_formatter_reg_load(
+		ID, HIVE_STR2MEM_INPUT_ENDIANNESS_REG_ADDRESS);
+	state->output_endianness = input_formatter_reg_load(
+		ID, HIVE_STR2MEM_OUTPUT_ENDIANNESS_REG_ADDRESS);
+	state->bitswap = input_formatter_reg_load(
+		ID, HIVE_STR2MEM_BIT_SWAPPING_REG_ADDRESS);
+	state->block_synch = input_formatter_reg_load(
+		ID, HIVE_STR2MEM_BLOCK_SYNC_LEVEL_REG_ADDRESS);
+	state->packet_synch = input_formatter_reg_load(
+		ID, HIVE_STR2MEM_PACKET_SYNC_LEVEL_REG_ADDRESS);
+	state->readpostwrite_synch = input_formatter_reg_load(
+		ID, HIVE_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ADDRESS);
+	state->is_2ppc = input_formatter_reg_load(
+		ID, HIVE_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ADDRESS);
+	state->en_status_update = input_formatter_reg_load(
+		ID, HIVE_STR2MEM_EN_STAT_UPDATE_ADDRESS);
 	return;
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter_local.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter_local.h
index 84cd031f8b8ddd3a557bfc2516df15fda1486bf9..83a7c4a30a58a5edb92b840083e277a023a8cc36 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter_local.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter_local.h
@@ -9,24 +9,24 @@
 
 #include "input_formatter_global.h"
 
-#include "isp.h"		/* ISP_VEC_ALIGN */
+#include "isp.h" /* ISP_VEC_ALIGN */
 
-typedef struct input_formatter_switch_state_s	input_formatter_switch_state_t;
-typedef struct input_formatter_state_s			input_formatter_state_t;
-typedef struct input_formatter_bin_state_s		input_formatter_bin_state_t;
+typedef struct input_formatter_switch_state_s input_formatter_switch_state_t;
+typedef struct input_formatter_state_s input_formatter_state_t;
+typedef struct input_formatter_bin_state_s input_formatter_bin_state_t;
 
-#define HIVE_IF_FSM_SYNC_STATUS                 0x100
-#define HIVE_IF_FSM_SYNC_COUNTER                0x104
-#define HIVE_IF_FSM_DEINTERLEAVING_IDX          0x114
-#define HIVE_IF_FSM_DECIMATION_H_COUNTER        0x118
-#define HIVE_IF_FSM_DECIMATION_V_COUNTER        0x11C
-#define HIVE_IF_FSM_DECIMATION_BLOCK_V_COUNTER  0x120
-#define HIVE_IF_FSM_PADDING_STATUS              0x124
-#define HIVE_IF_FSM_PADDING_ELEMENT_COUNTER     0x128
-#define HIVE_IF_FSM_VECTOR_SUPPORT_ERROR        0x12C
-#define HIVE_IF_FSM_VECTOR_SUPPORT_BUFF_FULL    0x130
-#define HIVE_IF_FSM_VECTOR_SUPPORT              0x134
-#define HIVE_IF_FIFO_SENSOR_STATUS              0x138
+#define HIVE_IF_FSM_SYNC_STATUS 0x100
+#define HIVE_IF_FSM_SYNC_COUNTER 0x104
+#define HIVE_IF_FSM_DEINTERLEAVING_IDX 0x114
+#define HIVE_IF_FSM_DECIMATION_H_COUNTER 0x118
+#define HIVE_IF_FSM_DECIMATION_V_COUNTER 0x11C
+#define HIVE_IF_FSM_DECIMATION_BLOCK_V_COUNTER 0x120
+#define HIVE_IF_FSM_PADDING_STATUS 0x124
+#define HIVE_IF_FSM_PADDING_ELEMENT_COUNTER 0x128
+#define HIVE_IF_FSM_VECTOR_SUPPORT_ERROR 0x12C
+#define HIVE_IF_FSM_VECTOR_SUPPORT_BUFF_FULL 0x130
+#define HIVE_IF_FSM_VECTOR_SUPPORT 0x134
+#define HIVE_IF_FIFO_SENSOR_STATUS 0x138
 
 /*
  * The switch LUT's coding defines a sink for each
@@ -51,59 +51,60 @@ typedef struct input_formatter_bin_state_s		input_formatter_bin_state_t;
  * goes to another place than the synch
  */
 struct input_formatter_switch_state_s {
-	int	if_input_switch_lut_reg[8];
-	int	if_input_switch_fsync_lut;
-	int	if_input_switch_ch_id_fmt_type;
-	bool if_input_switch_map[HIVE_SWITCH_N_CHANNELS][HIVE_SWITCH_N_FORMATTYPES];
+	int if_input_switch_lut_reg[8];
+	int if_input_switch_fsync_lut;
+	int if_input_switch_ch_id_fmt_type;
+	bool if_input_switch_map[HIVE_SWITCH_N_CHANNELS]
+				[HIVE_SWITCH_N_FORMATTYPES];
 };
 
 struct input_formatter_state_s {
 	/*	int	reset; */
-	int	start_line;
-	int	start_column;
-	int	cropped_height;
-	int	cropped_width;
-	int	ver_decimation;
-	int	hor_decimation;
-	int	ver_deinterleaving;
-	int	hor_deinterleaving;
-	int	left_padding;
-	int	eol_offset;
-	int	vmem_start_address;
-	int	vmem_end_address;
-	int	vmem_increment;
-	int	is_yuv420;
-	int	vsync_active_low;
-	int	hsync_active_low;
-	int	allow_fifo_overflow;
+	int start_line;
+	int start_column;
+	int cropped_height;
+	int cropped_width;
+	int ver_decimation;
+	int hor_decimation;
+	int ver_deinterleaving;
+	int hor_deinterleaving;
+	int left_padding;
+	int eol_offset;
+	int vmem_start_address;
+	int vmem_end_address;
+	int vmem_increment;
+	int is_yuv420;
+	int vsync_active_low;
+	int hsync_active_low;
+	int allow_fifo_overflow;
 	int block_fifo_when_no_req;
-	int	fsm_sync_status;
-	int	fsm_sync_counter;
-	int	fsm_crop_status;
-	int	fsm_crop_line_counter;
-	int	fsm_crop_pixel_counter;
-	int	fsm_deinterleaving_index;
-	int	fsm_dec_h_counter;
-	int	fsm_dec_v_counter;
-	int	fsm_dec_block_v_counter;
-	int	fsm_padding_status;
-	int	fsm_padding_elem_counter;
-	int	fsm_vector_support_error;
-	int	fsm_vector_buffer_full;
-	int	vector_support;
-	int	sensor_data_lost;
+	int fsm_sync_status;
+	int fsm_sync_counter;
+	int fsm_crop_status;
+	int fsm_crop_line_counter;
+	int fsm_crop_pixel_counter;
+	int fsm_deinterleaving_index;
+	int fsm_dec_h_counter;
+	int fsm_dec_v_counter;
+	int fsm_dec_block_v_counter;
+	int fsm_padding_status;
+	int fsm_padding_elem_counter;
+	int fsm_vector_support_error;
+	int fsm_vector_buffer_full;
+	int vector_support;
+	int sensor_data_lost;
 };
 
 struct input_formatter_bin_state_s {
-	u32	reset;
-	u32	input_endianness;
-	u32	output_endianness;
-	u32	bitswap;
-	u32	block_synch;
-	u32	packet_synch;
-	u32	readpostwrite_synch;
-	u32	is_2ppc;
-	u32	en_status_update;
+	u32 reset;
+	u32 input_endianness;
+	u32 output_endianness;
+	u32 bitswap;
+	u32 block_synch;
+	u32 packet_synch;
+	u32 readpostwrite_synch;
+	u32 is_2ppc;
+	u32 en_status_update;
 };
 
 #endif /* __INPUT_FORMATTER_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter_private.h
index 6b6ba49656e5e1cf9a221d29b174a7cff17db0f7..cc3e3c66e9646369c860e8d5d165a1fee54722cc 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_formatter_private.h
@@ -13,10 +13,9 @@
 
 #include "assert_support.h"
 
-STORAGE_CLASS_INPUT_FORMATTER_C void input_formatter_reg_store(
-    const input_formatter_ID_t		ID,
-    const hrt_address			reg_addr,
-    const hrt_data				value)
+STORAGE_CLASS_INPUT_FORMATTER_C void
+input_formatter_reg_store(const input_formatter_ID_t ID,
+			  const hrt_address reg_addr, const hrt_data value)
 {
 	assert(ID < N_INPUT_FORMATTER_ID);
 	assert(INPUT_FORMATTER_BASE[ID] != (hrt_address)-1);
@@ -26,8 +25,7 @@ STORAGE_CLASS_INPUT_FORMATTER_C void input_formatter_reg_store(
 }
 
 STORAGE_CLASS_INPUT_FORMATTER_C hrt_data input_formatter_reg_load(
-    const input_formatter_ID_t	ID,
-    const unsigned int			reg_addr)
+	const input_formatter_ID_t ID, const unsigned int reg_addr)
 {
 	assert(ID < N_INPUT_FORMATTER_ID);
 	assert(INPUT_FORMATTER_BASE[ID] != (hrt_address)-1);
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_system.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_system.c
index 9f1199c4761c43c5e52387aea9c2518d15129168..d27cf6bc4636a789b44766ef33b31b84bd9e32ab 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_system.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/input_system.c
@@ -6,7 +6,6 @@
 
 #include "system_global.h"
 
-
 #include "input_system.h"
 #include <type_support.h>
 #include "gp_device.h"
@@ -18,15 +17,15 @@
 #endif /* __INLINE_INPUT_SYSTEM__ */
 
 #define ZERO (0x0)
-#define ONE  (1U)
+#define ONE (1U)
 
-static const isp2400_ib_buffer_t   IB_BUFFER_NULL = {0, 0, 0 };
+static const isp2400_ib_buffer_t IB_BUFFER_NULL = { 0, 0, 0 };
 
-static input_system_err_t input_system_configure_channel(
-    const channel_cfg_t		channel);
+static input_system_err_t
+input_system_configure_channel(const channel_cfg_t channel);
 
-static input_system_err_t input_system_configure_channel_sensor(
-    const channel_cfg_t		channel);
+static input_system_err_t
+input_system_configure_channel_sensor(const channel_cfg_t channel);
 
 static input_system_err_t input_buffer_configuration(void);
 
@@ -35,63 +34,55 @@ static input_system_err_t configuration_to_registers(void);
 static void receiver_rst(const rx_ID_t ID);
 static void input_system_network_rst(const input_system_ID_t ID);
 
-static void capture_unit_configure(
-    const input_system_ID_t			ID,
-    const sub_system_ID_t			sub_id,
-    const isp2400_ib_buffer_t *const cfg);
+static void capture_unit_configure(const input_system_ID_t ID,
+				   const sub_system_ID_t sub_id,
+				   const isp2400_ib_buffer_t *const cfg);
 
-static void acquisition_unit_configure(
-    const input_system_ID_t			ID,
-    const sub_system_ID_t			sub_id,
-    const isp2400_ib_buffer_t *const cfg);
+static void acquisition_unit_configure(const input_system_ID_t ID,
+				       const sub_system_ID_t sub_id,
+				       const isp2400_ib_buffer_t *const cfg);
 
-static void ctrl_unit_configure(
-    const input_system_ID_t			ID,
-    const sub_system_ID_t			sub_id,
-    const ctrl_unit_cfg_t *const cfg);
+static void ctrl_unit_configure(const input_system_ID_t ID,
+				const sub_system_ID_t sub_id,
+				const ctrl_unit_cfg_t *const cfg);
 
-static void input_system_network_configure(
-    const input_system_ID_t			ID,
-    const input_system_network_cfg_t *const cfg);
+static void
+input_system_network_configure(const input_system_ID_t ID,
+			       const input_system_network_cfg_t *const cfg);
 
 // MW: CSI is previously named as "rx" short for "receiver"
-static input_system_err_t set_csi_cfg(
-    csi_cfg_t *const lhs,
-    const csi_cfg_t *const rhs,
-    input_system_config_flags_t *const flags);
+static input_system_err_t set_csi_cfg(csi_cfg_t *const lhs,
+				      const csi_cfg_t *const rhs,
+				      input_system_config_flags_t *const flags);
 
-static input_system_err_t set_source_type(
-    input_system_source_t *const lhs,
-    const input_system_source_t				rhs,
-    input_system_config_flags_t *const flags);
+static input_system_err_t
+set_source_type(input_system_source_t *const lhs,
+		const input_system_source_t rhs,
+		input_system_config_flags_t *const flags);
 
-static input_system_err_t input_system_multiplexer_cfg(
-    input_system_multiplex_t *const lhs,
-    const input_system_multiplex_t			rhs,
-    input_system_config_flags_t *const flags);
+static input_system_err_t
+input_system_multiplexer_cfg(input_system_multiplex_t *const lhs,
+			     const input_system_multiplex_t rhs,
+			     input_system_config_flags_t *const flags);
 
-static void gp_device_rst(const gp_device_ID_t		ID);
+static void gp_device_rst(const gp_device_ID_t ID);
 
-static void input_selector_cfg_for_sensor(const gp_device_ID_t	ID);
+static void input_selector_cfg_for_sensor(const gp_device_ID_t ID);
 
-static void input_switch_rst(const gp_device_ID_t	ID);
+static void input_switch_rst(const gp_device_ID_t ID);
 
-static void input_switch_cfg(
-    const gp_device_ID_t				ID,
-    const input_switch_cfg_t *const cfg
-);
+static void input_switch_cfg(const gp_device_ID_t ID,
+			     const input_switch_cfg_t *const cfg);
 
-void receiver_set_compression(
-    const rx_ID_t			ID,
-    const unsigned int		cfg_ID,
-    const mipi_compressor_t		comp,
-    const mipi_predictor_t		pred)
+void receiver_set_compression(const rx_ID_t ID, const unsigned int cfg_ID,
+			      const mipi_compressor_t comp,
+			      const mipi_predictor_t pred)
 {
-	const unsigned int		field_id = cfg_ID % N_MIPI_FORMAT_CUSTOM;
-	const unsigned int		ch_id = cfg_ID / N_MIPI_FORMAT_CUSTOM;
-	hrt_data			val;
-	hrt_address			addr = 0;
-	hrt_data			reg;
+	const unsigned int field_id = cfg_ID % N_MIPI_FORMAT_CUSTOM;
+	const unsigned int ch_id = cfg_ID / N_MIPI_FORMAT_CUSTOM;
+	hrt_data val;
+	hrt_address addr = 0;
+	hrt_data reg;
 
 	assert(ID < N_RX_ID);
 	assert(cfg_ID < N_MIPI_COMPRESSOR_CONTEXT);
@@ -104,20 +95,24 @@ void receiver_set_compression(
 
 	switch (ch_id) {
 	case 0:
-		addr = ((field_id < 6) ? _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX :
-			_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX);
+		addr = ((field_id < 6) ?
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX :
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX);
 		break;
 	case 1:
-		addr = ((field_id < 6) ? _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX :
-			_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX);
+		addr = ((field_id < 6) ?
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX :
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX);
 		break;
 	case 2:
-		addr = ((field_id < 6) ? _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX :
-			_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX);
+		addr = ((field_id < 6) ?
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX :
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX);
 		break;
 	case 3:
-		addr = ((field_id < 6) ? _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX :
-			_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX);
+		addr = ((field_id < 6) ?
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX :
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX);
 		break;
 	default:
 		/* should not happen */
@@ -125,18 +120,16 @@ void receiver_set_compression(
 		return;
 	}
 
-	reg = ((field_id < 6) ? (val << (field_id * 5)) : (val << ((
-		    field_id - 6) * 5)));
+	reg = ((field_id < 6) ? (val << (field_id * 5)) :
+				(val << ((field_id - 6) * 5)));
 	receiver_reg_store(ID, addr, reg);
 }
 
-void receiver_port_enable(
-    const rx_ID_t			ID,
-    const enum mipi_port_id		port_ID,
-    const bool			cnd)
+void receiver_port_enable(const rx_ID_t ID, const enum mipi_port_id port_ID,
+			  const bool cnd)
 {
-	hrt_data	reg = receiver_port_reg_load(ID, port_ID,
-			  _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
+	hrt_data reg = receiver_port_reg_load(
+		ID, port_ID, _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
 
 	if (cnd) {
 		reg |= 0x01;
@@ -148,52 +141,44 @@ void receiver_port_enable(
 				_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX, reg);
 }
 
-bool is_receiver_port_enabled(
-    const rx_ID_t			ID,
-    const enum mipi_port_id		port_ID)
+bool is_receiver_port_enabled(const rx_ID_t ID, const enum mipi_port_id port_ID)
 {
-	hrt_data	reg = receiver_port_reg_load(ID, port_ID,
-			  _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
+	hrt_data reg = receiver_port_reg_load(
+		ID, port_ID, _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
 	return ((reg & 0x01) != 0);
 }
 
-void receiver_irq_enable(
-    const rx_ID_t			ID,
-    const enum mipi_port_id		port_ID,
-    const rx_irq_info_t		irq_info)
+void receiver_irq_enable(const rx_ID_t ID, const enum mipi_port_id port_ID,
+			 const rx_irq_info_t irq_info)
 {
-	receiver_port_reg_store(ID,
-				port_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, irq_info);
+	receiver_port_reg_store(ID, port_ID,
+				_HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, irq_info);
 }
 
-rx_irq_info_t receiver_get_irq_info(
-    const rx_ID_t			ID,
-    const enum mipi_port_id		port_ID)
+rx_irq_info_t receiver_get_irq_info(const rx_ID_t ID,
+				    const enum mipi_port_id port_ID)
 {
-	return receiver_port_reg_load(ID,
-				      port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
+	return receiver_port_reg_load(ID, port_ID,
+				      _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
 }
 
-void receiver_irq_clear(
-    const rx_ID_t			ID,
-    const enum mipi_port_id		port_ID,
-    const rx_irq_info_t		irq_info)
+void receiver_irq_clear(const rx_ID_t ID, const enum mipi_port_id port_ID,
+			const rx_irq_info_t irq_info)
 {
-	receiver_port_reg_store(ID,
-				port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX, irq_info);
+	receiver_port_reg_store(ID, port_ID,
+				_HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX, irq_info);
 }
 
 // MW: "2400" in the name is not good, but this is to avoid a naming conflict
 static input_system_cfg2400_t config;
 
-static void receiver_rst(
-    const rx_ID_t				ID)
+static void receiver_rst(const rx_ID_t ID)
 {
-	enum mipi_port_id		port_id;
+	enum mipi_port_id port_id;
 
 	assert(ID < N_RX_ID);
 
-// Disable all ports.
+	// Disable all ports.
 	for (port_id = MIPI_PORT0_ID; port_id < N_MIPI_PORT_ID; port_id++) {
 		receiver_port_enable(ID, port_id, false);
 	}
@@ -202,7 +187,7 @@ static void receiver_rst(
 }
 
 //Single function to reset all the devices mapped via GP_DEVICE.
-static void gp_device_rst(const gp_device_ID_t		ID)
+static void gp_device_rst(const gp_device_ID_t ID)
 {
 	assert(ID < N_GP_DEVICE_ID);
 
@@ -215,11 +200,11 @@ static void gp_device_rst(const gp_device_ID_t		ID)
 	// gp_device_reg_store(ID, _REG_GP_SYNGEN_NR_LINES_ADDR, ZERO);
 	// gp_device_reg_store(ID, _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR, ZERO);
 	// gp_device_reg_store(ID, _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR, ZERO);
-// AM: Following calls cause strange warnings. Probably they should not be initialized.
-//	gp_device_reg_store(ID, _REG_GP_ISEL_SOF_ADDR, ZERO);
-//	gp_device_reg_store(ID, _REG_GP_ISEL_EOF_ADDR, ZERO);
-//	gp_device_reg_store(ID, _REG_GP_ISEL_SOL_ADDR, ZERO);
-//	gp_device_reg_store(ID, _REG_GP_ISEL_EOL_ADDR, ZERO);
+	// AM: Following calls cause strange warnings. Probably they should not be initialized.
+	//	gp_device_reg_store(ID, _REG_GP_ISEL_SOF_ADDR, ZERO);
+	//	gp_device_reg_store(ID, _REG_GP_ISEL_EOF_ADDR, ZERO);
+	//	gp_device_reg_store(ID, _REG_GP_ISEL_SOL_ADDR, ZERO);
+	//	gp_device_reg_store(ID, _REG_GP_ISEL_EOL_ADDR, ZERO);
 	gp_device_reg_store(ID, _REG_GP_ISEL_LFSR_ENABLE_ADDR, ZERO);
 	gp_device_reg_store(ID, _REG_GP_ISEL_LFSR_ENABLE_B_ADDR, ZERO);
 	gp_device_reg_store(ID, _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR, ZERO);
@@ -273,19 +258,17 @@ static void input_switch_rst(const gp_device_ID_t ID)
 
 	// Initialize the data&hsync LUT.
 	for (addr = _REG_GP_IFMT_input_switch_lut_reg0;
-	     addr <= _REG_GP_IFMT_input_switch_lut_reg7; addr += SIZEOF_HRT_REG) {
+	     addr <= _REG_GP_IFMT_input_switch_lut_reg7;
+	     addr += SIZEOF_HRT_REG) {
 		gp_device_reg_store(ID, addr, ZERO);
 	}
 
 	// Initialize the vsync LUT.
-	gp_device_reg_store(ID,
-			    _REG_GP_IFMT_input_switch_fsync_lut,
-			    ZERO);
+	gp_device_reg_store(ID, _REG_GP_IFMT_input_switch_fsync_lut, ZERO);
 }
 
-static void input_switch_cfg(
-    const gp_device_ID_t			ID,
-    const input_switch_cfg_t *const cfg)
+static void input_switch_cfg(const gp_device_ID_t ID,
+			     const input_switch_cfg_t *const cfg)
 {
 	int addr_offset;
 
@@ -293,17 +276,19 @@ static void input_switch_cfg(
 	assert(cfg);
 
 	// Initialize the data&hsync LUT.
-	for (addr_offset = 0; addr_offset < N_RX_CHANNEL_ID * 2; addr_offset++) {
-		assert(addr_offset * SIZEOF_HRT_REG + _REG_GP_IFMT_input_switch_lut_reg0 <=
+	for (addr_offset = 0; addr_offset < N_RX_CHANNEL_ID * 2;
+	     addr_offset++) {
+		assert(addr_offset * SIZEOF_HRT_REG +
+			       _REG_GP_IFMT_input_switch_lut_reg0 <=
 		       _REG_GP_IFMT_input_switch_lut_reg7);
 		gp_device_reg_store(ID,
-				    _REG_GP_IFMT_input_switch_lut_reg0 + addr_offset * SIZEOF_HRT_REG,
+				    _REG_GP_IFMT_input_switch_lut_reg0 +
+					    addr_offset * SIZEOF_HRT_REG,
 				    cfg->hsync_data_reg[addr_offset]);
 	}
 
 	// Initialize the vsync LUT.
-	gp_device_reg_store(ID,
-			    _REG_GP_IFMT_input_switch_fsync_lut,
+	gp_device_reg_store(ID, _REG_GP_IFMT_input_switch_fsync_lut,
 			    cfg->vsync_data_reg);
 }
 
@@ -312,40 +297,32 @@ static void input_system_network_rst(const input_system_ID_t ID)
 	unsigned int sub_id;
 
 	// Reset all 3 multicasts.
-	input_system_sub_system_reg_store(ID,
-					  GPREGS_UNIT0_ID,
+	input_system_sub_system_reg_store(ID, GPREGS_UNIT0_ID,
 					  HIVE_ISYS_GPREG_MULTICAST_A_IDX,
 					  INPUT_SYSTEM_DISCARD_ALL);
-	input_system_sub_system_reg_store(ID,
-					  GPREGS_UNIT0_ID,
+	input_system_sub_system_reg_store(ID, GPREGS_UNIT0_ID,
 					  HIVE_ISYS_GPREG_MULTICAST_B_IDX,
 					  INPUT_SYSTEM_DISCARD_ALL);
-	input_system_sub_system_reg_store(ID,
-					  GPREGS_UNIT0_ID,
+	input_system_sub_system_reg_store(ID, GPREGS_UNIT0_ID,
 					  HIVE_ISYS_GPREG_MULTICAST_C_IDX,
 					  INPUT_SYSTEM_DISCARD_ALL);
 
 	// Reset stream mux.
-	input_system_sub_system_reg_store(ID,
-					  GPREGS_UNIT0_ID,
+	input_system_sub_system_reg_store(ID, GPREGS_UNIT0_ID,
 					  HIVE_ISYS_GPREG_MUX_IDX,
 					  N_INPUT_SYSTEM_MULTIPLEX);
 
 	// Reset 3 capture units.
-	for (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID;
-	     sub_id++) {
-		input_system_sub_system_reg_store(ID,
-						  sub_id,
-						  CAPT_INIT_REG_ID,
+	for (sub_id = CAPTURE_UNIT0_ID;
+	     sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID; sub_id++) {
+		input_system_sub_system_reg_store(ID, sub_id, CAPT_INIT_REG_ID,
 						  1U << CAPT_INIT_RST_REG_BIT);
 	}
 
 	// Reset acquisition unit.
 	for (sub_id = ACQUISITION_UNIT0_ID;
 	     sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {
-		input_system_sub_system_reg_store(ID,
-						  sub_id,
-						  ACQ_INIT_REG_ID,
+		input_system_sub_system_reg_store(ID, sub_id, ACQ_INIT_REG_ID,
 						  1U << ACQ_INIT_RST_REG_BIT);
 	}
 
@@ -355,10 +332,9 @@ static void input_system_network_rst(const input_system_ID_t ID)
 	// NB: In future we need to keep part of ctrl_state for split capture and
 	for (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID;
 	     sub_id++) {
-		input_system_sub_system_reg_store(ID,
-						  sub_id,
-						  ISYS_CTRL_INIT_REG_ID,
-						  1U); //AM: Is there any named constant?
+		input_system_sub_system_reg_store(
+			ID, sub_id, ISYS_CTRL_INIT_REG_ID,
+			1U); //AM: Is there any named constant?
 	}
 }
 
@@ -388,13 +364,13 @@ input_system_err_t input_system_configuration_reset(void)
 	}
 
 	for (i = 0; i < N_CSI_PORTS; i++) {
-		config.csi_buffer_flags[i]	 = INPUT_SYSTEM_CFG_FLAG_RESET;
-		config.multicast[i]		 = INPUT_SYSTEM_DISCARD_ALL;
+		config.csi_buffer_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;
+		config.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;
 	}
 
-	config.source_type_flags				 = INPUT_SYSTEM_CFG_FLAG_RESET;
-	config.acquisition_buffer_unique_flags	 = INPUT_SYSTEM_CFG_FLAG_RESET;
-	config.unallocated_ib_mem_words			 = IB_CAPACITY_IN_WORDS;
+	config.source_type_flags = INPUT_SYSTEM_CFG_FLAG_RESET;
+	config.acquisition_buffer_unique_flags = INPUT_SYSTEM_CFG_FLAG_RESET;
+	config.unallocated_ib_mem_words = IB_CAPACITY_IN_WORDS;
 	//config.acq_allocated_ib_mem_words		 = 0;
 
 	/* Set the start of the session configuration. */
@@ -405,8 +381,8 @@ input_system_err_t input_system_configuration_reset(void)
 
 // MW: Comments are good, but doxygen is required, place it at the declaration
 // Function that appends the channel to current configuration.
-static input_system_err_t input_system_configure_channel(
-    const channel_cfg_t		channel)
+static input_system_err_t
+input_system_configure_channel(const channel_cfg_t channel)
 {
 	input_system_err_t error = INPUT_SYSTEM_ERR_NO_ERROR;
 	// Check if channel is not already configured.
@@ -423,31 +399,38 @@ static input_system_err_t input_system_configure_channel(
 			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
 		}
 
-		if (error != INPUT_SYSTEM_ERR_NO_ERROR) return error;
+		if (error != INPUT_SYSTEM_ERR_NO_ERROR)
+			return error;
 		// Input switch channel configurations must be combined in united config.
-		config.input_switch_cfg.hsync_data_reg[channel.source_cfg.csi_cfg.csi_port * 2]
-		    =
-			channel.target_cfg.input_switch_channel_cfg.hsync_data_reg[0];
-		config.input_switch_cfg.hsync_data_reg[channel.source_cfg.csi_cfg.csi_port * 2 +
-											   1] =
-							       channel.target_cfg.input_switch_channel_cfg.hsync_data_reg[1];
+		config.input_switch_cfg
+			.hsync_data_reg[channel.source_cfg.csi_cfg.csi_port * 2] =
+			channel.target_cfg.input_switch_channel_cfg
+				.hsync_data_reg[0];
+		config.input_switch_cfg
+			.hsync_data_reg[channel.source_cfg.csi_cfg.csi_port * 2 +
+					1] =
+			channel.target_cfg.input_switch_channel_cfg
+				.hsync_data_reg[1];
 		config.input_switch_cfg.vsync_data_reg |=
-		    (channel.target_cfg.input_switch_channel_cfg.vsync_data_reg & 0x7) <<
-		    (channel.source_cfg.csi_cfg.csi_port * 3);
+			(channel.target_cfg.input_switch_channel_cfg
+				 .vsync_data_reg &
+			 0x7)
+			<< (channel.source_cfg.csi_cfg.csi_port * 3);
 
 		// Other targets are just copied and marked as set.
 		config.target_isp[channel.source_cfg.csi_cfg.csi_port] =
-		    channel.target_cfg.target_isp_cfg;
+			channel.target_cfg.target_isp_cfg;
 		config.target_sp[channel.source_cfg.csi_cfg.csi_port] =
-		    channel.target_cfg.target_sp_cfg;
+			channel.target_cfg.target_sp_cfg;
 		config.target_strm2mem[channel.source_cfg.csi_cfg.csi_port] =
-		    channel.target_cfg.target_strm2mem_cfg;
+			channel.target_cfg.target_strm2mem_cfg;
 		config.target_isp_flags[channel.source_cfg.csi_cfg.csi_port] |=
-		    INPUT_SYSTEM_CFG_FLAG_SET;
+			INPUT_SYSTEM_CFG_FLAG_SET;
 		config.target_sp_flags[channel.source_cfg.csi_cfg.csi_port] |=
-		    INPUT_SYSTEM_CFG_FLAG_SET;
-		config.target_strm2mem_flags[channel.source_cfg.csi_cfg.csi_port] |=
-		    INPUT_SYSTEM_CFG_FLAG_SET;
+			INPUT_SYSTEM_CFG_FLAG_SET;
+		config.target_strm2mem_flags[channel.source_cfg.csi_cfg
+						     .csi_port] |=
+			INPUT_SYSTEM_CFG_FLAG_SET;
 
 		config.ch_flags[channel.ch_id] = INPUT_SYSTEM_CFG_FLAG_SET;
 	}
@@ -457,16 +440,17 @@ static input_system_err_t input_system_configure_channel(
 // Function that partitions input buffer space with determining addresses.
 static input_system_err_t input_buffer_configuration(void)
 {
-	u32 current_address    = 0;
+	u32 current_address = 0;
 	u32 unallocated_memory = IB_CAPACITY_IN_WORDS;
 
-	isp2400_ib_buffer_t	candidate_buffer_acq  = IB_BUFFER_NULL;
+	isp2400_ib_buffer_t candidate_buffer_acq = IB_BUFFER_NULL;
 	u32 size_requested;
-	input_system_config_flags_t	acq_already_specified = INPUT_SYSTEM_CFG_FLAG_RESET;
+	input_system_config_flags_t acq_already_specified =
+		INPUT_SYSTEM_CFG_FLAG_RESET;
 	input_system_csi_port_t port;
 
 	for (port = INPUT_SYSTEM_PORT_A; port < N_INPUT_SYSTEM_PORTS; port++) {
-		csi_cfg_t source = config.csi_value[port];//.csi_cfg;
+		csi_cfg_t source = config.csi_value[port]; //.csi_cfg;
 
 		if (config.csi_flags[port] & INPUT_SYSTEM_CFG_FLAG_SET) {
 			// Check and set csi buffer in input buffer.
@@ -474,33 +458,39 @@ static input_system_err_t input_buffer_configuration(void)
 			case INPUT_SYSTEM_FIFO_CAPTURE:
 			case INPUT_SYSTEM_XMEM_ACQUIRE:
 				config.csi_buffer_flags[port] =
-				    INPUT_SYSTEM_CFG_FLAG_BLOCKED; // Well, not used.
+					INPUT_SYSTEM_CFG_FLAG_BLOCKED; // Well, not used.
 				break;
 
 			case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING:
 			case INPUT_SYSTEM_SRAM_BUFFERING:
 			case INPUT_SYSTEM_XMEM_BUFFERING:
 			case INPUT_SYSTEM_XMEM_CAPTURE:
-				size_requested = source.csi_buffer.mem_reg_size *
-						 source.csi_buffer.nof_mem_regs;
-				if (source.csi_buffer.mem_reg_size > 0
-				    && source.csi_buffer.nof_mem_regs > 0
-				    && size_requested <= unallocated_memory
-				   ) {
-					config.csi_buffer[port].mem_reg_addr = current_address;
-					config.csi_buffer[port].mem_reg_size = source.csi_buffer.mem_reg_size;
-					config.csi_buffer[port].nof_mem_regs = source.csi_buffer.nof_mem_regs;
-					current_address		+= size_requested;
-					unallocated_memory	-= size_requested;
-					config.csi_buffer_flags[port] = INPUT_SYSTEM_CFG_FLAG_SET;
+				size_requested =
+					source.csi_buffer.mem_reg_size *
+					source.csi_buffer.nof_mem_regs;
+				if (source.csi_buffer.mem_reg_size > 0 &&
+				    source.csi_buffer.nof_mem_regs > 0 &&
+				    size_requested <= unallocated_memory) {
+					config.csi_buffer[port].mem_reg_addr =
+						current_address;
+					config.csi_buffer[port].mem_reg_size =
+						source.csi_buffer.mem_reg_size;
+					config.csi_buffer[port].nof_mem_regs =
+						source.csi_buffer.nof_mem_regs;
+					current_address += size_requested;
+					unallocated_memory -= size_requested;
+					config.csi_buffer_flags[port] =
+						INPUT_SYSTEM_CFG_FLAG_SET;
 				} else {
-					config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+					config.csi_buffer_flags[port] |=
+						INPUT_SYSTEM_CFG_FLAG_CONFLICT;
 					return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
 				}
 				break;
 
 			default:
-				config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+				config.csi_buffer_flags[port] |=
+					INPUT_SYSTEM_CFG_FLAG_CONFLICT;
 				return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
 			}
 
@@ -515,22 +505,36 @@ static input_system_err_t input_buffer_configuration(void)
 			case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING:
 			case INPUT_SYSTEM_XMEM_BUFFERING:
 			case INPUT_SYSTEM_XMEM_ACQUIRE:
-				if (acq_already_specified == INPUT_SYSTEM_CFG_FLAG_RESET) {
-					size_requested = source.acquisition_buffer.mem_reg_size
-							 * source.acquisition_buffer.nof_mem_regs;
-					if (source.acquisition_buffer.mem_reg_size > 0
-					    && source.acquisition_buffer.nof_mem_regs > 0
-					    && size_requested <= unallocated_memory
-					   ) {
-						candidate_buffer_acq = source.acquisition_buffer;
-						acq_already_specified = INPUT_SYSTEM_CFG_FLAG_SET;
+				if (acq_already_specified ==
+				    INPUT_SYSTEM_CFG_FLAG_RESET) {
+					size_requested =
+						source.acquisition_buffer
+							.mem_reg_size *
+						source.acquisition_buffer
+							.nof_mem_regs;
+					if (source.acquisition_buffer
+							    .mem_reg_size > 0 &&
+					    source.acquisition_buffer
+							    .nof_mem_regs > 0 &&
+					    size_requested <=
+						    unallocated_memory) {
+						candidate_buffer_acq =
+							source.acquisition_buffer;
+						acq_already_specified =
+							INPUT_SYSTEM_CFG_FLAG_SET;
 					}
 				} else {
 					// Check if specified acquisition buffer is the same as specified before.
-					if (source.acquisition_buffer.mem_reg_size != candidate_buffer_acq.mem_reg_size
-					    || source.acquisition_buffer.nof_mem_regs !=  candidate_buffer_acq.nof_mem_regs
-					   ) {
-						config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+					if (source.acquisition_buffer
+							    .mem_reg_size !=
+						    candidate_buffer_acq
+							    .mem_reg_size ||
+					    source.acquisition_buffer
+							    .nof_mem_regs !=
+						    candidate_buffer_acq
+							    .nof_mem_regs) {
+						config.acquisition_buffer_unique_flags |=
+							INPUT_SYSTEM_CFG_FLAG_CONFLICT;
 						return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
 					}
 				}
@@ -540,23 +544,25 @@ static input_system_err_t input_buffer_configuration(void)
 				return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
 			}
 		} else {
-			config.csi_buffer_flags[port] = INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			config.csi_buffer_flags[port] =
+				INPUT_SYSTEM_CFG_FLAG_BLOCKED;
 		}
 	} // end of for ( port )
 
 	// Set the acquisition buffer at the end.
 	size_requested = candidate_buffer_acq.mem_reg_size *
 			 candidate_buffer_acq.nof_mem_regs;
-	if (acq_already_specified == INPUT_SYSTEM_CFG_FLAG_SET
-	    && size_requested <= unallocated_memory) {
+	if (acq_already_specified == INPUT_SYSTEM_CFG_FLAG_SET &&
+	    size_requested <= unallocated_memory) {
 		config.acquisition_buffer_unique.mem_reg_addr = current_address;
 		config.acquisition_buffer_unique.mem_reg_size =
-		    candidate_buffer_acq.mem_reg_size;
+			candidate_buffer_acq.mem_reg_size;
 		config.acquisition_buffer_unique.nof_mem_regs =
-		    candidate_buffer_acq.nof_mem_regs;
-		current_address		+= size_requested;
-		unallocated_memory	-= size_requested;
-		config.acquisition_buffer_unique_flags = INPUT_SYSTEM_CFG_FLAG_SET;
+			candidate_buffer_acq.nof_mem_regs;
+		current_address += size_requested;
+		unallocated_memory -= size_requested;
+		config.acquisition_buffer_unique_flags =
+			INPUT_SYSTEM_CFG_FLAG_SET;
 
 		assert(current_address <= IB_CAPACITY_IN_WORDS);
 	}
@@ -564,122 +570,96 @@ static input_system_err_t input_buffer_configuration(void)
 	return INPUT_SYSTEM_ERR_NO_ERROR;
 }
 
-static void capture_unit_configure(
-    const input_system_ID_t			ID,
-    const sub_system_ID_t			sub_id,
-    const isp2400_ib_buffer_t *const cfg)
+static void capture_unit_configure(const input_system_ID_t ID,
+				   const sub_system_ID_t sub_id,
+				   const isp2400_ib_buffer_t *const cfg)
 {
 	assert(ID < N_INPUT_SYSTEM_ID);
-	assert(/*(sub_id >= CAPTURE_UNIT0_ID) &&*/ (sub_id <=
-		CAPTURE_UNIT2_ID)); // Commented part is always true.
+	assert(/*(sub_id >= CAPTURE_UNIT0_ID) &&*/ (
+		sub_id <= CAPTURE_UNIT2_ID)); // Commented part is always true.
 	assert(cfg);
 
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  CAPT_START_ADDR_REG_ID,
+	input_system_sub_system_reg_store(ID, sub_id, CAPT_START_ADDR_REG_ID,
 					  cfg->mem_reg_addr);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  CAPT_MEM_REGION_SIZE_REG_ID,
-					  cfg->mem_reg_size);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  CAPT_NUM_MEM_REGIONS_REG_ID,
-					  cfg->nof_mem_regs);
+	input_system_sub_system_reg_store(
+		ID, sub_id, CAPT_MEM_REGION_SIZE_REG_ID, cfg->mem_reg_size);
+	input_system_sub_system_reg_store(
+		ID, sub_id, CAPT_NUM_MEM_REGIONS_REG_ID, cfg->nof_mem_regs);
 }
 
-static void acquisition_unit_configure(
-    const input_system_ID_t			ID,
-    const sub_system_ID_t			sub_id,
-    const isp2400_ib_buffer_t *const cfg)
+static void acquisition_unit_configure(const input_system_ID_t ID,
+				       const sub_system_ID_t sub_id,
+				       const isp2400_ib_buffer_t *const cfg)
 {
 	assert(ID < N_INPUT_SYSTEM_ID);
 	assert(sub_id == ACQUISITION_UNIT0_ID);
 	assert(cfg);
 
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ACQ_START_ADDR_REG_ID,
+	input_system_sub_system_reg_store(ID, sub_id, ACQ_START_ADDR_REG_ID,
 					  cfg->mem_reg_addr);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ACQ_NUM_MEM_REGIONS_REG_ID,
-					  cfg->nof_mem_regs);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ACQ_MEM_REGION_SIZE_REG_ID,
-					  cfg->mem_reg_size);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ACQ_NUM_MEM_REGIONS_REG_ID, cfg->nof_mem_regs);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ACQ_MEM_REGION_SIZE_REG_ID, cfg->mem_reg_size);
 }
 
-static void ctrl_unit_configure(
-    const input_system_ID_t			ID,
-    const sub_system_ID_t			sub_id,
-    const ctrl_unit_cfg_t *const cfg)
+static void ctrl_unit_configure(const input_system_ID_t ID,
+				const sub_system_ID_t sub_id,
+				const ctrl_unit_cfg_t *const cfg)
 {
 	assert(ID < N_INPUT_SYSTEM_ID);
 	assert(sub_id == CTRL_UNIT0_ID);
 	assert(cfg);
 
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_CAPT_START_ADDR_A_REG_ID,
-					  cfg->buffer_mipi[CAPTURE_UNIT0_ID].mem_reg_addr);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID,
-					  cfg->buffer_mipi[CAPTURE_UNIT0_ID].mem_reg_size);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID,
-					  cfg->buffer_mipi[CAPTURE_UNIT0_ID].nof_mem_regs);
-
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_CAPT_START_ADDR_B_REG_ID,
-					  cfg->buffer_mipi[CAPTURE_UNIT1_ID].mem_reg_addr);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID,
-					  cfg->buffer_mipi[CAPTURE_UNIT1_ID].mem_reg_size);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID,
-					  cfg->buffer_mipi[CAPTURE_UNIT1_ID].nof_mem_regs);
-
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_CAPT_START_ADDR_C_REG_ID,
-					  cfg->buffer_mipi[CAPTURE_UNIT2_ID].mem_reg_addr);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID,
-					  cfg->buffer_mipi[CAPTURE_UNIT2_ID].mem_reg_size);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID,
-					  cfg->buffer_mipi[CAPTURE_UNIT2_ID].nof_mem_regs);
-
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_ACQ_START_ADDR_REG_ID,
-					  cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].mem_reg_addr);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID,
-					  cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].mem_reg_size);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID,
-					  cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].nof_mem_regs);
-	input_system_sub_system_reg_store(ID,
-					  sub_id,
-					  ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID,
-					  0);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_CAPT_START_ADDR_A_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT0_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT0_ID].mem_reg_size);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT0_ID].nof_mem_regs);
+
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_CAPT_START_ADDR_B_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT1_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT1_ID].mem_reg_size);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT1_ID].nof_mem_regs);
+
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_CAPT_START_ADDR_C_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT2_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT2_ID].mem_reg_size);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT2_ID].nof_mem_regs);
+
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_ACQ_START_ADDR_REG_ID,
+		cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID]
+			.mem_reg_addr);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID,
+		cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID]
+			.mem_reg_size);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID,
+		cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID]
+			.nof_mem_regs);
+	input_system_sub_system_reg_store(
+		ID, sub_id, ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID, 0);
 }
 
-static void input_system_network_configure(
-    const input_system_ID_t				ID,
-    const input_system_network_cfg_t *const cfg)
+static void
+input_system_network_configure(const input_system_ID_t ID,
+			       const input_system_network_cfg_t *const cfg)
 {
 	u32 sub_id;
 
@@ -687,40 +667,36 @@ static void input_system_network_configure(
 	assert(cfg);
 
 	// Set all 3 multicasts.
-	input_system_sub_system_reg_store(ID,
-					  GPREGS_UNIT0_ID,
+	input_system_sub_system_reg_store(ID, GPREGS_UNIT0_ID,
 					  HIVE_ISYS_GPREG_MULTICAST_A_IDX,
 					  cfg->multicast_cfg[CAPTURE_UNIT0_ID]);
-	input_system_sub_system_reg_store(ID,
-					  GPREGS_UNIT0_ID,
+	input_system_sub_system_reg_store(ID, GPREGS_UNIT0_ID,
 					  HIVE_ISYS_GPREG_MULTICAST_B_IDX,
 					  cfg->multicast_cfg[CAPTURE_UNIT1_ID]);
-	input_system_sub_system_reg_store(ID,
-					  GPREGS_UNIT0_ID,
+	input_system_sub_system_reg_store(ID, GPREGS_UNIT0_ID,
 					  HIVE_ISYS_GPREG_MULTICAST_C_IDX,
 					  cfg->multicast_cfg[CAPTURE_UNIT2_ID]);
 
 	// Set stream mux.
-	input_system_sub_system_reg_store(ID,
-					  GPREGS_UNIT0_ID,
-					  HIVE_ISYS_GPREG_MUX_IDX,
-					  cfg->mux_cfg);
+	input_system_sub_system_reg_store(
+		ID, GPREGS_UNIT0_ID, HIVE_ISYS_GPREG_MUX_IDX, cfg->mux_cfg);
 
 	// Set capture units.
-	for (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID;
-	     sub_id++) {
-		capture_unit_configure(ID,
-				       sub_id,
-				       &cfg->ctrl_unit_cfg[ID].buffer_mipi[sub_id - CAPTURE_UNIT0_ID]);
+	for (sub_id = CAPTURE_UNIT0_ID;
+	     sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID; sub_id++) {
+		capture_unit_configure(
+			ID, sub_id,
+			&cfg->ctrl_unit_cfg[ID]
+				 .buffer_mipi[sub_id - CAPTURE_UNIT0_ID]);
 	}
 
 	// Set acquisition units.
 	for (sub_id = ACQUISITION_UNIT0_ID;
 	     sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {
-		acquisition_unit_configure(ID,
-					   sub_id,
-					   &cfg->ctrl_unit_cfg[sub_id - ACQUISITION_UNIT0_ID].buffer_acquire[sub_id -
-						   ACQUISITION_UNIT0_ID]);
+		acquisition_unit_configure(
+			ID, sub_id,
+			&cfg->ctrl_unit_cfg[sub_id - ACQUISITION_UNIT0_ID]
+				 .buffer_acquire[sub_id - ACQUISITION_UNIT0_ID]);
 	}
 
 	// No DMA configuration needed. Ctrl_unit will fully control it.
@@ -728,9 +704,9 @@ static void input_system_network_configure(
 	// Set controller units.
 	for (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID;
 	     sub_id++) {
-		ctrl_unit_configure(ID,
-				    sub_id,
-				    &cfg->ctrl_unit_cfg[sub_id - CTRL_UNIT0_ID]);
+		ctrl_unit_configure(
+			ID, sub_id,
+			&cfg->ctrl_unit_cfg[sub_id - CTRL_UNIT0_ID]);
 	}
 }
 
@@ -751,25 +727,30 @@ static input_system_err_t configuration_to_registers(void)
 			if (config.csi_flags[i] & INPUT_SYSTEM_CFG_FLAG_SET) {
 				switch (config.csi_value[i].buffering_mode) {
 				case INPUT_SYSTEM_FIFO_CAPTURE:
-					config.multicast[i] = INPUT_SYSTEM_CSI_BACKEND;
+					config.multicast[i] =
+						INPUT_SYSTEM_CSI_BACKEND;
 					break;
 
 				case INPUT_SYSTEM_XMEM_CAPTURE:
 				case INPUT_SYSTEM_SRAM_BUFFERING:
 				case INPUT_SYSTEM_XMEM_BUFFERING:
-					config.multicast[i] = INPUT_SYSTEM_INPUT_BUFFER;
+					config.multicast[i] =
+						INPUT_SYSTEM_INPUT_BUFFER;
 					break;
 
 				case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING:
-					config.multicast[i] = INPUT_SYSTEM_MULTICAST;
+					config.multicast[i] =
+						INPUT_SYSTEM_MULTICAST;
 					break;
 
 				case INPUT_SYSTEM_XMEM_ACQUIRE:
-					config.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;
+					config.multicast[i] =
+						INPUT_SYSTEM_DISCARD_ALL;
 					break;
 
 				default:
-					config.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;
+					config.multicast[i] =
+						INPUT_SYSTEM_DISCARD_ALL;
 					return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
 					//break;
 				}
@@ -777,28 +758,34 @@ static input_system_err_t configuration_to_registers(void)
 				config.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;
 			}
 
-			input_system_network_cfg.multicast_cfg[i] = config.multicast[i];
+			input_system_network_cfg.multicast_cfg[i] =
+				config.multicast[i];
 
 		} // for
 
 		input_system_network_cfg.mux_cfg = config.multiplexer;
 
-		input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID -
-						       CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT0_ID] =
-							       config.csi_buffer[MIPI_PORT0_ID];
-		input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID -
-						       CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT1_ID] =
-							       config.csi_buffer[MIPI_PORT1_ID];
-		input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID -
-						       CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT2_ID] =
-							       config.csi_buffer[MIPI_PORT2_ID];
-		input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID -
-						       CTRL_UNIT0_ID].buffer_acquire[ACQUISITION_UNIT0_ID -
-							       ACQUISITION_UNIT0_ID] =
-								       config.acquisition_buffer_unique;
+		input_system_network_cfg
+			.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID]
+			.buffer_mipi[CAPTURE_UNIT0_ID] =
+			config.csi_buffer[MIPI_PORT0_ID];
+		input_system_network_cfg
+			.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID]
+			.buffer_mipi[CAPTURE_UNIT1_ID] =
+			config.csi_buffer[MIPI_PORT1_ID];
+		input_system_network_cfg
+			.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID]
+			.buffer_mipi[CAPTURE_UNIT2_ID] =
+			config.csi_buffer[MIPI_PORT2_ID];
+		input_system_network_cfg
+			.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID]
+			.buffer_acquire[ACQUISITION_UNIT0_ID -
+					ACQUISITION_UNIT0_ID] =
+			config.acquisition_buffer_unique;
 
 		// First set input network around CSI receiver.
-		input_system_network_configure(INPUT_SYSTEM0_ID, &input_system_network_cfg);
+		input_system_network_configure(INPUT_SYSTEM0_ID,
+					       &input_system_network_cfg);
 
 		// Set the CSI receiver.
 		//...
@@ -847,228 +834,208 @@ input_system_err_t input_system_configuration_commit(void)
 
 // FIFO
 
-input_system_err_t	input_system_csi_fifo_channel_cfg(
-    u32		ch_id,
-    input_system_csi_port_t	port,
-    backend_channel_cfg_t	backend_ch,
-    target_cfg2400_t	target
-)
+input_system_err_t
+input_system_csi_fifo_channel_cfg(u32 ch_id, input_system_csi_port_t port,
+				  backend_channel_cfg_t backend_ch,
+				  target_cfg2400_t target)
 {
 	channel_cfg_t channel;
 
-	channel.ch_id	= ch_id;
-	channel.backend_ch	= backend_ch;
+	channel.ch_id = ch_id;
+	channel.backend_ch = backend_ch;
 	channel.source_type = INPUT_SYSTEM_SOURCE_SENSOR;
 	//channel.source
-	channel.source_cfg.csi_cfg.csi_port			= port;
-	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_FIFO_CAPTURE;
-	channel.source_cfg.csi_cfg.csi_buffer			= IB_BUFFER_NULL;
-	channel.source_cfg.csi_cfg.acquisition_buffer	= IB_BUFFER_NULL;
-	channel.source_cfg.csi_cfg.nof_xmem_buffers	= 0;
+	channel.source_cfg.csi_cfg.csi_port = port;
+	channel.source_cfg.csi_cfg.buffering_mode = INPUT_SYSTEM_FIFO_CAPTURE;
+	channel.source_cfg.csi_cfg.csi_buffer = IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.acquisition_buffer = IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers = 0;
 
-	channel.target_cfg	= target;
+	channel.target_cfg = target;
 	return input_system_configure_channel(channel);
 }
 
-input_system_err_t	input_system_csi_fifo_channel_with_counting_cfg(
-    u32				ch_id,
-    u32				nof_frames,
-    input_system_csi_port_t			port,
-    backend_channel_cfg_t			backend_ch,
-    u32				csi_mem_reg_size,
-    u32				csi_nof_mem_regs,
-    target_cfg2400_t			target
-)
+input_system_err_t input_system_csi_fifo_channel_with_counting_cfg(
+	u32 ch_id, u32 nof_frames, input_system_csi_port_t port,
+	backend_channel_cfg_t backend_ch, u32 csi_mem_reg_size,
+	u32 csi_nof_mem_regs, target_cfg2400_t target)
 {
 	channel_cfg_t channel;
 
-	channel.ch_id	= ch_id;
-	channel.backend_ch	= backend_ch;
-	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	channel.ch_id = ch_id;
+	channel.backend_ch = backend_ch;
+	channel.source_type = INPUT_SYSTEM_SOURCE_SENSOR;
 	//channel.source
-	channel.source_cfg.csi_cfg.csi_port			= port;
-	channel.source_cfg.csi_cfg.buffering_mode	=
-	    INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING;
-	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
-	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs		= csi_nof_mem_regs;
-	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
-	channel.source_cfg.csi_cfg.acquisition_buffer			= IB_BUFFER_NULL;
-	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_frames;
-
-	channel.target_cfg	= target;
+	channel.source_cfg.csi_cfg.csi_port = port;
+	channel.source_cfg.csi_cfg.buffering_mode =
+		INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size = csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs = csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr = 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer = IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers = nof_frames;
+
+	channel.target_cfg = target;
 	return input_system_configure_channel(channel);
 }
 
 // SRAM
 
-input_system_err_t	input_system_csi_sram_channel_cfg(
-    u32				ch_id,
-    input_system_csi_port_t			port,
-    backend_channel_cfg_t			backend_ch,
-    u32				csi_mem_reg_size,
-    u32				csi_nof_mem_regs,
-    //	uint32_t				acq_mem_reg_size,
-    //	uint32_t				acq_nof_mem_regs,
-    target_cfg2400_t			target
-)
+input_system_err_t input_system_csi_sram_channel_cfg(
+	u32 ch_id, input_system_csi_port_t port,
+	backend_channel_cfg_t backend_ch, u32 csi_mem_reg_size,
+	u32 csi_nof_mem_regs,
+	//	uint32_t				acq_mem_reg_size,
+	//	uint32_t				acq_nof_mem_regs,
+	target_cfg2400_t target)
 {
 	channel_cfg_t channel;
 
-	channel.ch_id	= ch_id;
-	channel.backend_ch	= backend_ch;
-	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	channel.ch_id = ch_id;
+	channel.backend_ch = backend_ch;
+	channel.source_type = INPUT_SYSTEM_SOURCE_SENSOR;
 	//channel.source
-	channel.source_cfg.csi_cfg.csi_port			= port;
-	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_SRAM_BUFFERING;
-	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
-	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs		= csi_nof_mem_regs;
-	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
-	channel.source_cfg.csi_cfg.acquisition_buffer			= IB_BUFFER_NULL;
-	channel.source_cfg.csi_cfg.nof_xmem_buffers	= 0;
-
-	channel.target_cfg	= target;
+	channel.source_cfg.csi_cfg.csi_port = port;
+	channel.source_cfg.csi_cfg.buffering_mode = INPUT_SYSTEM_SRAM_BUFFERING;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size = csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs = csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr = 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer = IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers = 0;
+
+	channel.target_cfg = target;
 	return input_system_configure_channel(channel);
 }
 
 //XMEM
 
 // Collects all parameters and puts them in channel_cfg_t.
-input_system_err_t	input_system_csi_xmem_channel_cfg(
-    u32				ch_id,
-    input_system_csi_port_t			port,
-    backend_channel_cfg_t			backend_ch,
-    u32				csi_mem_reg_size,
-    u32				csi_nof_mem_regs,
-    u32				acq_mem_reg_size,
-    u32				acq_nof_mem_regs,
-    target_cfg2400_t			target,
-    uint32_t				nof_xmem_buffers
-)
+input_system_err_t input_system_csi_xmem_channel_cfg(
+	u32 ch_id, input_system_csi_port_t port,
+	backend_channel_cfg_t backend_ch, u32 csi_mem_reg_size,
+	u32 csi_nof_mem_regs, u32 acq_mem_reg_size, u32 acq_nof_mem_regs,
+	target_cfg2400_t target, uint32_t nof_xmem_buffers)
 {
 	channel_cfg_t channel;
 
-	channel.ch_id	= ch_id;
-	channel.backend_ch	= backend_ch;
-	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	channel.ch_id = ch_id;
+	channel.backend_ch = backend_ch;
+	channel.source_type = INPUT_SYSTEM_SOURCE_SENSOR;
 	//channel.source
-	channel.source_cfg.csi_cfg.csi_port			= port;
-	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_XMEM_BUFFERING;
-	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
-	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs		= csi_nof_mem_regs;
-	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
-	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size	= acq_mem_reg_size;
-	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs	= acq_nof_mem_regs;
-	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr	= 0;
-	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_xmem_buffers;
-
-	channel.target_cfg	= target;
+	channel.source_cfg.csi_cfg.csi_port = port;
+	channel.source_cfg.csi_cfg.buffering_mode = INPUT_SYSTEM_XMEM_BUFFERING;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size = csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs = csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr = 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size =
+		acq_mem_reg_size;
+	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs =
+		acq_nof_mem_regs;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr = 0;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers = nof_xmem_buffers;
+
+	channel.target_cfg = target;
 	return input_system_configure_channel(channel);
 }
 
-input_system_err_t	input_system_csi_xmem_acquire_only_channel_cfg(
-    u32				ch_id,
-    u32				nof_frames,
-    input_system_csi_port_t			port,
-    backend_channel_cfg_t			backend_ch,
-    u32				acq_mem_reg_size,
-    u32				acq_nof_mem_regs,
-    target_cfg2400_t			target)
+input_system_err_t input_system_csi_xmem_acquire_only_channel_cfg(
+	u32 ch_id, u32 nof_frames, input_system_csi_port_t port,
+	backend_channel_cfg_t backend_ch, u32 acq_mem_reg_size,
+	u32 acq_nof_mem_regs, target_cfg2400_t target)
 {
 	channel_cfg_t channel;
 
-	channel.ch_id	= ch_id;
-	channel.backend_ch	= backend_ch;
-	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	channel.ch_id = ch_id;
+	channel.backend_ch = backend_ch;
+	channel.source_type = INPUT_SYSTEM_SOURCE_SENSOR;
 	//channel.source
-	channel.source_cfg.csi_cfg.csi_port			= port;
-	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_XMEM_ACQUIRE;
-	channel.source_cfg.csi_cfg.csi_buffer		= IB_BUFFER_NULL;
-	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size	= acq_mem_reg_size;
-	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs	= acq_nof_mem_regs;
-	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr	= 0;
-	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_frames;
-
-	channel.target_cfg	= target;
+	channel.source_cfg.csi_cfg.csi_port = port;
+	channel.source_cfg.csi_cfg.buffering_mode = INPUT_SYSTEM_XMEM_ACQUIRE;
+	channel.source_cfg.csi_cfg.csi_buffer = IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size =
+		acq_mem_reg_size;
+	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs =
+		acq_nof_mem_regs;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr = 0;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers = nof_frames;
+
+	channel.target_cfg = target;
 	return input_system_configure_channel(channel);
 }
 
-input_system_err_t	input_system_csi_xmem_capture_only_channel_cfg(
-    u32				ch_id,
-    u32				nof_frames,
-    input_system_csi_port_t			port,
-    u32				csi_mem_reg_size,
-    u32				csi_nof_mem_regs,
-    u32				acq_mem_reg_size,
-    u32				acq_nof_mem_regs,
-    target_cfg2400_t			target)
+input_system_err_t input_system_csi_xmem_capture_only_channel_cfg(
+	u32 ch_id, u32 nof_frames, input_system_csi_port_t port,
+	u32 csi_mem_reg_size, u32 csi_nof_mem_regs, u32 acq_mem_reg_size,
+	u32 acq_nof_mem_regs, target_cfg2400_t target)
 {
 	channel_cfg_t channel;
 
-	channel.ch_id	= ch_id;
+	channel.ch_id = ch_id;
 	//channel.backend_ch	= backend_ch;
-	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	channel.source_type = INPUT_SYSTEM_SOURCE_SENSOR;
 	//channel.source
-	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.csi_port = port;
 	//channel.source_cfg.csi_cfg.backend_ch		= backend_ch;
-	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_XMEM_CAPTURE;
-	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
-	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs		= csi_nof_mem_regs;
-	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
-	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size	= acq_mem_reg_size;
-	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs	= acq_nof_mem_regs;
-	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr	= 0;
-	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_frames;
-
-	channel.target_cfg	= target;
+	channel.source_cfg.csi_cfg.buffering_mode = INPUT_SYSTEM_XMEM_CAPTURE;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size = csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs = csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr = 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size =
+		acq_mem_reg_size;
+	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs =
+		acq_nof_mem_regs;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr = 0;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers = nof_frames;
+
+	channel.target_cfg = target;
 	return input_system_configure_channel(channel);
 }
 
 // Non - CSI
 
-input_system_err_t	input_system_prbs_channel_cfg(
-    u32		ch_id,
-    u32		nof_frames,//not used yet
-    u32		seed,
-    u32		sync_gen_width,
-    u32		sync_gen_height,
-    u32		sync_gen_hblank_cycles,
-    u32		sync_gen_vblank_cycles,
-    target_cfg2400_t	target
-)
+input_system_err_t input_system_prbs_channel_cfg(u32 ch_id,
+						 u32 nof_frames, //not used yet
+						 u32 seed, u32 sync_gen_width,
+						 u32 sync_gen_height,
+						 u32 sync_gen_hblank_cycles,
+						 u32 sync_gen_vblank_cycles,
+						 target_cfg2400_t target)
 {
 	channel_cfg_t channel;
 
 	(void)nof_frames;
 
-	channel.ch_id	= ch_id;
+	channel.ch_id = ch_id;
 	channel.source_type = INPUT_SYSTEM_SOURCE_PRBS;
 
 	channel.source_cfg.prbs_cfg.seed = seed;
-	channel.source_cfg.prbs_cfg.sync_gen_cfg.width		= sync_gen_width;
-	channel.source_cfg.prbs_cfg.sync_gen_cfg.height		= sync_gen_height;
-	channel.source_cfg.prbs_cfg.sync_gen_cfg.hblank_cycles	= sync_gen_hblank_cycles;
-	channel.source_cfg.prbs_cfg.sync_gen_cfg.vblank_cycles	= sync_gen_vblank_cycles;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.width = sync_gen_width;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.height = sync_gen_height;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.hblank_cycles =
+		sync_gen_hblank_cycles;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.vblank_cycles =
+		sync_gen_vblank_cycles;
 
-	channel.target_cfg	= target;
+	channel.target_cfg = target;
 
 	return input_system_configure_channel(channel);
 }
 
 // MW: Don't use system specific names, (even in system specific files) "cfg2400" -> cfg
-input_system_err_t	input_system_gpfifo_channel_cfg(
-    u32		ch_id,
-    u32		nof_frames, //not used yet
+input_system_err_t
+input_system_gpfifo_channel_cfg(u32 ch_id,
+				u32 nof_frames, //not used yet
 
-    target_cfg2400_t	target)
+				target_cfg2400_t target)
 {
 	channel_cfg_t channel;
 
 	(void)nof_frames;
 
-	channel.ch_id	= ch_id;
-	channel.source_type	= INPUT_SYSTEM_SOURCE_FIFO;
+	channel.ch_id = ch_id;
+	channel.source_type = INPUT_SYSTEM_SOURCE_FIFO;
 
-	channel.target_cfg	= target;
+	channel.target_cfg = target;
 	return input_system_configure_channel(channel);
 }
 
@@ -1079,8 +1046,8 @@ input_system_err_t	input_system_gpfifo_channel_cfg(
 ///////////////////////////////////////////////////////////////////////////
 
 // Fills the parameters to config.csi_value[port]
-static input_system_err_t input_system_configure_channel_sensor(
-    const channel_cfg_t channel)
+static input_system_err_t
+input_system_configure_channel_sensor(const channel_cfg_t channel)
 {
 	const u32 port = channel.source_cfg.csi_cfg.csi_port;
 	input_system_err_t status = INPUT_SYSTEM_ERR_NO_ERROR;
@@ -1094,22 +1061,26 @@ static input_system_err_t input_system_configure_channel_sensor(
 
 	status = set_source_type(&config.source_type, channel.source_type,
 				 &config.source_type_flags);
-	if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+	if (status != INPUT_SYSTEM_ERR_NO_ERROR)
+		return status;
 
 	// Check for conflicts on source (implicitly on multicast, capture unit and input buffer).
 
-	status = set_csi_cfg(&config.csi_value[port], &channel.source_cfg.csi_cfg,
+	status = set_csi_cfg(&config.csi_value[port],
+			     &channel.source_cfg.csi_cfg,
 			     &config.csi_flags[port]);
-	if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+	if (status != INPUT_SYSTEM_ERR_NO_ERROR)
+		return status;
 
 	switch (channel.source_cfg.csi_cfg.buffering_mode) {
 	case INPUT_SYSTEM_FIFO_CAPTURE:
 
 		// Check for conflicts on mux.
 		mux = INPUT_SYSTEM_MIPI_PORT0 + port;
-		status = input_system_multiplexer_cfg(&config.multiplexer, mux,
-						      &config.multiplexer_flags);
-		if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+		status = input_system_multiplexer_cfg(
+			&config.multiplexer, mux, &config.multiplexer_flags);
+		if (status != INPUT_SYSTEM_ERR_NO_ERROR)
+			return status;
 		config.multicast[port] = INPUT_SYSTEM_CSI_BACKEND;
 
 		// Shared resource, so it should be blocked.
@@ -1122,9 +1093,10 @@ static input_system_err_t input_system_configure_channel_sensor(
 
 		// Check for conflicts on mux.
 		mux = INPUT_SYSTEM_ACQUISITION_UNIT;
-		status = input_system_multiplexer_cfg(&config.multiplexer, mux,
-						      &config.multiplexer_flags);
-		if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+		status = input_system_multiplexer_cfg(
+			&config.multiplexer, mux, &config.multiplexer_flags);
+		if (status != INPUT_SYSTEM_ERR_NO_ERROR)
+			return status;
 		config.multicast[port] = INPUT_SYSTEM_INPUT_BUFFER;
 
 		// Shared resource, so it should be blocked.
@@ -1137,9 +1109,10 @@ static input_system_err_t input_system_configure_channel_sensor(
 
 		// Check for conflicts on mux.
 		mux = INPUT_SYSTEM_ACQUISITION_UNIT;
-		status = input_system_multiplexer_cfg(&config.multiplexer, mux,
-						      &config.multiplexer_flags);
-		if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+		status = input_system_multiplexer_cfg(
+			&config.multiplexer, mux, &config.multiplexer_flags);
+		if (status != INPUT_SYSTEM_ERR_NO_ERROR)
+			return status;
 		config.multicast[port] = INPUT_SYSTEM_INPUT_BUFFER;
 
 		// Shared resource, so it should be blocked.
@@ -1159,10 +1132,10 @@ static input_system_err_t input_system_configure_channel_sensor(
 }
 
 // Test flags and set structure.
-static input_system_err_t set_source_type(
-    input_system_source_t *const lhs,
-    const input_system_source_t			rhs,
-    input_system_config_flags_t *const flags)
+static input_system_err_t
+set_source_type(input_system_source_t *const lhs,
+		const input_system_source_t rhs,
+		input_system_config_flags_t *const flags)
 {
 	// MW: Not enough asserts
 	assert(lhs);
@@ -1195,10 +1168,9 @@ static input_system_err_t set_source_type(
 }
 
 // Test flags and set structure.
-static input_system_err_t set_csi_cfg(
-    csi_cfg_t *const lhs,
-    const csi_cfg_t *const rhs,
-    input_system_config_flags_t *const flags)
+static input_system_err_t set_csi_cfg(csi_cfg_t *const lhs,
+				      const csi_cfg_t *const rhs,
+				      input_system_config_flags_t *const flags)
 {
 	u32 memory_required;
 	u32 acq_memory_required;
@@ -1214,13 +1186,17 @@ static input_system_err_t set_csi_cfg(
 	if (*flags & INPUT_SYSTEM_CFG_FLAG_SET) {
 		// check for consistency with already set value.
 		if (/*lhs->backend_ch == rhs.backend_ch
-			&&*/ lhs->buffering_mode == rhs->buffering_mode
-		    && lhs->csi_buffer.mem_reg_size == rhs->csi_buffer.mem_reg_size
-		    && lhs->csi_buffer.nof_mem_regs  == rhs->csi_buffer.nof_mem_regs
-		    && lhs->acquisition_buffer.mem_reg_size == rhs->acquisition_buffer.mem_reg_size
-		    && lhs->acquisition_buffer.nof_mem_regs  == rhs->acquisition_buffer.nof_mem_regs
-		    && lhs->nof_xmem_buffers  == rhs->nof_xmem_buffers
-		) {
+			&&*/
+			    lhs->buffering_mode == rhs->buffering_mode &&
+		    lhs->csi_buffer.mem_reg_size ==
+			    rhs->csi_buffer.mem_reg_size &&
+		    lhs->csi_buffer.nof_mem_regs ==
+			    rhs->csi_buffer.nof_mem_regs &&
+		    lhs->acquisition_buffer.mem_reg_size ==
+			    rhs->acquisition_buffer.mem_reg_size &&
+		    lhs->acquisition_buffer.nof_mem_regs ==
+			    rhs->acquisition_buffer.nof_mem_regs &&
+		    lhs->nof_xmem_buffers == rhs->nof_xmem_buffers) {
 			return INPUT_SYSTEM_ERR_NO_ERROR;
 		} else {
 			*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
@@ -1230,42 +1206,45 @@ static input_system_err_t set_csi_cfg(
 	// Check the value (individually).
 	// no check for backend_ch
 	// no check for nof_xmem_buffers
-	memory_required = rhs->csi_buffer.mem_reg_size * rhs->csi_buffer.nof_mem_regs;
+	memory_required =
+		rhs->csi_buffer.mem_reg_size * rhs->csi_buffer.nof_mem_regs;
 	acq_memory_required = rhs->acquisition_buffer.mem_reg_size *
 			      rhs->acquisition_buffer.nof_mem_regs;
-	if (rhs->buffering_mode >= N_INPUT_SYSTEM_BUFFERING_MODE
-	    ||
+	if (rhs->buffering_mode >= N_INPUT_SYSTEM_BUFFERING_MODE ||
 	    // Check if required memory is available in input buffer (SRAM).
-	    (memory_required + acq_memory_required) > config.unallocated_ib_mem_words
+	    (memory_required + acq_memory_required) >
+		    config.unallocated_ib_mem_words
 
-	   ) {
+	) {
 		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
 		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
 	}
 	// Set the value.
 	//lhs[port]->backend_ch		= rhs.backend_ch;
-	lhs->buffering_mode	= rhs->buffering_mode;
+	lhs->buffering_mode = rhs->buffering_mode;
 	lhs->nof_xmem_buffers = rhs->nof_xmem_buffers;
 
 	lhs->csi_buffer.mem_reg_size = rhs->csi_buffer.mem_reg_size;
-	lhs->csi_buffer.nof_mem_regs  = rhs->csi_buffer.nof_mem_regs;
-	lhs->acquisition_buffer.mem_reg_size = rhs->acquisition_buffer.mem_reg_size;
-	lhs->acquisition_buffer.nof_mem_regs  = rhs->acquisition_buffer.nof_mem_regs;
+	lhs->csi_buffer.nof_mem_regs = rhs->csi_buffer.nof_mem_regs;
+	lhs->acquisition_buffer.mem_reg_size =
+		rhs->acquisition_buffer.mem_reg_size;
+	lhs->acquisition_buffer.nof_mem_regs =
+		rhs->acquisition_buffer.nof_mem_regs;
 	// ALX: NB: Here we just set buffer parameters, but still not allocate it
 	// (no addresses determined). That will be done during commit.
 
 	//  FIXIT:	acq_memory_required is not deducted, since it can be allocated multiple times.
 	config.unallocated_ib_mem_words -= memory_required;
-//assert(config.unallocated_ib_mem_words >=0);
+	//assert(config.unallocated_ib_mem_words >=0);
 	*flags |= INPUT_SYSTEM_CFG_FLAG_SET;
 	return INPUT_SYSTEM_ERR_NO_ERROR;
 }
 
 // Test flags and set structure.
-static input_system_err_t input_system_multiplexer_cfg(
-    input_system_multiplex_t *const lhs,
-    const input_system_multiplex_t		rhs,
-    input_system_config_flags_t *const flags)
+static input_system_err_t
+input_system_multiplexer_cfg(input_system_multiplex_t *const lhs,
+			     const input_system_multiplex_t rhs,
+			     input_system_config_flags_t *const flags)
 {
 	assert(lhs);
 	assert(flags);
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq.c
index b66560bca62590efb7608f5b491321b454daaa18..51fb441dffaa16fc8c598205b5ac1aae742550f5 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq.c
@@ -10,13 +10,11 @@
 #ifndef __INLINE_GP_DEVICE__
 #define __INLINE_GP_DEVICE__
 #endif
-#include "gp_device.h"	/* _REG_GP_IRQ_REQUEST_ADDR */
+#include "gp_device.h" /* _REG_GP_IRQ_REQUEST_ADDR */
 
-static inline void irq_wait_for_write_complete(
-    const irq_ID_t		ID);
+static inline void irq_wait_for_write_complete(const irq_ID_t ID);
 
-static inline bool any_irq_channel_enabled(
-    const irq_ID_t				ID);
+static inline bool any_irq_channel_enabled(const irq_ID_t ID);
 
 static inline irq_ID_t virq_get_irq_id(const enum virq_id irq_ID,
 				       unsigned int *channel_ID);
@@ -25,32 +23,22 @@ static inline irq_ID_t virq_get_irq_id(const enum virq_id irq_ID,
 #include "irq_private.h"
 #endif /* __INLINE_IRQ__ */
 
-static unsigned short IRQ_N_CHANNEL[N_IRQ_ID] = {
-	IRQ0_ID_N_CHANNEL,
-	IRQ1_ID_N_CHANNEL,
-	IRQ2_ID_N_CHANNEL,
-	IRQ3_ID_N_CHANNEL
-};
+static unsigned short IRQ_N_CHANNEL[N_IRQ_ID] = { IRQ0_ID_N_CHANNEL,
+						  IRQ1_ID_N_CHANNEL,
+						  IRQ2_ID_N_CHANNEL,
+						  IRQ3_ID_N_CHANNEL };
 
 static unsigned short IRQ_N_ID_OFFSET[N_IRQ_ID + 1] = {
-	IRQ0_ID_OFFSET,
-	IRQ1_ID_OFFSET,
-	IRQ2_ID_OFFSET,
-	IRQ3_ID_OFFSET,
+	IRQ0_ID_OFFSET, IRQ1_ID_OFFSET, IRQ2_ID_OFFSET, IRQ3_ID_OFFSET,
 	IRQ_END_OFFSET
 };
 
-static enum virq_id IRQ_NESTING_ID[N_IRQ_ID] = {
-	N_virq_id,
-	virq_ifmt,
-	virq_isys,
-	virq_isel
-};
+static enum virq_id IRQ_NESTING_ID[N_IRQ_ID] = { N_virq_id, virq_ifmt,
+						 virq_isys, virq_isel };
 
-void irq_clear_all(
-    const irq_ID_t				ID)
+void irq_clear_all(const irq_ID_t ID)
 {
-	hrt_data	mask = 0xFFFFFFFF;
+	hrt_data mask = 0xFFFFFFFF;
 
 	assert(ID < N_IRQ_ID);
 	assert(IRQ_N_CHANNEL[ID] <= HRT_DATA_WIDTH);
@@ -59,24 +47,20 @@ void irq_clear_all(
 		mask = ~((~(hrt_data)0) >> IRQ_N_CHANNEL[ID]);
 	}
 
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, mask);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, mask);
 	return;
 }
 
 /*
  * Do we want the user to be able to set the signalling method ?
  */
-void irq_enable_channel(
-    const irq_ID_t				ID,
-    const unsigned int			irq_id)
+void irq_enable_channel(const irq_ID_t ID, const unsigned int irq_id)
 {
-	unsigned int mask = irq_reg_load(ID,
-					 _HRT_IRQ_CONTROLLER_MASK_REG_IDX);
-	unsigned int enable = irq_reg_load(ID,
-					   _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
-	unsigned int edge_in = irq_reg_load(ID,
-					    _HRT_IRQ_CONTROLLER_EDGE_REG_IDX);
+	unsigned int mask = irq_reg_load(ID, _HRT_IRQ_CONTROLLER_MASK_REG_IDX);
+	unsigned int enable =
+		irq_reg_load(ID, _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+	unsigned int edge_in =
+		irq_reg_load(ID, _HRT_IRQ_CONTROLLER_EDGE_REG_IDX);
 	unsigned int me = 1U << irq_id;
 
 	assert(ID < N_IRQ_ID);
@@ -84,34 +68,27 @@ void irq_enable_channel(
 
 	mask |= me;
 	enable |= me;
-	edge_in |= me;	/* rising edge */
+	edge_in |= me; /* rising edge */
 
 	/* to avoid mishaps configuration must follow the following order */
 
 	/* mask this interrupt */
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask & ~me);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask & ~me);
 	/* rising edge at input */
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_EDGE_REG_IDX, edge_in);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_EDGE_REG_IDX, edge_in);
 	/* enable interrupt to output */
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);
 	/* clear current irq only */
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);
 	/* unmask interrupt from input */
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);
 
 	irq_wait_for_write_complete(ID);
 
 	return;
 }
 
-void irq_enable_pulse(
-    const irq_ID_t	ID,
-    bool			pulse)
+void irq_enable_pulse(const irq_ID_t ID, bool pulse)
 {
 	unsigned int edge_out = 0x0;
 
@@ -119,19 +96,15 @@ void irq_enable_pulse(
 		edge_out = 0xffffffff;
 	}
 	/* output is given as edge, not pulse */
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX, edge_out);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX, edge_out);
 	return;
 }
 
-void irq_disable_channel(
-    const irq_ID_t				ID,
-    const unsigned int			irq_id)
+void irq_disable_channel(const irq_ID_t ID, const unsigned int irq_id)
 {
-	unsigned int mask = irq_reg_load(ID,
-					 _HRT_IRQ_CONTROLLER_MASK_REG_IDX);
-	unsigned int enable = irq_reg_load(ID,
-					   _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+	unsigned int mask = irq_reg_load(ID, _HRT_IRQ_CONTROLLER_MASK_REG_IDX);
+	unsigned int enable =
+		irq_reg_load(ID, _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
 	unsigned int me = 1U << irq_id;
 
 	assert(ID < N_IRQ_ID);
@@ -141,26 +114,22 @@ void irq_disable_channel(
 	enable &= ~me;
 
 	/* enable interrupt to output */
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);
 	/* unmask interrupt from input */
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);
 	/* clear current irq only */
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);
 
 	irq_wait_for_write_complete(ID);
 
 	return;
 }
 
-enum hrt_isp_css_irq_status irq_get_channel_id(
-    const irq_ID_t				ID,
-    unsigned int				*irq_id)
+enum hrt_isp_css_irq_status irq_get_channel_id(const irq_ID_t ID,
+					       unsigned int *irq_id)
 {
-	unsigned int irq_status = irq_reg_load(ID,
-					       _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+	unsigned int irq_status =
+		irq_reg_load(ID, _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
 	unsigned int idx;
 	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_success;
 
@@ -179,8 +148,7 @@ enum hrt_isp_css_irq_status irq_get_channel_id(
 	if (irq_status != (1U << idx))
 		status = hrt_isp_css_irq_status_more_irqs;
 
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);
 
 	irq_wait_for_write_complete(ID);
 
@@ -191,15 +159,12 @@ enum hrt_isp_css_irq_status irq_get_channel_id(
 }
 
 static const hrt_address IRQ_REQUEST_ADDR[N_IRQ_SW_CHANNEL_ID] = {
-	_REG_GP_IRQ_REQUEST0_ADDR,
-	_REG_GP_IRQ_REQUEST1_ADDR
+	_REG_GP_IRQ_REQUEST0_ADDR, _REG_GP_IRQ_REQUEST1_ADDR
 };
 
-void irq_raise(
-    const irq_ID_t				ID,
-    const irq_sw_channel_id_t	irq_id)
+void irq_raise(const irq_ID_t ID, const irq_sw_channel_id_t irq_id)
 {
-	hrt_address		addr;
+	hrt_address addr;
 
 	OP___assert(ID == IRQ0_ID);
 	OP___assert(IRQ_BASE[ID] != (hrt_address)-1);
@@ -209,28 +174,24 @@ void irq_raise(
 
 	addr = IRQ_REQUEST_ADDR[irq_id];
 	/* The SW IRQ pins are remapped to offset zero */
-	gp_device_reg_store(GP_DEVICE0_ID,
-			    (unsigned int)addr, 1);
-	gp_device_reg_store(GP_DEVICE0_ID,
-			    (unsigned int)addr, 0);
+	gp_device_reg_store(GP_DEVICE0_ID, (unsigned int)addr, 1);
+	gp_device_reg_store(GP_DEVICE0_ID, (unsigned int)addr, 0);
 	return;
 }
 
 bool any_virq_signal(void)
 {
-	unsigned int irq_status = irq_reg_load(IRQ0_ID,
-					       _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+	unsigned int irq_status =
+		irq_reg_load(IRQ0_ID, _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
 
 	return (irq_status != 0);
 }
 
-void cnd_virq_enable_channel(
-    const enum virq_id				irq_ID,
-    const bool					en)
+void cnd_virq_enable_channel(const enum virq_id irq_ID, const bool en)
 {
-	irq_ID_t		i;
-	unsigned int	channel_ID;
-	irq_ID_t		ID = virq_get_irq_id(irq_ID, &channel_ID);
+	irq_ID_t i;
+	unsigned int channel_ID;
+	irq_ID_t ID = virq_get_irq_id(irq_ID, &channel_ID);
 
 	assert(ID < N_IRQ_ID);
 
@@ -247,7 +208,8 @@ void cnd_virq_enable_channel(
 		}
 	} else {
 		irq_disable_channel(ID, channel_ID);
-		if ((IRQ_NESTING_ID[ID] != N_virq_id) && !any_irq_channel_enabled(ID)) {
+		if ((IRQ_NESTING_ID[ID] != N_virq_id) &&
+		    !any_irq_channel_enabled(ID)) {
 			/* Only disable the top if the nested ones are empty */
 			irq_disable_channel(IRQ0_ID, IRQ_NESTING_ID[ID]);
 		}
@@ -257,7 +219,7 @@ void cnd_virq_enable_channel(
 
 void virq_clear_all(void)
 {
-	irq_ID_t	irq_id;
+	irq_ID_t irq_id;
 
 	for (irq_id = (irq_ID_t)0; irq_id < N_IRQ_ID; irq_id++) {
 		irq_clear_all(irq_id);
@@ -265,18 +227,17 @@ void virq_clear_all(void)
 	return;
 }
 
-enum hrt_isp_css_irq_status
-virq_get_channel_signals(struct virq_info *irq_info)
+enum hrt_isp_css_irq_status virq_get_channel_signals(struct virq_info *irq_info)
 {
 	enum hrt_isp_css_irq_status irq_status = hrt_isp_css_irq_status_error;
 	irq_ID_t ID;
 
 	assert(irq_info);
 
-	for (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {
+	for (ID = (irq_ID_t)0; ID < N_IRQ_ID; ID++) {
 		if (any_irq_channel_enabled(ID)) {
-			hrt_data	irq_data = irq_reg_load(ID,
-							    _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+			hrt_data irq_data = irq_reg_load(
+				ID, _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
 
 			if (irq_data != 0) {
 				/* The error condition is an IRQ pulse received with no IRQ status written */
@@ -285,8 +246,8 @@ virq_get_channel_signals(struct virq_info *irq_info)
 
 			irq_info->irq_status_reg[ID] |= irq_data;
 
-			irq_reg_store(ID,
-				      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, irq_data);
+			irq_reg_store(ID, _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX,
+				      irq_data);
 
 			irq_wait_for_write_complete(ID);
 		}
@@ -301,17 +262,16 @@ void virq_clear_info(struct virq_info *irq_info)
 
 	assert(irq_info);
 
-	for (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {
+	for (ID = (irq_ID_t)0; ID < N_IRQ_ID; ID++) {
 		irq_info->irq_status_reg[ID] = 0;
 	}
 	return;
 }
 
-enum hrt_isp_css_irq_status virq_get_channel_id(
-    enum virq_id					*irq_id)
+enum hrt_isp_css_irq_status virq_get_channel_id(enum virq_id *irq_id)
 {
-	unsigned int irq_status = irq_reg_load(IRQ0_ID,
-					       _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+	unsigned int irq_status =
+		irq_reg_load(IRQ0_ID, _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
 	unsigned int idx;
 	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_success;
 	irq_ID_t ID;
@@ -334,7 +294,7 @@ enum hrt_isp_css_irq_status virq_get_channel_id(
 	}
 
 	/* Check whether we have an IRQ on one of the nested devices */
-	for (ID = N_IRQ_ID - 1 ; ID > (irq_ID_t)0; ID--) {
+	for (ID = N_IRQ_ID - 1; ID > (irq_ID_t)0; ID--) {
 		if (IRQ_NESTING_ID[ID] == (enum virq_id)idx) {
 			break;
 		}
@@ -342,8 +302,8 @@ enum hrt_isp_css_irq_status virq_get_channel_id(
 
 	/* If we have a nested IRQ, load that state, discard the device 0 state */
 	if (ID != IRQ0_ID) {
-		irq_status = irq_reg_load(ID,
-					  _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+		irq_status =
+			irq_reg_load(ID, _HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
 		/* find the first irq bit on device "id" */
 		for (idx = 0; idx < IRQ_N_CHANNEL[ID]; idx++) {
 			if (irq_status & (1U << idx))
@@ -360,13 +320,13 @@ enum hrt_isp_css_irq_status virq_get_channel_id(
 		} else {
 			/* If this device is empty, clear the state on device 0 */
 			irq_reg_store(IRQ0_ID,
-				      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << IRQ_NESTING_ID[ID]);
+				      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX,
+				      1U << IRQ_NESTING_ID[ID]);
 		}
 	} /* if (ID != IRQ0_ID) */
 
 	/* Here we proceed to clear the IRQ on detected device, if no nested IRQ, this is device 0 */
-	irq_reg_store(ID,
-		      _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);
+	irq_reg_store(ID, _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);
 
 	irq_wait_for_write_complete(ID);
 
@@ -377,37 +337,34 @@ enum hrt_isp_css_irq_status virq_get_channel_id(
 	return status;
 }
 
-static inline void irq_wait_for_write_complete(
-    const irq_ID_t		ID)
+static inline void irq_wait_for_write_complete(const irq_ID_t ID)
 {
 	assert(ID < N_IRQ_ID);
 	assert(IRQ_BASE[ID] != (hrt_address)-1);
 	(void)ia_css_device_load_uint32(IRQ_BASE[ID] +
-					_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX * sizeof(hrt_data));
+					_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX *
+						sizeof(hrt_data));
 }
 
-static inline bool any_irq_channel_enabled(
-    const irq_ID_t				ID)
+static inline bool any_irq_channel_enabled(const irq_ID_t ID)
 {
-	hrt_data	en_reg;
+	hrt_data en_reg;
 
 	assert(ID < N_IRQ_ID);
 
-	en_reg = irq_reg_load(ID,
-			      _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+	en_reg = irq_reg_load(ID, _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
 
 	return (en_reg != 0);
 }
 
-static inline irq_ID_t virq_get_irq_id(
-    const enum virq_id		irq_ID,
-    unsigned int		*channel_ID)
+static inline irq_ID_t virq_get_irq_id(const enum virq_id irq_ID,
+				       unsigned int *channel_ID)
 {
 	irq_ID_t ID;
 
 	assert(channel_ID);
 
-	for (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {
+	for (ID = (irq_ID_t)0; ID < N_IRQ_ID; ID++) {
 		if (irq_ID < IRQ_N_ID_OFFSET[ID + 1]) {
 			break;
 		}
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq_local.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq_local.h
index c74cd18c7aecb7e6d4830eb3e61e12c9df7d240c..31b82ce2b51cd8083c3afa9352f4e33c7ed835b0 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq_local.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq_local.h
@@ -13,97 +13,117 @@
 
 /* IRQ0_ID */
 #include "hive_isp_css_defs.h"
-#define HIVE_GP_DEV_IRQ_NUM_IRQS	32
+#define HIVE_GP_DEV_IRQ_NUM_IRQS 32
 /* IRQ1_ID */
 #include "input_formatter_subsystem_defs.h"
-#define HIVE_IFMT_IRQ_NUM_IRQS		5
+#define HIVE_IFMT_IRQ_NUM_IRQS 5
 /* IRQ2_ID */
 #include "input_system_defs.h"
 /* IRQ3_ID */
 #include "input_selector_defs.h"
 
-#define	IRQ_ID_OFFSET	32
-#define	IRQ0_ID_OFFSET	0
-#define	IRQ1_ID_OFFSET	IRQ_ID_OFFSET
-#define	IRQ2_ID_OFFSET	(2 * IRQ_ID_OFFSET)
-#define	IRQ3_ID_OFFSET	(3 * IRQ_ID_OFFSET)
-#define	IRQ_END_OFFSET	(4 * IRQ_ID_OFFSET)
+#define IRQ_ID_OFFSET 32
+#define IRQ0_ID_OFFSET 0
+#define IRQ1_ID_OFFSET IRQ_ID_OFFSET
+#define IRQ2_ID_OFFSET (2 * IRQ_ID_OFFSET)
+#define IRQ3_ID_OFFSET (3 * IRQ_ID_OFFSET)
+#define IRQ_END_OFFSET (4 * IRQ_ID_OFFSET)
 
-#define	IRQ0_ID_N_CHANNEL	HIVE_GP_DEV_IRQ_NUM_IRQS
-#define	IRQ1_ID_N_CHANNEL	HIVE_IFMT_IRQ_NUM_IRQS
-#define	IRQ2_ID_N_CHANNEL	HIVE_ISYS_IRQ_NUM_BITS
-#define	IRQ3_ID_N_CHANNEL	HIVE_ISEL_IRQ_NUM_IRQS
+#define IRQ0_ID_N_CHANNEL HIVE_GP_DEV_IRQ_NUM_IRQS
+#define IRQ1_ID_N_CHANNEL HIVE_IFMT_IRQ_NUM_IRQS
+#define IRQ2_ID_N_CHANNEL HIVE_ISYS_IRQ_NUM_BITS
+#define IRQ3_ID_N_CHANNEL HIVE_ISEL_IRQ_NUM_IRQS
 
 enum virq_id {
-	virq_gpio_pin_0            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID,
-	virq_gpio_pin_1            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID,
-	virq_gpio_pin_2            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID,
-	virq_gpio_pin_3            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID,
-	virq_gpio_pin_4            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID,
-	virq_gpio_pin_5            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID,
-	virq_gpio_pin_6            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID,
-	virq_gpio_pin_7            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID,
-	virq_gpio_pin_8            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID,
-	virq_gpio_pin_9            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID,
-	virq_gpio_pin_10           = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID,
-	virq_gpio_pin_11           = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID,
-	virq_sp                    = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_BIT_ID,
-	virq_isp                   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_BIT_ID,
-	virq_isys                  = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISYS_BIT_ID,
-	virq_isel                  = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISEL_BIT_ID,
-	virq_ifmt                  = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_IFMT_BIT_ID,
-	virq_sp_stream_mon         = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID,
-	virq_isp_stream_mon        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID,
-	virq_mod_stream_mon        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID,
-	virq_isp_pmem_error        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID,
-	virq_isp_bamem_error       = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID,
-	virq_isp_dmem_error        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID,
-	virq_sp_icache_mem_error   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID,
-	virq_sp_dmem_error         = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID,
-	virq_mmu_cache_mem_error   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID,
-	virq_gp_timer_0            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID,
-	virq_gp_timer_1            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID,
-	virq_sw_pin_0              = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID,
-	virq_sw_pin_1              = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID,
-	virq_dma                   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_DMA_BIT_ID,
-	virq_sp_stream_mon_b       = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID,
+	virq_gpio_pin_0 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID,
+	virq_gpio_pin_1 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID,
+	virq_gpio_pin_2 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID,
+	virq_gpio_pin_3 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID,
+	virq_gpio_pin_4 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID,
+	virq_gpio_pin_5 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID,
+	virq_gpio_pin_6 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID,
+	virq_gpio_pin_7 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID,
+	virq_gpio_pin_8 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID,
+	virq_gpio_pin_9 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID,
+	virq_gpio_pin_10 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID,
+	virq_gpio_pin_11 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID,
+	virq_sp = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_BIT_ID,
+	virq_isp = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_BIT_ID,
+	virq_isys = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISYS_BIT_ID,
+	virq_isel = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISEL_BIT_ID,
+	virq_ifmt = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_IFMT_BIT_ID,
+	virq_sp_stream_mon =
+		IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID,
+	virq_isp_stream_mon =
+		IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID,
+	virq_mod_stream_mon =
+		IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID,
+	virq_isp_pmem_error =
+		IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID,
+	virq_isp_bamem_error =
+		IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID,
+	virq_isp_dmem_error =
+		IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID,
+	virq_sp_icache_mem_error =
+		IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID,
+	virq_sp_dmem_error =
+		IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID,
+	virq_mmu_cache_mem_error =
+		IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID,
+	virq_gp_timer_0 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID,
+	virq_gp_timer_1 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID,
+	virq_sw_pin_0 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID,
+	virq_sw_pin_1 = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID,
+	virq_dma = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_DMA_BIT_ID,
+	virq_sp_stream_mon_b =
+		IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID,
 
-	virq_ifmt0_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_PRIM_BIT_ID,
-	virq_ifmt1_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_PRIM_B_BIT_ID,
-	virq_ifmt2_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_SEC_BIT_ID,
-	virq_ifmt3_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_MEM_CPY_BIT_ID,
-	virq_ifmt_sideband_changed = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_SIDEBAND_CHANGED_BIT_ID,
+	virq_ifmt0_id = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_PRIM_BIT_ID,
+	virq_ifmt1_id = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_PRIM_B_BIT_ID,
+	virq_ifmt2_id = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_SEC_BIT_ID,
+	virq_ifmt3_id = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_MEM_CPY_BIT_ID,
+	virq_ifmt_sideband_changed =
+		IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_SIDEBAND_CHANGED_BIT_ID,
 
-	virq_isys_sof              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_SOF_BIT_ID,
-	virq_isys_eof              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_EOF_BIT_ID,
-	virq_isys_sol              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_SOL_BIT_ID,
-	virq_isys_eol              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_EOL_BIT_ID,
-	virq_isys_csi              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_RECEIVER_BIT_ID,
-	virq_isys_csi_be           = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_RECEIVER_BE_BIT_ID,
-	virq_isys_capt0_id_no_sop  = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_A_NO_SOP,
-	virq_isys_capt0_id_late_sop = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_A_LATE_SOP,
-	virq_isys_capt1_id_no_sop  = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_B_NO_SOP,
-	virq_isys_capt1_id_late_sop = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_B_LATE_SOP,
-	virq_isys_capt2_id_no_sop  = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_C_NO_SOP,
-	virq_isys_capt2_id_late_sop = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_C_LATE_SOP,
-	virq_isys_acq_sop_mismatch = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_ACQ_UNIT_SOP_MISMATCH,
-	virq_isys_ctrl_capt0       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPA,
-	virq_isys_ctrl_capt1       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPB,
-	virq_isys_ctrl_capt2       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPC,
-	virq_isys_cio_to_ahb       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CIO2AHB,
-	virq_isys_dma              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_DMA_BIT_ID,
-	virq_isys_fifo_monitor     = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_STREAM_MON_BIT_ID,
+	virq_isys_sof = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_SOF_BIT_ID,
+	virq_isys_eof = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_EOF_BIT_ID,
+	virq_isys_sol = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_SOL_BIT_ID,
+	virq_isys_eol = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_EOL_BIT_ID,
+	virq_isys_csi = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_RECEIVER_BIT_ID,
+	virq_isys_csi_be =
+		IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_RECEIVER_BE_BIT_ID,
+	virq_isys_capt0_id_no_sop =
+		IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_A_NO_SOP,
+	virq_isys_capt0_id_late_sop =
+		IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_A_LATE_SOP,
+	virq_isys_capt1_id_no_sop =
+		IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_B_NO_SOP,
+	virq_isys_capt1_id_late_sop =
+		IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_B_LATE_SOP,
+	virq_isys_capt2_id_no_sop =
+		IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_C_NO_SOP,
+	virq_isys_capt2_id_late_sop =
+		IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_C_LATE_SOP,
+	virq_isys_acq_sop_mismatch =
+		IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_ACQ_UNIT_SOP_MISMATCH,
+	virq_isys_ctrl_capt0 = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPA,
+	virq_isys_ctrl_capt1 = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPB,
+	virq_isys_ctrl_capt2 = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPC,
+	virq_isys_cio_to_ahb = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CIO2AHB,
+	virq_isys_dma = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_DMA_BIT_ID,
+	virq_isys_fifo_monitor =
+		IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_STREAM_MON_BIT_ID,
 
-	virq_isel_sof              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_SOF_BIT_ID,
-	virq_isel_eof              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_EOF_BIT_ID,
-	virq_isel_sol              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_SOL_BIT_ID,
-	virq_isel_eol              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_EOL_BIT_ID,
+	virq_isel_sof = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_SOF_BIT_ID,
+	virq_isel_eof = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_EOF_BIT_ID,
+	virq_isel_sol = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_SOL_BIT_ID,
+	virq_isel_eol = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_EOL_BIT_ID,
 
-	N_virq_id                  = IRQ_END_OFFSET
+	N_virq_id = IRQ_END_OFFSET
 };
 
 struct virq_info {
-	hrt_data		irq_status_reg[N_IRQ_ID];
+	hrt_data irq_status_reg[N_IRQ_ID];
 };
 
 #endif /* __IRQ_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq_private.h
index ae0a8466a70a021f30be1f3d8eed5b9c0f604958..44b819a99c123d9c9686f916232163be301afce7 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/irq_private.h
@@ -13,23 +13,21 @@
 
 #include "assert_support.h"
 
-STORAGE_CLASS_IRQ_C void irq_reg_store(
-    const irq_ID_t		ID,
-    const unsigned int	reg,
-    const hrt_data		value)
+STORAGE_CLASS_IRQ_C void
+irq_reg_store(const irq_ID_t ID, const unsigned int reg, const hrt_data value)
 {
 	assert(ID < N_IRQ_ID);
-	assert(IRQ_BASE[ID] != (hrt_address) - 1);
-	ia_css_device_store_uint32(IRQ_BASE[ID] + reg * sizeof(hrt_data), value);
+	assert(IRQ_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(IRQ_BASE[ID] + reg * sizeof(hrt_data),
+				   value);
 	return;
 }
 
-STORAGE_CLASS_IRQ_C hrt_data irq_reg_load(
-    const irq_ID_t		ID,
-    const unsigned int	reg)
+STORAGE_CLASS_IRQ_C hrt_data irq_reg_load(const irq_ID_t ID,
+					  const unsigned int reg)
 {
 	assert(ID < N_IRQ_ID);
-	assert(IRQ_BASE[ID] != (hrt_address) - 1);
+	assert(IRQ_BASE[ID] != (hrt_address)-1);
 	return ia_css_device_load_uint32(IRQ_BASE[ID] + reg * sizeof(hrt_data));
 }
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp.c
index 39cccbfa3fcaa19014703c81d4f2a70ccc9a0625..be2f619640bbe714a0a86336d22f819b0c5af41c 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp.c
@@ -15,17 +15,14 @@
 
 #include "assert_support.h"
 
-void cnd_isp_irq_enable(
-    const isp_ID_t		ID,
-    const bool		cnd)
+void cnd_isp_irq_enable(const isp_ID_t ID, const bool cnd)
 {
 	if (cnd) {
 		isp_ctrl_setbit(ID, ISP_IRQ_READY_REG, ISP_IRQ_READY_BIT);
 		/* Enabling the IRQ immediately triggers an interrupt, clear it */
 		isp_ctrl_setbit(ID, ISP_IRQ_CLEAR_REG, ISP_IRQ_CLEAR_BIT);
 	} else {
-		isp_ctrl_clearbit(ID, ISP_IRQ_READY_REG,
-				  ISP_IRQ_READY_BIT);
+		isp_ctrl_clearbit(ID, ISP_IRQ_READY_REG, ISP_IRQ_READY_BIT);
 	}
 	return;
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp_local.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp_local.h
index b5c1ba55c991263b1a5f7005990f18b5af8fce80..18b6f88506e11c384fb6cb7da2b6507c02813df2 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp_local.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp_local.h
@@ -11,6 +11,6 @@
 
 #include <isp2400_support.h>
 
-#define HIVE_ISP_VMEM_MASK	((1U << ISP_VMEM_ELEMBITS) - 1)
+#define HIVE_ISP_VMEM_MASK ((1U << ISP_VMEM_ELEMBITS) - 1)
 
 #endif /* __ISP_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp_private.h
index 177770a9bc1d64fe128ef6360f9c0404ac2cd4fa..4ec0433af675470e61f48906e099dcf312541cc6 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/isp_private.h
@@ -18,74 +18,69 @@
 #include "assert_support.h"
 #include "type_support.h"
 
-STORAGE_CLASS_ISP_C void isp_ctrl_store(
-    const isp_ID_t		ID,
-    const unsigned int	reg,
-    const hrt_data		value)
+STORAGE_CLASS_ISP_C void
+isp_ctrl_store(const isp_ID_t ID, const unsigned int reg, const hrt_data value)
 {
 	assert(ID < N_ISP_ID);
-	assert(ISP_CTRL_BASE[ID] != (hrt_address) - 1);
+	assert(ISP_CTRL_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
-	ia_css_device_store_uint32(ISP_CTRL_BASE[ID] + reg * sizeof(hrt_data), value);
+	ia_css_device_store_uint32(ISP_CTRL_BASE[ID] + reg * sizeof(hrt_data),
+				   value);
 #else
-	hrt_master_port_store_32(ISP_CTRL_BASE[ID] + reg * sizeof(hrt_data), value);
+	hrt_master_port_store_32(ISP_CTRL_BASE[ID] + reg * sizeof(hrt_data),
+				 value);
 #endif
 	return;
 }
 
-STORAGE_CLASS_ISP_C hrt_data isp_ctrl_load(
-    const isp_ID_t		ID,
-    const unsigned int	reg)
+STORAGE_CLASS_ISP_C hrt_data isp_ctrl_load(const isp_ID_t ID,
+					   const unsigned int reg)
 {
 	assert(ID < N_ISP_ID);
-	assert(ISP_CTRL_BASE[ID] != (hrt_address) - 1);
+	assert(ISP_CTRL_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
-	return ia_css_device_load_uint32(ISP_CTRL_BASE[ID] + reg * sizeof(hrt_data));
+	return ia_css_device_load_uint32(ISP_CTRL_BASE[ID] +
+					 reg * sizeof(hrt_data));
 #else
-	return hrt_master_port_uload_32(ISP_CTRL_BASE[ID] + reg * sizeof(hrt_data));
+	return hrt_master_port_uload_32(ISP_CTRL_BASE[ID] +
+					reg * sizeof(hrt_data));
 #endif
 }
 
-STORAGE_CLASS_ISP_C bool isp_ctrl_getbit(
-    const isp_ID_t		ID,
-    const unsigned int	reg,
-    const unsigned int	bit)
+STORAGE_CLASS_ISP_C bool isp_ctrl_getbit(const isp_ID_t ID,
+					 const unsigned int reg,
+					 const unsigned int bit)
 {
 	hrt_data val = isp_ctrl_load(ID, reg);
 
 	return (val & (1UL << bit)) != 0;
 }
 
-STORAGE_CLASS_ISP_C void isp_ctrl_setbit(
-    const isp_ID_t		ID,
-    const unsigned int	reg,
-    const unsigned int	bit)
+STORAGE_CLASS_ISP_C void isp_ctrl_setbit(const isp_ID_t ID,
+					 const unsigned int reg,
+					 const unsigned int bit)
 {
-	hrt_data	data = isp_ctrl_load(ID, reg);
+	hrt_data data = isp_ctrl_load(ID, reg);
 
 	isp_ctrl_store(ID, reg, (data | (1UL << bit)));
 	return;
 }
 
-STORAGE_CLASS_ISP_C void isp_ctrl_clearbit(
-    const isp_ID_t		ID,
-    const unsigned int	reg,
-    const unsigned int	bit)
+STORAGE_CLASS_ISP_C void isp_ctrl_clearbit(const isp_ID_t ID,
+					   const unsigned int reg,
+					   const unsigned int bit)
 {
-	hrt_data	data = isp_ctrl_load(ID, reg);
+	hrt_data data = isp_ctrl_load(ID, reg);
 
 	isp_ctrl_store(ID, reg, (data & ~(1UL << bit)));
 	return;
 }
 
-STORAGE_CLASS_ISP_C void isp_dmem_store(
-    const isp_ID_t		ID,
-    unsigned int		addr,
-    const void		*data,
-    const size_t		size)
+STORAGE_CLASS_ISP_C void isp_dmem_store(const isp_ID_t ID, unsigned int addr,
+					const void *data, const size_t size)
 {
 	assert(ID < N_ISP_ID);
-	assert(ISP_DMEM_BASE[ID] != (hrt_address) - 1);
+	assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
 	ia_css_device_store(ISP_DMEM_BASE[ID] + addr, data, size);
 #else
@@ -94,14 +89,12 @@ STORAGE_CLASS_ISP_C void isp_dmem_store(
 	return;
 }
 
-STORAGE_CLASS_ISP_C void isp_dmem_load(
-    const isp_ID_t		ID,
-    const unsigned int	addr,
-    void			*data,
-    const size_t		size)
+STORAGE_CLASS_ISP_C void isp_dmem_load(const isp_ID_t ID,
+				       const unsigned int addr, void *data,
+				       const size_t size)
 {
 	assert(ID < N_ISP_ID);
-	assert(ISP_DMEM_BASE[ID] != (hrt_address) - 1);
+	assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
 	ia_css_device_load(ISP_DMEM_BASE[ID] + addr, data, size);
 #else
@@ -110,13 +103,11 @@ STORAGE_CLASS_ISP_C void isp_dmem_load(
 	return;
 }
 
-STORAGE_CLASS_ISP_C void isp_dmem_store_uint32(
-    const isp_ID_t		ID,
-    unsigned int		addr,
-    const uint32_t		data)
+STORAGE_CLASS_ISP_C void
+isp_dmem_store_uint32(const isp_ID_t ID, unsigned int addr, const uint32_t data)
 {
 	assert(ID < N_ISP_ID);
-	assert(ISP_DMEM_BASE[ID] != (hrt_address) - 1);
+	assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
 	(void)ID;
 #if !defined(HRT_MEMORY_ACCESS)
 	ia_css_device_store_uint32(ISP_DMEM_BASE[ID] + addr, data);
@@ -126,12 +117,11 @@ STORAGE_CLASS_ISP_C void isp_dmem_store_uint32(
 	return;
 }
 
-STORAGE_CLASS_ISP_C uint32_t isp_dmem_load_uint32(
-    const isp_ID_t		ID,
-    const unsigned int	addr)
+STORAGE_CLASS_ISP_C uint32_t isp_dmem_load_uint32(const isp_ID_t ID,
+						  const unsigned int addr)
 {
 	assert(ID < N_ISP_ID);
-	assert(ISP_DMEM_BASE[ID] != (hrt_address) - 1);
+	assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
 	(void)ID;
 #if !defined(HRT_MEMORY_ACCESS)
 	return ia_css_device_load_uint32(ISP_DMEM_BASE[ID] + addr);
@@ -140,12 +130,10 @@ STORAGE_CLASS_ISP_C uint32_t isp_dmem_load_uint32(
 #endif
 }
 
-STORAGE_CLASS_ISP_C uint32_t isp_2w_cat_1w(
-    const u16		x0,
-    const uint16_t		x1)
+STORAGE_CLASS_ISP_C uint32_t isp_2w_cat_1w(const u16 x0, const uint16_t x1)
 {
-	u32 out = ((uint32_t)(x1 & HIVE_ISP_VMEM_MASK) << ISP_VMEM_ELEMBITS)
-		  | (x0 & HIVE_ISP_VMEM_MASK);
+	u32 out = ((uint32_t)(x1 & HIVE_ISP_VMEM_MASK) << ISP_VMEM_ELEMBITS) |
+		  (x0 & HIVE_ISP_VMEM_MASK);
 	return out;
 }
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/mmu.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/mmu.c
index 064e88a5e06442d6ca1ed9e881c337ac73a9e00c..e5b9574b12d270603599b959c1d41d2193d1e97a 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/mmu.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/mmu.c
@@ -7,22 +7,18 @@
 /* The name "mmu.h is already taken" */
 #include "mmu_device.h"
 
-void mmu_set_page_table_base_index(
-    const mmu_ID_t		ID,
-    const hrt_data		base_index)
+void mmu_set_page_table_base_index(const mmu_ID_t ID, const hrt_data base_index)
 {
 	mmu_reg_store(ID, _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX, base_index);
 	return;
 }
 
-hrt_data mmu_get_page_table_base_index(
-    const mmu_ID_t		ID)
+hrt_data mmu_get_page_table_base_index(const mmu_ID_t ID)
 {
 	return mmu_reg_load(ID, _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX);
 }
 
-void mmu_invalidate_cache(
-    const mmu_ID_t		ID)
+void mmu_invalidate_cache(const mmu_ID_t ID)
 {
 	mmu_reg_store(ID, _HRT_MMU_INVALIDATE_TLB_REG_IDX, 1);
 	return;
@@ -30,7 +26,7 @@ void mmu_invalidate_cache(
 
 void mmu_invalidate_cache_all(void)
 {
-	mmu_ID_t	mmu_id;
+	mmu_ID_t mmu_id;
 
 	for (mmu_id = (mmu_ID_t)0; mmu_id < N_MMU_ID; mmu_id++) {
 		mmu_invalidate_cache(mmu_id);
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp.c
index 0fb8a675439e2ffaf4c15bd9ea3b2a27a84f45d0..9fe8c94c222a29a218682813b0e35229a0f458ac 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp.c
@@ -12,9 +12,7 @@
 
 #include "assert_support.h"
 
-void cnd_sp_irq_enable(
-    const sp_ID_t		ID,
-    const bool		cnd)
+void cnd_sp_irq_enable(const sp_ID_t ID, const bool cnd)
 {
 	if (cnd) {
 		sp_ctrl_setbit(ID, SP_IRQ_READY_REG, SP_IRQ_READY_BIT);
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp_local.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp_local.h
index 48546491eb838410dcd4e5d18d43d25375d83265..c1be4c48b3ec020fb181a8269125ec4be2ca03cc 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp_local.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp_local.h
@@ -10,58 +10,64 @@
 #include <type_support.h>
 #include "sp_global.h"
 
-#define sp_address_of(var)	(HIVE_ADDR_ ## var)
+#define sp_address_of(var) (HIVE_ADDR_##var)
 
 /*
  * deprecated
  */
-#define store_sp_int(var, value) \
+#define store_sp_int(var, value)                                       \
 	sp_dmem_store_uint32(SP0_ID, (unsigned int)sp_address_of(var), \
-		(uint32_t)(value))
+			     (uint32_t)(value))
 
-#define store_sp_ptr(var, value) \
+#define store_sp_ptr(var, value)                                       \
 	sp_dmem_store_uint32(SP0_ID, (unsigned int)sp_address_of(var), \
-		(uint32_t)(value))
+			     (uint32_t)(value))
 
 #define load_sp_uint(var) \
 	sp_dmem_load_uint32(SP0_ID, (unsigned int)sp_address_of(var))
 
-#define load_sp_array_uint8(array_name, index) \
+#define load_sp_array_uint8(array_name, index)                               \
 	sp_dmem_load_uint8(SP0_ID, (unsigned int)sp_address_of(array_name) + \
-		(index) * sizeof(uint8_t))
+					   (index) * sizeof(uint8_t))
 
-#define load_sp_array_uint16(array_name, index) \
+#define load_sp_array_uint16(array_name, index)                               \
 	sp_dmem_load_uint16(SP0_ID, (unsigned int)sp_address_of(array_name) + \
-		(index) * sizeof(uint16_t))
+					    (index) * sizeof(uint16_t))
 
-#define load_sp_array_uint(array_name, index) \
+#define load_sp_array_uint(array_name, index)                                 \
 	sp_dmem_load_uint32(SP0_ID, (unsigned int)sp_address_of(array_name) + \
-		(index) * sizeof(uint32_t))
+					    (index) * sizeof(uint32_t))
 
 #define store_sp_var(var, data, bytes) \
 	sp_dmem_store(SP0_ID, (unsigned int)sp_address_of(var), data, bytes)
 
-#define store_sp_array_uint8(array_name, index, value) \
-	sp_dmem_store_uint8(SP0_ID, (unsigned int)sp_address_of(array_name) + \
-		(index) * sizeof(uint8_t), value)
+#define store_sp_array_uint8(array_name, index, value)                \
+	sp_dmem_store_uint8(SP0_ID,                                   \
+			    (unsigned int)sp_address_of(array_name) + \
+				    (index) * sizeof(uint8_t),        \
+			    value)
 
-#define store_sp_array_uint16(array_name, index, value) \
-	sp_dmem_store_uint16(SP0_ID, (unsigned int)sp_address_of(array_name) + \
-		(index) * sizeof(uint16_t), value)
+#define store_sp_array_uint16(array_name, index, value)                \
+	sp_dmem_store_uint16(SP0_ID,                                   \
+			     (unsigned int)sp_address_of(array_name) + \
+				     (index) * sizeof(uint16_t),       \
+			     value)
 
-#define store_sp_array_uint(array_name, index, value) \
-	sp_dmem_store_uint32(SP0_ID, (unsigned int)sp_address_of(array_name) + \
-		(index) * sizeof(uint32_t), value)
+#define store_sp_array_uint(array_name, index, value)                  \
+	sp_dmem_store_uint32(SP0_ID,                                   \
+			     (unsigned int)sp_address_of(array_name) + \
+				     (index) * sizeof(uint32_t),       \
+			     value)
 
-#define store_sp_var_with_offset(var, offset, data, bytes) \
-	sp_dmem_store(SP0_ID, (unsigned int)sp_address_of(var) + \
-		offset, data, bytes)
+#define store_sp_var_with_offset(var, offset, data, bytes)                     \
+	sp_dmem_store(SP0_ID, (unsigned int)sp_address_of(var) + offset, data, \
+		      bytes)
 
 #define load_sp_var(var, data, bytes) \
 	sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(var), data, bytes)
 
-#define load_sp_var_with_offset(var, offset, data, bytes) \
-	sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(var) + offset, \
-		data, bytes)
+#define load_sp_var_with_offset(var, offset, data, bytes)                     \
+	sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(var) + offset, data, \
+		     bytes)
 
 #endif /* __SP_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp_private.h
index c69778411f2f08819217281e685f9223c0124b6f..75ec999afb34dec343bba0f571d6b6a6d17fca0e 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/sp_private.h
@@ -13,63 +13,54 @@
 
 #include "assert_support.h"
 
-STORAGE_CLASS_SP_C void sp_ctrl_store(
-    const sp_ID_t		ID,
-    const hrt_address	reg,
-    const hrt_data		value)
+STORAGE_CLASS_SP_C void sp_ctrl_store(const sp_ID_t ID, const hrt_address reg,
+				      const hrt_data value)
 {
 	assert(ID < N_SP_ID);
 	assert(SP_CTRL_BASE[ID] != (hrt_address)-1);
-	ia_css_device_store_uint32(SP_CTRL_BASE[ID] + reg * sizeof(hrt_data), value);
+	ia_css_device_store_uint32(SP_CTRL_BASE[ID] + reg * sizeof(hrt_data),
+				   value);
 	return;
 }
 
-STORAGE_CLASS_SP_C hrt_data sp_ctrl_load(
-    const sp_ID_t		ID,
-    const hrt_address	reg)
+STORAGE_CLASS_SP_C hrt_data sp_ctrl_load(const sp_ID_t ID,
+					 const hrt_address reg)
 {
 	assert(ID < N_SP_ID);
 	assert(SP_CTRL_BASE[ID] != (hrt_address)-1);
-	return ia_css_device_load_uint32(SP_CTRL_BASE[ID] + reg * sizeof(hrt_data));
+	return ia_css_device_load_uint32(SP_CTRL_BASE[ID] +
+					 reg * sizeof(hrt_data));
 }
 
-STORAGE_CLASS_SP_C bool sp_ctrl_getbit(
-    const sp_ID_t		ID,
-    const hrt_address	reg,
-    const unsigned int	bit)
+STORAGE_CLASS_SP_C bool sp_ctrl_getbit(const sp_ID_t ID, const hrt_address reg,
+				       const unsigned int bit)
 {
 	hrt_data val = sp_ctrl_load(ID, reg);
 
 	return (val & (1UL << bit)) != 0;
 }
 
-STORAGE_CLASS_SP_C void sp_ctrl_setbit(
-    const sp_ID_t		ID,
-    const hrt_address	reg,
-    const unsigned int	bit)
+STORAGE_CLASS_SP_C void sp_ctrl_setbit(const sp_ID_t ID, const hrt_address reg,
+				       const unsigned int bit)
 {
-	hrt_data	data = sp_ctrl_load(ID, reg);
+	hrt_data data = sp_ctrl_load(ID, reg);
 
 	sp_ctrl_store(ID, reg, (data | (1UL << bit)));
 	return;
 }
 
-STORAGE_CLASS_SP_C void sp_ctrl_clearbit(
-    const sp_ID_t		ID,
-    const hrt_address	reg,
-    const unsigned int	bit)
+STORAGE_CLASS_SP_C void sp_ctrl_clearbit(const sp_ID_t ID,
+					 const hrt_address reg,
+					 const unsigned int bit)
 {
-	hrt_data	data = sp_ctrl_load(ID, reg);
+	hrt_data data = sp_ctrl_load(ID, reg);
 
 	sp_ctrl_store(ID, reg, (data & ~(1UL << bit)));
 	return;
 }
 
-STORAGE_CLASS_SP_C void sp_dmem_store(
-    const sp_ID_t		ID,
-    hrt_address		addr,
-    const void			*data,
-    const size_t		size)
+STORAGE_CLASS_SP_C void sp_dmem_store(const sp_ID_t ID, hrt_address addr,
+				      const void *data, const size_t size)
 {
 	assert(ID < N_SP_ID);
 	assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
@@ -77,11 +68,8 @@ STORAGE_CLASS_SP_C void sp_dmem_store(
 	return;
 }
 
-STORAGE_CLASS_SP_C void sp_dmem_load(
-    const sp_ID_t		ID,
-    const hrt_address	addr,
-    void				*data,
-    const size_t		size)
+STORAGE_CLASS_SP_C void sp_dmem_load(const sp_ID_t ID, const hrt_address addr,
+				     void *data, const size_t size)
 {
 	assert(ID < N_SP_ID);
 	assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
@@ -89,10 +77,8 @@ STORAGE_CLASS_SP_C void sp_dmem_load(
 	return;
 }
 
-STORAGE_CLASS_SP_C void sp_dmem_store_uint8(
-    const sp_ID_t		ID,
-    hrt_address		addr,
-    const uint8_t		data)
+STORAGE_CLASS_SP_C void sp_dmem_store_uint8(const sp_ID_t ID, hrt_address addr,
+					    const uint8_t data)
 {
 	assert(ID < N_SP_ID);
 	assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
@@ -101,10 +87,8 @@ STORAGE_CLASS_SP_C void sp_dmem_store_uint8(
 	return;
 }
 
-STORAGE_CLASS_SP_C void sp_dmem_store_uint16(
-    const sp_ID_t		ID,
-    hrt_address		addr,
-    const uint16_t		data)
+STORAGE_CLASS_SP_C void sp_dmem_store_uint16(const sp_ID_t ID, hrt_address addr,
+					     const uint16_t data)
 {
 	assert(ID < N_SP_ID);
 	assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
@@ -113,10 +97,8 @@ STORAGE_CLASS_SP_C void sp_dmem_store_uint16(
 	return;
 }
 
-STORAGE_CLASS_SP_C void sp_dmem_store_uint32(
-    const sp_ID_t		ID,
-    hrt_address		addr,
-    const uint32_t		data)
+STORAGE_CLASS_SP_C void sp_dmem_store_uint32(const sp_ID_t ID, hrt_address addr,
+					     const uint32_t data)
 {
 	assert(ID < N_SP_ID);
 	assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
@@ -125,9 +107,8 @@ STORAGE_CLASS_SP_C void sp_dmem_store_uint32(
 	return;
 }
 
-STORAGE_CLASS_SP_C uint8_t sp_dmem_load_uint8(
-    const sp_ID_t		ID,
-    const hrt_address	addr)
+STORAGE_CLASS_SP_C uint8_t sp_dmem_load_uint8(const sp_ID_t ID,
+					      const hrt_address addr)
 {
 	assert(ID < N_SP_ID);
 	assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
@@ -135,9 +116,8 @@ STORAGE_CLASS_SP_C uint8_t sp_dmem_load_uint8(
 	return ia_css_device_load_uint8(SP_DMEM_BASE[SP0_ID] + addr);
 }
 
-STORAGE_CLASS_SP_C uint16_t sp_dmem_load_uint16(
-    const sp_ID_t		ID,
-    const hrt_address	addr)
+STORAGE_CLASS_SP_C uint16_t sp_dmem_load_uint16(const sp_ID_t ID,
+						const hrt_address addr)
 {
 	assert(ID < N_SP_ID);
 	assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
@@ -145,9 +125,8 @@ STORAGE_CLASS_SP_C uint16_t sp_dmem_load_uint16(
 	return ia_css_device_load_uint16(SP_DMEM_BASE[SP0_ID] + addr);
 }
 
-STORAGE_CLASS_SP_C uint32_t sp_dmem_load_uint32(
-    const sp_ID_t		ID,
-    const hrt_address	addr)
+STORAGE_CLASS_SP_C uint32_t sp_dmem_load_uint32(const sp_ID_t ID,
+						const hrt_address addr)
 {
 	assert(ID < N_SP_ID);
 	assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/timed_ctrl.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/timed_ctrl.c
index 948b0b0a0272e1faa13e38436a20e97d654e594d..ddad914f09051d862935d8b5e96f75076ef91e56 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/timed_ctrl.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/timed_ctrl.c
@@ -12,13 +12,9 @@
 
 #include "assert_support.h"
 
-void timed_ctrl_snd_commnd(
-    const timed_ctrl_ID_t			ID,
-    hrt_data				mask,
-    hrt_data				condition,
-    hrt_data				counter,
-    hrt_address				addr,
-    hrt_data				value)
+void timed_ctrl_snd_commnd(const timed_ctrl_ID_t ID, hrt_data mask,
+			   hrt_data condition, hrt_data counter,
+			   hrt_address addr, hrt_data value)
 {
 	OP___assert(ID == TIMED_CTRL0_ID);
 	OP___assert(TIMED_CTRL_BASE[ID] != (hrt_address)-1);
@@ -26,21 +22,18 @@ void timed_ctrl_snd_commnd(
 	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, mask);
 	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, condition);
 	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, counter);
-	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, (hrt_data)addr);
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX,
+			     (hrt_data)addr);
 	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, value);
 }
 
 /* pqiao TODO: make sure the following commands get
 	correct BASE address both for csim and android */
 
-void timed_ctrl_snd_sp_commnd(
-    const timed_ctrl_ID_t			ID,
-    hrt_data				mask,
-    hrt_data				condition,
-    hrt_data				counter,
-    const sp_ID_t				SP_ID,
-    hrt_address				offset,
-    hrt_data				value)
+void timed_ctrl_snd_sp_commnd(const timed_ctrl_ID_t ID, hrt_data mask,
+			      hrt_data condition, hrt_data counter,
+			      const sp_ID_t SP_ID, hrt_address offset,
+			      hrt_data value)
 {
 	OP___assert(SP_ID < N_SP_ID);
 	OP___assert(SP_DMEM_BASE[SP_ID] != (hrt_address)-1);
@@ -49,14 +42,10 @@ void timed_ctrl_snd_sp_commnd(
 			      SP_DMEM_BASE[SP_ID] + offset, value);
 }
 
-void timed_ctrl_snd_gpio_commnd(
-    const timed_ctrl_ID_t			ID,
-    hrt_data				mask,
-    hrt_data				condition,
-    hrt_data				counter,
-    const gpio_ID_t				GPIO_ID,
-    hrt_address				offset,
-    hrt_data				value)
+void timed_ctrl_snd_gpio_commnd(const timed_ctrl_ID_t ID, hrt_data mask,
+				hrt_data condition, hrt_data counter,
+				const gpio_ID_t GPIO_ID, hrt_address offset,
+				hrt_data value)
 {
 	OP___assert(GPIO_ID < N_GPIO_ID);
 	OP___assert(GPIO_BASE[GPIO_ID] != (hrt_address)-1);
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/timed_ctrl_private.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/timed_ctrl_private.h
index 7b90b4cf04024864223956861b1d967df44de4eb..509e44b5d63fb924968aa8c6d7f3c78f3c9f3189 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/timed_ctrl_private.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/timed_ctrl_private.h
@@ -13,14 +13,14 @@
 
 #include "assert_support.h"
 
-STORAGE_CLASS_TIMED_CTRL_C void timed_ctrl_reg_store(
-    const timed_ctrl_ID_t	ID,
-    const unsigned int		reg,
-    const hrt_data			value)
+STORAGE_CLASS_TIMED_CTRL_C void timed_ctrl_reg_store(const timed_ctrl_ID_t ID,
+						     const unsigned int reg,
+						     const hrt_data value)
 {
 	OP___assert(ID < N_TIMED_CTRL_ID);
-	OP___assert(TIMED_CTRL_BASE[ID] != (hrt_address) - 1);
-	ia_css_device_store_uint32(TIMED_CTRL_BASE[ID] + reg * sizeof(hrt_data), value);
+	OP___assert(TIMED_CTRL_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(TIMED_CTRL_BASE[ID] + reg * sizeof(hrt_data),
+				   value);
 }
 
 #endif /* __GP_DEVICE_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem.c b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem.c
index 722b684fbc37b96d23431a9a1bc1a25ce150f991..663331d3dd191ee26c9db86b93cd68e71c896108 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem.c
@@ -19,46 +19,48 @@ typedef hive_uedge *hive_wide;
 /* Copied from SDK: sim_semantics.c */
 
 /* subword bits move like this:         MSB[____xxxx____]LSB -> MSB[00000000xxxx]LSB */
-static inline hive_uedge
-subword(hive_uedge w, unsigned int start, unsigned int end)
+static inline hive_uedge subword(hive_uedge w, unsigned int start,
+				 unsigned int end)
 {
 	return (w & (((1ULL << (end - 1)) - 1) << 1 | 1)) >> start;
 }
 
 /* inverse subword bits move like this: MSB[xxxx____xxxx]LSB -> MSB[xxxx0000xxxx]LSB */
-static inline hive_uedge
-inv_subword(hive_uedge w, unsigned int start, unsigned int end)
+static inline hive_uedge inv_subword(hive_uedge w, unsigned int start,
+				     unsigned int end)
 {
-	return w & (~(((1ULL << (end - 1)) - 1) << 1 | 1) | ((1ULL << start) - 1));
+	return w &
+	       (~(((1ULL << (end - 1)) - 1) << 1 | 1) | ((1ULL << start) - 1));
 }
 
 #define uedge_bits (8 * sizeof(hive_uedge))
-#define move_lower_bits(target, target_bit, src, src_bit) move_subword(target, target_bit, src, 0, src_bit)
-#define move_upper_bits(target, target_bit, src, src_bit) move_subword(target, target_bit, src, src_bit, uedge_bits)
-#define move_word(target, target_bit, src) move_subword(target, target_bit, src, 0, uedge_bits)
-
-static void
-move_subword(
-    hive_uedge *target,
-    unsigned int target_bit,
-    hive_uedge src,
-    unsigned int src_start,
-    unsigned int src_end)
+#define move_lower_bits(target, target_bit, src, src_bit) \
+	move_subword(target, target_bit, src, 0, src_bit)
+#define move_upper_bits(target, target_bit, src, src_bit) \
+	move_subword(target, target_bit, src, src_bit, uedge_bits)
+#define move_word(target, target_bit, src) \
+	move_subword(target, target_bit, src, 0, uedge_bits)
+
+static void move_subword(hive_uedge *target, unsigned int target_bit,
+			 hive_uedge src, unsigned int src_start,
+			 unsigned int src_end)
 {
 	unsigned int start_elem = target_bit / uedge_bits;
-	unsigned int start_bit  = target_bit % uedge_bits;
+	unsigned int start_bit = target_bit % uedge_bits;
 	unsigned int subword_width = src_end - src_start;
 
 	hive_uedge src_subword = subword(src, src_start, src_end);
 
 	if (subword_width + start_bit > uedge_bits) { /* overlap */
 		hive_uedge old_val1;
-		hive_uedge old_val0 = inv_subword(target[start_elem], start_bit, uedge_bits);
+		hive_uedge old_val0 =
+			inv_subword(target[start_elem], start_bit, uedge_bits);
 
 		target[start_elem] = old_val0 | (src_subword << start_bit);
 		old_val1 = inv_subword(target[start_elem + 1], 0,
 				       subword_width + start_bit - uedge_bits);
-		target[start_elem + 1] = old_val1 | (src_subword >> (uedge_bits - start_bit));
+		target[start_elem + 1] =
+			old_val1 | (src_subword >> (uedge_bits - start_bit));
 	} else {
 		hive_uedge old_val = inv_subword(target[start_elem], start_bit,
 						 start_bit + subword_width);
@@ -67,18 +69,14 @@ move_subword(
 	}
 }
 
-static void
-hive_sim_wide_unpack(
-    hive_wide vector,
-    hive_wide elem,
-    hive_uint elem_bits,
-    hive_uint index)
+static void hive_sim_wide_unpack(hive_wide vector, hive_wide elem,
+				 hive_uint elem_bits, hive_uint index)
 {
 	/* pointers into wide_type: */
 	unsigned int start_elem = (elem_bits * index) / uedge_bits;
-	unsigned int start_bit  = (elem_bits * index) % uedge_bits;
-	unsigned int end_elem   = (elem_bits * (index + 1) - 1) / uedge_bits;
-	unsigned int end_bit    = ((elem_bits * (index + 1) - 1) % uedge_bits) + 1;
+	unsigned int start_bit = (elem_bits * index) % uedge_bits;
+	unsigned int end_elem = (elem_bits * (index + 1) - 1) / uedge_bits;
+	unsigned int end_bit = ((elem_bits * (index + 1) - 1) % uedge_bits) + 1;
 
 	if (elem_bits == uedge_bits) {
 		/* easy case for speedup: */
@@ -91,7 +89,8 @@ hive_sim_wide_unpack(
 		unsigned int bits_written = 0;
 		unsigned int i;
 
-		move_upper_bits(elem, bits_written, vector[start_elem], start_bit);
+		move_upper_bits(elem, bits_written, vector[start_elem],
+				start_bit);
 		bits_written += (64 - start_bit);
 		for (i = start_elem + 1; i < end_elem; i++) {
 			move_word(elem, bits_written, vector[i]);
@@ -101,12 +100,8 @@ hive_sim_wide_unpack(
 	}
 }
 
-static void
-hive_sim_wide_pack(
-    hive_wide vector,
-    hive_wide elem,
-    hive_uint elem_bits,
-    hive_uint index)
+static void hive_sim_wide_pack(hive_wide vector, hive_wide elem,
+			       hive_uint elem_bits, hive_uint index)
 {
 	/* pointers into wide_type: */
 	unsigned int start_elem = (elem_bits * index) / uedge_bits;
@@ -119,8 +114,9 @@ hive_sim_wide_pack(
 		unsigned int start_bit = elem_bits * index;
 		unsigned int i = 0;
 
-		for (; bits_to_write > uedge_bits;
-		     bits_to_write -= uedge_bits, i++, start_bit += uedge_bits) {
+		for (; bits_to_write > uedge_bits; bits_to_write -= uedge_bits,
+						   i++,
+						   start_bit += uedge_bits) {
 			move_word(vector, start_bit, elem[i]);
 		}
 		move_lower_bits(vector, start_bit, elem[i], bits_to_write);
@@ -130,21 +126,23 @@ hive_sim_wide_pack(
 	}
 }
 
-static void load_vector(
-    const isp_ID_t		ID,
-    t_vmem_elem		*to,
-    const t_vmem_elem	*from)
+static void load_vector(const isp_ID_t ID, t_vmem_elem *to,
+			const t_vmem_elem *from)
 {
 	unsigned int i;
 	hive_uedge *data;
 	unsigned int size = sizeof(short) * ISP_NWAY;
 
-	VMEM_ARRAY(v, 2 * ISP_NWAY); /* Need 2 vectors to work around vmem hss bug */
-	assert(ISP_BAMEM_BASE[ID] != (hrt_address) - 1);
+	VMEM_ARRAY(
+		v,
+		2 * ISP_NWAY); /* Need 2 vectors to work around vmem hss bug */
+	assert(ISP_BAMEM_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
-	ia_css_device_load(ISP_BAMEM_BASE[ID] + (unsigned long)from, &v[0][0], size);
+	ia_css_device_load(ISP_BAMEM_BASE[ID] + (unsigned long)from, &v[0][0],
+			   size);
 #else
-	hrt_master_port_load(ISP_BAMEM_BASE[ID] + (unsigned long)from, &v[0][0], size);
+	hrt_master_port_load(ISP_BAMEM_BASE[ID] + (unsigned long)from, &v[0][0],
+			     size);
 #endif
 	data = (hive_uedge *)v;
 	for (i = 0; i < ISP_NWAY; i++) {
@@ -156,22 +154,23 @@ static void load_vector(
 	udelay(1); /* Spend at least 1 cycles per vector */
 }
 
-static void store_vector(
-    const isp_ID_t		ID,
-    t_vmem_elem		*to,
-    const t_vmem_elem	*from)
+static void store_vector(const isp_ID_t ID, t_vmem_elem *to,
+			 const t_vmem_elem *from)
 {
 	unsigned int i;
 	unsigned int size = sizeof(short) * ISP_NWAY;
 
-	VMEM_ARRAY(v, 2 * ISP_NWAY); /* Need 2 vectors to work around vmem hss bug */
+	VMEM_ARRAY(
+		v,
+		2 * ISP_NWAY); /* Need 2 vectors to work around vmem hss bug */
 	//load_vector (&v[1][0], &to[ISP_NWAY]); /* Fetch the next vector, since it will be overwritten. */
 	hive_uedge *data = (hive_uedge *)v;
 
 	for (i = 0; i < ISP_NWAY; i++) {
-		hive_sim_wide_pack(data, (hive_wide)&from[i], ISP_VEC_ELEMBITS, i);
+		hive_sim_wide_pack(data, (hive_wide)&from[i], ISP_VEC_ELEMBITS,
+				   i);
 	}
-	assert(ISP_BAMEM_BASE[ID] != (hrt_address) - 1);
+	assert(ISP_BAMEM_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
 	ia_css_device_store(ISP_BAMEM_BASE[ID] + (unsigned long)to, &v, size);
 #else
@@ -181,11 +180,8 @@ static void store_vector(
 	udelay(1); /* Spend at least 1 cycles per vector */
 }
 
-void isp_vmem_load(
-    const isp_ID_t		ID,
-    const t_vmem_elem	*from,
-    t_vmem_elem		*to,
-    unsigned int elems) /* In t_vmem_elem */
+void isp_vmem_load(const isp_ID_t ID, const t_vmem_elem *from, t_vmem_elem *to,
+		   unsigned int elems) /* In t_vmem_elem */
 {
 	unsigned int c;
 	const t_vmem_elem *vp = from;
@@ -199,11 +195,8 @@ void isp_vmem_load(
 	}
 }
 
-void isp_vmem_store(
-    const isp_ID_t		ID,
-    t_vmem_elem		*to,
-    const t_vmem_elem	*from,
-    unsigned int elems) /* In t_vmem_elem */
+void isp_vmem_store(const isp_ID_t ID, t_vmem_elem *to, const t_vmem_elem *from,
+		    unsigned int elems) /* In t_vmem_elem */
 {
 	unsigned int c;
 	t_vmem_elem *vp = to;
@@ -217,15 +210,11 @@ void isp_vmem_store(
 	}
 }
 
-void isp_vmem_2d_load(
-    const isp_ID_t		ID,
-    const t_vmem_elem	*from,
-    t_vmem_elem		*to,
-    unsigned int height,
-    unsigned int width,
-    unsigned int stride_to,  /* In t_vmem_elem */
+void isp_vmem_2d_load(const isp_ID_t ID, const t_vmem_elem *from,
+		      t_vmem_elem *to, unsigned int height, unsigned int width,
+		      unsigned int stride_to, /* In t_vmem_elem */
 
-    unsigned stride_from /* In t_vmem_elem */)
+		      unsigned stride_from /* In t_vmem_elem */)
 {
 	unsigned int h;
 
@@ -241,20 +230,18 @@ void isp_vmem_2d_load(
 			load_vector(ID, &to[stride_to * h + c], vp);
 			vp = (t_vmem_elem *)((char *)vp + ISP_VEC_ALIGN);
 		}
-		from = (const t_vmem_elem *)((const char *)from + stride_from / ISP_NWAY *
-					     ISP_VEC_ALIGN);
+		from = (const t_vmem_elem *)((const char *)from +
+					     stride_from / ISP_NWAY *
+						     ISP_VEC_ALIGN);
 	}
 }
 
-void isp_vmem_2d_store(
-    const isp_ID_t		ID,
-    t_vmem_elem		*to,
-    const t_vmem_elem	*from,
-    unsigned int height,
-    unsigned int width,
-    unsigned int stride_to,  /* In t_vmem_elem */
+void isp_vmem_2d_store(const isp_ID_t ID, t_vmem_elem *to,
+		       const t_vmem_elem *from, unsigned int height,
+		       unsigned int width,
+		       unsigned int stride_to, /* In t_vmem_elem */
 
-    unsigned stride_from /* In t_vmem_elem */)
+		       unsigned stride_from /* In t_vmem_elem */)
 {
 	unsigned int h;
 
@@ -270,6 +257,7 @@ void isp_vmem_2d_store(
 			store_vector(ID, vp, &from[stride_from * h + c]);
 			vp = (t_vmem_elem *)((char *)vp + ISP_VEC_ALIGN);
 		}
-		to = (t_vmem_elem *)((char *)to + stride_to / ISP_NWAY * ISP_VEC_ALIGN);
+		to = (t_vmem_elem *)((char *)to +
+				     stride_to / ISP_NWAY * ISP_VEC_ALIGN);
 	}
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem_local.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem_local.h
index 0163d31cd169dd7b6b5d517bd1938e089a089f4d..a960ae1d1d3ac0e69bf4f1a6577f7d46e243efcc 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem_local.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem_local.h
@@ -13,39 +13,26 @@
 typedef u16 t_vmem_elem;
 typedef s16 t_svmem_elem;
 
-#define VMEM_ARRAY(x, s)	t_vmem_elem x[(s) / ISP_NWAY][ISP_NWAY]
-#define SVMEM_ARRAY(x, s)	t_svmem_elem x[(s) / ISP_NWAY][ISP_NWAY]
-
-void isp_vmem_load(
-    const isp_ID_t		ID,
-    const t_vmem_elem	*from,
-    t_vmem_elem		*to,
-    unsigned int elems); /* In t_vmem_elem */
-
-void isp_vmem_store(
-    const isp_ID_t		ID,
-    t_vmem_elem		*to,
-    const t_vmem_elem	*from,
-    unsigned int elems); /* In t_vmem_elem */
-
-void isp_vmem_2d_load(
-    const isp_ID_t		ID,
-    const t_vmem_elem	*from,
-    t_vmem_elem		*to,
-    unsigned int height,
-    unsigned int width,
-    unsigned int stride_to,  /* In t_vmem_elem */
-
-    unsigned		stride_from /* In t_vmem_elem */);
-
-void isp_vmem_2d_store(
-    const isp_ID_t		ID,
-    t_vmem_elem		*to,
-    const t_vmem_elem	*from,
-    unsigned int height,
-    unsigned int width,
-    unsigned int stride_to,  /* In t_vmem_elem */
-
-    unsigned		stride_from /* In t_vmem_elem */);
+#define VMEM_ARRAY(x, s) (t_vmem_elem x[(s) / ISP_NWAY][ISP_NWAY])
+#define SVMEM_ARRAY(x, s) (t_svmem_elem x[(s) / ISP_NWAY][ISP_NWAY])
+
+void isp_vmem_load(const isp_ID_t ID, const t_vmem_elem *from, t_vmem_elem *to,
+		   unsigned int elems); /* In t_vmem_elem */
+
+void isp_vmem_store(const isp_ID_t ID, t_vmem_elem *to, const t_vmem_elem *from,
+		    unsigned int elems); /* In t_vmem_elem */
+
+void isp_vmem_2d_load(const isp_ID_t ID, const t_vmem_elem *from,
+		      t_vmem_elem *to, unsigned int height, unsigned int width,
+		      unsigned int stride_to, /* In t_vmem_elem */
+
+		      unsigned stride_from /* In t_vmem_elem */);
+
+void isp_vmem_2d_store(const isp_ID_t ID, t_vmem_elem *to,
+		       const t_vmem_elem *from, unsigned int height,
+		       unsigned int width,
+		       unsigned int stride_to, /* In t_vmem_elem */
+
+		       unsigned stride_from /* In t_vmem_elem */);
 
 #endif /* __VMEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/input_formatter_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/input_formatter_global.h
index b8ed8964c7b8aa22db6c9eb05a32d00c3f97fc74..b339ac5c37aa1dc2e7d7f60f8a3761a5475df3ef 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/input_formatter_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/input_formatter_global.h
@@ -16,87 +16,97 @@
 #include "str2mem_defs.h"
 #include "input_switch_2400_defs.h"
 
-#define _HIVE_INPUT_SWITCH_GET_FSYNC_REG_LSB(ch_id)        ((ch_id) * 3)
+#define _HIVE_INPUT_SWITCH_GET_FSYNC_REG_LSB(ch_id) ((ch_id)*3)
 
-#define HIVE_SWITCH_N_CHANNELS				4
-#define HIVE_SWITCH_N_FORMATTYPES			32
-#define HIVE_SWITCH_N_SWITCH_CODE			4
-#define HIVE_SWITCH_M_CHANNELS				0x00000003
-#define HIVE_SWITCH_M_FORMATTYPES			0x0000001f
-#define HIVE_SWITCH_M_SWITCH_CODE			0x00000003
-#define HIVE_SWITCH_M_FSYNC					0x00000007
+#define HIVE_SWITCH_N_CHANNELS 4
+#define HIVE_SWITCH_N_FORMATTYPES 32
+#define HIVE_SWITCH_N_SWITCH_CODE 4
+#define HIVE_SWITCH_M_CHANNELS 0x00000003
+#define HIVE_SWITCH_M_FORMATTYPES 0x0000001f
+#define HIVE_SWITCH_M_SWITCH_CODE 0x00000003
+#define HIVE_SWITCH_M_FSYNC 0x00000007
 
-#define HIVE_SWITCH_ENCODE_FSYNC(x) \
-	(1U << (((x) - 1) & HIVE_SWITCH_M_CHANNELS))
+#define HIVE_SWITCH_ENCODE_FSYNC(x) (1U << (((x)-1) & HIVE_SWITCH_M_CHANNELS))
 
 #define _HIVE_INPUT_SWITCH_GET_LUT_FIELD(reg, bit_index) \
 	(((reg) >> (bit_index)) & HIVE_SWITCH_M_SWITCH_CODE)
-#define _HIVE_INPUT_SWITCH_SET_LUT_FIELD(reg, bit_index, val) \
-	(((reg) & ~(HIVE_SWITCH_M_SWITCH_CODE << (bit_index))) | (((hrt_data)(val) & HIVE_SWITCH_M_SWITCH_CODE) << (bit_index)))
+#define _HIVE_INPUT_SWITCH_SET_LUT_FIELD(reg, bit_index, val)    \
+	(((reg) & ~(HIVE_SWITCH_M_SWITCH_CODE << (bit_index))) | \
+	 (((hrt_data)(val)&HIVE_SWITCH_M_SWITCH_CODE) << (bit_index)))
 #define _HIVE_INPUT_SWITCH_GET_FSYNC_FIELD(reg, bit_index) \
 	(((reg) >> (bit_index)) & HIVE_SWITCH_M_FSYNC)
 #define _HIVE_INPUT_SWITCH_SET_FSYNC_FIELD(reg, bit_index, val) \
-	(((reg) & ~(HIVE_SWITCH_M_FSYNC << (bit_index))) | (((hrt_data)(val) & HIVE_SWITCH_M_FSYNC) << (bit_index)))
+	(((reg) & ~(HIVE_SWITCH_M_FSYNC << (bit_index))) |      \
+	 (((hrt_data)(val)&HIVE_SWITCH_M_FSYNC) << (bit_index)))
 
-typedef struct input_formatter_cfg_s	input_formatter_cfg_t;
+typedef struct input_formatter_cfg_s input_formatter_cfg_t;
 
 /* Hardware registers */
 /*#define HIVE_IF_RESET_ADDRESS                   0x000*/ /* deprecated */
-#define HIVE_IF_START_LINE_ADDRESS              0x004
-#define HIVE_IF_START_COLUMN_ADDRESS            0x008
-#define HIVE_IF_CROPPED_HEIGHT_ADDRESS          0x00C
-#define HIVE_IF_CROPPED_WIDTH_ADDRESS           0x010
-#define HIVE_IF_VERTICAL_DECIMATION_ADDRESS     0x014
-#define HIVE_IF_HORIZONTAL_DECIMATION_ADDRESS   0x018
-#define HIVE_IF_H_DEINTERLEAVING_ADDRESS        0x01C
-#define HIVE_IF_LEFTPADDING_WIDTH_ADDRESS       0x020
-#define HIVE_IF_END_OF_LINE_OFFSET_ADDRESS      0x024
-#define HIVE_IF_VMEM_START_ADDRESS_ADDRESS      0x028
-#define HIVE_IF_VMEM_END_ADDRESS_ADDRESS        0x02C
-#define HIVE_IF_VMEM_INCREMENT_ADDRESS          0x030
-#define HIVE_IF_YUV_420_FORMAT_ADDRESS          0x034
-#define HIVE_IF_VSYNCK_ACTIVE_LOW_ADDRESS       0x038
-#define HIVE_IF_HSYNCK_ACTIVE_LOW_ADDRESS       0x03C
-#define HIVE_IF_ALLOW_FIFO_OVERFLOW_ADDRESS     0x040
-#define HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS       0x044
-#define HIVE_IF_V_DEINTERLEAVING_ADDRESS        0x048
-#define HIVE_IF_FSM_CROP_PIXEL_COUNTER          0x110
-#define HIVE_IF_FSM_CROP_LINE_COUNTER           0x10C
-#define HIVE_IF_FSM_CROP_STATUS                 0x108
+#define HIVE_IF_START_LINE_ADDRESS 0x004
+#define HIVE_IF_START_COLUMN_ADDRESS 0x008
+#define HIVE_IF_CROPPED_HEIGHT_ADDRESS 0x00C
+#define HIVE_IF_CROPPED_WIDTH_ADDRESS 0x010
+#define HIVE_IF_VERTICAL_DECIMATION_ADDRESS 0x014
+#define HIVE_IF_HORIZONTAL_DECIMATION_ADDRESS 0x018
+#define HIVE_IF_H_DEINTERLEAVING_ADDRESS 0x01C
+#define HIVE_IF_LEFTPADDING_WIDTH_ADDRESS 0x020
+#define HIVE_IF_END_OF_LINE_OFFSET_ADDRESS 0x024
+#define HIVE_IF_VMEM_START_ADDRESS_ADDRESS 0x028
+#define HIVE_IF_VMEM_END_ADDRESS_ADDRESS 0x02C
+#define HIVE_IF_VMEM_INCREMENT_ADDRESS 0x030
+#define HIVE_IF_YUV_420_FORMAT_ADDRESS 0x034
+#define HIVE_IF_VSYNCK_ACTIVE_LOW_ADDRESS 0x038
+#define HIVE_IF_HSYNCK_ACTIVE_LOW_ADDRESS 0x03C
+#define HIVE_IF_ALLOW_FIFO_OVERFLOW_ADDRESS 0x040
+#define HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS 0x044
+#define HIVE_IF_V_DEINTERLEAVING_ADDRESS 0x048
+#define HIVE_IF_FSM_CROP_PIXEL_COUNTER 0x110
+#define HIVE_IF_FSM_CROP_LINE_COUNTER 0x10C
+#define HIVE_IF_FSM_CROP_STATUS 0x108
 
 /* Registers only for simulation */
-#define HIVE_IF_CRUN_MODE_ADDRESS               0x04C
-#define HIVE_IF_DUMP_OUTPUT_ADDRESS             0x050
+#define HIVE_IF_CRUN_MODE_ADDRESS 0x04C
+#define HIVE_IF_DUMP_OUTPUT_ADDRESS 0x050
 
 /* Follow the DMA syntax, "cmd" last */
-#define IF_PACK(val, cmd)             ((val & 0x0fff) | (cmd /*& 0xf000*/))
+#define IF_PACK(val, cmd) ((val & 0x0fff) | (cmd /*& 0xf000*/))
 
-#define HIVE_STR2MEM_SOFT_RESET_REG_ADDRESS                   (_STR2MEM_SOFT_RESET_REG_ID * _STR2MEM_REG_ALIGN)
-#define HIVE_STR2MEM_INPUT_ENDIANNESS_REG_ADDRESS             (_STR2MEM_INPUT_ENDIANNESS_REG_ID * _STR2MEM_REG_ALIGN)
-#define HIVE_STR2MEM_OUTPUT_ENDIANNESS_REG_ADDRESS            (_STR2MEM_OUTPUT_ENDIANNESS_REG_ID * _STR2MEM_REG_ALIGN)
-#define HIVE_STR2MEM_BIT_SWAPPING_REG_ADDRESS                 (_STR2MEM_BIT_SWAPPING_REG_ID * _STR2MEM_REG_ALIGN)
-#define HIVE_STR2MEM_BLOCK_SYNC_LEVEL_REG_ADDRESS             (_STR2MEM_BLOCK_SYNC_LEVEL_REG_ID * _STR2MEM_REG_ALIGN)
-#define HIVE_STR2MEM_PACKET_SYNC_LEVEL_REG_ADDRESS            (_STR2MEM_PACKET_SYNC_LEVEL_REG_ID * _STR2MEM_REG_ALIGN)
-#define HIVE_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ADDRESS  (_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ID * _STR2MEM_REG_ALIGN)
-#define HIVE_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ADDRESS     (_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ID * _STR2MEM_REG_ALIGN)
-#define HIVE_STR2MEM_EN_STAT_UPDATE_ADDRESS                   (_STR2MEM_EN_STAT_UPDATE_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_SOFT_RESET_REG_ADDRESS \
+	(_STR2MEM_SOFT_RESET_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_INPUT_ENDIANNESS_REG_ADDRESS \
+	(_STR2MEM_INPUT_ENDIANNESS_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_OUTPUT_ENDIANNESS_REG_ADDRESS \
+	(_STR2MEM_OUTPUT_ENDIANNESS_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_BIT_SWAPPING_REG_ADDRESS \
+	(_STR2MEM_BIT_SWAPPING_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_BLOCK_SYNC_LEVEL_REG_ADDRESS \
+	(_STR2MEM_BLOCK_SYNC_LEVEL_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_PACKET_SYNC_LEVEL_REG_ADDRESS \
+	(_STR2MEM_PACKET_SYNC_LEVEL_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ADDRESS \
+	(_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ADDRESS \
+	(_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_EN_STAT_UPDATE_ADDRESS \
+	(_STR2MEM_EN_STAT_UPDATE_ID * _STR2MEM_REG_ALIGN)
 
 /*
  * This data structure is shared between host and SP
  */
 struct input_formatter_cfg_s {
-	u32	start_line;
-	u32	start_column;
-	u32	left_padding;
-	u32	cropped_height;
-	u32	cropped_width;
-	u32	deinterleaving;
-	u32	buf_vecs;
-	u32	buf_start_index;
-	u32	buf_increment;
-	u32	buf_eol_offset;
-	u32	is_yuv420_format;
-	u32	block_no_reqs;
+	u32 start_line;
+	u32 start_column;
+	u32 left_padding;
+	u32 cropped_height;
+	u32 cropped_width;
+	u32 deinterleaving;
+	u32 buf_vecs;
+	u32 buf_start_index;
+	u32 buf_increment;
+	u32 buf_eol_offset;
+	u32 is_yuv420_format;
+	u32 block_no_reqs;
 };
 
 extern const hrt_address HIVE_IF_SRST_ADDRESS[N_INPUT_FORMATTER_ID];
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/irq_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/irq_global.h
index 69e68ecd6bc380f37d190bfbee254216cf9aaeb4..c97ae3a0d2accb8ce323fdf209fd1e4f5d9e02d1 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/irq_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/irq_global.h
@@ -18,7 +18,7 @@
 #endif
 
 /* The IRQ is not mapped uniformly on its related interfaces */
-#define	IRQ_SW_CHANNEL_OFFSET	HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID
+#define IRQ_SW_CHANNEL_OFFSET HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID
 
 typedef enum {
 	IRQ_SW_CHANNEL0_ID = hrt_isp_css_irq_sw_pin_0 - IRQ_SW_CHANNEL_OFFSET,
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/isp_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/isp_global.h
index 2df468bd76d65019fbc08c2d1210e8dc04a7030c..3220afda6a4184acefe9751043d5b40623d0b026 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/isp_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/isp_global.h
@@ -11,78 +11,78 @@
 
 #include "mamoiada_params.h"
 
-#define ISP_PMEM_WIDTH_LOG2		ISP_LOG2_PMEM_WIDTH
-#define ISP_PMEM_SIZE			ISP_PMEM_DEPTH
+#define ISP_PMEM_WIDTH_LOG2 ISP_LOG2_PMEM_WIDTH
+#define ISP_PMEM_SIZE ISP_PMEM_DEPTH
 
-#define ISP_NWAY_LOG2			6
-#define ISP_VEC_NELEMS_LOG2		ISP_NWAY_LOG2
+#define ISP_NWAY_LOG2 6
+#define ISP_VEC_NELEMS_LOG2 ISP_NWAY_LOG2
 
 #ifdef PIPE_GENERATION
 #define PIPEMEM(x) MEM(x)
-#define ISP_NWAY   BIT(ISP_NWAY_LOG2)
+#define ISP_NWAY BIT(ISP_NWAY_LOG2)
 #else
 #define PIPEMEM(x)
 #endif
 
 /* The number of data bytes in a vector disregarding the reduced precision */
-#define ISP_VEC_BYTES			(ISP_VEC_NELEMS * sizeof(uint16_t))
+#define ISP_VEC_BYTES (ISP_VEC_NELEMS * sizeof(uint16_t))
 
 /* ISP SC Registers */
-#define ISP_SC_REG			0x00
-#define ISP_PC_REG			0x07
-#define ISP_IRQ_READY_REG		0x00
-#define ISP_IRQ_CLEAR_REG		0x00
+#define ISP_SC_REG 0x00
+#define ISP_PC_REG 0x07
+#define ISP_IRQ_READY_REG 0x00
+#define ISP_IRQ_CLEAR_REG 0x00
 
 /* ISP SC Register bits */
-#define ISP_RST_BIT			0x00
-#define ISP_START_BIT			0x01
-#define ISP_BREAK_BIT			0x02
-#define ISP_RUN_BIT			0x03
-#define ISP_BROKEN_BIT			0x04
-#define ISP_IDLE_BIT			0x05     /* READY */
-#define ISP_SLEEPING_BIT		0x06
-#define ISP_STALLING_BIT		0x07
-#define ISP_IRQ_CLEAR_BIT		0x08
-#define ISP_IRQ_READY_BIT		0x0A
-#define ISP_IRQ_SLEEPING_BIT		0x0B
+#define ISP_RST_BIT 0x00
+#define ISP_START_BIT 0x01
+#define ISP_BREAK_BIT 0x02
+#define ISP_RUN_BIT 0x03
+#define ISP_BROKEN_BIT 0x04
+#define ISP_IDLE_BIT 0x05 /* READY */
+#define ISP_SLEEPING_BIT 0x06
+#define ISP_STALLING_BIT 0x07
+#define ISP_IRQ_CLEAR_BIT 0x08
+#define ISP_IRQ_READY_BIT 0x0A
+#define ISP_IRQ_SLEEPING_BIT 0x0B
 
 /* ISP Register bits */
-#define ISP_CTRL_SINK_BIT		0x00
-#define ISP_PMEM_SINK_BIT		0x01
-#define ISP_DMEM_SINK_BIT		0x02
-#define ISP_FIFO0_SINK_BIT		0x03
-#define ISP_FIFO1_SINK_BIT		0x04
-#define ISP_FIFO2_SINK_BIT		0x05
-#define ISP_FIFO3_SINK_BIT		0x06
-#define ISP_FIFO4_SINK_BIT		0x07
-#define ISP_FIFO5_SINK_BIT		0x08
-#define ISP_FIFO6_SINK_BIT		0x09
-#define ISP_VMEM_SINK_BIT		0x0A
-#define ISP_VAMEM1_SINK_BIT		0x0B
-#define ISP_VAMEM2_SINK_BIT		0x0C
-#define ISP_VAMEM3_SINK_BIT		0x0D
-#define ISP_HMEM_SINK_BIT		0x0E
+#define ISP_CTRL_SINK_BIT 0x00
+#define ISP_PMEM_SINK_BIT 0x01
+#define ISP_DMEM_SINK_BIT 0x02
+#define ISP_FIFO0_SINK_BIT 0x03
+#define ISP_FIFO1_SINK_BIT 0x04
+#define ISP_FIFO2_SINK_BIT 0x05
+#define ISP_FIFO3_SINK_BIT 0x06
+#define ISP_FIFO4_SINK_BIT 0x07
+#define ISP_FIFO5_SINK_BIT 0x08
+#define ISP_FIFO6_SINK_BIT 0x09
+#define ISP_VMEM_SINK_BIT 0x0A
+#define ISP_VAMEM1_SINK_BIT 0x0B
+#define ISP_VAMEM2_SINK_BIT 0x0C
+#define ISP_VAMEM3_SINK_BIT 0x0D
+#define ISP_HMEM_SINK_BIT 0x0E
 
-#define ISP_CTRL_SINK_REG		0x08
-#define ISP_PMEM_SINK_REG		0x08
-#define ISP_DMEM_SINK_REG		0x08
-#define ISP_FIFO0_SINK_REG		0x08
-#define ISP_FIFO1_SINK_REG		0x08
-#define ISP_FIFO2_SINK_REG		0x08
-#define ISP_FIFO3_SINK_REG		0x08
-#define ISP_FIFO4_SINK_REG		0x08
-#define ISP_FIFO5_SINK_REG		0x08
-#define ISP_FIFO6_SINK_REG		0x08
-#define ISP_VMEM_SINK_REG		0x08
-#define ISP_VAMEM1_SINK_REG		0x08
-#define ISP_VAMEM2_SINK_REG		0x08
-#define ISP_VAMEM3_SINK_REG		0x08
-#define ISP_HMEM_SINK_REG		0x08
+#define ISP_CTRL_SINK_REG 0x08
+#define ISP_PMEM_SINK_REG 0x08
+#define ISP_DMEM_SINK_REG 0x08
+#define ISP_FIFO0_SINK_REG 0x08
+#define ISP_FIFO1_SINK_REG 0x08
+#define ISP_FIFO2_SINK_REG 0x08
+#define ISP_FIFO3_SINK_REG 0x08
+#define ISP_FIFO4_SINK_REG 0x08
+#define ISP_FIFO5_SINK_REG 0x08
+#define ISP_FIFO6_SINK_REG 0x08
+#define ISP_VMEM_SINK_REG 0x08
+#define ISP_VAMEM1_SINK_REG 0x08
+#define ISP_VAMEM2_SINK_REG 0x08
+#define ISP_VAMEM3_SINK_REG 0x08
+#define ISP_HMEM_SINK_REG 0x08
 
 /* ISP2401 */
 #define BAMEM VMEM
-#define XNR3_DOWN_BAMEM_BASE_ADDRESS    (0x16880)
-#define XNR3_UP_BAMEM_BASE_ADDRESS      (0x12880)
+#define XNR3_DOWN_BAMEM_BASE_ADDRESS (0x16880)
+#define XNR3_UP_BAMEM_BASE_ADDRESS (0x12880)
 #define bmem_ldrow(fu, pid, offset, data) bmem_ldrow_s(fu, pid, offset, data)
 #define bmem_strow(fu, pid, offset, data) bmem_strow_s(fu, pid, offset, data)
 #define bmem_ldblk(fu, pid, offset, data) bmem_ldblk_s(fu, pid, offset, data)
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/sp_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/sp_global.h
index db72d7b29f73627ba8cfcf45048f10d9dd4cb26c..184013d150788884907ddbff3dc46fe15795be6b 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/sp_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/sp_global.h
@@ -11,65 +11,65 @@
 
 #include <scalar_processor_2400_params.h>
 
-#define SP_PMEM_WIDTH_LOG2		SP_PMEM_LOG_WIDTH_BITS
-#define SP_PMEM_SIZE			SP_PMEM_DEPTH
+#define SP_PMEM_WIDTH_LOG2 SP_PMEM_LOG_WIDTH_BITS
+#define SP_PMEM_SIZE SP_PMEM_DEPTH
 
-#define SP_DMEM_SIZE			0x4000
+#define SP_DMEM_SIZE 0x4000
 
 /* SP Registers */
-#define SP_PC_REG				0x09
-#define SP_SC_REG				0x00
-#define SP_START_ADDR_REG		0x01
-#define SP_ICACHE_ADDR_REG		0x05
-#define SP_IRQ_READY_REG		0x00
-#define SP_IRQ_CLEAR_REG		0x00
-#define SP_ICACHE_INV_REG		0x00
-#define SP_CTRL_SINK_REG		0x0A
+#define SP_PC_REG 0x09
+#define SP_SC_REG 0x00
+#define SP_START_ADDR_REG 0x01
+#define SP_ICACHE_ADDR_REG 0x05
+#define SP_IRQ_READY_REG 0x00
+#define SP_IRQ_CLEAR_REG 0x00
+#define SP_ICACHE_INV_REG 0x00
+#define SP_CTRL_SINK_REG 0x0A
 
 /* SP Register bits */
-#define SP_RST_BIT			0x00
-#define SP_START_BIT			0x01
-#define SP_BREAK_BIT			0x02
-#define SP_RUN_BIT			0x03
-#define SP_BROKEN_BIT			0x04
-#define SP_IDLE_BIT			0x05     /* READY */
-#define SP_SLEEPING_BIT			0x06
-#define SP_STALLING_BIT			0x07
-#define SP_IRQ_CLEAR_BIT		0x08
-#define SP_IRQ_READY_BIT		0x0A
-#define SP_IRQ_SLEEPING_BIT		0x0B
+#define SP_RST_BIT 0x00
+#define SP_START_BIT 0x01
+#define SP_BREAK_BIT 0x02
+#define SP_RUN_BIT 0x03
+#define SP_BROKEN_BIT 0x04
+#define SP_IDLE_BIT 0x05 /* READY */
+#define SP_SLEEPING_BIT 0x06
+#define SP_STALLING_BIT 0x07
+#define SP_IRQ_CLEAR_BIT 0x08
+#define SP_IRQ_READY_BIT 0x0A
+#define SP_IRQ_SLEEPING_BIT 0x0B
 
-#define SP_ICACHE_INV_BIT		0x0C
-#define SP_IPREFETCH_EN_BIT		0x0D
+#define SP_ICACHE_INV_BIT 0x0C
+#define SP_IPREFETCH_EN_BIT 0x0D
 
-#define SP_FIFO0_SINK_BIT		0x00
-#define SP_FIFO1_SINK_BIT		0x01
-#define SP_FIFO2_SINK_BIT		0x02
-#define SP_FIFO3_SINK_BIT		0x03
-#define SP_FIFO4_SINK_BIT		0x04
-#define SP_FIFO5_SINK_BIT		0x05
-#define SP_FIFO6_SINK_BIT		0x06
-#define SP_FIFO7_SINK_BIT		0x07
-#define SP_FIFO8_SINK_BIT		0x08
-#define SP_FIFO9_SINK_BIT		0x09
-#define SP_FIFOA_SINK_BIT		0x0A
-#define SP_DMEM_SINK_BIT		0x0B
-#define SP_CTRL_MT_SINK_BIT		0x0C
-#define SP_ICACHE_MT_SINK_BIT	0x0D
+#define SP_FIFO0_SINK_BIT 0x00
+#define SP_FIFO1_SINK_BIT 0x01
+#define SP_FIFO2_SINK_BIT 0x02
+#define SP_FIFO3_SINK_BIT 0x03
+#define SP_FIFO4_SINK_BIT 0x04
+#define SP_FIFO5_SINK_BIT 0x05
+#define SP_FIFO6_SINK_BIT 0x06
+#define SP_FIFO7_SINK_BIT 0x07
+#define SP_FIFO8_SINK_BIT 0x08
+#define SP_FIFO9_SINK_BIT 0x09
+#define SP_FIFOA_SINK_BIT 0x0A
+#define SP_DMEM_SINK_BIT 0x0B
+#define SP_CTRL_MT_SINK_BIT 0x0C
+#define SP_ICACHE_MT_SINK_BIT 0x0D
 
-#define SP_FIFO0_SINK_REG		0x0A
-#define SP_FIFO1_SINK_REG		0x0A
-#define SP_FIFO2_SINK_REG		0x0A
-#define SP_FIFO3_SINK_REG		0x0A
-#define SP_FIFO4_SINK_REG		0x0A
-#define SP_FIFO5_SINK_REG		0x0A
-#define SP_FIFO6_SINK_REG		0x0A
-#define SP_FIFO7_SINK_REG		0x0A
-#define SP_FIFO8_SINK_REG		0x0A
-#define SP_FIFO9_SINK_REG		0x0A
-#define SP_FIFOA_SINK_REG		0x0A
-#define SP_DMEM_SINK_REG		0x0A
-#define SP_CTRL_MT_SINK_REG		0x0A
-#define SP_ICACHE_MT_SINK_REG	0x0A
+#define SP_FIFO0_SINK_REG 0x0A
+#define SP_FIFO1_SINK_REG 0x0A
+#define SP_FIFO2_SINK_REG 0x0A
+#define SP_FIFO3_SINK_REG 0x0A
+#define SP_FIFO4_SINK_REG 0x0A
+#define SP_FIFO5_SINK_REG 0x0A
+#define SP_FIFO6_SINK_REG 0x0A
+#define SP_FIFO7_SINK_REG 0x0A
+#define SP_FIFO8_SINK_REG 0x0A
+#define SP_FIFO9_SINK_REG 0x0A
+#define SP_FIFOA_SINK_REG 0x0A
+#define SP_DMEM_SINK_REG 0x0A
+#define SP_CTRL_MT_SINK_REG 0x0A
+#define SP_ICACHE_MT_SINK_REG 0x0A
 
 #endif /* __SP_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/timed_ctrl_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/timed_ctrl_global.h
index 2dc0fb88399fa71c0b869d2801c73299cc9e80fc..01b1c050895d592562f1c2d24a07b69afdada73a 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/timed_ctrl_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/timed_ctrl_global.h
@@ -18,29 +18,29 @@
  *
  * Check for other systems.
  */
-#define HIVE_TIMED_CTRL_GPIO_PIN_0_BIT_ID                       0
-#define HIVE_TIMED_CTRL_GPIO_PIN_1_BIT_ID                       1
-#define HIVE_TIMED_CTRL_GPIO_PIN_2_BIT_ID                       2
-#define HIVE_TIMED_CTRL_GPIO_PIN_3_BIT_ID                       3
-#define HIVE_TIMED_CTRL_GPIO_PIN_4_BIT_ID                       4
-#define HIVE_TIMED_CTRL_GPIO_PIN_5_BIT_ID                       5
-#define HIVE_TIMED_CTRL_GPIO_PIN_6_BIT_ID                       6
-#define HIVE_TIMED_CTRL_GPIO_PIN_7_BIT_ID                       7
-#define HIVE_TIMED_CTRL_GPIO_PIN_8_BIT_ID                       8
-#define HIVE_TIMED_CTRL_GPIO_PIN_9_BIT_ID                       9
-#define HIVE_TIMED_CTRL_GPIO_PIN_10_BIT_ID                      10
-#define HIVE_TIMED_CTRL_GPIO_PIN_11_BIT_ID                      11
-#define HIVE_TIMED_CTRL_IRQ_SP_BIT_ID                           12
-#define HIVE_TIMED_CTRL_IRQ_ISP_BIT_ID                          13
-#define HIVE_TIMED_CTRL_IRQ_INPUT_SYSTEM_BIT_ID                 14
-#define HIVE_TIMED_CTRL_IRQ_INPUT_SELECTOR_BIT_ID               15
-#define HIVE_TIMED_CTRL_IRQ_IF_BLOCK_BIT_ID                     16
-#define HIVE_TIMED_CTRL_IRQ_GP_TIMER_0_BIT_ID                   17
-#define HIVE_TIMED_CTRL_IRQ_GP_TIMER_1_BIT_ID                   18
-#define HIVE_TIMED_CTRL_CSI_SOL_BIT_ID                          19
-#define HIVE_TIMED_CTRL_CSI_EOL_BIT_ID                          20
-#define HIVE_TIMED_CTRL_CSI_SOF_BIT_ID                          21
-#define HIVE_TIMED_CTRL_CSI_EOF_BIT_ID                          22
-#define HIVE_TIMED_CTRL_IRQ_IS_STREAMING_MONITOR_BIT_ID         23
+#define HIVE_TIMED_CTRL_GPIO_PIN_0_BIT_ID 0
+#define HIVE_TIMED_CTRL_GPIO_PIN_1_BIT_ID 1
+#define HIVE_TIMED_CTRL_GPIO_PIN_2_BIT_ID 2
+#define HIVE_TIMED_CTRL_GPIO_PIN_3_BIT_ID 3
+#define HIVE_TIMED_CTRL_GPIO_PIN_4_BIT_ID 4
+#define HIVE_TIMED_CTRL_GPIO_PIN_5_BIT_ID 5
+#define HIVE_TIMED_CTRL_GPIO_PIN_6_BIT_ID 6
+#define HIVE_TIMED_CTRL_GPIO_PIN_7_BIT_ID 7
+#define HIVE_TIMED_CTRL_GPIO_PIN_8_BIT_ID 8
+#define HIVE_TIMED_CTRL_GPIO_PIN_9_BIT_ID 9
+#define HIVE_TIMED_CTRL_GPIO_PIN_10_BIT_ID 10
+#define HIVE_TIMED_CTRL_GPIO_PIN_11_BIT_ID 11
+#define HIVE_TIMED_CTRL_IRQ_SP_BIT_ID 12
+#define HIVE_TIMED_CTRL_IRQ_ISP_BIT_ID 13
+#define HIVE_TIMED_CTRL_IRQ_INPUT_SYSTEM_BIT_ID 14
+#define HIVE_TIMED_CTRL_IRQ_INPUT_SELECTOR_BIT_ID 15
+#define HIVE_TIMED_CTRL_IRQ_IF_BLOCK_BIT_ID 16
+#define HIVE_TIMED_CTRL_IRQ_GP_TIMER_0_BIT_ID 17
+#define HIVE_TIMED_CTRL_IRQ_GP_TIMER_1_BIT_ID 18
+#define HIVE_TIMED_CTRL_CSI_SOL_BIT_ID 19
+#define HIVE_TIMED_CTRL_CSI_EOL_BIT_ID 20
+#define HIVE_TIMED_CTRL_CSI_SOF_BIT_ID 21
+#define HIVE_TIMED_CTRL_CSI_EOF_BIT_ID 22
+#define HIVE_TIMED_CTRL_IRQ_IS_STREAMING_MONITOR_BIT_ID 23
 
 #endif /* __TIMED_CTRL_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/vamem_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/vamem_global.h
index 0042925f1d2b97975d2e84e4e5b45b542e0a6404..77703426fb817caed55ed7bef161d7edd9b002f9 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/vamem_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/vamem_global.h
@@ -12,15 +12,16 @@
 #define IS_VAMEM_VERSION_2
 
 /* (log) stepsize of linear interpolation */
-#define VAMEM_INTERP_STEP_LOG2	4
-#define VAMEM_INTERP_STEP		BIT(VAMEM_INTERP_STEP_LOG2)
+#define VAMEM_INTERP_STEP_LOG2 4
+#define VAMEM_INTERP_STEP BIT(VAMEM_INTERP_STEP_LOG2)
 /* (physical) size of the tables */
-#define VAMEM_TABLE_UNIT_SIZE	((1 << (ISP_VAMEM_ADDRESS_BITS - VAMEM_INTERP_STEP_LOG2)) + 1)
+#define VAMEM_TABLE_UNIT_SIZE \
+	((1 << (ISP_VAMEM_ADDRESS_BITS - VAMEM_INTERP_STEP_LOG2)) + 1)
 /* (logical) size of the tables */
-#define VAMEM_TABLE_UNIT_STEP	((VAMEM_TABLE_UNIT_SIZE - 1) << 1)
+#define VAMEM_TABLE_UNIT_STEP ((VAMEM_TABLE_UNIT_SIZE - 1) << 1)
 /* Number of tables */
-#define VAMEM_TABLE_UNIT_COUNT	(ISP_VAMEM_DEPTH / VAMEM_TABLE_UNIT_STEP)
+#define VAMEM_TABLE_UNIT_COUNT (ISP_VAMEM_DEPTH / VAMEM_TABLE_UNIT_STEP)
 
-typedef u16				vamem_data_t;
+typedef u16 vamem_data_t;
 
 #endif /* __VAMEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_common/vmem_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_common/vmem_global.h
index 6d8bde959b5287f8d9f5779410e3a7eabad1b817..41168288f90b2b4cdc8a640dba32a52d886585af 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_common/vmem_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_common/vmem_global.h
@@ -9,9 +9,9 @@
 
 #include "isp.h"
 
-#define VMEM_SIZE	ISP_VMEM_DEPTH
-#define VMEM_ELEMBITS	ISP_VMEM_ELEMBITS
-#define VMEM_ALIGN	ISP_VMEM_ALIGN
+#define VMEM_SIZE ISP_VMEM_DEPTH
+#define VMEM_ELEMBITS ISP_VMEM_ELEMBITS
+#define VMEM_ALIGN ISP_VMEM_ALIGN
 
 #ifndef PIPE_GENERATION
 typedef tvector *pvector;
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_defs.h b/drivers/staging/media/atomisp/pci/hive_isp_css_defs.h
index 0e2c8ec534a17a7526404785aa893fbae7057620..9967225be9165b558fc3cb7fa1200323679dd266 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_defs.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_defs.h
@@ -7,27 +7,34 @@
 #ifndef _hive_isp_css_defs_h__
 #define _hive_isp_css_defs_h__
 
-#define HIVE_ISP_CTRL_DATA_WIDTH     32
-#define HIVE_ISP_CTRL_ADDRESS_WIDTH  32
-#define HIVE_ISP_CTRL_MAX_BURST_SIZE  1
-#define HIVE_ISP_DDR_ADDRESS_WIDTH   36
+#define HIVE_ISP_CTRL_DATA_WIDTH 32
+#define HIVE_ISP_CTRL_ADDRESS_WIDTH 32
+#define HIVE_ISP_CTRL_MAX_BURST_SIZE 1
+#define HIVE_ISP_DDR_ADDRESS_WIDTH 36
 
-#define HIVE_ISP_HOST_MAX_BURST_SIZE  8 /* host supports bursts in order to prevent repeating DDRAM accesses */
-#define HIVE_ISP_NUM_GPIO_PINS       12
+#define HIVE_ISP_HOST_MAX_BURST_SIZE \
+	8 /* host supports bursts in order to prevent repeating DDRAM accesses */
+#define HIVE_ISP_NUM_GPIO_PINS 12
 
 /* This list of vector num_elems/elem_bits pairs is valid both in C as initializer
    and in the DMA parameter list */
-#define HIVE_ISP_DDR_DMA_SPECS {{32,  8}, {16, 16}, {18, 14}, {25, 10}, {21, 12}}
+#define HIVE_ISP_DDR_DMA_SPECS                                 \
+	{                                                      \
+		{ 32, 8 }, { 16, 16 }, { 18, 14 }, { 25, 10 }, \
+		{                                              \
+			21, 12                                 \
+		}                                              \
+	}
 #define HIVE_ISP_DDR_WORD_BITS 256
-#define HIVE_ISP_DDR_WORD_BYTES  (HIVE_ISP_DDR_WORD_BITS / 8)
-#define HIVE_ISP_DDR_BYTES       (512 * 1024 * 1024) /* hss only */
-#define HIVE_ISP_DDR_BYTES_RTL   (127 * 1024 * 1024) /* RTL only */
+#define HIVE_ISP_DDR_WORD_BYTES (HIVE_ISP_DDR_WORD_BITS / 8)
+#define HIVE_ISP_DDR_BYTES (512 * 1024 * 1024) /* hss only */
+#define HIVE_ISP_DDR_BYTES_RTL (127 * 1024 * 1024) /* RTL only */
 #define HIVE_ISP_DDR_SMALL_BYTES (128 * 256 / 8)
-#define HIVE_ISP_PAGE_SHIFT    12
-#define HIVE_ISP_PAGE_SIZE     BIT(HIVE_ISP_PAGE_SHIFT)
+#define HIVE_ISP_PAGE_SHIFT 12
+#define HIVE_ISP_PAGE_SIZE BIT(HIVE_ISP_PAGE_SHIFT)
 
-#define CSS_DDR_WORD_BITS        HIVE_ISP_DDR_WORD_BITS
-#define CSS_DDR_WORD_BYTES       HIVE_ISP_DDR_WORD_BYTES
+#define CSS_DDR_WORD_BITS HIVE_ISP_DDR_WORD_BITS
+#define CSS_DDR_WORD_BYTES HIVE_ISP_DDR_WORD_BYTES
 
 /* If HIVE_ISP_DDR_BASE_OFFSET is set to a non-zero value, the wide bus just before the DDRAM gets an extra dummy port where         */
 /* address range 0 .. HIVE_ISP_DDR_BASE_OFFSET-1 maps onto. This effectively creates an offset for the DDRAM from system perspective */
@@ -40,364 +47,364 @@
 #define HIVE_DMA_BUS_MASTER master_port1
 #define HIVE_DMA_DDR_MASTER master_port2
 
-#define HIVE_DMA_NUM_CHANNELS       32 /* old value was  8 */
-#define HIVE_DMA_CMD_FIFO_DEPTH     24 /* old value was 12 */
+#define HIVE_DMA_NUM_CHANNELS 32 /* old value was  8 */
+#define HIVE_DMA_CMD_FIFO_DEPTH 24 /* old value was 12 */
 
 #define HIVE_IF_PIXEL_WIDTH 12
 
-#define HIVE_MMU_TLB_SETS           8
-#define HIVE_MMU_TLB_SET_BLOCKS     8
+#define HIVE_MMU_TLB_SETS 8
+#define HIVE_MMU_TLB_SET_BLOCKS 8
 #define HIVE_MMU_TLB_BLOCK_ELEMENTS 8
-#define HIVE_MMU_PAGE_TABLE_LEVELS  2
-#define HIVE_MMU_PAGE_BYTES         HIVE_ISP_PAGE_SIZE
+#define HIVE_MMU_PAGE_TABLE_LEVELS 2
+#define HIVE_MMU_PAGE_BYTES HIVE_ISP_PAGE_SIZE
 
-#define HIVE_ISP_CH_ID_BITS    2
+#define HIVE_ISP_CH_ID_BITS 2
 #define HIVE_ISP_FMT_TYPE_BITS 5
 #define HIVE_ISP_ISEL_SEL_BITS 2
 
-#define HIVE_GP_REGS_SDRAM_WAKEUP_IDX                           0
-#define HIVE_GP_REGS_IDLE_IDX                                   1
-#define HIVE_GP_REGS_IRQ_0_IDX                                  2
-#define HIVE_GP_REGS_IRQ_1_IDX                                  3
-#define HIVE_GP_REGS_SP_STREAM_STAT_IDX                         4
-#define HIVE_GP_REGS_SP_STREAM_STAT_B_IDX                       5
-#define HIVE_GP_REGS_ISP_STREAM_STAT_IDX                        6
-#define HIVE_GP_REGS_MOD_STREAM_STAT_IDX                        7
-#define HIVE_GP_REGS_SP_STREAM_STAT_IRQ_COND_IDX                8
-#define HIVE_GP_REGS_SP_STREAM_STAT_B_IRQ_COND_IDX              9
-#define HIVE_GP_REGS_ISP_STREAM_STAT_IRQ_COND_IDX              10
-#define HIVE_GP_REGS_MOD_STREAM_STAT_IRQ_COND_IDX              11
-#define HIVE_GP_REGS_SP_STREAM_STAT_IRQ_ENABLE_IDX             12
-#define HIVE_GP_REGS_SP_STREAM_STAT_B_IRQ_ENABLE_IDX           13
-#define HIVE_GP_REGS_ISP_STREAM_STAT_IRQ_ENABLE_IDX            14
-#define HIVE_GP_REGS_MOD_STREAM_STAT_IRQ_ENABLE_IDX            15
-#define HIVE_GP_REGS_SWITCH_PRIM_IF_IDX                        16
-#define HIVE_GP_REGS_SWITCH_GDC1_IDX                           17
-#define HIVE_GP_REGS_SWITCH_GDC2_IDX                           18
-#define HIVE_GP_REGS_SRST_IDX                                  19
-#define HIVE_GP_REGS_SLV_REG_SRST_IDX                          20
+#define HIVE_GP_REGS_SDRAM_WAKEUP_IDX 0
+#define HIVE_GP_REGS_IDLE_IDX 1
+#define HIVE_GP_REGS_IRQ_0_IDX 2
+#define HIVE_GP_REGS_IRQ_1_IDX 3
+#define HIVE_GP_REGS_SP_STREAM_STAT_IDX 4
+#define HIVE_GP_REGS_SP_STREAM_STAT_B_IDX 5
+#define HIVE_GP_REGS_ISP_STREAM_STAT_IDX 6
+#define HIVE_GP_REGS_MOD_STREAM_STAT_IDX 7
+#define HIVE_GP_REGS_SP_STREAM_STAT_IRQ_COND_IDX 8
+#define HIVE_GP_REGS_SP_STREAM_STAT_B_IRQ_COND_IDX 9
+#define HIVE_GP_REGS_ISP_STREAM_STAT_IRQ_COND_IDX 10
+#define HIVE_GP_REGS_MOD_STREAM_STAT_IRQ_COND_IDX 11
+#define HIVE_GP_REGS_SP_STREAM_STAT_IRQ_ENABLE_IDX 12
+#define HIVE_GP_REGS_SP_STREAM_STAT_B_IRQ_ENABLE_IDX 13
+#define HIVE_GP_REGS_ISP_STREAM_STAT_IRQ_ENABLE_IDX 14
+#define HIVE_GP_REGS_MOD_STREAM_STAT_IRQ_ENABLE_IDX 15
+#define HIVE_GP_REGS_SWITCH_PRIM_IF_IDX 16
+#define HIVE_GP_REGS_SWITCH_GDC1_IDX 17
+#define HIVE_GP_REGS_SWITCH_GDC2_IDX 18
+#define HIVE_GP_REGS_SRST_IDX 19
+#define HIVE_GP_REGS_SLV_REG_SRST_IDX 20
 
 /* Bit numbers of the soft reset register */
-#define HIVE_GP_REGS_SRST_ISYS_CBUS                             0
-#define HIVE_GP_REGS_SRST_ISEL_CBUS                             1
-#define HIVE_GP_REGS_SRST_IFMT_CBUS                             2
-#define HIVE_GP_REGS_SRST_GPDEV_CBUS                            3
-#define HIVE_GP_REGS_SRST_GPIO                                  4
-#define HIVE_GP_REGS_SRST_TC                                    5
-#define HIVE_GP_REGS_SRST_GPTIMER                               6
-#define HIVE_GP_REGS_SRST_FACELLFIFOS                           7
-#define HIVE_GP_REGS_SRST_D_OSYS                                8
-#define HIVE_GP_REGS_SRST_IFT_SEC_PIPE                          9
-#define HIVE_GP_REGS_SRST_GDC1                                 10
-#define HIVE_GP_REGS_SRST_GDC2                                 11
-#define HIVE_GP_REGS_SRST_VEC_BUS                              12
-#define HIVE_GP_REGS_SRST_ISP                                  13
-#define HIVE_GP_REGS_SRST_SLV_GRP_BUS                          14
-#define HIVE_GP_REGS_SRST_DMA                                  15
-#define HIVE_GP_REGS_SRST_SF_ISP_SP                            16
-#define HIVE_GP_REGS_SRST_SF_PIF_CELLS                         17
-#define HIVE_GP_REGS_SRST_SF_SIF_SP                            18
-#define HIVE_GP_REGS_SRST_SF_MC_SP                             19
-#define HIVE_GP_REGS_SRST_SF_ISYS_SP                           20
-#define HIVE_GP_REGS_SRST_SF_DMA_CELLS                         21
-#define HIVE_GP_REGS_SRST_SF_GDC1_CELLS                        22
-#define HIVE_GP_REGS_SRST_SF_GDC2_CELLS                        23
-#define HIVE_GP_REGS_SRST_SP                                   24
-#define HIVE_GP_REGS_SRST_OCP2CIO                              25
-#define HIVE_GP_REGS_SRST_NBUS                                 26
-#define HIVE_GP_REGS_SRST_HOST12BUS                            27
-#define HIVE_GP_REGS_SRST_WBUS                                 28
-#define HIVE_GP_REGS_SRST_IC_OSYS                              29
-#define HIVE_GP_REGS_SRST_WBUS_IC                              30
+#define HIVE_GP_REGS_SRST_ISYS_CBUS 0
+#define HIVE_GP_REGS_SRST_ISEL_CBUS 1
+#define HIVE_GP_REGS_SRST_IFMT_CBUS 2
+#define HIVE_GP_REGS_SRST_GPDEV_CBUS 3
+#define HIVE_GP_REGS_SRST_GPIO 4
+#define HIVE_GP_REGS_SRST_TC 5
+#define HIVE_GP_REGS_SRST_GPTIMER 6
+#define HIVE_GP_REGS_SRST_FACELLFIFOS 7
+#define HIVE_GP_REGS_SRST_D_OSYS 8
+#define HIVE_GP_REGS_SRST_IFT_SEC_PIPE 9
+#define HIVE_GP_REGS_SRST_GDC1 10
+#define HIVE_GP_REGS_SRST_GDC2 11
+#define HIVE_GP_REGS_SRST_VEC_BUS 12
+#define HIVE_GP_REGS_SRST_ISP 13
+#define HIVE_GP_REGS_SRST_SLV_GRP_BUS 14
+#define HIVE_GP_REGS_SRST_DMA 15
+#define HIVE_GP_REGS_SRST_SF_ISP_SP 16
+#define HIVE_GP_REGS_SRST_SF_PIF_CELLS 17
+#define HIVE_GP_REGS_SRST_SF_SIF_SP 18
+#define HIVE_GP_REGS_SRST_SF_MC_SP 19
+#define HIVE_GP_REGS_SRST_SF_ISYS_SP 20
+#define HIVE_GP_REGS_SRST_SF_DMA_CELLS 21
+#define HIVE_GP_REGS_SRST_SF_GDC1_CELLS 22
+#define HIVE_GP_REGS_SRST_SF_GDC2_CELLS 23
+#define HIVE_GP_REGS_SRST_SP 24
+#define HIVE_GP_REGS_SRST_OCP2CIO 25
+#define HIVE_GP_REGS_SRST_NBUS 26
+#define HIVE_GP_REGS_SRST_HOST12BUS 27
+#define HIVE_GP_REGS_SRST_WBUS 28
+#define HIVE_GP_REGS_SRST_IC_OSYS 29
+#define HIVE_GP_REGS_SRST_WBUS_IC 30
 
 /* Bit numbers of the slave register soft reset register */
-#define HIVE_GP_REGS_SLV_REG_SRST_DMA                           0
-#define HIVE_GP_REGS_SLV_REG_SRST_GDC1                          1
-#define HIVE_GP_REGS_SLV_REG_SRST_GDC2                          2
+#define HIVE_GP_REGS_SLV_REG_SRST_DMA 0
+#define HIVE_GP_REGS_SLV_REG_SRST_GDC1 1
+#define HIVE_GP_REGS_SLV_REG_SRST_GDC2 2
 
 /* order of the input bits for the irq controller */
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID                       0
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID                       1
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID                       2
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID                       3
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID                       4
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID                       5
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID                       6
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID                       7
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID                       8
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID                       9
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID                     10
-#define HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID                     11
-#define HIVE_GP_DEV_IRQ_SP_BIT_ID                              12
-#define HIVE_GP_DEV_IRQ_ISP_BIT_ID                             13
-#define HIVE_GP_DEV_IRQ_ISYS_BIT_ID                            14
-#define HIVE_GP_DEV_IRQ_ISEL_BIT_ID                            15
-#define HIVE_GP_DEV_IRQ_IFMT_BIT_ID                            16
-#define HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID                   17
-#define HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID                  18
-#define HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID                  19
-#define HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID                  20
-#define HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID                 21
-#define HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID                  22
-#define HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID             23
-#define HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID                   24
-#define HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID             25
-#define HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID                      26
-#define HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID                      27
-#define HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID                        28
-#define HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID                        29
-#define HIVE_GP_DEV_IRQ_DMA_BIT_ID                             30
-#define HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID                 31
-
-#define HIVE_GP_REGS_NUM_SW_IRQ_REGS                            2
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID 0
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID 1
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID 2
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID 3
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID 4
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID 5
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID 6
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID 7
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID 8
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID 9
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID 10
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID 11
+#define HIVE_GP_DEV_IRQ_SP_BIT_ID 12
+#define HIVE_GP_DEV_IRQ_ISP_BIT_ID 13
+#define HIVE_GP_DEV_IRQ_ISYS_BIT_ID 14
+#define HIVE_GP_DEV_IRQ_ISEL_BIT_ID 15
+#define HIVE_GP_DEV_IRQ_IFMT_BIT_ID 16
+#define HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID 17
+#define HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID 18
+#define HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID 19
+#define HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID 20
+#define HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID 21
+#define HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID 22
+#define HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID 23
+#define HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID 24
+#define HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID 25
+#define HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID 26
+#define HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID 27
+#define HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID 28
+#define HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID 29
+#define HIVE_GP_DEV_IRQ_DMA_BIT_ID 30
+#define HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID 31
+
+#define HIVE_GP_REGS_NUM_SW_IRQ_REGS 2
 
 /* order of the input bits for the timed controller */
-#define HIVE_GP_DEV_TC_GPIO_PIN_0_BIT_ID                       0
-#define HIVE_GP_DEV_TC_GPIO_PIN_1_BIT_ID                       1
-#define HIVE_GP_DEV_TC_GPIO_PIN_2_BIT_ID                       2
-#define HIVE_GP_DEV_TC_GPIO_PIN_3_BIT_ID                       3
-#define HIVE_GP_DEV_TC_GPIO_PIN_4_BIT_ID                       4
-#define HIVE_GP_DEV_TC_GPIO_PIN_5_BIT_ID                       5
-#define HIVE_GP_DEV_TC_GPIO_PIN_6_BIT_ID                       6
-#define HIVE_GP_DEV_TC_GPIO_PIN_7_BIT_ID                       7
-#define HIVE_GP_DEV_TC_GPIO_PIN_8_BIT_ID                       8
-#define HIVE_GP_DEV_TC_GPIO_PIN_9_BIT_ID                       9
-#define HIVE_GP_DEV_TC_GPIO_PIN_10_BIT_ID                     10
-#define HIVE_GP_DEV_TC_GPIO_PIN_11_BIT_ID                     11
-#define HIVE_GP_DEV_TC_SP_BIT_ID                              12
-#define HIVE_GP_DEV_TC_ISP_BIT_ID                             13
-#define HIVE_GP_DEV_TC_ISYS_BIT_ID                            14
-#define HIVE_GP_DEV_TC_ISEL_BIT_ID                            15
-#define HIVE_GP_DEV_TC_IFMT_BIT_ID                            16
-#define HIVE_GP_DEV_TC_GP_TIMER_0_BIT_ID                      17
-#define HIVE_GP_DEV_TC_GP_TIMER_1_BIT_ID                      18
-#define HIVE_GP_DEV_TC_MIPI_SOL_BIT_ID                        19
-#define HIVE_GP_DEV_TC_MIPI_EOL_BIT_ID                        20
-#define HIVE_GP_DEV_TC_MIPI_SOF_BIT_ID                        21
-#define HIVE_GP_DEV_TC_MIPI_EOF_BIT_ID                        22
-#define HIVE_GP_DEV_TC_INPSYS_SM                              23
+#define HIVE_GP_DEV_TC_GPIO_PIN_0_BIT_ID 0
+#define HIVE_GP_DEV_TC_GPIO_PIN_1_BIT_ID 1
+#define HIVE_GP_DEV_TC_GPIO_PIN_2_BIT_ID 2
+#define HIVE_GP_DEV_TC_GPIO_PIN_3_BIT_ID 3
+#define HIVE_GP_DEV_TC_GPIO_PIN_4_BIT_ID 4
+#define HIVE_GP_DEV_TC_GPIO_PIN_5_BIT_ID 5
+#define HIVE_GP_DEV_TC_GPIO_PIN_6_BIT_ID 6
+#define HIVE_GP_DEV_TC_GPIO_PIN_7_BIT_ID 7
+#define HIVE_GP_DEV_TC_GPIO_PIN_8_BIT_ID 8
+#define HIVE_GP_DEV_TC_GPIO_PIN_9_BIT_ID 9
+#define HIVE_GP_DEV_TC_GPIO_PIN_10_BIT_ID 10
+#define HIVE_GP_DEV_TC_GPIO_PIN_11_BIT_ID 11
+#define HIVE_GP_DEV_TC_SP_BIT_ID 12
+#define HIVE_GP_DEV_TC_ISP_BIT_ID 13
+#define HIVE_GP_DEV_TC_ISYS_BIT_ID 14
+#define HIVE_GP_DEV_TC_ISEL_BIT_ID 15
+#define HIVE_GP_DEV_TC_IFMT_BIT_ID 16
+#define HIVE_GP_DEV_TC_GP_TIMER_0_BIT_ID 17
+#define HIVE_GP_DEV_TC_GP_TIMER_1_BIT_ID 18
+#define HIVE_GP_DEV_TC_MIPI_SOL_BIT_ID 19
+#define HIVE_GP_DEV_TC_MIPI_EOL_BIT_ID 20
+#define HIVE_GP_DEV_TC_MIPI_SOF_BIT_ID 21
+#define HIVE_GP_DEV_TC_MIPI_EOF_BIT_ID 22
+#define HIVE_GP_DEV_TC_INPSYS_SM 23
 
 /* definitions for the gp_timer block */
-#define HIVE_GP_TIMER_0                                         0
-#define HIVE_GP_TIMER_1                                         1
-#define HIVE_GP_TIMER_2                                         2
-#define HIVE_GP_TIMER_3                                         3
-#define HIVE_GP_TIMER_4                                         4
-#define HIVE_GP_TIMER_5                                         5
-#define HIVE_GP_TIMER_6                                         6
-#define HIVE_GP_TIMER_7                                         7
-#define HIVE_GP_TIMER_NUM_COUNTERS                              8
-
-#define HIVE_GP_TIMER_IRQ_0                                     0
-#define HIVE_GP_TIMER_IRQ_1                                     1
-#define HIVE_GP_TIMER_NUM_IRQS                                  2
-
-#define HIVE_GP_TIMER_GPIO_0_BIT_ID                             0
-#define HIVE_GP_TIMER_GPIO_1_BIT_ID                             1
-#define HIVE_GP_TIMER_GPIO_2_BIT_ID                             2
-#define HIVE_GP_TIMER_GPIO_3_BIT_ID                             3
-#define HIVE_GP_TIMER_GPIO_4_BIT_ID                             4
-#define HIVE_GP_TIMER_GPIO_5_BIT_ID                             5
-#define HIVE_GP_TIMER_GPIO_6_BIT_ID                             6
-#define HIVE_GP_TIMER_GPIO_7_BIT_ID                             7
-#define HIVE_GP_TIMER_GPIO_8_BIT_ID                             8
-#define HIVE_GP_TIMER_GPIO_9_BIT_ID                             9
-#define HIVE_GP_TIMER_GPIO_10_BIT_ID                           10
-#define HIVE_GP_TIMER_GPIO_11_BIT_ID                           11
-#define HIVE_GP_TIMER_INP_SYS_IRQ                              12
-#define HIVE_GP_TIMER_ISEL_IRQ                                 13
-#define HIVE_GP_TIMER_IFMT_IRQ                                 14
-#define HIVE_GP_TIMER_SP_STRMON_IRQ                            15
-#define HIVE_GP_TIMER_SP_B_STRMON_IRQ                          16
-#define HIVE_GP_TIMER_ISP_STRMON_IRQ                           17
-#define HIVE_GP_TIMER_MOD_STRMON_IRQ                           18
-#define HIVE_GP_TIMER_ISP_BAMEM_ERROR_IRQ                      20
-#define HIVE_GP_TIMER_ISP_DMEM_ERROR_IRQ                       21
-#define HIVE_GP_TIMER_SP_ICACHE_MEM_ERROR_IRQ                  22
-#define HIVE_GP_TIMER_SP_DMEM_ERROR_IRQ                        23
-#define HIVE_GP_TIMER_SP_OUT_RUN_DP                            24
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I0         25
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I1         26
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I2         27
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I3         28
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I4         29
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I5         30
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I6         31
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I7         32
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I8         33
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I9         34
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I10        35
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I1_I0         36
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I2_I0         37
-#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I3_I0         38
-#define HIVE_GP_TIMER_ISP_OUT_RUN_DP                           39
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I0_I0        40
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I0_I1        41
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I1_I0        42
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I0        43
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I1        44
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I2        45
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I3        46
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I4        47
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I5        48
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I6        49
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I3_I0        50
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I4_I0        51
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I5_I0        52
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I6_I0        53
-#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I7_I0        54
-#define HIVE_GP_TIMER_MIPI_SOL_BIT_ID                          55
-#define HIVE_GP_TIMER_MIPI_EOL_BIT_ID                          56
-#define HIVE_GP_TIMER_MIPI_SOF_BIT_ID                          57
-#define HIVE_GP_TIMER_MIPI_EOF_BIT_ID                          58
-#define HIVE_GP_TIMER_INPSYS_SM                                59
+#define HIVE_GP_TIMER_0 0
+#define HIVE_GP_TIMER_1 1
+#define HIVE_GP_TIMER_2 2
+#define HIVE_GP_TIMER_3 3
+#define HIVE_GP_TIMER_4 4
+#define HIVE_GP_TIMER_5 5
+#define HIVE_GP_TIMER_6 6
+#define HIVE_GP_TIMER_7 7
+#define HIVE_GP_TIMER_NUM_COUNTERS 8
+
+#define HIVE_GP_TIMER_IRQ_0 0
+#define HIVE_GP_TIMER_IRQ_1 1
+#define HIVE_GP_TIMER_NUM_IRQS 2
+
+#define HIVE_GP_TIMER_GPIO_0_BIT_ID 0
+#define HIVE_GP_TIMER_GPIO_1_BIT_ID 1
+#define HIVE_GP_TIMER_GPIO_2_BIT_ID 2
+#define HIVE_GP_TIMER_GPIO_3_BIT_ID 3
+#define HIVE_GP_TIMER_GPIO_4_BIT_ID 4
+#define HIVE_GP_TIMER_GPIO_5_BIT_ID 5
+#define HIVE_GP_TIMER_GPIO_6_BIT_ID 6
+#define HIVE_GP_TIMER_GPIO_7_BIT_ID 7
+#define HIVE_GP_TIMER_GPIO_8_BIT_ID 8
+#define HIVE_GP_TIMER_GPIO_9_BIT_ID 9
+#define HIVE_GP_TIMER_GPIO_10_BIT_ID 10
+#define HIVE_GP_TIMER_GPIO_11_BIT_ID 11
+#define HIVE_GP_TIMER_INP_SYS_IRQ 12
+#define HIVE_GP_TIMER_ISEL_IRQ 13
+#define HIVE_GP_TIMER_IFMT_IRQ 14
+#define HIVE_GP_TIMER_SP_STRMON_IRQ 15
+#define HIVE_GP_TIMER_SP_B_STRMON_IRQ 16
+#define HIVE_GP_TIMER_ISP_STRMON_IRQ 17
+#define HIVE_GP_TIMER_MOD_STRMON_IRQ 18
+#define HIVE_GP_TIMER_ISP_BAMEM_ERROR_IRQ 20
+#define HIVE_GP_TIMER_ISP_DMEM_ERROR_IRQ 21
+#define HIVE_GP_TIMER_SP_ICACHE_MEM_ERROR_IRQ 22
+#define HIVE_GP_TIMER_SP_DMEM_ERROR_IRQ 23
+#define HIVE_GP_TIMER_SP_OUT_RUN_DP 24
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I0 25
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I1 26
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I2 27
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I3 28
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I4 29
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I5 30
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I6 31
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I7 32
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I8 33
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I9 34
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I10 35
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I1_I0 36
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I2_I0 37
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I3_I0 38
+#define HIVE_GP_TIMER_ISP_OUT_RUN_DP 39
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I0_I0 40
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I0_I1 41
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I1_I0 42
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I0 43
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I1 44
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I2 45
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I3 46
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I4 47
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I5 48
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I6 49
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I3_I0 50
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I4_I0 51
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I5_I0 52
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I6_I0 53
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I7_I0 54
+#define HIVE_GP_TIMER_MIPI_SOL_BIT_ID 55
+#define HIVE_GP_TIMER_MIPI_EOL_BIT_ID 56
+#define HIVE_GP_TIMER_MIPI_SOF_BIT_ID 57
+#define HIVE_GP_TIMER_MIPI_EOF_BIT_ID 58
+#define HIVE_GP_TIMER_INPSYS_SM 59
 
 /* port definitions for the streaming monitors */
 /* port definititions SP streaming monitor, monitors the status of streaming ports at the SP side of the streaming FIFO's */
-#define SP_STR_MON_PORT_SP2SIF            0
-#define SP_STR_MON_PORT_SIF2SP            1
-#define SP_STR_MON_PORT_SP2MC             2
-#define SP_STR_MON_PORT_MC2SP             3
-#define SP_STR_MON_PORT_SP2DMA            4
-#define SP_STR_MON_PORT_DMA2SP            5
-#define SP_STR_MON_PORT_SP2ISP            6
-#define SP_STR_MON_PORT_ISP2SP            7
-#define SP_STR_MON_PORT_SP2GPD            8
-#define SP_STR_MON_PORT_FA2SP             9
-#define SP_STR_MON_PORT_SP2ISYS          10
-#define SP_STR_MON_PORT_ISYS2SP          11
-#define SP_STR_MON_PORT_SP2PIFA          12
-#define SP_STR_MON_PORT_PIFA2SP          13
-#define SP_STR_MON_PORT_SP2PIFB          14
-#define SP_STR_MON_PORT_PIFB2SP          15
-
-#define SP_STR_MON_PORT_B_SP2GDC1         0
-#define SP_STR_MON_PORT_B_GDC12SP         1
-#define SP_STR_MON_PORT_B_SP2GDC2         2
-#define SP_STR_MON_PORT_B_GDC22SP         3
+#define SP_STR_MON_PORT_SP2SIF 0
+#define SP_STR_MON_PORT_SIF2SP 1
+#define SP_STR_MON_PORT_SP2MC 2
+#define SP_STR_MON_PORT_MC2SP 3
+#define SP_STR_MON_PORT_SP2DMA 4
+#define SP_STR_MON_PORT_DMA2SP 5
+#define SP_STR_MON_PORT_SP2ISP 6
+#define SP_STR_MON_PORT_ISP2SP 7
+#define SP_STR_MON_PORT_SP2GPD 8
+#define SP_STR_MON_PORT_FA2SP 9
+#define SP_STR_MON_PORT_SP2ISYS 10
+#define SP_STR_MON_PORT_ISYS2SP 11
+#define SP_STR_MON_PORT_SP2PIFA 12
+#define SP_STR_MON_PORT_PIFA2SP 13
+#define SP_STR_MON_PORT_SP2PIFB 14
+#define SP_STR_MON_PORT_PIFB2SP 15
+
+#define SP_STR_MON_PORT_B_SP2GDC1 0
+#define SP_STR_MON_PORT_B_GDC12SP 1
+#define SP_STR_MON_PORT_B_SP2GDC2 2
+#define SP_STR_MON_PORT_B_GDC22SP 3
 
 /* previously used SP streaming monitor port identifiers, kept for backward compatibility */
-#define SP_STR_MON_PORT_SND_SIF           SP_STR_MON_PORT_SP2SIF
-#define SP_STR_MON_PORT_RCV_SIF           SP_STR_MON_PORT_SIF2SP
-#define SP_STR_MON_PORT_SND_MC            SP_STR_MON_PORT_SP2MC
-#define SP_STR_MON_PORT_RCV_MC            SP_STR_MON_PORT_MC2SP
-#define SP_STR_MON_PORT_SND_DMA           SP_STR_MON_PORT_SP2DMA
-#define SP_STR_MON_PORT_RCV_DMA           SP_STR_MON_PORT_DMA2SP
-#define SP_STR_MON_PORT_SND_ISP           SP_STR_MON_PORT_SP2ISP
-#define SP_STR_MON_PORT_RCV_ISP           SP_STR_MON_PORT_ISP2SP
-#define SP_STR_MON_PORT_SND_GPD           SP_STR_MON_PORT_SP2GPD
-#define SP_STR_MON_PORT_RCV_GPD           SP_STR_MON_PORT_FA2SP
+#define SP_STR_MON_PORT_SND_SIF SP_STR_MON_PORT_SP2SIF
+#define SP_STR_MON_PORT_RCV_SIF SP_STR_MON_PORT_SIF2SP
+#define SP_STR_MON_PORT_SND_MC SP_STR_MON_PORT_SP2MC
+#define SP_STR_MON_PORT_RCV_MC SP_STR_MON_PORT_MC2SP
+#define SP_STR_MON_PORT_SND_DMA SP_STR_MON_PORT_SP2DMA
+#define SP_STR_MON_PORT_RCV_DMA SP_STR_MON_PORT_DMA2SP
+#define SP_STR_MON_PORT_SND_ISP SP_STR_MON_PORT_SP2ISP
+#define SP_STR_MON_PORT_RCV_ISP SP_STR_MON_PORT_ISP2SP
+#define SP_STR_MON_PORT_SND_GPD SP_STR_MON_PORT_SP2GPD
+#define SP_STR_MON_PORT_RCV_GPD SP_STR_MON_PORT_FA2SP
 /* Deprecated */
-#define SP_STR_MON_PORT_SND_PIF           SP_STR_MON_PORT_SP2PIFA
-#define SP_STR_MON_PORT_RCV_PIF           SP_STR_MON_PORT_PIFA2SP
-#define SP_STR_MON_PORT_SND_PIFB          SP_STR_MON_PORT_SP2PIFB
-#define SP_STR_MON_PORT_RCV_PIFB          SP_STR_MON_PORT_PIFB2SP
+#define SP_STR_MON_PORT_SND_PIF SP_STR_MON_PORT_SP2PIFA
+#define SP_STR_MON_PORT_RCV_PIF SP_STR_MON_PORT_PIFA2SP
+#define SP_STR_MON_PORT_SND_PIFB SP_STR_MON_PORT_SP2PIFB
+#define SP_STR_MON_PORT_RCV_PIFB SP_STR_MON_PORT_PIFB2SP
 
-#define SP_STR_MON_PORT_SND_PIF_A         SP_STR_MON_PORT_SP2PIFA
-#define SP_STR_MON_PORT_RCV_PIF_A         SP_STR_MON_PORT_PIFA2SP
-#define SP_STR_MON_PORT_SND_PIF_B         SP_STR_MON_PORT_SP2PIFB
-#define SP_STR_MON_PORT_RCV_PIF_B         SP_STR_MON_PORT_PIFB2SP
+#define SP_STR_MON_PORT_SND_PIF_A SP_STR_MON_PORT_SP2PIFA
+#define SP_STR_MON_PORT_RCV_PIF_A SP_STR_MON_PORT_PIFA2SP
+#define SP_STR_MON_PORT_SND_PIF_B SP_STR_MON_PORT_SP2PIFB
+#define SP_STR_MON_PORT_RCV_PIF_B SP_STR_MON_PORT_PIFB2SP
 
 /* port definititions ISP streaming monitor, monitors the status of streaming ports at the ISP side of the streaming FIFO's */
-#define ISP_STR_MON_PORT_ISP2PIFA         0
-#define ISP_STR_MON_PORT_PIFA2ISP         1
-#define ISP_STR_MON_PORT_ISP2PIFB         2
-#define ISP_STR_MON_PORT_PIFB2ISP         3
-#define ISP_STR_MON_PORT_ISP2DMA          4
-#define ISP_STR_MON_PORT_DMA2ISP          5
-#define ISP_STR_MON_PORT_ISP2GDC1         6
-#define ISP_STR_MON_PORT_GDC12ISP         7
-#define ISP_STR_MON_PORT_ISP2GDC2         8
-#define ISP_STR_MON_PORT_GDC22ISP         9
-#define ISP_STR_MON_PORT_ISP2GPD         10
-#define ISP_STR_MON_PORT_FA2ISP          11
-#define ISP_STR_MON_PORT_ISP2SP          12
-#define ISP_STR_MON_PORT_SP2ISP          13
+#define ISP_STR_MON_PORT_ISP2PIFA 0
+#define ISP_STR_MON_PORT_PIFA2ISP 1
+#define ISP_STR_MON_PORT_ISP2PIFB 2
+#define ISP_STR_MON_PORT_PIFB2ISP 3
+#define ISP_STR_MON_PORT_ISP2DMA 4
+#define ISP_STR_MON_PORT_DMA2ISP 5
+#define ISP_STR_MON_PORT_ISP2GDC1 6
+#define ISP_STR_MON_PORT_GDC12ISP 7
+#define ISP_STR_MON_PORT_ISP2GDC2 8
+#define ISP_STR_MON_PORT_GDC22ISP 9
+#define ISP_STR_MON_PORT_ISP2GPD 10
+#define ISP_STR_MON_PORT_FA2ISP 11
+#define ISP_STR_MON_PORT_ISP2SP 12
+#define ISP_STR_MON_PORT_SP2ISP 13
 
 /* previously used ISP streaming monitor port identifiers, kept for backward compatibility */
-#define ISP_STR_MON_PORT_SND_PIF_A       ISP_STR_MON_PORT_ISP2PIFA
-#define ISP_STR_MON_PORT_RCV_PIF_A       ISP_STR_MON_PORT_PIFA2ISP
-#define ISP_STR_MON_PORT_SND_PIF_B       ISP_STR_MON_PORT_ISP2PIFB
-#define ISP_STR_MON_PORT_RCV_PIF_B       ISP_STR_MON_PORT_PIFB2ISP
-#define ISP_STR_MON_PORT_SND_DMA         ISP_STR_MON_PORT_ISP2DMA
-#define ISP_STR_MON_PORT_RCV_DMA         ISP_STR_MON_PORT_DMA2ISP
-#define ISP_STR_MON_PORT_SND_GDC         ISP_STR_MON_PORT_ISP2GDC1
-#define ISP_STR_MON_PORT_RCV_GDC         ISP_STR_MON_PORT_GDC12ISP
-#define ISP_STR_MON_PORT_SND_GPD         ISP_STR_MON_PORT_ISP2GPD
-#define ISP_STR_MON_PORT_RCV_GPD         ISP_STR_MON_PORT_FA2ISP
-#define ISP_STR_MON_PORT_SND_SP          ISP_STR_MON_PORT_ISP2SP
-#define ISP_STR_MON_PORT_RCV_SP          ISP_STR_MON_PORT_SP2ISP
+#define ISP_STR_MON_PORT_SND_PIF_A ISP_STR_MON_PORT_ISP2PIFA
+#define ISP_STR_MON_PORT_RCV_PIF_A ISP_STR_MON_PORT_PIFA2ISP
+#define ISP_STR_MON_PORT_SND_PIF_B ISP_STR_MON_PORT_ISP2PIFB
+#define ISP_STR_MON_PORT_RCV_PIF_B ISP_STR_MON_PORT_PIFB2ISP
+#define ISP_STR_MON_PORT_SND_DMA ISP_STR_MON_PORT_ISP2DMA
+#define ISP_STR_MON_PORT_RCV_DMA ISP_STR_MON_PORT_DMA2ISP
+#define ISP_STR_MON_PORT_SND_GDC ISP_STR_MON_PORT_ISP2GDC1
+#define ISP_STR_MON_PORT_RCV_GDC ISP_STR_MON_PORT_GDC12ISP
+#define ISP_STR_MON_PORT_SND_GPD ISP_STR_MON_PORT_ISP2GPD
+#define ISP_STR_MON_PORT_RCV_GPD ISP_STR_MON_PORT_FA2ISP
+#define ISP_STR_MON_PORT_SND_SP ISP_STR_MON_PORT_ISP2SP
+#define ISP_STR_MON_PORT_RCV_SP ISP_STR_MON_PORT_SP2ISP
 
 /* port definititions MOD streaming monitor, monitors the status of streaming ports at the module side of the streaming FIFO's */
 
-#define MOD_STR_MON_PORT_PIFA2CELLS       0
-#define MOD_STR_MON_PORT_CELLS2PIFA       1
-#define MOD_STR_MON_PORT_PIFB2CELLS       2
-#define MOD_STR_MON_PORT_CELLS2PIFB       3
-#define MOD_STR_MON_PORT_SIF2SP           4
-#define MOD_STR_MON_PORT_SP2SIF           5
-#define MOD_STR_MON_PORT_MC2SP            6
-#define MOD_STR_MON_PORT_SP2MC            7
-#define MOD_STR_MON_PORT_DMA2ISP          8
-#define MOD_STR_MON_PORT_ISP2DMA          9
-#define MOD_STR_MON_PORT_DMA2SP          10
-#define MOD_STR_MON_PORT_SP2DMA          11
-#define MOD_STR_MON_PORT_GDC12CELLS      12
-#define MOD_STR_MON_PORT_CELLS2GDC1      13
-#define MOD_STR_MON_PORT_GDC22CELLS      14
-#define MOD_STR_MON_PORT_CELLS2GDC2      15
-
-#define MOD_STR_MON_PORT_SND_PIF_A        0
-#define MOD_STR_MON_PORT_RCV_PIF_A        1
-#define MOD_STR_MON_PORT_SND_PIF_B        2
-#define MOD_STR_MON_PORT_RCV_PIF_B        3
-#define MOD_STR_MON_PORT_SND_SIF          4
-#define MOD_STR_MON_PORT_RCV_SIF          5
-#define MOD_STR_MON_PORT_SND_MC           6
-#define MOD_STR_MON_PORT_RCV_MC           7
-#define MOD_STR_MON_PORT_SND_DMA2ISP      8
-#define MOD_STR_MON_PORT_RCV_DMA_FR_ISP   9
-#define MOD_STR_MON_PORT_SND_DMA2SP      10
-#define MOD_STR_MON_PORT_RCV_DMA_FR_SP   11
-#define MOD_STR_MON_PORT_SND_GDC         12
-#define MOD_STR_MON_PORT_RCV_GDC         13
+#define MOD_STR_MON_PORT_PIFA2CELLS 0
+#define MOD_STR_MON_PORT_CELLS2PIFA 1
+#define MOD_STR_MON_PORT_PIFB2CELLS 2
+#define MOD_STR_MON_PORT_CELLS2PIFB 3
+#define MOD_STR_MON_PORT_SIF2SP 4
+#define MOD_STR_MON_PORT_SP2SIF 5
+#define MOD_STR_MON_PORT_MC2SP 6
+#define MOD_STR_MON_PORT_SP2MC 7
+#define MOD_STR_MON_PORT_DMA2ISP 8
+#define MOD_STR_MON_PORT_ISP2DMA 9
+#define MOD_STR_MON_PORT_DMA2SP 10
+#define MOD_STR_MON_PORT_SP2DMA 11
+#define MOD_STR_MON_PORT_GDC12CELLS 12
+#define MOD_STR_MON_PORT_CELLS2GDC1 13
+#define MOD_STR_MON_PORT_GDC22CELLS 14
+#define MOD_STR_MON_PORT_CELLS2GDC2 15
+
+#define MOD_STR_MON_PORT_SND_PIF_A 0
+#define MOD_STR_MON_PORT_RCV_PIF_A 1
+#define MOD_STR_MON_PORT_SND_PIF_B 2
+#define MOD_STR_MON_PORT_RCV_PIF_B 3
+#define MOD_STR_MON_PORT_SND_SIF 4
+#define MOD_STR_MON_PORT_RCV_SIF 5
+#define MOD_STR_MON_PORT_SND_MC 6
+#define MOD_STR_MON_PORT_RCV_MC 7
+#define MOD_STR_MON_PORT_SND_DMA2ISP 8
+#define MOD_STR_MON_PORT_RCV_DMA_FR_ISP 9
+#define MOD_STR_MON_PORT_SND_DMA2SP 10
+#define MOD_STR_MON_PORT_RCV_DMA_FR_SP 11
+#define MOD_STR_MON_PORT_SND_GDC 12
+#define MOD_STR_MON_PORT_RCV_GDC 13
 
 /* testbench signals:       */
 
 /* testbench GP adapter register ids  */
-#define HIVE_TESTBENCH_GPIO_DATA_OUT_REG_IDX                    0
-#define HIVE_TESTBENCH_GPIO_DIR_OUT_REG_IDX                     1
-#define HIVE_TESTBENCH_IRQ_REG_IDX                              2
-#define HIVE_TESTBENCH_SDRAM_WAKEUP_REG_IDX                     3
-#define HIVE_TESTBENCH_IDLE_REG_IDX                             4
-#define HIVE_TESTBENCH_GPIO_DATA_IN_REG_IDX                     5
-#define HIVE_TESTBENCH_MIPI_BFM_EN_REG_IDX                      6
-#define HIVE_TESTBENCH_CSI_CONFIG_REG_IDX                       7
-#define HIVE_TESTBENCH_DDR_STALL_EN_REG_IDX                     8
-
-#define HIVE_TESTBENCH_ISP_PMEM_ERROR_IRQ_REG_IDX               9
-#define HIVE_TESTBENCH_ISP_BAMEM_ERROR_IRQ_REG_IDX             10
-#define HIVE_TESTBENCH_ISP_DMEM_ERROR_IRQ_REG_IDX              11
-#define HIVE_TESTBENCH_SP_ICACHE_MEM_ERROR_IRQ_REG_IDX         12
-#define HIVE_TESTBENCH_SP_DMEM_ERROR_IRQ_REG_IDX               13
+#define HIVE_TESTBENCH_GPIO_DATA_OUT_REG_IDX 0
+#define HIVE_TESTBENCH_GPIO_DIR_OUT_REG_IDX 1
+#define HIVE_TESTBENCH_IRQ_REG_IDX 2
+#define HIVE_TESTBENCH_SDRAM_WAKEUP_REG_IDX 3
+#define HIVE_TESTBENCH_IDLE_REG_IDX 4
+#define HIVE_TESTBENCH_GPIO_DATA_IN_REG_IDX 5
+#define HIVE_TESTBENCH_MIPI_BFM_EN_REG_IDX 6
+#define HIVE_TESTBENCH_CSI_CONFIG_REG_IDX 7
+#define HIVE_TESTBENCH_DDR_STALL_EN_REG_IDX 8
+
+#define HIVE_TESTBENCH_ISP_PMEM_ERROR_IRQ_REG_IDX 9
+#define HIVE_TESTBENCH_ISP_BAMEM_ERROR_IRQ_REG_IDX 10
+#define HIVE_TESTBENCH_ISP_DMEM_ERROR_IRQ_REG_IDX 11
+#define HIVE_TESTBENCH_SP_ICACHE_MEM_ERROR_IRQ_REG_IDX 12
+#define HIVE_TESTBENCH_SP_DMEM_ERROR_IRQ_REG_IDX 13
 
 /* Signal monitor input bit ids */
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_O_BIT_ID                0
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_1_BIT_ID                1
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_2_BIT_ID                2
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_3_BIT_ID                3
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_4_BIT_ID                4
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_5_BIT_ID                5
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_6_BIT_ID                6
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_7_BIT_ID                7
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_8_BIT_ID                8
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_9_BIT_ID                9
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_10_BIT_ID              10
-#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_11_BIT_ID              11
-#define HIVE_TESTBENCH_SIG_MON_IRQ_PIN_BIT_ID                  12
-#define HIVE_TESTBENCH_SIG_MON_SDRAM_WAKEUP_PIN_BIT_ID         13
-#define HIVE_TESTBENCH_SIG_MON_IDLE_PIN_BIT_ID                 14
-
-#define ISP2400_DEBUG_NETWORK    1
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_O_BIT_ID 0
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_1_BIT_ID 1
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_2_BIT_ID 2
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_3_BIT_ID 3
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_4_BIT_ID 4
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_5_BIT_ID 5
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_6_BIT_ID 6
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_7_BIT_ID 7
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_8_BIT_ID 8
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_9_BIT_ID 9
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_10_BIT_ID 10
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_11_BIT_ID 11
+#define HIVE_TESTBENCH_SIG_MON_IRQ_PIN_BIT_ID 12
+#define HIVE_TESTBENCH_SIG_MON_SDRAM_WAKEUP_PIN_BIT_ID 13
+#define HIVE_TESTBENCH_SIG_MON_IDLE_PIN_BIT_ID 14
+
+#define ISP2400_DEBUG_NETWORK 1
 
 #endif /* _hive_isp_css_defs_h__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/assert_support.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/assert_support.h
index 4010976eb4f3c275ba1fc5eb5da19dc03dc0ef47..3c5852c416d39bb51dd206ea8c6bfcba38e04182 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/assert_support.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/assert_support.h
@@ -9,7 +9,7 @@
 
 /* Compile time assertion */
 #ifndef CT_ASSERT
-#define CT_ASSERT(cnd) ((void)sizeof(char[(cnd) ? 1 :  -1]))
+#define CT_ASSERT(cnd) ((void)sizeof(char[(cnd) ? 1 : -1]))
 #endif /* CT_ASSERT */
 
 #include <linux/bug.h>
@@ -20,9 +20,9 @@
  * because it seems that the BUG_ON() macro is not seen as a check by
  * gcc like the BUG() macro is.
  */
-#define assert(cnd) \
-	do { \
-		if (!(cnd)) \
+#define assert(cnd)            \
+	do {                   \
+		if (!(cnd))    \
 			BUG(); \
 	} while (0)
 
@@ -37,7 +37,8 @@ static inline void compile_time_assert(unsigned int cond)
 {
 	/* Call undefined function if cond is false */
 	void _compile_time_assert(void);
-	if (!cond) _compile_time_assert();
+	if (!cond)
+		_compile_time_assert();
 }
 #endif /* PIPE_GENERATION */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/csi_rx.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/csi_rx.h
index 8fd1b846d82786bffd1089c7252a301c17aeef40..811232c54c5d7f196ce4e5ba8e2948e8d39dffb5 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/csi_rx.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/csi_rx.h
@@ -27,7 +27,7 @@
 
 #ifndef __INLINE_CSI_RX__
 #include "csi_rx_public.h"
-#else  /* __INLINE_CSI_RX__ */
+#else /* __INLINE_CSI_RX__ */
 #include "csi_rx_private.h"
 #endif /* __INLINE_CSI_RX__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/debug.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/debug.h
index fc6de151ac642249272777a084ef51a47fdc6e8c..6fdcffbc0acd7f014aff0a500f596295d51ae781 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/debug.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/debug.h
@@ -29,9 +29,9 @@
 #define STORAGE_CLASS_DEBUG_H extern
 #define STORAGE_CLASS_DEBUG_C
 #include "debug_public.h"
-#else  /* __INLINE_DEBUG__ */
-#define STORAGE_CLASS_DEBUG_H static inline
-#define STORAGE_CLASS_DEBUG_C static inline
+#else /* __INLINE_DEBUG__ */
+#define STORAGE_CLASS_DEBUG_H (static inline)
+#define STORAGE_CLASS_DEBUG_C (static inline)
 #include "debug_private.h"
 #endif /* __INLINE_DEBUG__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/device_access/device_access.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/device_access/device_access.h
index ca33a1e03d8d6e400ff23da3bee69dbaff69ddcb..cf3fb56be7d70dcc7765fdfa51a6aa4c7a0e51ac 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/device_access/device_access.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/device_access/device_access.h
@@ -43,7 +43,7 @@ Copyright (c) 2010 - 2015, Intel Corporation.
  */
 
 /*typedef	char *sys_address;*/
-typedef	hrt_address		sys_address;
+typedef hrt_address sys_address;
 
 /*! Set the (sub)system base address
 
@@ -52,8 +52,7 @@ typedef	hrt_address		sys_address;
 
  \return none,
  */
-void device_set_base_address(
-    const sys_address		base_addr);
+void device_set_base_address(const sys_address base_addr);
 
 /*! Get the (sub)system base address
 
@@ -67,8 +66,7 @@ sys_address device_get_base_address(void);
 
  \return device[addr]
  */
-uint8_t ia_css_device_load_uint8(
-    const hrt_address		addr);
+uint8_t ia_css_device_load_uint8(const hrt_address addr);
 
 /*! Read a 16-bit value from a device register or memory in the device
 
@@ -76,8 +74,7 @@ uint8_t ia_css_device_load_uint8(
 
  \return device[addr]
  */
-uint16_t ia_css_device_load_uint16(
-    const hrt_address		addr);
+uint16_t ia_css_device_load_uint16(const hrt_address addr);
 
 /*! Read a 32-bit value from a device register or memory in the device
 
@@ -85,8 +82,7 @@ uint16_t ia_css_device_load_uint16(
 
  \return device[addr]
  */
-uint32_t ia_css_device_load_uint32(
-    const hrt_address		addr);
+uint32_t ia_css_device_load_uint32(const hrt_address addr);
 
 /*! Read a 64-bit value from a device register or memory in the device
 
@@ -94,8 +90,7 @@ uint32_t ia_css_device_load_uint32(
 
  \return device[addr]
  */
-uint64_t ia_css_device_load_uint64(
-    const hrt_address		addr);
+uint64_t ia_css_device_load_uint64(const hrt_address addr);
 
 /*! Write an 8-bit value to a device register or memory in the device
 
@@ -104,9 +99,7 @@ uint64_t ia_css_device_load_uint64(
 
  \return none, device[addr] = value
  */
-void ia_css_device_store_uint8(
-    const hrt_address		addr,
-    const uint8_t			data);
+void ia_css_device_store_uint8(const hrt_address addr, const uint8_t data);
 
 /*! Write a 16-bit value to a device register or memory in the device
 
@@ -115,9 +108,7 @@ void ia_css_device_store_uint8(
 
  \return none, device[addr] = value
  */
-void ia_css_device_store_uint16(
-    const hrt_address		addr,
-    const uint16_t			data);
+void ia_css_device_store_uint16(const hrt_address addr, const uint16_t data);
 
 /*! Write a 32-bit value to a device register or memory in the device
 
@@ -126,9 +117,7 @@ void ia_css_device_store_uint16(
 
  \return none, device[addr] = value
  */
-void ia_css_device_store_uint32(
-    const hrt_address		addr,
-    const uint32_t			data);
+void ia_css_device_store_uint32(const hrt_address addr, const uint32_t data);
 
 /*! Write a 64-bit value to a device register or memory in the device
 
@@ -137,9 +126,7 @@ void ia_css_device_store_uint32(
 
  \return none, device[addr] = value
  */
-void ia_css_device_store_uint64(
-    const hrt_address		addr,
-    const uint64_t			data);
+void ia_css_device_store_uint64(const hrt_address addr, const uint64_t data);
 
 /*! Read an array of bytes from device registers or memory in the device
 
@@ -149,10 +136,7 @@ void ia_css_device_store_uint64(
 
  \return none
  */
-void ia_css_device_load(
-    const hrt_address		addr,
-    void					*data,
-    const size_t			size);
+void ia_css_device_load(const hrt_address addr, void *data, const size_t size);
 
 /*! Write an array of bytes to device registers or memory in the device
 
@@ -162,9 +146,7 @@ void ia_css_device_load(
 
  \return none
  */
-void ia_css_device_store(
-    const hrt_address		addr,
-    const void				*data,
-    const size_t			size);
+void ia_css_device_store(const hrt_address addr, const void *data,
+			 const size_t size);
 
 #endif /* __DEVICE_ACCESS_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/dma.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/dma.h
index 1e0731391ad83861bb0c3876c4b2379cdb20cc89..b366e1f68c32e1cb827207d353a1012093337b80 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/dma.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/dma.h
@@ -29,9 +29,9 @@
 #define STORAGE_CLASS_DMA_H extern
 #define STORAGE_CLASS_DMA_C
 #include "dma_public.h"
-#else  /* __INLINE_DMA__ */
-#define STORAGE_CLASS_DMA_H static inline
-#define STORAGE_CLASS_DMA_C static inline
+#else /* __INLINE_DMA__ */
+#define STORAGE_CLASS_DMA_H (static inline)
+#define STORAGE_CLASS_DMA_C (static inline)
 #include "dma_private.h"
 #endif /* __INLINE_DMA__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/event_fifo.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/event_fifo.h
index cd1a0fb57267c74b8c7604a571075653da2a1900..f995fbdf2dd83452bf52d1e90b974ea984c3d56f 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/event_fifo.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/event_fifo.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_EVENT_H extern
 #define STORAGE_CLASS_EVENT_C
 #include "event_fifo_public.h"
-#else  /* __INLINE_EVENT__ */
-#define STORAGE_CLASS_EVENT_H static inline
-#define STORAGE_CLASS_EVENT_C static inline
+#else /* __INLINE_EVENT__ */
+#define STORAGE_CLASS_EVENT_H (static inline)
+#define STORAGE_CLASS_EVENT_C (static inline)
 #include "event_fifo_private.h"
 #endif /* __INLINE_EVENT__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/fifo_monitor.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/fifo_monitor.h
index e85b50d780033d538ad5095f869af2aeae61e5a7..04f6cdb0b8a644eefc7ca8de86e1f4a366e8d977 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/fifo_monitor.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/fifo_monitor.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_FIFO_MONITOR_H extern
 #define STORAGE_CLASS_FIFO_MONITOR_C
 #include "fifo_monitor_public.h"
-#else  /* __INLINE_FIFO_MONITOR__ */
-#define STORAGE_CLASS_FIFO_MONITOR_H static inline
-#define STORAGE_CLASS_FIFO_MONITOR_C static inline
+#else /* __INLINE_FIFO_MONITOR__ */
+#define STORAGE_CLASS_FIFO_MONITOR_H (static inline)
+#define STORAGE_CLASS_FIFO_MONITOR_C (static inline)
 #include "fifo_monitor_private.h"
 #endif /* __INLINE_FIFO_MONITOR__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/gdc_device.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/gdc_device.h
index d8633859c393c05f7010a1dd8a8f6de383ba34da..c045baa4d34ffcbf8d6a60b3f9c4fd8d151fe5cd 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/gdc_device.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/gdc_device.h
@@ -30,9 +30,9 @@
 #define STORAGE_CLASS_GDC_H extern
 #define STORAGE_CLASS_GDC_C
 #include "gdc_public.h"
-#else  /* __INLINE_GDC__ */
-#define STORAGE_CLASS_GDC_H static inline
-#define STORAGE_CLASS_GDC_C static inline
+#else /* __INLINE_GDC__ */
+#define STORAGE_CLASS_GDC_H (static inline)
+#define STORAGE_CLASS_GDC_C (static inline)
 #include "gdc_private.h"
 #endif /* __INLINE_GDC__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/gp_device.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/gp_device.h
index 33ab0642a93173eb4b7bdd31e2beb556432dd79e..4e6e85f80189c3f27235d58dc45078d54cde9f90 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/gp_device.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/gp_device.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_GP_DEVICE_H extern
 #define STORAGE_CLASS_GP_DEVICE_C
 #include "gp_device_public.h"
-#else  /* __INLINE_GP_DEVICE__ */
-#define STORAGE_CLASS_GP_DEVICE_H static inline
-#define STORAGE_CLASS_GP_DEVICE_C static inline
+#else /* __INLINE_GP_DEVICE__ */
+#define STORAGE_CLASS_GP_DEVICE_H (static inline)
+#define STORAGE_CLASS_GP_DEVICE_C (static inline)
 #include "gp_device_private.h"
 #endif /* __INLINE_GP_DEVICE__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/gp_timer.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/gp_timer.h
index 94f81af70007fa23defbba579e64f6f482b32f5c..d38c95c903b4cda97f55443bc844033054cc51eb 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/gp_timer.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/gp_timer.h
@@ -21,17 +21,17 @@
  *	- local:   system and cell specific constants and identifiers
  */
 
-#include "system_local.h"    /*GP_TIMER_BASE address */
-#include "gp_timer_local.h"  /*GP_TIMER register offsets */
+#include "system_local.h" /*GP_TIMER_BASE address */
+#include "gp_timer_local.h" /*GP_TIMER register offsets */
 
 #ifndef __INLINE_GP_TIMER__
 #define STORAGE_CLASS_GP_TIMER_H extern
 #define STORAGE_CLASS_GP_TIMER_C
-#include "gp_timer_public.h"   /* functions*/
-#else  /* __INLINE_GP_TIMER__ */
-#define STORAGE_CLASS_GP_TIMER_H static inline
-#define STORAGE_CLASS_GP_TIMER_C static inline
-#include "gp_timer_private.h"  /* inline functions*/
+#include "gp_timer_public.h" /* functions*/
+#else /* __INLINE_GP_TIMER__ */
+#define STORAGE_CLASS_GP_TIMER_H (static inline)
+#define STORAGE_CLASS_GP_TIMER_C (static inline)
+#include "gp_timer_private.h" /* inline functions*/
 #endif /* __INLINE_GP_TIMER__ */
 
 #endif /* __GP_TIMER_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/hmem.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/hmem.h
index c916618a0fb9e81e4664b817118e5488d1e12175..3341955cf7a02b802f13f0b34cc44d14b4fe5515 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/hmem.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/hmem.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_HMEM_H extern
 #define STORAGE_CLASS_HMEM_C
 #include "hmem_public.h"
-#else  /* __INLINE_HMEM__ */
-#define STORAGE_CLASS_HMEM_H static inline
-#define STORAGE_CLASS_HMEM_C static inline
+#else /* __INLINE_HMEM__ */
+#define STORAGE_CLASS_HMEM_H (static inline)
+#define STORAGE_CLASS_HMEM_C (static inline)
 #include "hmem_private.h"
 #endif /* __INLINE_HMEM__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/csi_rx_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/csi_rx_public.h
index 2002960f078e7ce44663d9cadd6ce2c7db34e356..2b56a3262bf3f40fd02003346ab15751f9c05741 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/csi_rx_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/csi_rx_public.h
@@ -19,9 +19,8 @@
  * @param[in]	id	The global unique ID of the csi rx fe controller.
  * @param[out]	state	Point to the register-state.
  */
-void csi_rx_fe_ctrl_get_state(
-    const csi_rx_frontend_ID_t ID,
-    csi_rx_fe_ctrl_state_t *state);
+void csi_rx_fe_ctrl_get_state(const csi_rx_frontend_ID_t ID,
+			      csi_rx_fe_ctrl_state_t *state);
 /**
  * @brief Dump the csi rx frontend state.
  * Dump the state of the csi rx frontend regiester-set.
@@ -29,9 +28,8 @@ void csi_rx_fe_ctrl_get_state(
  * @param[in]	id	The global unique ID of the csi rx fe controller.
  * @param[in]	state	Point to the register-state.
  */
-void csi_rx_fe_ctrl_dump_state(
-    const csi_rx_frontend_ID_t ID,
-    csi_rx_fe_ctrl_state_t *state);
+void csi_rx_fe_ctrl_dump_state(const csi_rx_frontend_ID_t ID,
+			       csi_rx_fe_ctrl_state_t *state);
 /**
  * @brief Get the state of the csi rx fe dlane.
  * Get the state of the register set per dlane process.
@@ -40,10 +38,9 @@ void csi_rx_fe_ctrl_dump_state(
  * @param[in]	lane		The lane ID.
  * @param[out]	state		Point to the dlane state.
  */
-void csi_rx_fe_ctrl_get_dlane_state(
-    const csi_rx_frontend_ID_t ID,
-    const u32 lane,
-    csi_rx_fe_ctrl_lane_t *dlane_state);
+void csi_rx_fe_ctrl_get_dlane_state(const csi_rx_frontend_ID_t ID,
+				    const u32 lane,
+				    csi_rx_fe_ctrl_lane_t *dlane_state);
 /**
  * @brief Get the csi rx backend state.
  * Get the state of the csi rx backend regiester-set.
@@ -51,9 +48,8 @@ void csi_rx_fe_ctrl_get_dlane_state(
  * @param[in]	id	The global unique ID of the csi rx be controller.
  * @param[out]	state	Point to the register-state.
  */
-void csi_rx_be_ctrl_get_state(
-    const csi_rx_backend_ID_t ID,
-    csi_rx_be_ctrl_state_t *state);
+void csi_rx_be_ctrl_get_state(const csi_rx_backend_ID_t ID,
+			      csi_rx_be_ctrl_state_t *state);
 /**
  * @brief Dump the csi rx backend state.
  * Dump the state of the csi rx backend regiester-set.
@@ -61,9 +57,8 @@ void csi_rx_be_ctrl_get_state(
  * @param[in]	id	The global unique ID of the csi rx be controller.
  * @param[in]	state	Point to the register-state.
  */
-void csi_rx_be_ctrl_dump_state(
-    const csi_rx_backend_ID_t ID,
-    csi_rx_be_ctrl_state_t *state);
+void csi_rx_be_ctrl_dump_state(const csi_rx_backend_ID_t ID,
+			       csi_rx_be_ctrl_state_t *state);
 /* end of NCI */
 
 /*****************************************************
@@ -80,9 +75,8 @@ void csi_rx_be_ctrl_dump_state(
  *
  * @return the value of the register.
  */
-hrt_data csi_rx_fe_ctrl_reg_load(
-    const csi_rx_frontend_ID_t ID,
-    const hrt_address reg);
+hrt_data csi_rx_fe_ctrl_reg_load(const csi_rx_frontend_ID_t ID,
+				 const hrt_address reg);
 /**
  * @brief Store a value to the register.
  * Store a value to the register of the csi rx fe.
@@ -92,10 +86,8 @@ hrt_data csi_rx_fe_ctrl_reg_load(
  * @param[in]	value	The value to be stored.
  *
  */
-void csi_rx_fe_ctrl_reg_store(
-    const csi_rx_frontend_ID_t ID,
-    const hrt_address reg,
-    const hrt_data value);
+void csi_rx_fe_ctrl_reg_store(const csi_rx_frontend_ID_t ID,
+			      const hrt_address reg, const hrt_data value);
 /**
  * @brief Load the register value.
  * Load the value of the register of the csirx be.
@@ -105,9 +97,8 @@ void csi_rx_fe_ctrl_reg_store(
  *
  * @return the value of the register.
  */
-hrt_data csi_rx_be_ctrl_reg_load(
-    const csi_rx_backend_ID_t ID,
-    const hrt_address reg);
+hrt_data csi_rx_be_ctrl_reg_load(const csi_rx_backend_ID_t ID,
+				 const hrt_address reg);
 /**
  * @brief Store a value to the register.
  * Store a value to the register of the csi rx be.
@@ -117,9 +108,7 @@ hrt_data csi_rx_be_ctrl_reg_load(
  * @param[in]	value	The value to be stored.
  *
  */
-void csi_rx_be_ctrl_reg_store(
-    const csi_rx_backend_ID_t ID,
-    const hrt_address reg,
-    const hrt_data value);
+void csi_rx_be_ctrl_reg_store(const csi_rx_backend_ID_t ID,
+			      const hrt_address reg, const hrt_data value);
 /* end of DLI */
 #endif /* __CSI_RX_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/debug_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/debug_public.h
index 947381e5b8a8be21afdd754f6bd8b37961971027..07be98d589b402db28c8929c15e1ae2d91151da5 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/debug_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/debug_public.h
@@ -30,12 +30,12 @@
  * implementation is followed)
  */
 
-typedef struct debug_data_s		debug_data_t;
-typedef struct debug_data_ddr_s	debug_data_ddr_t;
+typedef struct debug_data_s debug_data_t;
+typedef struct debug_data_ddr_s debug_data_ddr_t;
 
-extern debug_data_t				*debug_data_ptr;
-extern hrt_address				debug_buffer_address;
-extern ia_css_ptr				debug_buffer_ddr_address;
+extern debug_data_t *debug_data_ptr;
+extern hrt_address debug_buffer_address;
+extern ia_css_ptr debug_buffer_ddr_address;
 
 /*! Check the empty state of the local debug data buffer
 
@@ -71,21 +71,18 @@ STORAGE_CLASS_DEBUG_H void debug_synch_queue_ddr(void);
 
  \return none
  */
-void debug_buffer_init(
-    const hrt_address		addr);
+void debug_buffer_init(const hrt_address addr);
 
 /*! Set the offset/address of the (remote) debug buffer
 
  \return none
  */
-void debug_buffer_ddr_init(
-    const ia_css_ptr		addr);
+void debug_buffer_ddr_init(const ia_css_ptr addr);
 
 /*! Set the (remote) operating mode of the debug buffer
 
  \return none
  */
-void debug_buffer_setmode(
-    const debug_buf_mode_t	mode);
+void debug_buffer_setmode(const debug_buf_mode_t mode);
 
 #endif /* __DEBUG_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/dma_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/dma_public.h
index fe3b1b8ecc5038c50bd25d7708cc7187caa460fa..f9835b5b77e67ed3e151e26e70195bed3cf4ab7b 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/dma_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/dma_public.h
@@ -17,10 +17,8 @@
 
  \return none, DMA[ID].ctrl[reg] = value
  */
-STORAGE_CLASS_DMA_H void dma_reg_store(
-    const dma_ID_t		ID,
-    const unsigned int	reg,
-    const hrt_data		value);
+STORAGE_CLASS_DMA_H void
+dma_reg_store(const dma_ID_t ID, const unsigned int reg, const hrt_data value);
 
 /*! Read from a control register of DMA[ID]
 
@@ -30,9 +28,8 @@ STORAGE_CLASS_DMA_H void dma_reg_store(
 
  \return DMA[ID].ctrl[reg]
  */
-STORAGE_CLASS_DMA_H hrt_data dma_reg_load(
-    const dma_ID_t		ID,
-    const unsigned int	reg);
+STORAGE_CLASS_DMA_H hrt_data dma_reg_load(const dma_ID_t ID,
+					  const unsigned int reg);
 
 /*! Set maximum burst size of DMA[ID]
 
@@ -42,10 +39,7 @@ STORAGE_CLASS_DMA_H hrt_data dma_reg_load(
 
  \return none
 */
-void
-dma_set_max_burst_size(
-    dma_ID_t		ID,
-    dma_connection		conn,
-    uint32_t		max_burst_size);
+void dma_set_max_burst_size(dma_ID_t ID, dma_connection conn,
+			    uint32_t max_burst_size);
 
 #endif /* __DMA_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/event_fifo_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/event_fifo_public.h
index 9c2365e59b6341342e6b9ca6237134925bdd18f4..b706a4b388520c311969cfc5159e4bf990898f16 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/event_fifo_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/event_fifo_public.h
@@ -16,8 +16,7 @@
 
  \return none, dequeue(event_queue[ID])
  */
-STORAGE_CLASS_EVENT_H void event_wait_for(
-    const event_ID_t		ID);
+STORAGE_CLASS_EVENT_H void event_wait_for(const event_ID_t ID);
 
 /*! Conditional blocking wait for an event source EVENT[ID]
 
@@ -26,9 +25,8 @@ STORAGE_CLASS_EVENT_H void event_wait_for(
 
  \return none, if(cnd) dequeue(event_queue[ID])
  */
-STORAGE_CLASS_EVENT_H void cnd_event_wait_for(
-    const event_ID_t		ID,
-    const bool				cnd);
+STORAGE_CLASS_EVENT_H void cnd_event_wait_for(const event_ID_t ID,
+					      const bool cnd);
 
 /*! Blocking read from an event source EVENT[ID]
 
@@ -36,8 +34,7 @@ STORAGE_CLASS_EVENT_H void cnd_event_wait_for(
 
  \return dequeue(event_queue[ID])
  */
-STORAGE_CLASS_EVENT_H hrt_data event_receive_token(
-    const event_ID_t		ID);
+STORAGE_CLASS_EVENT_H hrt_data event_receive_token(const event_ID_t ID);
 
 /*! Blocking write to an event sink EVENT[ID]
 
@@ -46,9 +43,8 @@ STORAGE_CLASS_EVENT_H hrt_data event_receive_token(
 
  \return none, enqueue(event_queue[ID])
  */
-STORAGE_CLASS_EVENT_H void event_send_token(
-    const event_ID_t		ID,
-    const hrt_data			token);
+STORAGE_CLASS_EVENT_H void event_send_token(const event_ID_t ID,
+					    const hrt_data token);
 
 /*! Query an event source EVENT[ID]
 
@@ -56,8 +52,7 @@ STORAGE_CLASS_EVENT_H void event_send_token(
 
  \return !isempty(event_queue[ID])
  */
-STORAGE_CLASS_EVENT_H bool is_event_pending(
-    const event_ID_t		ID);
+STORAGE_CLASS_EVENT_H bool is_event_pending(const event_ID_t ID);
 
 /*! Query an event sink EVENT[ID]
 
@@ -65,7 +60,6 @@ STORAGE_CLASS_EVENT_H bool is_event_pending(
 
  \return !isfull(event_queue[ID])
  */
-STORAGE_CLASS_EVENT_H bool can_event_send_token(
-    const event_ID_t		ID);
+STORAGE_CLASS_EVENT_H bool can_event_send_token(const event_ID_t ID);
 
 #endif /* __EVENT_FIFO_PUBLIC_H */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/fifo_monitor_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/fifo_monitor_public.h
index 37cb9eb1391994c975bea50392d97c1ba37342d3..746819ca6bad5568ca04803d203e7566dfe5e8d0 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/fifo_monitor_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/fifo_monitor_public.h
@@ -9,9 +9,9 @@
 
 #include "system_local.h"
 
-typedef struct fifo_channel_state_s		fifo_channel_state_t;
-typedef struct fifo_switch_state_s		fifo_switch_state_t;
-typedef struct fifo_monitor_state_s		fifo_monitor_state_t;
+typedef struct fifo_channel_state_s fifo_channel_state_t;
+typedef struct fifo_switch_state_s fifo_switch_state_t;
+typedef struct fifo_monitor_state_s fifo_monitor_state_t;
 
 /*! Set a fifo switch multiplex
 
@@ -21,10 +21,9 @@ typedef struct fifo_monitor_state_s		fifo_monitor_state_t;
 
  \return none, fifo_switch[switch_id].sel = sel
  */
-STORAGE_CLASS_FIFO_MONITOR_H void fifo_switch_set(
-    const fifo_monitor_ID_t		ID,
-    const fifo_switch_t			switch_id,
-    const hrt_data				sel);
+STORAGE_CLASS_FIFO_MONITOR_H void fifo_switch_set(const fifo_monitor_ID_t ID,
+						  const fifo_switch_t switch_id,
+						  const hrt_data sel);
 
 /*! Get a fifo switch multiplex
 
@@ -33,9 +32,8 @@ STORAGE_CLASS_FIFO_MONITOR_H void fifo_switch_set(
 
  \return fifo_switch[switch_id].sel
  */
-STORAGE_CLASS_FIFO_MONITOR_H hrt_data fifo_switch_get(
-    const fifo_monitor_ID_t		ID,
-    const fifo_switch_t			switch_id);
+STORAGE_CLASS_FIFO_MONITOR_H hrt_data
+fifo_switch_get(const fifo_monitor_ID_t ID, const fifo_switch_t switch_id);
 
 /*! Read the state of FIFO_MONITOR[ID]
 
@@ -44,9 +42,8 @@ STORAGE_CLASS_FIFO_MONITOR_H hrt_data fifo_switch_get(
 
  \return none, state = FIFO_MONITOR[ID].state
  */
-void fifo_monitor_get_state(
-    const fifo_monitor_ID_t		ID,
-    fifo_monitor_state_t		*state);
+void fifo_monitor_get_state(const fifo_monitor_ID_t ID,
+			    fifo_monitor_state_t *state);
 
 /*! Read the state of a fifo channel
 
@@ -56,10 +53,9 @@ void fifo_monitor_get_state(
 
  \return none, state = fifo_channel[channel_id].state
  */
-void fifo_channel_get_state(
-    const fifo_monitor_ID_t		ID,
-    const fifo_channel_t		channel_id,
-    fifo_channel_state_t		*state);
+void fifo_channel_get_state(const fifo_monitor_ID_t ID,
+			    const fifo_channel_t channel_id,
+			    fifo_channel_state_t *state);
 
 /*! Read the state of a fifo switch
 
@@ -69,10 +65,9 @@ void fifo_channel_get_state(
 
  \return none, state = fifo_switch[switch_id].state
  */
-void fifo_switch_get_state(
-    const fifo_monitor_ID_t		ID,
-    const fifo_switch_t			switch_id,
-    fifo_switch_state_t			*state);
+void fifo_switch_get_state(const fifo_monitor_ID_t ID,
+			   const fifo_switch_t switch_id,
+			   fifo_switch_state_t *state);
 
 /*! Write to a control register of FIFO_MONITOR[ID]
 
@@ -82,10 +77,9 @@ void fifo_switch_get_state(
 
  \return none, FIFO_MONITOR[ID].ctrl[reg] = value
  */
-STORAGE_CLASS_FIFO_MONITOR_H void fifo_monitor_reg_store(
-    const fifo_monitor_ID_t		ID,
-    const unsigned int			reg,
-    const hrt_data				value);
+STORAGE_CLASS_FIFO_MONITOR_H void
+fifo_monitor_reg_store(const fifo_monitor_ID_t ID, const unsigned int reg,
+		       const hrt_data value);
 
 /*! Read from a control register of FIFO_MONITOR[ID]
 
@@ -95,8 +89,7 @@ STORAGE_CLASS_FIFO_MONITOR_H void fifo_monitor_reg_store(
 
  \return FIFO_MONITOR[ID].ctrl[reg]
  */
-STORAGE_CLASS_FIFO_MONITOR_H hrt_data fifo_monitor_reg_load(
-    const fifo_monitor_ID_t		ID,
-    const unsigned int			reg);
+STORAGE_CLASS_FIFO_MONITOR_H hrt_data
+fifo_monitor_reg_load(const fifo_monitor_ID_t ID, const unsigned int reg);
 
 #endif /* __FIFO_MONITOR_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gdc_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gdc_public.h
index 77654b163598595e70d23f6fbf2477048e46f7e3..80e9ab692031d71ca4fb4c5c1918e1a2a1688b3f 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gdc_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gdc_public.h
@@ -25,9 +25,7 @@
 
  \return none, GDC[ID].lut[0...3][0...HRT_GDC_N-1] = data
  */
-void gdc_lut_store(
-    const gdc_ID_t		ID,
-    const int			data[4][HRT_GDC_N]);
+void gdc_lut_store(const gdc_ID_t ID, const int data[4][HRT_GDC_N]);
 
 /*! Convert the bicubic interpolation table of GDC[ID] to the ISP-specific format
 
@@ -35,9 +33,8 @@ void gdc_lut_store(
  \param in_lut[in]			The data matrix to be converted
  \param out_lut[out]			The data matrix as the output of conversion
  */
-void gdc_lut_convert_to_isp_format(
-    const int in_lut[4][HRT_GDC_N],
-    int out_lut[4][HRT_GDC_N]);
+void gdc_lut_convert_to_isp_format(const int in_lut[4][HRT_GDC_N],
+				   int out_lut[4][HRT_GDC_N]);
 
 /*! Return the integer representation of 1.0 of GDC[ID]
 
@@ -45,7 +42,6 @@ void gdc_lut_convert_to_isp_format(
 
  \return unity
  */
-int gdc_get_unity(
-    const gdc_ID_t		ID);
+int gdc_get_unity(const gdc_ID_t ID);
 
 #endif /* __GDC_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gp_device_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gp_device_public.h
index b93cd00a0b1ded8d00b73e555dab4e9b7a738863..c5b2707cc4005bc03a8110756b04a0abd964e92a 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gp_device_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gp_device_public.h
@@ -9,7 +9,7 @@
 
 #include "system_local.h"
 
-typedef struct gp_device_state_s		gp_device_state_t;
+typedef struct gp_device_state_s gp_device_state_t;
 
 /*! Read the state of GP_DEVICE[ID]
 
@@ -18,9 +18,7 @@ typedef struct gp_device_state_s		gp_device_state_t;
 
  \return none, state = GP_DEVICE[ID].state
  */
-void gp_device_get_state(
-    const gp_device_ID_t		ID,
-    gp_device_state_t			*state);
+void gp_device_get_state(const gp_device_ID_t ID, gp_device_state_t *state);
 
 /*! Write to a control register of GP_DEVICE[ID]
 
@@ -30,10 +28,9 @@ void gp_device_get_state(
 
  \return none, GP_DEVICE[ID].ctrl[reg] = value
  */
-STORAGE_CLASS_GP_DEVICE_H void gp_device_reg_store(
-    const gp_device_ID_t	ID,
-    const unsigned int		reg_addr,
-    const hrt_data			value);
+STORAGE_CLASS_GP_DEVICE_H void gp_device_reg_store(const gp_device_ID_t ID,
+						   const unsigned int reg_addr,
+						   const hrt_data value);
 
 /*! Read from a control register of GP_DEVICE[ID]
 
@@ -43,8 +40,7 @@ STORAGE_CLASS_GP_DEVICE_H void gp_device_reg_store(
 
  \return GP_DEVICE[ID].ctrl[reg]
  */
-STORAGE_CLASS_GP_DEVICE_H hrt_data gp_device_reg_load(
-    const gp_device_ID_t	ID,
-    const hrt_address	reg_addr);
+STORAGE_CLASS_GP_DEVICE_H hrt_data
+gp_device_reg_load(const gp_device_ID_t ID, const hrt_address reg_addr);
 
 #endif /* __GP_DEVICE_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gp_timer_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gp_timer_public.h
index cc016eb9e84d6a66be70fe678294ad9e6031997e..c4b2ed7bd6e77230c9463935ed4fd1e1396aa02e 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gp_timer_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/gp_timer_public.h
@@ -12,14 +12,12 @@
 /*! initialize mentioned timer
 param ID		timer_id
 */
-extern void
-gp_timer_init(gp_timer_ID_t ID);
+extern void gp_timer_init(gp_timer_ID_t ID);
 
 /*! read timer value for (platform selected)selected timer.
 param ID		timer_id
  \return uint32_t	32 bit timer value
 */
-extern uint32_t
-gp_timer_read(gp_timer_ID_t ID);
+extern uint32_t gp_timer_read(gp_timer_ID_t ID);
 
 #endif /* __GP_TIMER_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/hmem_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/hmem_public.h
index 7cfc2228c0b87f3da755921dceab46f99c39e5c5..e3ba5c3227479f8bc762590049d9b666ec3e909e 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/hmem_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/hmem_public.h
@@ -7,7 +7,7 @@
 #ifndef __HMEM_PUBLIC_H_INCLUDED__
 #define __HMEM_PUBLIC_H_INCLUDED__
 
-#include <linux/types.h>		/* size_t */
+#include <linux/types.h> /* size_t */
 
 /*! Return the size of HMEM[ID]
 
@@ -18,7 +18,6 @@
 
  \return sizeof(HMEM[ID])
  */
-STORAGE_CLASS_HMEM_H size_t sizeof_hmem(
-    const hmem_ID_t		ID);
+STORAGE_CLASS_HMEM_H size_t sizeof_hmem(const hmem_ID_t ID);
 
 #endif /* __HMEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/input_formatter_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/input_formatter_public.h
index e67d252aa43f758e0c869906744bf4bb0cfb0cca..ab3325d97eb5fbcbc8aac917e8cf0cfa770c8b4e 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/input_formatter_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/input_formatter_public.h
@@ -16,8 +16,7 @@
 
  \return none, reset(INPUT_FORMATTER[ID])
  */
-void input_formatter_rst(
-    const input_formatter_ID_t		ID);
+void input_formatter_rst(const input_formatter_ID_t ID);
 
 /*! Set the blocking mode of INPUT_FORMATTER[ID]
 
@@ -33,9 +32,8 @@ void input_formatter_rst(
 
  \return none, INPUT_FORMATTER[ID].blocking_mode = enable
  */
-void input_formatter_set_fifo_blocking_mode(
-    const input_formatter_ID_t		ID,
-    const bool						enable);
+void input_formatter_set_fifo_blocking_mode(const input_formatter_ID_t ID,
+					    const bool enable);
 
 /*! Return the data alignment of INPUT_FORMATTER[ID]
 
@@ -43,8 +41,7 @@ void input_formatter_set_fifo_blocking_mode(
 
  \return alignment(INPUT_FORMATTER[ID].data)
  */
-unsigned int input_formatter_get_alignment(
-    const input_formatter_ID_t		ID);
+unsigned int input_formatter_get_alignment(const input_formatter_ID_t ID);
 
 /*! Read the source switch state into INPUT_FORMATTER[ID]
 
@@ -53,9 +50,8 @@ unsigned int input_formatter_get_alignment(
 
  \return none, state = INPUT_FORMATTER[ID].switch_state
  */
-void input_formatter_get_switch_state(
-    const input_formatter_ID_t		ID,
-    input_formatter_switch_state_t	*state);
+void input_formatter_get_switch_state(const input_formatter_ID_t ID,
+				      input_formatter_switch_state_t *state);
 
 /*! Read the control registers of INPUT_FORMATTER[ID]
 
@@ -64,9 +60,8 @@ void input_formatter_get_switch_state(
 
  \return none, state = INPUT_FORMATTER[ID].state
  */
-void input_formatter_get_state(
-    const input_formatter_ID_t		ID,
-    input_formatter_state_t			*state);
+void input_formatter_get_state(const input_formatter_ID_t ID,
+			       input_formatter_state_t *state);
 
 /*! Read the control registers of bin copy INPUT_FORMATTER[ID]
 
@@ -75,9 +70,8 @@ void input_formatter_get_state(
 
  \return none, state = INPUT_FORMATTER[ID].state
  */
-void input_formatter_bin_get_state(
-    const input_formatter_ID_t		ID,
-    input_formatter_bin_state_t		*state);
+void input_formatter_bin_get_state(const input_formatter_ID_t ID,
+				   input_formatter_bin_state_t *state);
 
 /*! Write to a control register of INPUT_FORMATTER[ID]
 
@@ -87,10 +81,9 @@ void input_formatter_bin_get_state(
 
  \return none, INPUT_FORMATTER[ID].ctrl[reg] = value
  */
-STORAGE_CLASS_INPUT_FORMATTER_H void input_formatter_reg_store(
-    const input_formatter_ID_t	ID,
-    const hrt_address		reg_addr,
-    const hrt_data				value);
+STORAGE_CLASS_INPUT_FORMATTER_H void
+input_formatter_reg_store(const input_formatter_ID_t ID,
+			  const hrt_address reg_addr, const hrt_data value);
 
 /*! Read from a control register of INPUT_FORMATTER[ID]
 
@@ -101,7 +94,6 @@ STORAGE_CLASS_INPUT_FORMATTER_H void input_formatter_reg_store(
  \return INPUT_FORMATTER[ID].ctrl[reg]
  */
 STORAGE_CLASS_INPUT_FORMATTER_H hrt_data input_formatter_reg_load(
-    const input_formatter_ID_t	ID,
-    const unsigned int			reg_addr);
+	const input_formatter_ID_t ID, const unsigned int reg_addr);
 
 #endif /* __INPUT_FORMATTER_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/irq_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/irq_public.h
index 901e10f8743cbba9cbd45ac61ef04b49b54d0c0e..e92b6c758b6e90eb080e306d5fc0aa1dbf61e4d8 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/irq_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/irq_public.h
@@ -18,10 +18,8 @@
 
  \return none, IRQ[ID].ctrl[reg] = value
  */
-STORAGE_CLASS_IRQ_H void irq_reg_store(
-    const irq_ID_t		ID,
-    const unsigned int	reg,
-    const hrt_data		value);
+STORAGE_CLASS_IRQ_H void
+irq_reg_store(const irq_ID_t ID, const unsigned int reg, const hrt_data value);
 
 /*! Read from a control register of IRQ[ID]
 
@@ -31,9 +29,8 @@ STORAGE_CLASS_IRQ_H void irq_reg_store(
 
  \return IRQ[ID].ctrl[reg]
  */
-STORAGE_CLASS_IRQ_H hrt_data irq_reg_load(
-    const irq_ID_t		ID,
-    const unsigned int	reg);
+STORAGE_CLASS_IRQ_H hrt_data irq_reg_load(const irq_ID_t ID,
+					  const unsigned int reg);
 
 /*! Enable an IRQ channel of IRQ[ID] with a mode
 
@@ -42,9 +39,7 @@ STORAGE_CLASS_IRQ_H hrt_data irq_reg_load(
 
  \return none, enable(IRQ[ID].channel[irq_ID])
  */
-void irq_enable_channel(
-    const irq_ID_t				ID,
-    const unsigned int			irq_ID);
+void irq_enable_channel(const irq_ID_t ID, const unsigned int irq_ID);
 
 /*! Enable pulse interrupts for IRQ[ID] with a mode
 
@@ -53,9 +48,7 @@ void irq_enable_channel(
 
  \return none
  */
-void irq_enable_pulse(
-    const irq_ID_t	ID,
-    bool			pulse);
+void irq_enable_pulse(const irq_ID_t ID, bool pulse);
 
 /*! Disable an IRQ channel of IRQ[ID]
 
@@ -64,9 +57,7 @@ void irq_enable_pulse(
 
  \return none, disable(IRQ[ID].channel[irq_ID])
  */
-void irq_disable_channel(
-    const irq_ID_t				ID,
-    const unsigned int			irq);
+void irq_disable_channel(const irq_ID_t ID, const unsigned int irq);
 
 /*! Clear the state of all IRQ channels of IRQ[ID]
 
@@ -74,8 +65,7 @@ void irq_disable_channel(
 
  \return none, clear(IRQ[ID].channel[])
  */
-void irq_clear_all(
-    const irq_ID_t				ID);
+void irq_clear_all(const irq_ID_t ID);
 
 /*! Return the ID of a signalling IRQ channel of IRQ[ID]
 
@@ -88,9 +78,8 @@ void irq_clear_all(
 
  \return state(IRQ[ID])
  */
-enum hrt_isp_css_irq_status irq_get_channel_id(
-    const irq_ID_t				ID,
-    unsigned int				*irq_id);
+enum hrt_isp_css_irq_status irq_get_channel_id(const irq_ID_t ID,
+					       unsigned int *irq_id);
 
 /*! Raise an interrupt on channel irq_id of device IRQ[ID]
 
@@ -99,9 +88,7 @@ enum hrt_isp_css_irq_status irq_get_channel_id(
 
  \return none, signal(IRQ[ID].channel[irq_id])
  */
-void irq_raise(
-    const irq_ID_t				ID,
-    const irq_sw_channel_id_t	irq_id);
+void irq_raise(const irq_ID_t ID, const irq_sw_channel_id_t irq_id);
 
 /*! Test if any IRQ channel of the virtual super IRQ has raised a signal
 
@@ -116,9 +103,7 @@ bool any_virq_signal(void);
 
  \return none, VIRQ.channel[irq_ID].enable = en
  */
-void cnd_virq_enable_channel(
-    const enum virq_id				irq_ID,
-    const bool					en);
+void cnd_virq_enable_channel(const enum virq_id irq_ID, const bool en);
 
 /*! Clear the state of all IRQ channels of the virtual super IRQ
 
@@ -144,8 +129,7 @@ void virq_clear_info(struct virq_info *irq_info);
 
  \return state(IRQ[...])
  */
-enum hrt_isp_css_irq_status virq_get_channel_id(
-    enum virq_id					*irq_id);
+enum hrt_isp_css_irq_status virq_get_channel_id(enum virq_id *irq_id);
 
 /*! Return the IDs of all signaling IRQ channels of the virtual super IRQ
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isp_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isp_public.h
index 78abd77c5bdbf408714d0bf7c5e6614ed6930df0..ae0ad58e113f5f6dd6604794af1cb27cdbaa230e 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isp_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isp_public.h
@@ -17,9 +17,7 @@
 
  \return none, if(cnd) enable(ISP[ID].irq) else disable(ISP[ID].irq)
  */
-void cnd_isp_irq_enable(
-    const isp_ID_t		ID,
-    const bool			cnd);
+void cnd_isp_irq_enable(const isp_ID_t ID, const bool cnd);
 
 /*! Write to the status and control register of ISP[ID]
 
@@ -29,10 +27,8 @@ void cnd_isp_irq_enable(
 
  \return none, ISP[ID].sc[reg] = value
  */
-STORAGE_CLASS_ISP_H void isp_ctrl_store(
-    const isp_ID_t		ID,
-    const unsigned int	reg,
-    const hrt_data		value);
+STORAGE_CLASS_ISP_H void
+isp_ctrl_store(const isp_ID_t ID, const unsigned int reg, const hrt_data value);
 
 /*! Read from the status and control register of ISP[ID]
 
@@ -42,9 +38,8 @@ STORAGE_CLASS_ISP_H void isp_ctrl_store(
 
  \return ISP[ID].sc[reg]
  */
-STORAGE_CLASS_ISP_H hrt_data isp_ctrl_load(
-    const isp_ID_t		ID,
-    const unsigned int	reg);
+STORAGE_CLASS_ISP_H hrt_data isp_ctrl_load(const isp_ID_t ID,
+					   const unsigned int reg);
 
 /*! Get the status of a bitfield in the control register of ISP[ID]
 
@@ -54,10 +49,9 @@ STORAGE_CLASS_ISP_H hrt_data isp_ctrl_load(
 
  \return  (ISP[ID].sc[reg] & (1<<bit)) != 0
  */
-STORAGE_CLASS_ISP_H bool isp_ctrl_getbit(
-    const isp_ID_t		ID,
-    const unsigned int	reg,
-    const unsigned int	bit);
+STORAGE_CLASS_ISP_H bool isp_ctrl_getbit(const isp_ID_t ID,
+					 const unsigned int reg,
+					 const unsigned int bit);
 
 /*! Set a bitfield in the control register of ISP[ID]
 
@@ -67,10 +61,9 @@ STORAGE_CLASS_ISP_H bool isp_ctrl_getbit(
 
  \return none, ISP[ID].sc[reg] |= (1<<bit)
  */
-STORAGE_CLASS_ISP_H void isp_ctrl_setbit(
-    const isp_ID_t		ID,
-    const unsigned int	reg,
-    const unsigned int	bit);
+STORAGE_CLASS_ISP_H void isp_ctrl_setbit(const isp_ID_t ID,
+					 const unsigned int reg,
+					 const unsigned int bit);
 
 /*! Clear a bitfield in the control register of ISP[ID]
 
@@ -80,10 +73,9 @@ STORAGE_CLASS_ISP_H void isp_ctrl_setbit(
 
  \return none, ISP[ID].sc[reg] &= ~(1<<bit)
  */
-STORAGE_CLASS_ISP_H void isp_ctrl_clearbit(
-    const isp_ID_t		ID,
-    const unsigned int	reg,
-    const unsigned int	bit);
+STORAGE_CLASS_ISP_H void isp_ctrl_clearbit(const isp_ID_t ID,
+					   const unsigned int reg,
+					   const unsigned int bit);
 
 /*! Write to the DMEM of ISP[ID]
 
@@ -94,11 +86,8 @@ STORAGE_CLASS_ISP_H void isp_ctrl_clearbit(
 
  \return none, ISP[ID].dmem[addr...addr+size-1] = data
  */
-STORAGE_CLASS_ISP_H void isp_dmem_store(
-    const isp_ID_t		ID,
-    unsigned int		addr,
-    const void			*data,
-    const size_t		size);
+STORAGE_CLASS_ISP_H void isp_dmem_store(const isp_ID_t ID, unsigned int addr,
+					const void *data, const size_t size);
 
 /*! Read from the DMEM of ISP[ID]
 
@@ -109,11 +98,9 @@ STORAGE_CLASS_ISP_H void isp_dmem_store(
 
  \return none, data = ISP[ID].dmem[addr...addr+size-1]
  */
-STORAGE_CLASS_ISP_H void isp_dmem_load(
-    const isp_ID_t		ID,
-    const unsigned int	addr,
-    void				*data,
-    const size_t		size);
+STORAGE_CLASS_ISP_H void isp_dmem_load(const isp_ID_t ID,
+				       const unsigned int addr, void *data,
+				       const size_t size);
 
 /*! Write a 32-bit datum to the DMEM of ISP[ID]
 
@@ -124,10 +111,9 @@ STORAGE_CLASS_ISP_H void isp_dmem_load(
 
  \return none, ISP[ID].dmem[addr] = data
  */
-STORAGE_CLASS_ISP_H void isp_dmem_store_uint32(
-    const isp_ID_t		ID,
-    unsigned int		addr,
-    const uint32_t		data);
+STORAGE_CLASS_ISP_H void isp_dmem_store_uint32(const isp_ID_t ID,
+					       unsigned int addr,
+					       const uint32_t data);
 
 /*! Load a 32-bit datum from the DMEM of ISP[ID]
 
@@ -138,9 +124,8 @@ STORAGE_CLASS_ISP_H void isp_dmem_store_uint32(
 
  \return none, data = ISP[ID].dmem[addr]
  */
-STORAGE_CLASS_ISP_H uint32_t isp_dmem_load_uint32(
-    const isp_ID_t		ID,
-    const unsigned int	addr);
+STORAGE_CLASS_ISP_H uint32_t isp_dmem_load_uint32(const isp_ID_t ID,
+						  const unsigned int addr);
 
 /*! Concatenate the LSW and MSW into a double precision word
 
@@ -149,9 +134,7 @@ STORAGE_CLASS_ISP_H uint32_t isp_dmem_load_uint32(
 
  \return x0 | (x1 << bits_per_vector_element)
  */
-STORAGE_CLASS_ISP_H uint32_t isp_2w_cat_1w(
-    const u16		x0,
-    const uint16_t		x1);
+STORAGE_CLASS_ISP_H uint32_t isp_2w_cat_1w(const u16 x0, const uint16_t x1);
 
 unsigned int isp_is_ready(isp_ID_t ID);
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_dma_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_dma_public.h
index fceab6dcbddb6f10df1a2855647030b96ccebf2c..89a1bdc9812c6ddf98c700b34b960379552524b8 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_dma_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_dma_public.h
@@ -7,22 +7,17 @@
 #ifndef __ISYS_DMA_PUBLIC_H_INCLUDED__
 #define __ISYS_DMA_PUBLIC_H_INCLUDED__
 
-
 #include "system_local.h"
 #include "type_support.h"
 
-extern void isys2401_dma_reg_store(
-    const isys2401_dma_ID_t dma_id,
-    const unsigned int	reg,
-    const hrt_data		value);
-
-extern hrt_data isys2401_dma_reg_load(
-    const isys2401_dma_ID_t dma_id,
-    const unsigned int	reg);
+extern void isys2401_dma_reg_store(const isys2401_dma_ID_t dma_id,
+				   const unsigned int reg,
+				   const hrt_data value);
 
-void isys2401_dma_set_max_burst_size(
-    const isys2401_dma_ID_t dma_id,
-    uint32_t		max_burst_size);
+extern hrt_data isys2401_dma_reg_load(const isys2401_dma_ID_t dma_id,
+				      const unsigned int reg);
 
+void isys2401_dma_set_max_burst_size(const isys2401_dma_ID_t dma_id,
+				     uint32_t max_burst_size);
 
 #endif /* __ISYS_DMA_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_irq_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_irq_public.h
index a728b9b9fd5256bac821a8e8be5cfef7fae76f01..430d136f0239394e680f0a235c04cf0690478bac 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_irq_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_irq_public.h
@@ -10,21 +10,18 @@
 #include "isys_irq_global.h"
 #include "isys_irq_local.h"
 
+void isys_irqc_state_get(const isys_irq_ID_t isys_irqc_id,
+			 isys_irqc_state_t *state);
 
-void isys_irqc_state_get(const isys_irq_ID_t	isys_irqc_id,
-			 isys_irqc_state_t	*state);
-
-void isys_irqc_state_dump(const isys_irq_ID_t	isys_irqc_id,
+void isys_irqc_state_dump(const isys_irq_ID_t isys_irqc_id,
 			  const isys_irqc_state_t *state);
 
-void isys_irqc_reg_store(const isys_irq_ID_t	isys_irqc_id,
-			 const unsigned int	reg_idx,
-			 const hrt_data		value);
+void isys_irqc_reg_store(const isys_irq_ID_t isys_irqc_id,
+			 const unsigned int reg_idx, const hrt_data value);
 
-hrt_data isys_irqc_reg_load(const isys_irq_ID_t	isys_irqc_id,
-			    const unsigned int	reg_idx);
+hrt_data isys_irqc_reg_load(const isys_irq_ID_t isys_irqc_id,
+			    const unsigned int reg_idx);
 
 void isys_irqc_status_enable(const isys_irq_ID_t isys_irqc_id);
 
-
-#endif	/* __ISYS_IRQ_PUBLIC_H__ */
+#endif /* __ISYS_IRQ_PUBLIC_H__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_stream2mmio_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_stream2mmio_public.h
index 7ed55d427cf6376ce80017088f9371c4f37c41f3..3e66a73755699a48163cfd5d20649afae7226adc 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_stream2mmio_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/isys_stream2mmio_public.h
@@ -19,9 +19,8 @@
  * @param[in]	id		The global unique ID of the steeam2mmio controller.
  * @param[out]	state	Point to the register-state.
  */
-STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_state(
-    const stream2mmio_ID_t ID,
-    stream2mmio_state_t *state);
+STORAGE_CLASS_STREAM2MMIO_H void
+stream2mmio_get_state(const stream2mmio_ID_t ID, stream2mmio_state_t *state);
 
 /**
  * @brief Get the state of the stream2mmio-controller sidess.
@@ -31,10 +30,10 @@ STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_state(
  * @param[in]	sid_id		The sid ID.
  * @param[out]	state		Point to the sid state.
  */
-STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_sid_state(
-    const stream2mmio_ID_t ID,
-    const stream2mmio_sid_ID_t sid_id,
-    stream2mmio_sid_state_t *state);
+STORAGE_CLASS_STREAM2MMIO_H void
+stream2mmio_get_sid_state(const stream2mmio_ID_t ID,
+			  const stream2mmio_sid_ID_t sid_id,
+			  stream2mmio_sid_state_t *state);
 /* end of NCI */
 
 /*****************************************************
@@ -52,10 +51,9 @@ STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_sid_state(
  *
  * @return the value of the register.
  */
-STORAGE_CLASS_STREAM2MMIO_H hrt_data stream2mmio_reg_load(
-    const stream2mmio_ID_t ID,
-    const stream2mmio_sid_ID_t sid_id,
-    const uint32_t reg_idx);
+STORAGE_CLASS_STREAM2MMIO_H hrt_data
+stream2mmio_reg_load(const stream2mmio_ID_t ID,
+		     const stream2mmio_sid_ID_t sid_id, const uint32_t reg_idx);
 
 /**
  * @brief Dump the SID processor state.
@@ -63,8 +61,8 @@ STORAGE_CLASS_STREAM2MMIO_H hrt_data stream2mmio_reg_load(
  *
  * @param[in]	state		Pointer to the register-state.
  */
-STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_print_sid_state(
-    stream2mmio_sid_state_t	*state);
+STORAGE_CLASS_STREAM2MMIO_H void
+stream2mmio_print_sid_state(stream2mmio_sid_state_t *state);
 /**
  * @brief Dump the stream2mmio state.
  * Dump the state of the ibuf-controller regiester-set.
@@ -72,9 +70,8 @@ STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_print_sid_state(
  * @param[in]	id		The global unique ID of the st2mmio
  * @param[in]	state		Pointer to the register-state.
  */
-STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_dump_state(
-    const stream2mmio_ID_t ID,
-    stream2mmio_state_t *state);
+STORAGE_CLASS_STREAM2MMIO_H void
+stream2mmio_dump_state(const stream2mmio_ID_t ID, stream2mmio_state_t *state);
 /**
  * @brief Store a value to the register.
  * Store a value to the registe of the stream2mmio-controller.
@@ -84,10 +81,9 @@ STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_dump_state(
  * @param[in]	value	The value to be stored.
  *
  */
-STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_reg_store(
-    const stream2mmio_ID_t ID,
-    const hrt_address reg,
-    const hrt_data value);
+STORAGE_CLASS_STREAM2MMIO_H void
+stream2mmio_reg_store(const stream2mmio_ID_t ID, const hrt_address reg,
+		      const hrt_data value);
 /* end of DLI */
 
 #endif /* __ISYS_STREAM2MMIO_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/mmu_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/mmu_public.h
index 1a435a348318286d537cb5664bc0012a97491a1d..203b242bf3b06a48c5171c5f571444f9f1cda417 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/mmu_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/mmu_public.h
@@ -18,9 +18,8 @@
 
  \return none, MMU[ID].page_table_base_index = base_index
  */
-void mmu_set_page_table_base_index(
-    const mmu_ID_t		ID,
-    const hrt_data		base_index);
+void mmu_set_page_table_base_index(const mmu_ID_t ID,
+				   const hrt_data base_index);
 
 /*! Get the page table base index of MMU[ID]
 
@@ -29,8 +28,7 @@ void mmu_set_page_table_base_index(
 
  \return MMU[ID].page_table_base_index
  */
-hrt_data mmu_get_page_table_base_index(
-    const mmu_ID_t		ID);
+hrt_data mmu_get_page_table_base_index(const mmu_ID_t ID);
 
 /*! Invalidate the page table cache of MMU[ID]
 
@@ -38,8 +36,7 @@ hrt_data mmu_get_page_table_base_index(
 
  \return none
  */
-void mmu_invalidate_cache(
-    const mmu_ID_t		ID);
+void mmu_invalidate_cache(const mmu_ID_t ID);
 
 /*! Invalidate the page table cache of all MMUs
 
@@ -55,14 +52,13 @@ void mmu_invalidate_cache_all(void);
 
  \return none, MMU[ID].ctrl[reg] = value
  */
-static inline void mmu_reg_store(
-    const mmu_ID_t		ID,
-    const unsigned int	reg,
-    const hrt_data		value)
+static inline void mmu_reg_store(const mmu_ID_t ID, const unsigned int reg,
+				 const hrt_data value)
 {
 	assert(ID < N_MMU_ID);
-	assert(MMU_BASE[ID] != (hrt_address) - 1);
-	ia_css_device_store_uint32(MMU_BASE[ID] + reg * sizeof(hrt_data), value);
+	assert(MMU_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(MMU_BASE[ID] + reg * sizeof(hrt_data),
+				   value);
 	return;
 }
 
@@ -74,12 +70,10 @@ static inline void mmu_reg_store(
 
  \return MMU[ID].ctrl[reg]
  */
-static inline hrt_data mmu_reg_load(
-    const mmu_ID_t		ID,
-    const unsigned int	reg)
+static inline hrt_data mmu_reg_load(const mmu_ID_t ID, const unsigned int reg)
 {
 	assert(ID < N_MMU_ID);
-	assert(MMU_BASE[ID] != (hrt_address) - 1);
+	assert(MMU_BASE[ID] != (hrt_address)-1);
 	return ia_css_device_load_uint32(MMU_BASE[ID] + reg * sizeof(hrt_data));
 }
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/pixelgen_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/pixelgen_public.h
index dc31ce3cd741e5a331a37f32da6defb5feac79fa..0054524b0d0f2f7bc33c5447b73275bd3605c44a 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/pixelgen_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/pixelgen_public.h
@@ -19,9 +19,8 @@
  * @param[in]	id	The global unique ID of the pixelgen controller.
  * @param[out]	state	Point to the register-state.
  */
-STORAGE_CLASS_PIXELGEN_H void pixelgen_ctrl_get_state(
-    const pixelgen_ID_t ID,
-    pixelgen_ctrl_state_t *state);
+STORAGE_CLASS_PIXELGEN_H void
+pixelgen_ctrl_get_state(const pixelgen_ID_t ID, pixelgen_ctrl_state_t *state);
 /**
  * @brief Dump the pixelgen state.
  * Dump the state of the pixelgen regiester-set.
@@ -29,9 +28,8 @@ STORAGE_CLASS_PIXELGEN_H void pixelgen_ctrl_get_state(
  * @param[in]	id	The global unique ID of the pixelgen controller.
  * @param[in]	state	Point to the register-state.
  */
-STORAGE_CLASS_PIXELGEN_H void pixelgen_ctrl_dump_state(
-    const pixelgen_ID_t ID,
-    pixelgen_ctrl_state_t *state);
+STORAGE_CLASS_PIXELGEN_H void
+pixelgen_ctrl_dump_state(const pixelgen_ID_t ID, pixelgen_ctrl_state_t *state);
 /* end of NCI */
 
 /*****************************************************
@@ -48,9 +46,8 @@ STORAGE_CLASS_PIXELGEN_H void pixelgen_ctrl_dump_state(
  *
  * @return the value of the register.
  */
-STORAGE_CLASS_PIXELGEN_H hrt_data pixelgen_ctrl_reg_load(
-    const pixelgen_ID_t ID,
-    const hrt_address reg);
+STORAGE_CLASS_PIXELGEN_H hrt_data pixelgen_ctrl_reg_load(const pixelgen_ID_t ID,
+							 const hrt_address reg);
 /**
  * @brief Store a value to the register.
  * Store a value to the registe of the pixelgen
@@ -60,10 +57,9 @@ STORAGE_CLASS_PIXELGEN_H hrt_data pixelgen_ctrl_reg_load(
  * @param[in]	value	The value to be stored.
  *
  */
-STORAGE_CLASS_PIXELGEN_H void pixelgen_ctrl_reg_store(
-    const pixelgen_ID_t ID,
-    const hrt_address reg,
-    const hrt_data value);
+STORAGE_CLASS_PIXELGEN_H void pixelgen_ctrl_reg_store(const pixelgen_ID_t ID,
+						      const hrt_address reg,
+						      const hrt_data value);
 /* end of DLI */
 
 #endif /* __PIXELGEN_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/sp_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/sp_public.h
index 15faa52d4ab647d7037987022c05a0f37584dee0..eeec0f8b7909f65d219bd53e23bb1f140e7a7e53 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/sp_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/sp_public.h
@@ -17,9 +17,7 @@
 
  \return none, if(cnd) enable(SP[ID].irq) else disable(SP[ID].irq)
  */
-void cnd_sp_irq_enable(
-    const sp_ID_t		ID,
-    const bool			cnd);
+void cnd_sp_irq_enable(const sp_ID_t ID, const bool cnd);
 
 /*! Write to the status and control register of SP[ID]
 
@@ -29,10 +27,8 @@ void cnd_sp_irq_enable(
 
  \return none, SP[ID].sc[reg] = value
  */
-STORAGE_CLASS_SP_H void sp_ctrl_store(
-    const sp_ID_t		ID,
-    const hrt_address	reg,
-    const hrt_data		value);
+STORAGE_CLASS_SP_H void sp_ctrl_store(const sp_ID_t ID, const hrt_address reg,
+				      const hrt_data value);
 
 /*! Read from the status and control register of SP[ID]
 
@@ -42,9 +38,8 @@ STORAGE_CLASS_SP_H void sp_ctrl_store(
 
  \return SP[ID].sc[reg]
  */
-STORAGE_CLASS_SP_H hrt_data sp_ctrl_load(
-    const sp_ID_t		ID,
-    const hrt_address	reg);
+STORAGE_CLASS_SP_H hrt_data sp_ctrl_load(const sp_ID_t ID,
+					 const hrt_address reg);
 
 /*! Get the status of a bitfield in the control register of SP[ID]
 
@@ -54,10 +49,8 @@ STORAGE_CLASS_SP_H hrt_data sp_ctrl_load(
 
  \return  (SP[ID].sc[reg] & (1<<bit)) != 0
  */
-STORAGE_CLASS_SP_H bool sp_ctrl_getbit(
-    const sp_ID_t		ID,
-    const hrt_address	reg,
-    const unsigned int	bit);
+STORAGE_CLASS_SP_H bool sp_ctrl_getbit(const sp_ID_t ID, const hrt_address reg,
+				       const unsigned int bit);
 
 /*! Set a bitfield in the control register of SP[ID]
 
@@ -67,10 +60,8 @@ STORAGE_CLASS_SP_H bool sp_ctrl_getbit(
 
  \return none, SP[ID].sc[reg] |= (1<<bit)
  */
-STORAGE_CLASS_SP_H void sp_ctrl_setbit(
-    const sp_ID_t		ID,
-    const hrt_address	reg,
-    const unsigned int	bit);
+STORAGE_CLASS_SP_H void sp_ctrl_setbit(const sp_ID_t ID, const hrt_address reg,
+				       const unsigned int bit);
 
 /*! Clear a bitfield in the control register of SP[ID]
 
@@ -80,10 +71,9 @@ STORAGE_CLASS_SP_H void sp_ctrl_setbit(
 
  \return none, SP[ID].sc[reg] &= ~(1<<bit)
  */
-STORAGE_CLASS_SP_H void sp_ctrl_clearbit(
-    const sp_ID_t		ID,
-    const hrt_address	reg,
-    const unsigned int	bit);
+STORAGE_CLASS_SP_H void sp_ctrl_clearbit(const sp_ID_t ID,
+					 const hrt_address reg,
+					 const unsigned int bit);
 
 /*! Write to the DMEM of SP[ID]
 
@@ -94,11 +84,8 @@ STORAGE_CLASS_SP_H void sp_ctrl_clearbit(
 
  \return none, SP[ID].dmem[addr...addr+size-1] = data
  */
-STORAGE_CLASS_SP_H void sp_dmem_store(
-    const sp_ID_t		ID,
-    hrt_address		addr,
-    const void			*data,
-    const size_t		size);
+STORAGE_CLASS_SP_H void sp_dmem_store(const sp_ID_t ID, hrt_address addr,
+				      const void *data, const size_t size);
 
 /*! Read from the DMEM of SP[ID]
 
@@ -109,11 +96,8 @@ STORAGE_CLASS_SP_H void sp_dmem_store(
 
  \return none, data = SP[ID].dmem[addr...addr+size-1]
  */
-STORAGE_CLASS_SP_H void sp_dmem_load(
-    const sp_ID_t		ID,
-    const hrt_address	addr,
-    void			*data,
-    const size_t		size);
+STORAGE_CLASS_SP_H void sp_dmem_load(const sp_ID_t ID, const hrt_address addr,
+				     void *data, const size_t size);
 
 /*! Write a 8-bit datum to the DMEM of SP[ID]
 
@@ -124,10 +108,8 @@ STORAGE_CLASS_SP_H void sp_dmem_load(
 
  \return none, SP[ID].dmem[addr...addr+size-1] = data
  */
-STORAGE_CLASS_SP_H void sp_dmem_store_uint8(
-    const sp_ID_t		ID,
-    hrt_address		addr,
-    const uint8_t		data);
+STORAGE_CLASS_SP_H void sp_dmem_store_uint8(const sp_ID_t ID, hrt_address addr,
+					    const uint8_t data);
 
 /*! Write a 16-bit datum to the DMEM of SP[ID]
 
@@ -138,10 +120,8 @@ STORAGE_CLASS_SP_H void sp_dmem_store_uint8(
 
  \return none, SP[ID].dmem[addr...addr+size-1] = data
  */
-STORAGE_CLASS_SP_H void sp_dmem_store_uint16(
-    const sp_ID_t		ID,
-    hrt_address		addr,
-    const uint16_t		data);
+STORAGE_CLASS_SP_H void sp_dmem_store_uint16(const sp_ID_t ID, hrt_address addr,
+					     const uint16_t data);
 
 /*! Write a 32-bit datum to the DMEM of SP[ID]
 
@@ -152,10 +132,8 @@ STORAGE_CLASS_SP_H void sp_dmem_store_uint16(
 
  \return none, SP[ID].dmem[addr...addr+size-1] = data
  */
-STORAGE_CLASS_SP_H void sp_dmem_store_uint32(
-    const sp_ID_t		ID,
-    hrt_address		addr,
-    const uint32_t		data);
+STORAGE_CLASS_SP_H void sp_dmem_store_uint32(const sp_ID_t ID, hrt_address addr,
+					     const uint32_t data);
 
 /*! Load a 8-bit datum from the DMEM of SP[ID]
 
@@ -166,9 +144,8 @@ STORAGE_CLASS_SP_H void sp_dmem_store_uint32(
 
  \return none, data = SP[ID].dmem[addr...addr+size-1]
  */
-STORAGE_CLASS_SP_H uint8_t sp_dmem_load_uint8(
-    const sp_ID_t		ID,
-    const hrt_address	addr);
+STORAGE_CLASS_SP_H uint8_t sp_dmem_load_uint8(const sp_ID_t ID,
+					      const hrt_address addr);
 
 /*! Load a 16-bit datum from the DMEM of SP[ID]
 
@@ -179,9 +156,8 @@ STORAGE_CLASS_SP_H uint8_t sp_dmem_load_uint8(
 
  \return none, data = SP[ID].dmem[addr...addr+size-1]
  */
-STORAGE_CLASS_SP_H uint16_t sp_dmem_load_uint16(
-    const sp_ID_t		ID,
-    const hrt_address	addr);
+STORAGE_CLASS_SP_H uint16_t sp_dmem_load_uint16(const sp_ID_t ID,
+						const hrt_address addr);
 
 /*! Load a 32-bit datum from the DMEM of SP[ID]
 
@@ -192,8 +168,7 @@ STORAGE_CLASS_SP_H uint16_t sp_dmem_load_uint16(
 
  \return none, data = SP[ID].dmem[addr...addr+size-1]
  */
-STORAGE_CLASS_SP_H uint32_t sp_dmem_load_uint32(
-    const sp_ID_t		ID,
-    const hrt_address	addr);
+STORAGE_CLASS_SP_H uint32_t sp_dmem_load_uint32(const sp_ID_t ID,
+						const hrt_address addr);
 
 #endif /* __SP_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/tag_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/tag_public.h
index ad83ff97bbd6a52b680816b96df0785369adec85..e27db7375d724d15b41f29bb6d4726edde7b7b9a 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/tag_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/tag_public.h
@@ -14,19 +14,15 @@
  * @param[in]	offset
  * @param[out]	tag_descr
  */
-void
-sh_css_create_tag_descr(int num_captures,
-			unsigned int skip,
-			int offset,
-			unsigned int exp_id,
-			struct sh_css_tag_descr *tag_descr);
+void sh_css_create_tag_descr(int num_captures, unsigned int skip, int offset,
+			     unsigned int exp_id,
+			     struct sh_css_tag_descr *tag_descr);
 
 /**
  * @brief	Encodes the members of tag description into a 32-bit value.
  * @param[in]	tag		Pointer to the tag description
  * @return	(unsigned int)	Encoded 32-bit tag-info
  */
-unsigned int
-sh_css_encode_tag_descr(struct sh_css_tag_descr *tag);
+unsigned int sh_css_encode_tag_descr(struct sh_css_tag_descr *tag);
 
 #endif /* __TAG_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/timed_ctrl_public.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/timed_ctrl_public.h
index 51e0bc0d0f97180e70f09339e36de7870435916b..36a238ecf01568ccc39ba86541bdb31bb54d0480 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/timed_ctrl_public.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/host/timed_ctrl_public.h
@@ -17,35 +17,22 @@
 
  \return none, TIMED_CTRL[ID].ctrl[reg] = value
  */
-STORAGE_CLASS_TIMED_CTRL_H void timed_ctrl_reg_store(
-    const timed_ctrl_ID_t	ID,
-    const unsigned int		reg_addr,
-    const hrt_data			value);
-
-void timed_ctrl_snd_commnd(
-    const timed_ctrl_ID_t				ID,
-    hrt_data				mask,
-    hrt_data				condition,
-    hrt_data				counter,
-    hrt_address				addr,
-    hrt_data				value);
-
-void timed_ctrl_snd_sp_commnd(
-    const timed_ctrl_ID_t				ID,
-    hrt_data				mask,
-    hrt_data				condition,
-    hrt_data				counter,
-    const sp_ID_t			SP_ID,
-    hrt_address				offset,
-    hrt_data				value);
-
-void timed_ctrl_snd_gpio_commnd(
-    const timed_ctrl_ID_t				ID,
-    hrt_data				mask,
-    hrt_data				condition,
-    hrt_data				counter,
-    const gpio_ID_t			GPIO_ID,
-    hrt_address				offset,
-    hrt_data				value);
+STORAGE_CLASS_TIMED_CTRL_H void
+timed_ctrl_reg_store(const timed_ctrl_ID_t ID, const unsigned int reg_addr,
+		     const hrt_data value);
+
+void timed_ctrl_snd_commnd(const timed_ctrl_ID_t ID, hrt_data mask,
+			   hrt_data condition, hrt_data counter,
+			   hrt_address addr, hrt_data value);
+
+void timed_ctrl_snd_sp_commnd(const timed_ctrl_ID_t ID, hrt_data mask,
+			      hrt_data condition, hrt_data counter,
+			      const sp_ID_t SP_ID, hrt_address offset,
+			      hrt_data value);
+
+void timed_ctrl_snd_gpio_commnd(const timed_ctrl_ID_t ID, hrt_data mask,
+				hrt_data condition, hrt_data counter,
+				const gpio_ID_t GPIO_ID, hrt_address offset,
+				hrt_data value);
 
 #endif /* __TIMED_CTRL_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/input_formatter.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/input_formatter.h
index 21d9ea26f929f574f6f1fafb5603c746b14729b1..6f031e08fd9f9eebe08d4b27d5cb0a03513f4ae6 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/input_formatter.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/input_formatter.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_INPUT_FORMATTER_H extern
 #define STORAGE_CLASS_INPUT_FORMATTER_C
 #include "input_formatter_public.h"
-#else  /* __INLINE_INPUT_FORMATTER__ */
-#define STORAGE_CLASS_INPUT_FORMATTER_H static inline
-#define STORAGE_CLASS_INPUT_FORMATTER_C static inline
+#else /* __INLINE_INPUT_FORMATTER__ */
+#define STORAGE_CLASS_INPUT_FORMATTER_H (static inline)
+#define STORAGE_CLASS_INPUT_FORMATTER_C (static inline)
 #include "input_formatter_private.h"
 #endif /* __INLINE_INPUT_FORMATTER__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/input_system.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/input_system.h
index 97a698ce83d9802f24834b429e3b3b42975278de..893702140be9f88022dac3d8dee1efed6117b539 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/input_system.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/input_system.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_INPUT_SYSTEM_H extern
 #define STORAGE_CLASS_INPUT_SYSTEM_C
 #include "input_system_public.h"
-#else  /* __INLINE_INPUT_SYSTEM__ */
-#define STORAGE_CLASS_INPUT_SYSTEM_H static inline
-#define STORAGE_CLASS_INPUT_SYSTEM_C static inline
+#else /* __INLINE_INPUT_SYSTEM__ */
+#define STORAGE_CLASS_INPUT_SYSTEM_H (static inline)
+#define STORAGE_CLASS_INPUT_SYSTEM_C (static inline)
 #include "input_system_private.h"
 #endif /* __INLINE_INPUT_SYSTEM__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/irq.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/irq.h
index 0f6c8f081a07397cdf79699134cbd80923f279ed..7f225b3c405ec7ced4a242e303ba9a87d5a0394b 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/irq.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/irq.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_IRQ_H extern
 #define STORAGE_CLASS_IRQ_C
 #include "irq_public.h"
-#else  /* __INLINE_IRQ__ */
-#define STORAGE_CLASS_IRQ_H static inline
-#define STORAGE_CLASS_IRQ_C static inline
+#else /* __INLINE_IRQ__ */
+#define STORAGE_CLASS_IRQ_H (static inline)
+#define STORAGE_CLASS_IRQ_C (static inline)
 #include "irq_private.h"
 #endif /* __INLINE_IRQ__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/isp.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/isp.h
index 0ffea40ff0015d4afe7062bedf03583099e037c6..839632dec0840f014949c23fc615a9289f40a7b7 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/isp.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/isp.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_ISP_H extern
 #define STORAGE_CLASS_ISP_C
 #include "isp_public.h"
-#else  /* __INLINE_iSP__ */
-#define STORAGE_CLASS_ISP_H static inline
-#define STORAGE_CLASS_ISP_C static inline
+#else /* __INLINE_iSP__ */
+#define STORAGE_CLASS_ISP_H (static inline)
+#define STORAGE_CLASS_ISP_C (static inline)
 #include "isp_private.h"
 #endif /* __INLINE_ISP__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/isys_irq.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/isys_irq.h
index a4a8e92df592c8d6673df54f6818f136c40335a2..20e349bbf7dadbd91d0df30942218cad58e6ceb6 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/isys_irq.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/isys_irq.h
@@ -10,8 +10,6 @@
 #include <type_support.h>
 #include <system_local.h>
 
-
 #include "isys_irq_public.h"
 
-
-#endif	/* __IA_CSS_ISYS_IRQ_H__ */
+#endif /* __IA_CSS_ISYS_IRQ_H__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/isys_stream2mmio.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/isys_stream2mmio.h
index e88710c65cb9d24af7e4497746951412f150b7a6..a98599aff210cc88a42186eacf4e37cef0409e87 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/isys_stream2mmio.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/isys_stream2mmio.h
@@ -29,9 +29,9 @@
 #define STORAGE_CLASS_STREAM2MMIO_H extern
 #define STORAGE_CLASS_STREAM2MMIO_C
 #include "isys_stream2mmio_public.h"
-#else  /* __INLINE_STREAM2MMIO__ */
-#define STORAGE_CLASS_STREAM2MMIO_H static inline
-#define STORAGE_CLASS_STREAM2MMIO_C static inline
+#else /* __INLINE_STREAM2MMIO__ */
+#define STORAGE_CLASS_STREAM2MMIO_H (static inline)
+#define STORAGE_CLASS_STREAM2MMIO_C (static inline)
 #include "isys_stream2mmio_private.h"
 #endif /* __INLINE_STREAM2MMIO__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/math_support.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/math_support.h
index 6d45d0d8d060bb34182a026fb3aad33a6d8ca512..3e3a8e6fb9ea6ca133b367ac9f0ffc2622b34d59 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/math_support.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/math_support.h
@@ -11,12 +11,12 @@
 #include <linux/minmax.h>
 
 /* force a value to a lower even value */
-#define EVEN_FLOOR(x)        ((x) & ~1)
+#define EVEN_FLOOR(x) ((x) & ~1)
 
-#define CEIL_DIV(a, b)       (((b) != 0) ? ((a) + (b) - 1) / (b) : 0)
-#define CEIL_MUL(a, b)       (CEIL_DIV(a, b) * (b))
-#define CEIL_MUL2(a, b)      (((a) + (b) - 1) & ~((b) - 1))
-#define CEIL_SHIFT(a, b)     (((a) + (1 << (b)) - 1) >> (b))
+#define CEIL_DIV(a, b) (((b) != 0) ? ((a) + (b)-1) / (b) : 0)
+#define CEIL_MUL(a, b) (CEIL_DIV(a, b) * (b))
+#define CEIL_MUL2(a, b) (((a) + (b)-1) & ~((b)-1))
+#define CEIL_SHIFT(a, b) (((a) + (1 << (b)) - 1) >> (b))
 #define CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
 
 /*
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/misc_support.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/misc_support.h
index f8c5a88ae1ad339c217883ffb19707ce074747f3..55b9a961f5f9d955a75d0b2941952db9d3a9c966 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/misc_support.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/misc_support.h
@@ -13,6 +13,7 @@
 #endif
 
 /* Calculate the  total bytes for pow(2) byte alignment */
-#define tot_bytes_for_pow2_align(pow2, cur_bytes)	((cur_bytes + (pow2 - 1)) & ~(pow2 - 1))
+#define tot_bytes_for_pow2_align(pow2, cur_bytes) \
+	((cur_bytes + (pow2 - 1)) & ~(pow2 - 1))
 
 #endif /* __MISC_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/pixelgen.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/pixelgen.h
index 3215098ee60ab1e7458df477bb47db9212ff2bcf..03cc68743df37748f0451afbe8a7c78b1eb03a5b 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/pixelgen.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/pixelgen.h
@@ -29,9 +29,9 @@
 #define STORAGE_CLASS_PIXELGEN_H extern
 #define STORAGE_CLASS_PIXELGEN_C
 #include "pixelgen_public.h"
-#else  /* __INLINE_PIXELGEN__ */
-#define STORAGE_CLASS_PIXELGEN_H static inline
-#define STORAGE_CLASS_PIXELGEN_C static inline
+#else /* __INLINE_PIXELGEN__ */
+#define STORAGE_CLASS_PIXELGEN_H (static inline)
+#define STORAGE_CLASS_PIXELGEN_C (static inline)
 #include "pixelgen_private.h"
 #endif /* __INLINE_PIXELGEN__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/platform_support.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/platform_support.h
index 473d8d4fb9baada0ae8d7ca839bfb7c0f60f8d31..bf629e8ab86e6c7f8dc472d9e7a11a90109e8469 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/platform_support.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/platform_support.h
@@ -18,8 +18,8 @@
 
 #define UINT16_MAX USHRT_MAX
 #define UINT32_MAX UINT_MAX
-#define UCHAR_MAX  (255)
+#define UCHAR_MAX (255)
 
-#define CSS_ALIGN(d, a) d __attribute__((aligned(a)))
+#define CSS_ALIGN(d, a) (d __attribute__((aligned(a))))
 
 #endif /* __PLATFORM_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/print_support.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/print_support.h
index e6ce7b51d3415553dcbd21e4f9b6d0d4a74ef6ea..f8999dd994ae518629d622c0b88e1aa1b05141be 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/print_support.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/print_support.h
@@ -11,7 +11,7 @@
 
 extern int (*sh_css_printf)(const char *fmt, va_list args);
 /* depends on host supplied print function in ia_css_init() */
-static inline  __printf(1, 2) void ia_css_print(const char *fmt, ...)
+static inline __printf(1, 2) void ia_css_print(const char *fmt, ...)
 {
 	va_list ap;
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/queue.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/queue.h
index d778bcb5664691b814af411f93ff7dc5745ea913..09a1a44171340762b4b9b95a50c7fad493ef26c0 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/queue.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/queue.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_QUEUE_C
 /* #include "queue_public.h" */
 #include "ia_css_queue.h"
-#else  /* __INLINE_QUEUE__ */
-#define STORAGE_CLASS_QUEUE_H static inline
-#define STORAGE_CLASS_QUEUE_C static inline
+#else /* __INLINE_QUEUE__ */
+#define STORAGE_CLASS_QUEUE_H (static inline)
+#define STORAGE_CLASS_QUEUE_C (static inline)
 #include "queue_private.h"
 #endif /* __INLINE_QUEUE__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/resource.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/resource.h
index c7a92b530f898983ab3bf1022a6022fbfd541d28..d2ff2333d330b8a7ada10b589a5071fd7e954149 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/resource.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/resource.h
@@ -29,9 +29,9 @@
 #define STORAGE_CLASS_RESOURCE_H extern
 #define STORAGE_CLASS_RESOURCE_C
 #include "resource_public.h"
-#else  /* __INLINE_RESOURCE__ */
-#define STORAGE_CLASS_RESOURCE_H static inline
-#define STORAGE_CLASS_RESOURCE_C static inline
+#else /* __INLINE_RESOURCE__ */
+#define STORAGE_CLASS_RESOURCE_H (static inline)
+#define STORAGE_CLASS_RESOURCE_C (static inline)
 #include "resource_private.h"
 #endif /* __INLINE_RESOURCE__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/sp.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/sp.h
index 92724ae59e6b93fe973378358333075033273c5c..e2eb742a404b05e3dca8cb43097c17f8e6c672ba 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/sp.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/sp.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_SP_H extern
 #define STORAGE_CLASS_SP_C
 #include "sp_public.h"
-#else  /* __INLINE_SP__ */
-#define STORAGE_CLASS_SP_H static inline
-#define STORAGE_CLASS_SP_C static inline
+#else /* __INLINE_SP__ */
+#define STORAGE_CLASS_SP_H (static inline)
+#define STORAGE_CLASS_SP_C (static inline)
 #include "sp_private.h"
 #endif /* __INLINE_SP__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/tag.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/tag.h
index b335222c7334757e93794e5dc59a778e39304f81..7297567ec82c7791bc768b203b208e66209e70f4 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/tag.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/tag.h
@@ -27,9 +27,9 @@
 #define STORAGE_CLASS_TAG_H extern
 #define STORAGE_CLASS_TAG_C
 #include "tag_public.h"
-#else  /* __INLINE_TAG__ */
-#define STORAGE_CLASS_TAG_H static inline
-#define STORAGE_CLASS_TAG_C static inline
+#else /* __INLINE_TAG__ */
+#define STORAGE_CLASS_TAG_H (static inline)
+#define STORAGE_CLASS_TAG_C (static inline)
 #include "tag_private.h"
 #endif /* __INLINE_TAG__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/timed_ctrl.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/timed_ctrl.h
index b8f48b3c9f1e97ea22bd6944c99561fd8bc0c47c..9112582cd3e9787ae387b4b23e75c2fdda8f51c6 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/timed_ctrl.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/timed_ctrl.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_TIMED_CTRL_H extern
 #define STORAGE_CLASS_TIMED_CTRL_C
 #include "timed_ctrl_public.h"
-#else  /* __INLINE_TIMED_CTRL__ */
-#define STORAGE_CLASS_TIMED_CTRL_H static inline
-#define STORAGE_CLASS_TIMED_CTRL_C static inline
+#else /* __INLINE_TIMED_CTRL__ */
+#define STORAGE_CLASS_TIMED_CTRL_H (static inline)
+#define STORAGE_CLASS_TIMED_CTRL_C (static inline)
 #include "timed_ctrl_private.h"
 #endif /* __INLINE_TIMED_CTRL__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/type_support.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/type_support.h
index 097be6bd3cb529f09a99f4e9520e07f594f90e03..645b022f21459a868f867160319c856440f8aa5a 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/type_support.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/type_support.h
@@ -16,11 +16,11 @@
 * platform specific definitions.
 */
 
-#define IA_CSS_UINT8_T_BITS						8
-#define IA_CSS_UINT16_T_BITS					16
-#define IA_CSS_UINT32_T_BITS					32
-#define IA_CSS_INT32_T_BITS						32
-#define IA_CSS_UINT64_T_BITS					64
+#define IA_CSS_UINT8_T_BITS 8
+#define IA_CSS_UINT16_T_BITS 16
+#define IA_CSS_UINT32_T_BITS 32
+#define IA_CSS_INT32_T_BITS 32
+#define IA_CSS_UINT64_T_BITS 64
 
 #define CHAR_BIT (8)
 
@@ -28,6 +28,6 @@
 #include <linux/limits.h>
 #include <linux/types.h>
 
-#define HOST_ADDRESS(x) (unsigned long)(x)
+#define HOST_ADDRESS(x) ((unsigned long)(x))
 
 #endif /* __TYPE_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_include/vmem.h b/drivers/staging/media/atomisp/pci/hive_isp_css_include/vmem.h
index 8e8d187d12217df2cc4306a69ba3266351f73b9f..aae7aac2d06b56fafd4a87a6450380f65afc2539 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_include/vmem.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_include/vmem.h
@@ -28,9 +28,9 @@
 #define STORAGE_CLASS_VMEM_H extern
 #define STORAGE_CLASS_VMEM_C
 #include "vmem_public.h"
-#else  /* __INLINE_VMEM__ */
-#define STORAGE_CLASS_VMEM_H static inline
-#define STORAGE_CLASS_VMEM_C static inline
+#else /* __INLINE_VMEM__ */
+#define STORAGE_CLASS_VMEM_H (static inline)
+#define STORAGE_CLASS_VMEM_C (static inline)
 #include "vmem_private.h"
 #endif /* __INLINE_VMEM__ */
 
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_shared/host/tag.c b/drivers/staging/media/atomisp/pci/hive_isp_css_shared/host/tag.c
index c68b096444de0f593cee6a8fb11976e8ed2962b5..6f7b1870bf4151edefa70745d17de1c56f192301 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_shared/host/tag.c
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_shared/host/tag.c
@@ -5,7 +5,7 @@
  */
 
 #include "tag.h"
-#include <platform_support.h>	/* NULL */
+#include <platform_support.h> /* NULL */
 #include <assert_support.h>
 #include "tag_local.h"
 
@@ -16,19 +16,16 @@
  * @param[in]	offset
  * @param[out]	tag_descr
  */
-void
-sh_css_create_tag_descr(int num_captures,
-			unsigned int skip,
-			int offset,
-			unsigned int exp_id,
-			struct sh_css_tag_descr *tag_descr)
+void sh_css_create_tag_descr(int num_captures, unsigned int skip, int offset,
+			     unsigned int exp_id,
+			     struct sh_css_tag_descr *tag_descr)
 {
 	assert(tag_descr);
 
 	tag_descr->num_captures = num_captures;
-	tag_descr->skip		= skip;
-	tag_descr->offset	= offset;
-	tag_descr->exp_id	= exp_id;
+	tag_descr->skip = skip;
+	tag_descr->offset = offset;
+	tag_descr->exp_id = exp_id;
 }
 
 /*
@@ -36,8 +33,7 @@ sh_css_create_tag_descr(int num_captures,
  * @param[in]	tag		Pointer to the tag description
  * @return	(unsigned int)	Encoded 32-bit tag-info
  */
-unsigned int
-sh_css_encode_tag_descr(struct sh_css_tag_descr *tag)
+unsigned int sh_css_encode_tag_descr(struct sh_css_tag_descr *tag)
 {
 	int num_captures;
 	unsigned int num_captures_sign;
@@ -72,12 +68,15 @@ sh_css_encode_tag_descr(struct sh_css_tag_descr *tag)
 
 		encoded_tag = TAG_EXP | (exp_id & 0xFF) << TAG_EXP_ID_SHIFT;
 	} else {
-		encoded_tag = TAG_CAP
-			      | ((num_captures_sign & 0x00000001) << TAG_NUM_CAPTURES_SIGN_SHIFT)
-			      | ((offset_sign       & 0x00000001) << TAG_OFFSET_SIGN_SHIFT)
-			      | ((num_captures      & 0x000000FF) << TAG_NUM_CAPTURES_SHIFT)
-			      | ((skip              & 0x000000FF) << TAG_OFFSET_SHIFT)
-			      | ((offset            & 0x000000FF) << TAG_SKIP_SHIFT);
+		encoded_tag =
+			TAG_CAP |
+			((num_captures_sign & 0x00000001)
+			 << TAG_NUM_CAPTURES_SIGN_SHIFT) |
+			((offset_sign & 0x00000001) << TAG_OFFSET_SIGN_SHIFT) |
+			((num_captures & 0x000000FF)
+			 << TAG_NUM_CAPTURES_SHIFT) |
+			((skip & 0x000000FF) << TAG_OFFSET_SHIFT) |
+			((offset & 0x000000FF) << TAG_SKIP_SHIFT);
 	}
 	return encoded_tag;
 }
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_shared/sw_event_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_shared/sw_event_global.h
index c9ee03d604983302e0e07f72d1e79a66b251b5e8..20e37fa5494c7573e48c6252a9ab280483962b44 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_shared/sw_event_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_shared/sw_event_global.h
@@ -20,8 +20,6 @@ enum ia_css_psys_sw_event {
 	IA_CSS_PSYS_SW_EVENT_STAGE_ENABLE_DISABLE /* for extension state change enable/disable */
 };
 
-enum ia_css_isys_sw_event {
-	IA_CSS_ISYS_SW_EVENT_EVENT_DEQUEUED
-};
+enum ia_css_isys_sw_event { IA_CSS_ISYS_SW_EVENT_EVENT_DEQUEUED };
 
 #endif /* __SW_EVENT_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_shared/tag_global.h b/drivers/staging/media/atomisp/pci/hive_isp_css_shared/tag_global.h
index 7aef49429f98da0b9a56e761759eb0c5d1e8a13b..b7ced5068b7e4a02fe942466226c0f6ec7ad983a 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_shared/tag_global.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_shared/tag_global.h
@@ -9,16 +9,16 @@
 
 /* offsets for encoding/decoding the tag into an uint32_t */
 
-#define TAG_CAP	1
-#define TAG_EXP	2
+#define TAG_CAP 1
+#define TAG_EXP 2
 
-#define TAG_NUM_CAPTURES_SIGN_SHIFT	 6
-#define TAG_OFFSET_SIGN_SHIFT		 7
-#define TAG_NUM_CAPTURES_SHIFT		 8
-#define TAG_OFFSET_SHIFT		16
-#define TAG_SKIP_SHIFT			24
+#define TAG_NUM_CAPTURES_SIGN_SHIFT 6
+#define TAG_OFFSET_SIGN_SHIFT 7
+#define TAG_NUM_CAPTURES_SHIFT 8
+#define TAG_OFFSET_SHIFT 16
+#define TAG_SKIP_SHIFT 24
 
-#define TAG_EXP_ID_SHIFT		 8
+#define TAG_EXP_ID_SHIFT 8
 
 /* Data structure containing the tagging information which is used in
  * continuous mode to specify which frames should be captured.
diff --git a/drivers/staging/media/atomisp/pci/hive_isp_css_streaming_to_mipi_types_hrt.h b/drivers/staging/media/atomisp/pci/hive_isp_css_streaming_to_mipi_types_hrt.h
index 7579b1ec25961f302109a4c984a2df51b6207286..6468ed5e26ffe913a51c14fe3098a17e724f343f 100644
--- a/drivers/staging/media/atomisp/pci/hive_isp_css_streaming_to_mipi_types_hrt.h
+++ b/drivers/staging/media/atomisp/pci/hive_isp_css_streaming_to_mipi_types_hrt.h
@@ -9,10 +9,12 @@
 
 #include <streaming_to_mipi_defs.h>
 
-#define _HIVE_ISP_CH_ID_MASK    ((1U << HIVE_ISP_CH_ID_BITS) - 1)
+#define _HIVE_ISP_CH_ID_MASK ((1U << HIVE_ISP_CH_ID_BITS) - 1)
 #define _HIVE_ISP_FMT_TYPE_MASK ((1U << HIVE_ISP_FMT_TYPE_BITS) - 1)
 
-#define _HIVE_STR_TO_MIPI_FMT_TYPE_LSB (HIVE_STR_TO_MIPI_CH_ID_LSB + HIVE_ISP_CH_ID_BITS)
-#define _HIVE_STR_TO_MIPI_DATA_B_LSB   (HIVE_STR_TO_MIPI_DATA_A_LSB + HIVE_IF_PIXEL_WIDTH)
+#define _HIVE_STR_TO_MIPI_FMT_TYPE_LSB \
+	(HIVE_STR_TO_MIPI_CH_ID_LSB + HIVE_ISP_CH_ID_BITS)
+#define _HIVE_STR_TO_MIPI_DATA_B_LSB \
+	(HIVE_STR_TO_MIPI_DATA_A_LSB + HIVE_IF_PIXEL_WIDTH)
 
 #endif /* _hive_isp_css_streaming_to_mipi_types_hrt_h_ */
diff --git a/drivers/staging/media/atomisp/pci/hive_types.h b/drivers/staging/media/atomisp/pci/hive_types.h
index c5c5ce3f2228c195a8cd43244435b125200317ee..a0b427524db5c2664cb854aed349d3975ac48215 100644
--- a/drivers/staging/media/atomisp/pci/hive_types.h
+++ b/drivers/staging/media/atomisp/pci/hive_types.h
@@ -12,39 +12,39 @@
 /* boolean data type */
 typedef unsigned int hive_bool;
 #define hive_false 0
-#define hive_true  1
+#define hive_true 1
 
-typedef signed char          hive_int8;
-typedef short                hive_int16;
-typedef int                  hive_int32;
-typedef long long            hive_int64;
+typedef signed char hive_int8;
+typedef short hive_int16;
+typedef int hive_int32;
+typedef long long hive_int64;
 
-typedef unsigned char        hive_uint8;
-typedef unsigned short       hive_uint16;
-typedef unsigned int         hive_uint32;
-typedef unsigned long long   hive_uint64;
+typedef unsigned char hive_uint8;
+typedef unsigned short hive_uint16;
+typedef unsigned int hive_uint32;
+typedef unsigned long long hive_uint64;
 
-#define HRT_DATA_WIDTH	  32
+#define HRT_DATA_WIDTH 32
 #define HRT_ADDRESS_WIDTH 64
-#define HRT_DATA_BYTES    (HRT_DATA_WIDTH / 8)
+#define HRT_DATA_BYTES (HRT_DATA_WIDTH / 8)
 #define HRT_ADDRESS_BYTES (HRT_ADDRESS_WIDTH / 8)
-#define SIZEOF_HRT_REG    (HRT_DATA_WIDTH >> 3)
+#define SIZEOF_HRT_REG (HRT_DATA_WIDTH >> 3)
 
 typedef hive_uint32 hrt_data;
 typedef hive_uint64 hrt_address;
 
 /* use 64 bit addresses in simulation, where possible */
-typedef hive_uint64  hive_sim_address;
+typedef hive_uint64 hive_sim_address;
 
 /* below is for csim, not for hrt, rename and move this elsewhere */
 
 typedef unsigned int hive_uint;
-typedef hive_uint32  hive_address;
+typedef hive_uint32 hive_address;
 typedef hive_address hive_slave_address;
 typedef hive_address hive_mem_address;
 
 /* MMIO devices */
-typedef hive_uint    hive_mmio_id;
+typedef hive_uint hive_mmio_id;
 typedef hive_mmio_id hive_slave_id;
 typedef hive_mmio_id hive_port_id;
 typedef hive_mmio_id hive_master_id;
@@ -52,8 +52,8 @@ typedef hive_mmio_id hive_mem_id;
 typedef hive_mmio_id hive_dev_id;
 typedef hive_mmio_id hive_fifo_id;
 
-typedef hive_uint      hive_hier_id;
-typedef hive_hier_id   hive_device_id;
+typedef hive_uint hive_hier_id;
+typedef hive_hier_id hive_device_id;
 typedef hive_device_id hive_proc_id;
 typedef hive_device_id hive_cell_id;
 typedef hive_device_id hive_host_id;
diff --git a/drivers/staging/media/atomisp/pci/hmm/hmm.c b/drivers/staging/media/atomisp/pci/hmm/hmm.c
index 84102c3aaf9759f430313477d93774f912461bbd..22f33fd3be0f5afa63c189fae28a340d91f8a38f 100644
--- a/drivers/staging/media/atomisp/pci/hmm/hmm.c
+++ b/drivers/staging/media/atomisp/pci/hmm/hmm.c
@@ -12,8 +12,8 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/mm.h>
-#include <linux/highmem.h>	/* for kmap */
-#include <linux/io.h>		/* for page_to_phys */
+#include <linux/highmem.h> /* for kmap */
+#include <linux/io.h> /* for page_to_phys */
 #include <linux/sysfs.h>
 
 #include "hmm/hmm.h"
@@ -57,8 +57,8 @@ static ssize_t bo_show(struct device *dev, struct device_attribute *attr,
 		if ((active && (bo->status & HMM_BO_ALLOCED)) ||
 		    (!active && !(bo->status & HMM_BO_ALLOCED))) {
 			ret = scnprintf(buf + index1, PAGE_SIZE - index1,
-					"%c %d\n",
-					hmm_bo_type_string[bo->type], bo->pgnr);
+					"%c %d\n", hmm_bo_type_string[bo->type],
+					bo->pgnr);
 
 			total[bo->type] += bo->pgnr;
 			count[bo->type]++;
@@ -96,26 +96,22 @@ static ssize_t free_bo_show(struct device *dev, struct device_attribute *attr,
 	return bo_show(dev, attr, buf, &bo_device.entire_bo_list, false);
 }
 
-
 static DEVICE_ATTR_RO(active_bo);
 static DEVICE_ATTR_RO(free_bo);
 
-static struct attribute *sysfs_attrs_ctrl[] = {
-	&dev_attr_active_bo.attr,
-	&dev_attr_free_bo.attr,
-	NULL
-};
+static struct attribute *sysfs_attrs_ctrl[] = { &dev_attr_active_bo.attr,
+						&dev_attr_free_bo.attr, NULL };
 
 static struct attribute_group atomisp_attribute_group[] = {
-	{.attrs = sysfs_attrs_ctrl },
+	{ .attrs = sysfs_attrs_ctrl },
 };
 
 int hmm_init(void)
 {
 	int ret;
 
-	ret = hmm_bo_device_init(&bo_device, &sh_mmu_mrfld,
-				 ISP_VM_START, ISP_VM_SIZE);
+	ret = hmm_bo_device_init(&bo_device, &sh_mmu_mrfld, ISP_VM_START,
+				 ISP_VM_SIZE);
 	if (ret)
 		dev_err(atomisp_dev, "hmm_bo_device_init failed.\n");
 
@@ -134,8 +130,8 @@ int hmm_init(void)
 		ret = sysfs_create_group(&atomisp_dev->kobj,
 					 atomisp_attribute_group);
 		if (ret)
-			dev_err(atomisp_dev,
-				"%s Failed to create sysfs\n", __func__);
+			dev_err(atomisp_dev, "%s Failed to create sysfs\n",
+				__func__);
 	}
 
 	return ret;
@@ -244,8 +240,7 @@ static inline int hmm_check_bo(struct hmm_buffer_object *bo, unsigned int ptr)
 	}
 
 	if (!hmm_bo_page_allocated(bo)) {
-		dev_err(atomisp_dev,
-			"buffer object has no page allocated.\n");
+		dev_err(atomisp_dev, "buffer object has no page allocated.\n");
 		return -EINVAL;
 	}
 
@@ -287,7 +282,7 @@ static int load_and_flush_by_kmap(ia_css_ptr virt, void *data,
 			bytes = 0;
 		}
 
-		virt += len;	/* update virt for next loop */
+		virt += len; /* update virt for next loop */
 
 		if (des) {
 			memcpy(des, src, len);
@@ -341,13 +336,11 @@ static int load_and_flush(ia_css_ptr virt, void *data, unsigned int bytes)
 int hmm_load(ia_css_ptr virt, void *data, unsigned int bytes)
 {
 	if (!virt) {
-		dev_warn(atomisp_dev,
-			"hmm_store: address is NULL\n");
+		dev_warn(atomisp_dev, "hmm_store: address is NULL\n");
 		return -EINVAL;
 	}
 	if (!data) {
-		dev_err(atomisp_dev,
-			"hmm_store: data is a NULL argument\n");
+		dev_err(atomisp_dev, "hmm_store: data is a NULL argument\n");
 		return -EINVAL;
 	}
 	return load_and_flush(virt, data, bytes);
@@ -368,13 +361,11 @@ int hmm_store(ia_css_ptr virt, const void *data, unsigned int bytes)
 	int ret;
 
 	if (!virt) {
-		dev_warn(atomisp_dev,
-			"hmm_store: address is NULL\n");
+		dev_warn(atomisp_dev, "hmm_store: address is NULL\n");
 		return -EINVAL;
 	}
 	if (!data) {
-		dev_err(atomisp_dev,
-			"hmm_store: data is a NULL argument\n");
+		dev_err(atomisp_dev, "hmm_store: data is a NULL argument\n");
 		return -EINVAL;
 	}
 
diff --git a/drivers/staging/media/atomisp/pci/hmm/hmm_bo.c b/drivers/staging/media/atomisp/pci/hmm/hmm_bo.c
index 224ca8d42721a68a01c148f20194cc6a173213ab..a0b06831f2f4560e9ded22075b397a5965862711 100644
--- a/drivers/staging/media/atomisp/pci/hmm/hmm_bo.c
+++ b/drivers/staging/media/atomisp/pci/hmm/hmm_bo.c
@@ -11,12 +11,12 @@
  */
 #include <linux/kernel.h>
 #include <linux/types.h>
-#include <linux/gfp.h>		/* for GFP_ATOMIC */
+#include <linux/gfp.h> /* for GFP_ATOMIC */
 #include <linux/mm.h>
 #include <linux/mm_types.h>
 #include <linux/hugetlb.h>
 #include <linux/highmem.h>
-#include <linux/slab.h>		/* for kmalloc */
+#include <linux/slab.h> /* for kmalloc */
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/string.h>
@@ -63,24 +63,23 @@ static int __bo_init(struct hmm_bo_device *bdev, struct hmm_buffer_object *bo,
 	return 0;
 }
 
-static struct hmm_buffer_object *__bo_search_and_remove_from_free_rbtree(
-    struct rb_node *node, unsigned int pgnr)
+static struct hmm_buffer_object *
+__bo_search_and_remove_from_free_rbtree(struct rb_node *node, unsigned int pgnr)
 {
 	struct hmm_buffer_object *this, *ret_bo, *temp_bo;
 
 	this = rb_entry(node, struct hmm_buffer_object, node);
-	if (this->pgnr == pgnr ||
-	    (this->pgnr > pgnr && !this->node.rb_left)) {
+	if (this->pgnr == pgnr || (this->pgnr > pgnr && !this->node.rb_left)) {
 		goto remove_bo_and_return;
 	} else {
 		if (this->pgnr < pgnr) {
 			if (!this->node.rb_right)
 				return NULL;
 			ret_bo = __bo_search_and_remove_from_free_rbtree(
-				     this->node.rb_right, pgnr);
+				this->node.rb_right, pgnr);
 		} else {
 			ret_bo = __bo_search_and_remove_from_free_rbtree(
-				     this->node.rb_left, pgnr);
+				this->node.rb_left, pgnr);
 		}
 		if (!ret_bo) {
 			if (this->pgnr > pgnr)
@@ -115,7 +114,7 @@ static struct hmm_buffer_object *__bo_search_and_remove_from_free_rbtree(
 }
 
 static struct hmm_buffer_object *__bo_search_by_addr(struct rb_root *root,
-	ia_css_ptr start)
+						     ia_css_ptr start)
 {
 	struct rb_node *n = root->rb_node;
 	struct hmm_buffer_object *bo;
@@ -139,8 +138,8 @@ static struct hmm_buffer_object *__bo_search_by_addr(struct rb_root *root,
 	return NULL;
 }
 
-static struct hmm_buffer_object *__bo_search_by_addr_in_range(
-    struct rb_root *root, unsigned int start)
+static struct hmm_buffer_object *
+__bo_search_by_addr_in_range(struct rb_root *root, unsigned int start)
 {
 	struct rb_node *n = root->rb_node;
 	struct hmm_buffer_object *bo;
@@ -223,8 +222,8 @@ static void __bo_insert_to_alloc_rbtree(struct rb_root *root,
 }
 
 static struct hmm_buffer_object *__bo_break_up(struct hmm_bo_device *bdev,
-	struct hmm_buffer_object *bo,
-	unsigned int pgnr)
+					       struct hmm_buffer_object *bo,
+					       unsigned int pgnr)
 {
 	struct hmm_buffer_object *new_bo;
 	unsigned long flags;
@@ -296,7 +295,7 @@ static void __bo_take_off_handling(struct hmm_buffer_object *bo)
 }
 
 static struct hmm_buffer_object *__bo_merge(struct hmm_buffer_object *bo,
-	struct hmm_buffer_object *next_bo)
+					    struct hmm_buffer_object *next_bo)
 {
 	struct hmm_bo_device *bdev;
 	unsigned long flags;
@@ -319,8 +318,7 @@ static struct hmm_buffer_object *__bo_merge(struct hmm_buffer_object *bo,
  */
 int hmm_bo_device_init(struct hmm_bo_device *bdev,
 		       struct isp_mmu_client *mmu_driver,
-		       unsigned int vaddr_start,
-		       unsigned int size)
+		       unsigned int vaddr_start, unsigned int size)
 {
 	struct hmm_buffer_object *bo;
 	unsigned long flags;
@@ -347,8 +345,8 @@ int hmm_bo_device_init(struct hmm_bo_device *bdev,
 	bdev->allocated_rbtree = RB_ROOT;
 	bdev->free_rbtree = RB_ROOT;
 
-	bdev->bo_cache = kmem_cache_create("bo_cache",
-					   sizeof(struct hmm_buffer_object), 0, 0, NULL);
+	bdev->bo_cache = kmem_cache_create(
+		"bo_cache", sizeof(struct hmm_buffer_object), 0, 0, NULL);
 	if (!bdev->bo_cache) {
 		dev_err(atomisp_dev, "%s: create cache failed!\n", __func__);
 		isp_mmu_exit(&bdev->mmu);
@@ -444,17 +442,20 @@ void hmm_bo_release(struct hmm_buffer_object *bo)
 	 */
 	if (bo->status & HMM_BO_MMAPED) {
 		mutex_unlock(&bdev->rbtree_mutex);
-		dev_dbg(atomisp_dev, "destroy bo which is MMAPED, do nothing\n");
+		dev_dbg(atomisp_dev,
+			"destroy bo which is MMAPED, do nothing\n");
 		return;
 	}
 
 	if (bo->status & HMM_BO_BINDED) {
-		dev_warn(atomisp_dev, "the bo is still binded, unbind it first...\n");
+		dev_warn(atomisp_dev,
+			 "the bo is still binded, unbind it first...\n");
 		hmm_bo_unbind(bo);
 	}
 
 	if (bo->status & HMM_BO_PAGE_ALLOCED) {
-		dev_warn(atomisp_dev, "the pages is not freed, free pages first\n");
+		dev_warn(atomisp_dev,
+			 "the pages is not freed, free pages first\n");
 		hmm_bo_free_pages(bo);
 	}
 	if (bo->status & HMM_BO_VMAPED || bo->status & HMM_BO_VMAPED_CACHED) {
@@ -502,7 +503,7 @@ void hmm_bo_device_exit(struct hmm_bo_device *bdev)
 	 */
 	while (!RB_EMPTY_ROOT(&bdev->allocated_rbtree))
 		hmm_bo_release(
-		    rbtree_node_to_hmm_bo(bdev->allocated_rbtree.rb_node));
+			rbtree_node_to_hmm_bo(bdev->allocated_rbtree.rb_node));
 
 	dev_dbg(atomisp_dev, "%s: finished releasing all allocated bos!\n",
 		__func__);
@@ -539,8 +540,8 @@ int hmm_bo_allocated(struct hmm_buffer_object *bo)
 	return bo->status & HMM_BO_ALLOCED;
 }
 
-struct hmm_buffer_object *hmm_bo_device_search_start(
-    struct hmm_bo_device *bdev, ia_css_ptr vaddr)
+struct hmm_buffer_object *hmm_bo_device_search_start(struct hmm_bo_device *bdev,
+						     ia_css_ptr vaddr)
 {
 	struct hmm_buffer_object *bo;
 
@@ -559,8 +560,8 @@ struct hmm_buffer_object *hmm_bo_device_search_start(
 	return bo;
 }
 
-struct hmm_buffer_object *hmm_bo_device_search_in_range(
-    struct hmm_bo_device *bdev, unsigned int vaddr)
+struct hmm_buffer_object *
+hmm_bo_device_search_in_range(struct hmm_bo_device *bdev, unsigned int vaddr)
 {
 	struct hmm_buffer_object *bo;
 
@@ -579,8 +580,8 @@ struct hmm_buffer_object *hmm_bo_device_search_in_range(
 	return bo;
 }
 
-struct hmm_buffer_object *hmm_bo_device_search_vmap_start(
-    struct hmm_bo_device *bdev, const void *vaddr)
+struct hmm_buffer_object *
+hmm_bo_device_search_vmap_start(struct hmm_bo_device *bdev, const void *vaddr)
 {
 	struct list_head *pos;
 	struct hmm_buffer_object *bo;
@@ -604,7 +605,8 @@ struct hmm_buffer_object *hmm_bo_device_search_vmap_start(
 	return bo;
 }
 
-static void free_pages_bulk_array(unsigned long nr_pages, struct page **page_array)
+static void free_pages_bulk_array(unsigned long nr_pages,
+				  struct page **page_array)
 {
 	unsigned long i;
 
@@ -649,7 +651,9 @@ static int alloc_vmalloc_pages(struct hmm_buffer_object *bo, void *vmalloc_addr)
 	for (i = 0; i < bo->pgnr; i++) {
 		bo->pages[i] = vmalloc_to_page(vaddr);
 		if (!bo->pages[i]) {
-			dev_err(atomisp_dev, "Error could not get page %d of vmalloc buf\n", i);
+			dev_err(atomisp_dev,
+				"Error could not get page %d of vmalloc buf\n",
+				i);
 			return -ENOMEM;
 		}
 		vaddr += PAGE_SIZE;
@@ -666,8 +670,7 @@ static int alloc_vmalloc_pages(struct hmm_buffer_object *bo, void *vmalloc_addr)
  *
  * vmalloc_addr is only valid when type is HMM_BO_VMALLOC.
  */
-int hmm_bo_alloc_pages(struct hmm_buffer_object *bo,
-		       enum hmm_bo_type type,
+int hmm_bo_alloc_pages(struct hmm_buffer_object *bo, enum hmm_bo_type type,
 		       void *vmalloc_addr)
 {
 	int ret = -EINVAL;
@@ -709,8 +712,7 @@ int hmm_bo_alloc_pages(struct hmm_buffer_object *bo,
 	return ret;
 status_err:
 	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev,
-		"buffer object has already page allocated.\n");
+	dev_err(atomisp_dev, "buffer object has already page allocated.\n");
 	return -EINVAL;
 }
 
@@ -742,8 +744,7 @@ void hmm_bo_free_pages(struct hmm_buffer_object *bo)
 
 status_err2:
 	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev,
-		"buffer object not page allocated yet.\n");
+	dev_err(atomisp_dev, "buffer object not page allocated yet.\n");
 }
 
 int hmm_bo_page_allocated(struct hmm_buffer_object *bo)
@@ -767,8 +768,7 @@ int hmm_bo_bind(struct hmm_buffer_object *bo)
 
 	mutex_lock(&bo->mutex);
 
-	check_bo_status_yes_goto(bo,
-				 HMM_BO_PAGE_ALLOCED | HMM_BO_ALLOCED,
+	check_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED | HMM_BO_ALLOCED,
 				 status_err1);
 
 	check_bo_status_no_goto(bo, HMM_BO_BINDED, status_err2);
@@ -778,9 +778,8 @@ int hmm_bo_bind(struct hmm_buffer_object *bo)
 	virt = bo->start;
 
 	for (i = 0; i < bo->pgnr; i++) {
-		ret =
-		    isp_mmu_map(&bdev->mmu, virt,
-				page_to_phys(bo->pages[i]), 1);
+		ret = isp_mmu_map(&bdev->mmu, virt, page_to_phys(bo->pages[i]),
+				  1);
 		if (ret)
 			goto map_err;
 		virt += (1 << PAGE_SHIFT);
@@ -810,14 +809,13 @@ int hmm_bo_bind(struct hmm_buffer_object *bo)
 map_err:
 	/* unbind the physical pages with related virtual address space */
 	virt = bo->start;
-	for ( ; i > 0; i--) {
+	for (; i > 0; i--) {
 		isp_mmu_unmap(&bdev->mmu, virt, 1);
 		virt += pgnr_to_size(1);
 	}
 
 	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev,
-		"setup MMU address mapping failed.\n");
+	dev_err(atomisp_dev, "setup MMU address mapping failed.\n");
 	return ret;
 
 status_err2:
@@ -826,8 +824,7 @@ int hmm_bo_bind(struct hmm_buffer_object *bo)
 	return -EINVAL;
 status_err1:
 	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev,
-		"buffer object vm_node or page not allocated.\n");
+	dev_err(atomisp_dev, "buffer object vm_node or page not allocated.\n");
 	return -EINVAL;
 }
 
@@ -844,10 +841,9 @@ void hmm_bo_unbind(struct hmm_buffer_object *bo)
 
 	mutex_lock(&bo->mutex);
 
-	check_bo_status_yes_goto(bo,
-				 HMM_BO_PAGE_ALLOCED |
-				 HMM_BO_ALLOCED |
-				 HMM_BO_BINDED, status_err);
+	check_bo_status_yes_goto(
+		bo, HMM_BO_PAGE_ALLOCED | HMM_BO_ALLOCED | HMM_BO_BINDED,
+		status_err);
 
 	bdev = bo->bdev;
 
@@ -977,7 +973,7 @@ void hmm_bo_unref(struct hmm_buffer_object *bo)
 static void hmm_bo_vm_open(struct vm_area_struct *vma)
 {
 	struct hmm_buffer_object *bo =
-	    (struct hmm_buffer_object *)vma->vm_private_data;
+		(struct hmm_buffer_object *)vma->vm_private_data;
 
 	check_bo_null_return_void(bo);
 
@@ -995,7 +991,7 @@ static void hmm_bo_vm_open(struct vm_area_struct *vma)
 static void hmm_bo_vm_close(struct vm_area_struct *vma)
 {
 	struct hmm_buffer_object *bo =
-	    (struct hmm_buffer_object *)vma->vm_private_data;
+		(struct hmm_buffer_object *)vma->vm_private_data;
 
 	check_bo_null_return_void(bo);
 
@@ -1041,8 +1037,9 @@ int hmm_bo_mmap(struct vm_area_struct *vma, struct hmm_buffer_object *bo)
 	 * must be the same.
 	 */
 	if ((start + pgnr_to_size(pgnr)) != end) {
-		dev_warn(atomisp_dev,
-			 "vma's address space size not equal to buffer object's size");
+		dev_warn(
+			atomisp_dev,
+			"vma's address space size not equal to buffer object's size");
 		return -EINVAL;
 	}
 
@@ -1050,9 +1047,10 @@ int hmm_bo_mmap(struct vm_area_struct *vma, struct hmm_buffer_object *bo)
 	for (i = 0; i < pgnr; i++) {
 		pfn = page_to_pfn(bo->pages[i]);
 		if (remap_pfn_range(vma, virt, pfn, PAGE_SIZE, PAGE_SHARED)) {
-			dev_warn(atomisp_dev,
-				 "remap_pfn_range failed: virt = 0x%x, pfn = 0x%x, mapped_pgnr = %d\n",
-				 virt, pfn, 1);
+			dev_warn(
+				atomisp_dev,
+				"remap_pfn_range failed: virt = 0x%x, pfn = 0x%x, mapped_pgnr = %d\n",
+				virt, pfn, 1);
 			return -EINVAL;
 		}
 		virt += PAGE_SIZE;
diff --git a/drivers/staging/media/atomisp/pci/ia_css_3a.h b/drivers/staging/media/atomisp/pci/ia_css_3a.h
index 1a10f91a77d447ce578ec1ae5115daaf3a406da7..f89a9852b5bb6467586d12bd6d3a8c2a6027fd2f 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_3a.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_3a.h
@@ -43,37 +43,30 @@ struct ia_css_isp_3a_statistics {
 	struct {
 		ia_css_ptr rgby_tbl;
 	} data_hmem;
-	u32 exp_id;     /** exposure id, to match statistics to a frame,
+	u32 exp_id; /** exposure id, to match statistics to a frame,
 				  see ia_css_event_public.h for more detail. */
-	u32 isp_config_id;/** Unique ID to track which config was actually applied to a particular frame */
+	u32 isp_config_id; /** Unique ID to track which config was actually applied to a particular frame */
 	ia_css_ptr data_ptr; /** pointer to base of all data */
-	u32   size;     /** total size of all data */
-	u32   dmem_size;
-	u32   vmem_size; /** both lo and hi have this size */
-	u32   hmem_size;
+	u32 size; /** total size of all data */
+	u32 dmem_size;
+	u32 vmem_size; /** both lo and hi have this size */
+	u32 hmem_size;
 };
 
-#define SIZE_OF_DMEM_STRUCT						\
-	(SIZE_OF_IA_CSS_PTR)
+#define SIZE_OF_DMEM_STRUCT (SIZE_OF_IA_CSS_PTR)
 
-#define SIZE_OF_VMEM_STRUCT						\
-	(2 * SIZE_OF_IA_CSS_PTR)
+#define SIZE_OF_VMEM_STRUCT (2 * SIZE_OF_IA_CSS_PTR)
 
-#define SIZE_OF_DATA_UNION						\
-	(MAX(SIZE_OF_DMEM_STRUCT, SIZE_OF_VMEM_STRUCT))
+#define SIZE_OF_DATA_UNION (MAX(SIZE_OF_DMEM_STRUCT, SIZE_OF_VMEM_STRUCT))
 
-#define SIZE_OF_DATA_HMEM_STRUCT					\
-	(SIZE_OF_IA_CSS_PTR)
+#define SIZE_OF_DATA_HMEM_STRUCT (SIZE_OF_IA_CSS_PTR)
 
-#define SIZE_OF_IA_CSS_ISP_3A_STATISTICS_STRUCT				\
-	(SIZE_OF_DATA_UNION +						\
-	 SIZE_OF_DATA_HMEM_STRUCT +					\
-	 sizeof(uint32_t) +						\
-	 sizeof(uint32_t) +						\
-	 SIZE_OF_IA_CSS_PTR +						\
-	 4 * sizeof(uint32_t))
+#define SIZE_OF_IA_CSS_ISP_3A_STATISTICS_STRUCT                             \
+	(SIZE_OF_DATA_UNION + SIZE_OF_DATA_HMEM_STRUCT + sizeof(uint32_t) + \
+	 sizeof(uint32_t) + SIZE_OF_IA_CSS_PTR + 4 * sizeof(uint32_t))
 
-static_assert(sizeof(struct ia_css_isp_3a_statistics) == SIZE_OF_IA_CSS_ISP_3A_STATISTICS_STRUCT);
+static_assert(sizeof(struct ia_css_isp_3a_statistics) ==
+	      SIZE_OF_IA_CSS_ISP_3A_STATISTICS_STRUCT);
 
 /* Map with host-side pointers to ISP-format statistics.
  * These pointers can either be copies of ISP data or memory mapped
@@ -83,13 +76,13 @@ static_assert(sizeof(struct ia_css_isp_3a_statistics) == SIZE_OF_IA_CSS_ISP_3A_S
  * point into this one block of data.
  */
 struct ia_css_isp_3a_statistics_map {
-	void                    *data_ptr; /** Pointer to start of memory */
+	void *data_ptr; /** Pointer to start of memory */
 	struct ia_css_3a_output *dmem_stats;
-	u16                *vmem_stats_hi;
-	u16                *vmem_stats_lo;
-	struct ia_css_bh_table  *hmem_stats;
-	u32                 size; /** total size in bytes of data_ptr */
-	u32                 data_allocated; /** indicate whether data_ptr
+	u16 *vmem_stats_hi;
+	u16 *vmem_stats_lo;
+	struct ia_css_bh_table *hmem_stats;
+	u32 size; /** total size in bytes of data_ptr */
+	u32 data_allocated; /** indicate whether data_ptr
 						    was allocated or not. */
 };
 
@@ -103,9 +96,8 @@ struct ia_css_isp_3a_statistics_map {
  * used.
  * Always use this function, never copy the buffer directly.
  */
-int
-ia_css_get_3a_statistics(struct ia_css_3a_statistics           *host_stats,
-			 const struct ia_css_isp_3a_statistics *isp_stats);
+int ia_css_get_3a_statistics(struct ia_css_3a_statistics *host_stats,
+			     const struct ia_css_isp_3a_statistics *isp_stats);
 
 /* @brief Translate 3A statistics from ISP format to host format.
  * @param[out]	host_stats host-format statistics
@@ -116,10 +108,9 @@ ia_css_get_3a_statistics(struct ia_css_3a_statistics           *host_stats,
  * the host-format. This function does not include an additional copy
  * step.
  * */
-void
-ia_css_translate_3a_statistics(
-    struct ia_css_3a_statistics               *host_stats,
-    const struct ia_css_isp_3a_statistics_map *isp_stats);
+void ia_css_translate_3a_statistics(
+	struct ia_css_3a_statistics *host_stats,
+	const struct ia_css_isp_3a_statistics_map *isp_stats);
 
 /* Convenience functions for alloc/free of certain datatypes */
 
@@ -134,8 +125,7 @@ ia_css_isp_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid);
  * @param[in]	me Pointer to the 3a statistics buffer on the ISP.
  * @return		None
 */
-void
-ia_css_isp_3a_statistics_free(struct ia_css_isp_3a_statistics *me);
+void ia_css_isp_3a_statistics_free(struct ia_css_isp_3a_statistics *me);
 
 /* @brief Allocate memory for the 3a statistics on the host
  * @param[in]	grid The grid.
@@ -148,8 +138,7 @@ ia_css_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid);
  * @param[in]	me Pointer to the 3a statistics buffer on the host.
  * @return		None
  */
-void
-ia_css_3a_statistics_free(struct ia_css_3a_statistics *me);
+void ia_css_3a_statistics_free(struct ia_css_3a_statistics *me);
 
 /* @brief Allocate a 3a statistics map structure
  * @param[in]	isp_stats pointer to ISP 3a statistis struct
@@ -167,10 +156,8 @@ ia_css_3a_statistics_free(struct ia_css_3a_statistics *me);
  * Note that this function does not allocate or map any ISP
  * memory.
 */
-struct ia_css_isp_3a_statistics_map *
-ia_css_isp_3a_statistics_map_allocate(
-    const struct ia_css_isp_3a_statistics *isp_stats,
-    void *data_ptr);
+struct ia_css_isp_3a_statistics_map *ia_css_isp_3a_statistics_map_allocate(
+	const struct ia_css_isp_3a_statistics *isp_stats, void *data_ptr);
 
 /* @brief Free the 3a statistics map
  * @param[in]	me Pointer to the 3a statistics map
@@ -180,7 +167,6 @@ ia_css_isp_3a_statistics_map_allocate(
  * was allocated inside ia_css_isp_3a_statistics_map_allocate(), it
  * will be freed in this function. Otherwise it will not be freed.
  */
-void
-ia_css_isp_3a_statistics_map_free(struct ia_css_isp_3a_statistics_map *me);
+void ia_css_isp_3a_statistics_map_free(struct ia_css_isp_3a_statistics_map *me);
 
 #endif /* __IA_CSS_3A_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_acc_types.h b/drivers/staging/media/atomisp/pci/ia_css_acc_types.h
index e13ca0d8484777b1c700b223e625147e83bad550..353e1c6e70caf16d3975ae0daac206cdb10cd116 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_acc_types.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_acc_types.h
@@ -11,7 +11,7 @@
  * This file contains types used for acceleration
  */
 
-#include <system_local.h>	/* HAS_IRQ_MAP_VERSION_# */
+#include <system_local.h> /* HAS_IRQ_MAP_VERSION_# */
 #include <type_support.h>
 #include <platform_support.h>
 #include <debug_global.h>
@@ -36,10 +36,10 @@
 /* Type of acceleration.
  */
 enum ia_css_acc_type {
-	IA_CSS_ACC_NONE,	/** Normal binary */
-	IA_CSS_ACC_OUTPUT,	/** Accelerator stage on output frame */
-	IA_CSS_ACC_VIEWFINDER,	/** Accelerator stage on viewfinder frame */
-	IA_CSS_ACC_STANDALONE,	/** Stand-alone acceleration */
+	IA_CSS_ACC_NONE, /** Normal binary */
+	IA_CSS_ACC_OUTPUT, /** Accelerator stage on output frame */
+	IA_CSS_ACC_VIEWFINDER, /** Accelerator stage on viewfinder frame */
+	IA_CSS_ACC_STANDALONE, /** Stand-alone acceleration */
 };
 
 /* Cells types
@@ -54,10 +54,10 @@ enum ia_css_cell_type {
 /* Firmware types.
  */
 enum ia_css_fw_type {
-	ia_css_sp_firmware,		/** Firmware for the SP */
-	ia_css_isp_firmware,		/** Firmware for the ISP */
-	ia_css_bootloader_firmware,	/** Firmware for the BootLoader */
-	ia_css_acc_firmware		/** Firmware for accelrations */
+	ia_css_sp_firmware, /** Firmware for the SP */
+	ia_css_isp_firmware, /** Firmware for the ISP */
+	ia_css_bootloader_firmware, /** Firmware for the BootLoader */
+	ia_css_acc_firmware /** Firmware for accelrations */
 };
 
 struct ia_css_blob_descr;
@@ -70,123 +70,125 @@ struct ia_css_blob_descr;
  */
 struct ia_css_blob_info {
 	/** Static blob data */
-	u32 offset;		/** Blob offset in fw file */
+	u32 offset; /** Blob offset in fw file */
 	struct ia_css_isp_param_memory_offsets
-		memory_offsets;  /** offset wrt hdr in bytes */
-	u32 prog_name_offset;  /** offset wrt hdr in bytes */
-	u32 size;			/** Size of blob */
-	u32 padding_size;	/** total accumulation of bytes added due to section alignment */
-	u32 icache_source;	/** Position of icache in blob */
-	u32 icache_size;	/** Size of icache section */
-	u32 icache_padding;/** bytes added due to icache section alignment */
-	u32 text_source;	/** Position of text in blob */
-	u32 text_size;		/** Size of text section */
-	u32 text_padding;	/** bytes added due to text section alignment */
-	u32 data_source;	/** Position of data in blob */
-	u32 data_target;	/** Start of data in SP dmem */
-	u32 data_size;		/** Size of text section */
-	u32 data_padding;	/** bytes added due to data section alignment */
-	u32 bss_target;	/** Start position of bss in SP dmem */
-	u32 bss_size;		/** Size of bss section */
+		memory_offsets; /** offset wrt hdr in bytes */
+	u32 prog_name_offset; /** offset wrt hdr in bytes */
+	u32 size; /** Size of blob */
+	u32 padding_size; /** total accumulation of bytes added due to section alignment */
+	u32 icache_source; /** Position of icache in blob */
+	u32 icache_size; /** Size of icache section */
+	u32 icache_padding; /** bytes added due to icache section alignment */
+	u32 text_source; /** Position of text in blob */
+	u32 text_size; /** Size of text section */
+	u32 text_padding; /** bytes added due to text section alignment */
+	u32 data_source; /** Position of data in blob */
+	u32 data_target; /** Start of data in SP dmem */
+	u32 data_size; /** Size of text section */
+	u32 data_padding; /** bytes added due to data section alignment */
+	u32 bss_target; /** Start position of bss in SP dmem */
+	u32 bss_size; /** Size of bss section */
 	/** Dynamic data filled by loader */
-	CSS_ALIGN(const void  *code,
-		  8);		/** Code section absolute pointer within fw, code = icache + text */
-	CSS_ALIGN(const void  *data,
-		  8);		/** Data section absolute pointer within fw, data = data + bss */
+	CSS_ALIGN(
+		const void *code,
+		8); /** Code section absolute pointer within fw, code = icache + text */
+	CSS_ALIGN(
+		const void *data,
+		8); /** Data section absolute pointer within fw, data = data + bss */
 };
 
 struct ia_css_binary_input_info {
-	u32		min_width;
-	u32		min_height;
-	u32		max_width;
-	u32		max_height;
-	u32		source; /* memory, sensor, variable */
+	u32 min_width;
+	u32 min_height;
+	u32 max_width;
+	u32 max_height;
+	u32 source; /* memory, sensor, variable */
 };
 
 struct ia_css_binary_output_info {
-	u32		min_width;
-	u32		min_height;
-	u32		max_width;
-	u32		max_height;
-	u32		num_chunks;
-	u32		variable_format;
+	u32 min_width;
+	u32 min_height;
+	u32 max_width;
+	u32 max_height;
+	u32 num_chunks;
+	u32 variable_format;
 };
 
 struct ia_css_binary_internal_info {
-	u32		max_width;
-	u32		max_height;
+	u32 max_width;
+	u32 max_height;
 };
 
 struct ia_css_binary_bds_info {
-	u32		supported_bds_factors;
+	u32 supported_bds_factors;
 };
 
 struct ia_css_binary_dvs_info {
-	u32		max_envelope_width;
-	u32		max_envelope_height;
+	u32 max_envelope_width;
+	u32 max_envelope_height;
 };
 
 struct ia_css_binary_vf_dec_info {
-	u32		is_variable;
-	u32		max_log_downscale;
+	u32 is_variable;
+	u32 max_log_downscale;
 };
 
 struct ia_css_binary_s3a_info {
-	u32		s3atbl_use_dmem;
-	u32		fixed_s3a_deci_log;
+	u32 s3atbl_use_dmem;
+	u32 fixed_s3a_deci_log;
 };
 
 /* DPC related binary info */
 struct ia_css_binary_dpc_info {
-	u32		bnr_lite; /** bnr lite enable flag */
+	u32 bnr_lite; /** bnr lite enable flag */
 };
 
 struct ia_css_binary_iterator_info {
-	u32		num_stripes;
-	u32		row_stripes_height;
-	u32		row_stripes_overlap_lines;
+	u32 num_stripes;
+	u32 row_stripes_height;
+	u32 row_stripes_overlap_lines;
 };
 
 struct ia_css_binary_address_info {
-	u32		isp_addresses;	/* Address in ISP dmem */
-	u32		main_entry;	/* Address of entry fct */
-	u32		in_frame;	/* Address in ISP dmem */
-	u32		out_frame;	/* Address in ISP dmem */
-	u32		in_data;	/* Address in ISP dmem */
-	u32		out_data;	/* Address in ISP dmem */
-	u32		sh_dma_cmd_ptr;     /* In ISP dmem */
+	u32 isp_addresses; /* Address in ISP dmem */
+	u32 main_entry; /* Address of entry fct */
+	u32 in_frame; /* Address in ISP dmem */
+	u32 out_frame; /* Address in ISP dmem */
+	u32 in_data; /* Address in ISP dmem */
+	u32 out_data; /* Address in ISP dmem */
+	u32 sh_dma_cmd_ptr; /* In ISP dmem */
 };
 
 struct ia_css_binary_uds_info {
-	u16	bpp;
-	u16	use_bci;
-	u16	use_str;
-	u16	woix;
-	u16	woiy;
-	u16	extra_out_vecs;
-	u16	vectors_per_line_in;
-	u16	vectors_per_line_out;
-	u16	vectors_c_per_line_in;
-	u16	vectors_c_per_line_out;
-	u16	vmem_gdc_in_block_height_y;
-	u16	vmem_gdc_in_block_height_c;
+	u16 bpp;
+	u16 use_bci;
+	u16 use_str;
+	u16 woix;
+	u16 woiy;
+	u16 extra_out_vecs;
+	u16 vectors_per_line_in;
+	u16 vectors_per_line_out;
+	u16 vectors_c_per_line_in;
+	u16 vectors_c_per_line_out;
+	u16 vmem_gdc_in_block_height_y;
+	u16 vmem_gdc_in_block_height_c;
 	/* uint16_t padding; */
 };
 
 struct ia_css_binary_pipeline_info {
-	u32	mode;
-	u32	isp_pipe_version;
-	u32	pipelining;
-	u32	c_subsampling;
-	u32	top_cropping;
-	u32	left_cropping;
-	u32	variable_resolution;
+	u32 mode;
+	u32 isp_pipe_version;
+	u32 pipelining;
+	u32 c_subsampling;
+	u32 top_cropping;
+	u32 left_cropping;
+	u32 variable_resolution;
 };
 
 struct ia_css_binary_block_info {
-	u32	block_width;
-	u32	block_height;
-	u32	output_block_height;
+	u32 block_width;
+	u32 block_height;
+	u32 output_block_height;
 };
 
 /* Structure describing an ISP binary.
@@ -197,65 +199,65 @@ struct ia_css_binary_block_info {
  * thereby making the SP code more binary independent.
  */
 struct ia_css_binary_info {
-	CSS_ALIGN(u32			id, 8); /* IA_CSS_BINARY_ID_* */
-	struct ia_css_binary_pipeline_info	pipeline;
-	struct ia_css_binary_input_info		input;
-	struct ia_css_binary_output_info	output;
-	struct ia_css_binary_internal_info	internal;
-	struct ia_css_binary_bds_info		bds;
-	struct ia_css_binary_dvs_info		dvs;
-	struct ia_css_binary_vf_dec_info	vf_dec;
-	struct ia_css_binary_s3a_info		s3a;
-	struct ia_css_binary_dpc_info		dpc_bnr; /** DPC related binary info */
-	struct ia_css_binary_iterator_info	iterator;
-	struct ia_css_binary_address_info	addresses;
-	struct ia_css_binary_uds_info		uds;
-	struct ia_css_binary_block_info		block;
-	struct ia_css_isp_param_isp_segments	mem_initializers;
+	CSS_ALIGN(u32 id, 8); /* IA_CSS_BINARY_ID_* */
+	struct ia_css_binary_pipeline_info pipeline;
+	struct ia_css_binary_input_info input;
+	struct ia_css_binary_output_info output;
+	struct ia_css_binary_internal_info internal;
+	struct ia_css_binary_bds_info bds;
+	struct ia_css_binary_dvs_info dvs;
+	struct ia_css_binary_vf_dec_info vf_dec;
+	struct ia_css_binary_s3a_info s3a;
+	struct ia_css_binary_dpc_info dpc_bnr; /** DPC related binary info */
+	struct ia_css_binary_iterator_info iterator;
+	struct ia_css_binary_address_info addresses;
+	struct ia_css_binary_uds_info uds;
+	struct ia_css_binary_block_info block;
+	struct ia_css_isp_param_isp_segments mem_initializers;
 	/* MW: Packing (related) bools in an integer ?? */
 	struct {
-		u8	reduced_pipe;
-		u8	vf_veceven;
-		u8	dis;
-		u8	dvs_envelope;
-		u8	uds;
-		u8	dvs_6axis;
-		u8	block_output;
-		u8	streaming_dma;
-		u8	ds;
-		u8	bayer_fir_6db;
-		u8	raw_binning;
-		u8	continuous;
-		u8	s3a;
-		u8	fpnr;
-		u8	sc;
-		u8	macc;
-		u8	output;
-		u8	ref_frame;
-		u8	tnr;
-		u8	xnr;
-		u8	params;
-		u8	ca_gdc;
-		u8	isp_addresses;
-		u8	in_frame;
-		u8	out_frame;
-		u8	high_speed;
-		u8	dpc;
+		u8 reduced_pipe;
+		u8 vf_veceven;
+		u8 dis;
+		u8 dvs_envelope;
+		u8 uds;
+		u8 dvs_6axis;
+		u8 block_output;
+		u8 streaming_dma;
+		u8 ds;
+		u8 bayer_fir_6db;
+		u8 raw_binning;
+		u8 continuous;
+		u8 s3a;
+		u8 fpnr;
+		u8 sc;
+		u8 macc;
+		u8 output;
+		u8 ref_frame;
+		u8 tnr;
+		u8 xnr;
+		u8 params;
+		u8 ca_gdc;
+		u8 isp_addresses;
+		u8 in_frame;
+		u8 out_frame;
+		u8 high_speed;
+		u8 dpc;
 		u8 padding[2];
 	} enable;
 	struct {
 		/* DMA channel ID: [0,...,HIVE_ISP_NUM_DMA_CHANNELS> */
-		u8	ref_y_channel;
-		u8	ref_c_channel;
-		u8	tnr_channel;
-		u8	tnr_out_channel;
-		u8	dvs_coords_channel;
-		u8	output_channel;
-		u8	c_channel;
-		u8	vfout_channel;
-		u8	vfout_c_channel;
-		u8	vfdec_bits_per_pixel;
-		u8	claimed_by_isp;
+		u8 ref_y_channel;
+		u8 ref_c_channel;
+		u8 tnr_channel;
+		u8 tnr_out_channel;
+		u8 dvs_coords_channel;
+		u8 output_channel;
+		u8 c_channel;
+		u8 vfout_channel;
+		u8 vfout_c_channel;
+		u8 vfdec_bits_per_pixel;
+		u8 claimed_by_isp;
 		u8 padding[2];
 	} dma;
 };
@@ -266,19 +268,19 @@ struct ia_css_binary_info {
  */
 struct ia_css_binary_xinfo {
 	/* Part that is of interest to the SP. */
-	struct ia_css_binary_info    sp;
+	struct ia_css_binary_info sp;
 
 	/* Rest of the binary info, only interesting to the host. */
-	enum ia_css_acc_type	     type;
+	enum ia_css_acc_type type;
 
-	CSS_ALIGN(s32	     num_output_formats, 8);
-	enum ia_css_frame_format     output_formats[IA_CSS_FRAME_FORMAT_NUM];
+	CSS_ALIGN(s32 num_output_formats, 8);
+	enum ia_css_frame_format output_formats[IA_CSS_FRAME_FORMAT_NUM];
 
-	CSS_ALIGN(s32	     num_vf_formats, 8); /** number of supported vf formats */
-	enum ia_css_frame_format
-	vf_formats[IA_CSS_FRAME_FORMAT_NUM]; /** types of supported vf formats */
-	u8			     num_output_pins;
-	ia_css_ptr		     xmem_addr;
+	CSS_ALIGN(s32 num_vf_formats, 8); /** number of supported vf formats */
+	enum ia_css_frame_format vf_formats
+		[IA_CSS_FRAME_FORMAT_NUM]; /** types of supported vf formats */
+	u8 num_output_pins;
+	ia_css_ptr xmem_addr;
 
 	CSS_ALIGN(const struct ia_css_blob_descr *blob, 8);
 	CSS_ALIGN(u32 blob_index, 8);
@@ -291,11 +293,11 @@ struct ia_css_binary_xinfo {
  * the entry function in icache.
  */
 struct ia_css_bl_info {
-	u32 num_dma_cmds;	/** Number of cmds sent by CSS */
-	u32 dma_cmd_list;	/** Dma command list sent by CSS */
-	u32 sw_state;	/** Polled from css */
+	u32 num_dma_cmds; /** Number of cmds sent by CSS */
+	u32 dma_cmd_list; /** Dma command list sent by CSS */
+	u32 sw_state; /** Polled from css */
 	/* Entry functions */
-	u32 bl_entry;	/** The SP entry function */
+	u32 bl_entry; /** The SP entry function */
 };
 
 /* Structure describing the SP binary.
@@ -305,33 +307,33 @@ struct ia_css_bl_info {
 struct ia_css_sp_info {
 	u32 init_dmem_data; /** data sect config, stored to dmem */
 	u32 per_frame_data; /** Per frame data, stored to dmem */
-	u32 group;		/** Per pipeline data, loaded by dma */
-	u32 output;		/** SP output data, loaded by dmem */
-	u32 host_sp_queue;	/** Host <-> SP queues */
-	u32 host_sp_com;/** Host <-> SP commands */
-	u32 isp_started;	/** Polled from sensor thread, csim only */
-	u32 sw_state;	/** Polled from css */
+	u32 group; /** Per pipeline data, loaded by dma */
+	u32 output; /** SP output data, loaded by dmem */
+	u32 host_sp_queue; /** Host <-> SP queues */
+	u32 host_sp_com; /** Host <-> SP commands */
+	u32 isp_started; /** Polled from sensor thread, csim only */
+	u32 sw_state; /** Polled from css */
 	u32 host_sp_queues_initialized; /** Polled from the SP */
-	u32 sleep_mode;  /** different mode to halt SP */
-	u32 invalidate_tlb;		/** inform SP to invalidate mmu TLB */
+	u32 sleep_mode; /** different mode to halt SP */
+	u32 invalidate_tlb; /** inform SP to invalidate mmu TLB */
 
 	/* ISP2400 */
-	u32 stop_copy_preview;       /** suspend copy and preview pipe when capture */
+	u32 stop_copy_preview; /** suspend copy and preview pipe when capture */
 
-	u32 debug_buffer_ddr_address;	/** inform SP the address
+	u32 debug_buffer_ddr_address; /** inform SP the address
 	of DDR debug queue */
 	u32 perf_counter_input_system_error; /** input system perf
 	counter array */
 
 	u32 threads_stack; /** sp thread's stack pointers */
 	u32 threads_stack_size; /** sp thread's stack sizes */
-	u32 curr_binary_id;        /** current binary id */
-	u32 raw_copy_line_count;   /** raw copy line counter */
+	u32 curr_binary_id; /** current binary id */
+	u32 raw_copy_line_count; /** raw copy line counter */
 	u32 ddr_parameter_address; /** acc param ddrptr, sp dmem */
-	u32 ddr_parameter_size;    /** acc param size, sp dmem */
+	u32 ddr_parameter_size; /** acc param size, sp dmem */
 	/* Entry functions */
-	u32 sp_entry;	/** The SP entry function */
-	u32 tagger_frames_addr;   /** Base address of tagger state */
+	u32 sp_entry; /** The SP entry function */
+	u32 tagger_frames_addr; /** Base address of tagger state */
 };
 
 /* The following #if is there because this header file is also included
@@ -349,36 +351,36 @@ struct ia_css_acc_info {
 /* Firmware information.
  */
 union ia_css_fw_union {
-	struct ia_css_binary_xinfo	isp; /** ISP info */
-	struct ia_css_sp_info		sp;  /** SP info */
-	struct ia_css_bl_info           bl;  /** Bootloader info */
-	struct ia_css_acc_info		acc; /** Accelerator info */
+	struct ia_css_binary_xinfo isp; /** ISP info */
+	struct ia_css_sp_info sp; /** SP info */
+	struct ia_css_bl_info bl; /** Bootloader info */
+	struct ia_css_acc_info acc; /** Accelerator info */
 };
 
 /* Firmware information.
  */
 struct ia_css_fw_info {
-	size_t			 header_size; /** size of fw header */
+	size_t header_size; /** size of fw header */
 
 	CSS_ALIGN(u32 type, 8);
-	union ia_css_fw_union	 info; /** Binary info */
-	struct ia_css_blob_info  blob; /** Blob info */
+	union ia_css_fw_union info; /** Binary info */
+	struct ia_css_blob_info blob; /** Blob info */
 	/* Dynamic part */
-	struct ia_css_fw_info   *next;
+	struct ia_css_fw_info *next;
 
-	CSS_ALIGN(u32       loaded, 8);	/** Firmware has been loaded */
-	CSS_ALIGN(const u8 *isp_code, 8);  /** ISP pointer to code */
+	CSS_ALIGN(u32 loaded, 8); /** Firmware has been loaded */
+	CSS_ALIGN(const u8 *isp_code, 8); /** ISP pointer to code */
 	/** Firmware handle between user space and kernel */
-	CSS_ALIGN(u32	handle, 8);
+	CSS_ALIGN(u32 handle, 8);
 	/** Sections to copy from/to ISP */
 	struct ia_css_isp_param_css_segments mem_initializers;
 	/** Initializer for local ISP memories */
 };
 
 struct ia_css_blob_descr {
-	const unsigned char  *blob;
+	const unsigned char *blob;
 	struct ia_css_fw_info header;
-	const char	     *name;
+	const char *name;
 	union ia_css_all_memory_offsets mem_offsets;
 };
 
@@ -387,15 +389,15 @@ struct ia_css_acc_fw;
 /* Structure describing the SP binary of a stand-alone accelerator.
  */
 struct ia_css_acc_sp {
-	void (*init)(struct ia_css_acc_fw *);	/** init for crun */
-	u32 sp_prog_name_offset;		/** program name offset wrt hdr in bytes */
-	u32 sp_blob_offset;		/** blob offset wrt hdr in bytes */
-	void	 *entry;			/** Address of sp entry point */
-	u32 *css_abort;			/** SP dmem abort flag */
-	void	 *isp_code;			/** SP dmem address holding xmem
+	void (*init)(struct ia_css_acc_fw *); /** init for crun */
+	u32 sp_prog_name_offset; /** program name offset wrt hdr in bytes */
+	u32 sp_blob_offset; /** blob offset wrt hdr in bytes */
+	void *entry; /** Address of sp entry point */
+	u32 *css_abort; /** SP dmem abort flag */
+	void *isp_code; /** SP dmem address holding xmem
 						     address of isp code */
-	struct ia_css_fw_info fw;		/** SP fw descriptor */
-	const u8 *code;			/** ISP pointer of allocated SP code */
+	struct ia_css_fw_info fw; /** SP fw descriptor */
+	const u8 *code; /** ISP pointer of allocated SP code */
 };
 
 /* Acceleration firmware descriptor.
@@ -403,16 +405,16 @@ struct ia_css_acc_sp {
   * ISP code (a separate pipeline stage).
   */
 struct ia_css_acc_fw_hdr {
-	enum ia_css_acc_type type;	/** Type of accelerator */
-	u32	isp_prog_name_offset; /** program name offset wrt
+	enum ia_css_acc_type type; /** Type of accelerator */
+	u32 isp_prog_name_offset; /** program name offset wrt
 						   header in bytes */
-	u32	isp_blob_offset;      /** blob offset wrt header
+	u32 isp_blob_offset; /** blob offset wrt header
 						   in bytes */
-	u32	isp_size;	      /** Size of isp blob */
-	const u8  *isp_code;	      /** ISP pointer to code */
-	struct ia_css_acc_sp  sp;  /** Standalone sp code */
+	u32 isp_size; /** Size of isp blob */
+	const u8 *isp_code; /** ISP pointer to code */
+	struct ia_css_acc_sp sp; /** Standalone sp code */
 	/** Firmware handle between user space and kernel */
-	u32	handle;
+	u32 handle;
 	struct ia_css_data parameters; /** Current SP parameters */
 };
 
@@ -435,26 +437,26 @@ struct ia_css_acc_fw {
 
 /* Access macros for firmware */
 #define IA_CSS_ACC_OFFSET(t, f, n) ((t)((uint8_t *)(f) + (f->header.n)))
-#define IA_CSS_ACC_SP_PROG_NAME(f) IA_CSS_ACC_OFFSET(const char *, f, \
-						 sp.sp_prog_name_offset)
-#define IA_CSS_ACC_ISP_PROG_NAME(f) IA_CSS_ACC_OFFSET(const char *, f, \
-						 isp_prog_name_offset)
-#define IA_CSS_ACC_SP_CODE(f)      IA_CSS_ACC_OFFSET(uint8_t *, f, \
-						 sp.sp_blob_offset)
-#define IA_CSS_ACC_SP_DATA(f)      (IA_CSS_ACC_SP_CODE(f) + \
-					(f)->header.sp.fw.blob.data_source)
-#define IA_CSS_ACC_ISP_CODE(f)     IA_CSS_ACC_OFFSET(uint8_t*, f,\
-						 isp_blob_offset)
-#define IA_CSS_ACC_ISP_SIZE(f)     ((f)->header.isp_size)
+#define IA_CSS_ACC_SP_PROG_NAME(f) \
+	IA_CSS_ACC_OFFSET(const char *, f, sp.sp_prog_name_offset)
+#define IA_CSS_ACC_ISP_PROG_NAME(f) \
+	IA_CSS_ACC_OFFSET(const char *, f, isp_prog_name_offset)
+#define IA_CSS_ACC_SP_CODE(f) IA_CSS_ACC_OFFSET(uint8_t *, f, sp.sp_blob_offset)
+#define IA_CSS_ACC_SP_DATA(f) \
+	(IA_CSS_ACC_SP_CODE(f) + (f)->header.sp.fw.blob.data_source)
+#define IA_CSS_ACC_ISP_CODE(f) IA_CSS_ACC_OFFSET(uint8_t *, f, isp_blob_offset)
+#define IA_CSS_ACC_ISP_SIZE(f) ((f)->header.isp_size)
 
 /* Binary name follows header immediately */
-#define IA_CSS_EXT_ISP_PROG_NAME(f)   ((const char *)(f) + (f)->blob.prog_name_offset)
-#define IA_CSS_EXT_ISP_MEM_OFFSETS(f) \
-	((const struct ia_css_memory_offsets *)((const char *)(f) + (f)->blob.mem_offsets))
+#define IA_CSS_EXT_ISP_PROG_NAME(f) \
+	((const char *)(f) + (f)->blob.prog_name_offset)
+#define IA_CSS_EXT_ISP_MEM_OFFSETS(f)                               \
+	((const struct ia_css_memory_offsets *)((const char *)(f) + \
+						(f)->blob.mem_offsets))
 
 enum ia_css_sp_sleep_mode {
 	SP_DISABLE_SLEEP_MODE = 0,
-	SP_SLEEP_AFTER_FRAME  = BIT(0),
-	SP_SLEEP_AFTER_IRQ    = BIT(1),
+	SP_SLEEP_AFTER_FRAME = BIT(0),
+	SP_SLEEP_AFTER_IRQ = BIT(1),
 };
 #endif /* _IA_CSS_ACC_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_buffer.h b/drivers/staging/media/atomisp/pci/ia_css_buffer.h
index 7c00dd1d33fd07811cafd25d5fd5ae5e40773a65..064ee07036ff5380d4b991428ec3d44f67fc8f75 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_buffer.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_buffer.h
@@ -49,13 +49,15 @@ struct ia_css_buffer {
 	/** exposure id for this buffer; 0 = not available
 	     see ia_css_event_public.h for more detail. */
 	union {
-		struct ia_css_isp_3a_statistics
-			*stats_3a;    /** 3A statistics & optionally RGBY statistics. */
-		struct ia_css_isp_dvs_statistics *stats_dvs;   /** DVS statistics. */
-		struct ia_css_isp_skc_dvs_statistics *stats_skc_dvs;  /** SKC DVS statistics. */
-		struct ia_css_frame              *frame;       /** Frame buffer. */
-		struct ia_css_acc_param          *custom_data; /** Custom buffer. */
-		struct ia_css_metadata           *metadata;    /** Sensor metadata. */
+		struct ia_css_isp_3a_statistics *
+			stats_3a; /** 3A statistics & optionally RGBY statistics. */
+		struct ia_css_isp_dvs_statistics
+			*stats_dvs; /** DVS statistics. */
+		struct ia_css_isp_skc_dvs_statistics
+			*stats_skc_dvs; /** SKC DVS statistics. */
+		struct ia_css_frame *frame; /** Frame buffer. */
+		struct ia_css_acc_param *custom_data; /** Custom buffer. */
+		struct ia_css_metadata *metadata; /** Sensor metadata. */
 	} data; /** Buffer data pointer. */
 	u64 driver_cookie; /** cookie for the driver */
 	struct ia_css_time_meas
@@ -71,7 +73,6 @@ struct ia_css_buffer {
  * This function must be called at every driver interrupt handler to prevent
  * overflow of sp2host_queue.
  */
-void
-ia_css_dequeue_param_buffers(void);
+void ia_css_dequeue_param_buffers(void);
 
 #endif /* __IA_CSS_BUFFER_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_control.h b/drivers/staging/media/atomisp/pci/ia_css_control.h
index d374ceaf7574fecd89479c7597fa50d6746cea06..8ef367255f62c7617ff2c43a7e95143b50e2cdaa 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_control.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_control.h
@@ -33,10 +33,8 @@
  * ia_css_load_firmware() must be called to load the firmware before calling
  * this function.
  */
-int ia_css_init(struct device           *dev,
-		const struct ia_css_env *env,
-		u32                     l1_base,
-		enum ia_css_irq_type    irq_type);
+int ia_css_init(struct device *dev, const struct ia_css_env *env, u32 l1_base,
+		enum ia_css_irq_type irq_type);
 
 /* @brief Un-initialize the CSS API.
  * @return	None
@@ -44,8 +42,7 @@ int ia_css_init(struct device           *dev,
  * This function deallocates all memory that has been allocated by the CSS API.
  * After this function is called, no other CSS functions should be called.
  */
-void
-ia_css_uninit(void);
+void ia_css_uninit(void);
 
 /* @brief Enable use of a separate queue for ISYS events.
  *
@@ -58,8 +55,7 @@ ia_css_uninit(void);
  * This function should only be called when the SP is not running, calling it
  * when the SP is running will result in an error value being returned. }
  */
-int
-ia_css_enable_isys_event_queue(bool enable);
+int ia_css_enable_isys_event_queue(bool enable);
 
 /* @brief Test whether the ISP has started.
  *
@@ -67,8 +63,7 @@ ia_css_enable_isys_event_queue(bool enable);
  *
  * Temporary function to poll whether the ISP has been started. Once it has,
  * the sensor can also be started. */
-bool
-ia_css_isp_has_started(void);
+bool ia_css_isp_has_started(void);
 
 /* @brief Test whether the SP has initialized.
  *
@@ -76,8 +71,7 @@ ia_css_isp_has_started(void);
  *
  * Temporary function to poll whether the SP has been initialized. Once it has,
  * we can enqueue buffers. */
-bool
-ia_css_sp_has_initialized(void);
+bool ia_css_sp_has_initialized(void);
 
 /* @brief Test whether the SP has terminated.
  *
@@ -85,8 +79,7 @@ ia_css_sp_has_initialized(void);
  *
  * Temporary function to poll whether the SP has been terminated. Once it has,
  * we can switch mode. */
-bool
-ia_css_sp_has_terminated(void);
+bool ia_css_sp_has_terminated(void);
 
 /* @brief start SP hardware
  *
@@ -96,8 +89,7 @@ ia_css_sp_has_terminated(void);
  * All threads will be started and blocked by semaphore. This function should
  * be called before any ia_css_stream_start().
  */
-int
-ia_css_start_sp(void);
+int ia_css_start_sp(void);
 
 /* @brief stop SP hardware
  *
@@ -106,7 +98,6 @@ ia_css_start_sp(void);
  * This function will terminate all threads and shut down SP. It should be
  * called after all ia_css_stream_stop().
  */
-int
-ia_css_stop_sp(void);
+int ia_css_stop_sp(void);
 
 #endif /* __IA_CSS_CONTROL_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_device_access.c b/drivers/staging/media/atomisp/pci/ia_css_device_access.c
index 8ee7656f614b89e5f9c9c6d75f2223db222889ae..2d46a2f81351418fae99c2f3c2a3b972c1cbd0cf 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_device_access.c
+++ b/drivers/staging/media/atomisp/pci/ia_css_device_access.c
@@ -5,41 +5,36 @@
  */
 
 #include "ia_css_device_access.h"
-#include <type_support.h>   /* for uint*, size_t */
-#include <system_local.h>   /* for hrt_address */
-#include <ia_css_env.h>     /* for ia_css_hw_access_env */
+#include <type_support.h> /* for uint*, size_t */
+#include <system_local.h> /* for hrt_address */
+#include <ia_css_env.h> /* for ia_css_hw_access_env */
 #include <assert_support.h> /* for assert */
 
 static struct ia_css_hw_access_env my_env;
 
-void
-ia_css_device_access_init(const struct ia_css_hw_access_env *env)
+void ia_css_device_access_init(const struct ia_css_hw_access_env *env)
 {
 	assert(env);
 
 	my_env = *env;
 }
 
-uint8_t
-ia_css_device_load_uint8(const hrt_address addr)
+uint8_t ia_css_device_load_uint8(const hrt_address addr)
 {
 	return my_env.load_8(addr);
 }
 
-uint16_t
-ia_css_device_load_uint16(const hrt_address addr)
+uint16_t ia_css_device_load_uint16(const hrt_address addr)
 {
 	return my_env.load_16(addr);
 }
 
-uint32_t
-ia_css_device_load_uint32(const hrt_address addr)
+uint32_t ia_css_device_load_uint32(const hrt_address addr)
 {
 	return my_env.load_32(addr);
 }
 
-uint64_t
-ia_css_device_load_uint64(const hrt_address addr)
+uint64_t ia_css_device_load_uint64(const hrt_address addr)
 {
 	assert(0);
 
@@ -47,26 +42,22 @@ ia_css_device_load_uint64(const hrt_address addr)
 	return 0;
 }
 
-void
-ia_css_device_store_uint8(const hrt_address addr, const uint8_t data)
+void ia_css_device_store_uint8(const hrt_address addr, const uint8_t data)
 {
 	my_env.store_8(addr, data);
 }
 
-void
-ia_css_device_store_uint16(const hrt_address addr, const uint16_t data)
+void ia_css_device_store_uint16(const hrt_address addr, const uint16_t data)
 {
 	my_env.store_16(addr, data);
 }
 
-void
-ia_css_device_store_uint32(const hrt_address addr, const uint32_t data)
+void ia_css_device_store_uint32(const hrt_address addr, const uint32_t data)
 {
 	my_env.store_32(addr, data);
 }
 
-void
-ia_css_device_store_uint64(const hrt_address addr, const uint64_t data)
+void ia_css_device_store_uint64(const hrt_address addr, const uint64_t data)
 {
 	assert(0);
 
@@ -74,14 +65,13 @@ ia_css_device_store_uint64(const hrt_address addr, const uint64_t data)
 	(void)data;
 }
 
-void
-ia_css_device_load(const hrt_address addr, void *data, const size_t size)
+void ia_css_device_load(const hrt_address addr, void *data, const size_t size)
 {
 	my_env.load(addr, data, (uint32_t)size);
 }
 
-void
-ia_css_device_store(const hrt_address addr, const void *data, const size_t size)
+void ia_css_device_store(const hrt_address addr, const void *data,
+			 const size_t size)
 {
 	my_env.store(addr, data, (uint32_t)size);
 }
diff --git a/drivers/staging/media/atomisp/pci/ia_css_device_access.h b/drivers/staging/media/atomisp/pci/ia_css_device_access.h
index f2ea16c093b68b81010d6c19ea3569e2f584bee9..a74f274c5be6f846d21ed0666c045911b77a35fa 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_device_access.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_device_access.h
@@ -13,40 +13,29 @@
 
 #include <type_support.h> /* for uint*, size_t */
 #include <system_local.h> /* for hrt_address */
-#include <ia_css_env.h>   /* for ia_css_hw_access_env */
+#include <ia_css_env.h> /* for ia_css_hw_access_env */
 
-void
-ia_css_device_access_init(const struct ia_css_hw_access_env *env);
+void ia_css_device_access_init(const struct ia_css_hw_access_env *env);
 
-uint8_t
-ia_css_device_load_uint8(const hrt_address addr);
+uint8_t ia_css_device_load_uint8(const hrt_address addr);
 
-uint16_t
-ia_css_device_load_uint16(const hrt_address addr);
+uint16_t ia_css_device_load_uint16(const hrt_address addr);
 
-uint32_t
-ia_css_device_load_uint32(const hrt_address addr);
+uint32_t ia_css_device_load_uint32(const hrt_address addr);
 
-uint64_t
-ia_css_device_load_uint64(const hrt_address addr);
+uint64_t ia_css_device_load_uint64(const hrt_address addr);
 
-void
-ia_css_device_store_uint8(const hrt_address addr, const uint8_t data);
+void ia_css_device_store_uint8(const hrt_address addr, const uint8_t data);
 
-void
-ia_css_device_store_uint16(const hrt_address addr, const uint16_t data);
+void ia_css_device_store_uint16(const hrt_address addr, const uint16_t data);
 
-void
-ia_css_device_store_uint32(const hrt_address addr, const uint32_t data);
+void ia_css_device_store_uint32(const hrt_address addr, const uint32_t data);
 
-void
-ia_css_device_store_uint64(const hrt_address addr, const uint64_t data);
+void ia_css_device_store_uint64(const hrt_address addr, const uint64_t data);
 
-void
-ia_css_device_load(const hrt_address addr, void *data, const size_t size);
+void ia_css_device_load(const hrt_address addr, void *data, const size_t size);
 
-void
-ia_css_device_store(const hrt_address addr, const void *data,
-		    const size_t size);
+void ia_css_device_store(const hrt_address addr, const void *data,
+			 const size_t size);
 
 #endif /* _IA_CSS_DEVICE_ACCESS_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_dvs.h b/drivers/staging/media/atomisp/pci/ia_css_dvs.h
index 6930f1ec3aee30e4e1ddf4ed12b4dc905c914287..403a4fd09a9db92c47798ba70aa2de7cc4f7c175 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_dvs.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_dvs.h
@@ -31,11 +31,11 @@ enum dvs_statistics_type {
 struct ia_css_isp_dvs_statistics {
 	ia_css_ptr hor_proj;
 	ia_css_ptr ver_proj;
-	u32   hor_size;
-	u32   ver_size;
-	u32   exp_id;   /** see ia_css_event_public.h for more detail */
+	u32 hor_size;
+	u32 ver_size;
+	u32 exp_id; /** see ia_css_event_public.h for more detail */
 	ia_css_ptr data_ptr; /* base pointer containing all memory */
-	u32   size;     /* size of allocated memory in data_ptr */
+	u32 size; /* size of allocated memory in data_ptr */
 };
 
 /* Structure that holds SKC DVS statistics in the ISP internal
@@ -44,11 +44,11 @@ struct ia_css_isp_dvs_statistics {
  * */
 struct ia_css_isp_skc_dvs_statistics;
 
-#define SIZE_OF_IA_CSS_ISP_DVS_STATISTICS_STRUCT			\
-	((3 * SIZE_OF_IA_CSS_PTR) +					\
-	 (4 * sizeof(uint32_t)))
+#define SIZE_OF_IA_CSS_ISP_DVS_STATISTICS_STRUCT \
+	((3 * SIZE_OF_IA_CSS_PTR) + (4 * sizeof(uint32_t)))
 
-static_assert(sizeof(struct ia_css_isp_dvs_statistics) == SIZE_OF_IA_CSS_ISP_DVS_STATISTICS_STRUCT);
+static_assert(sizeof(struct ia_css_isp_dvs_statistics) ==
+	      SIZE_OF_IA_CSS_ISP_DVS_STATISTICS_STRUCT);
 
 /* Map with host-side pointers to ISP-format statistics.
  * These pointers can either be copies of ISP data or memory mapped
@@ -58,10 +58,10 @@ static_assert(sizeof(struct ia_css_isp_dvs_statistics) == SIZE_OF_IA_CSS_ISP_DVS
  * point into this one block of data.
  */
 struct ia_css_isp_dvs_statistics_map {
-	void    *data_ptr;
+	void *data_ptr;
 	s32 *hor_proj;
 	s32 *ver_proj;
-	u32 size;		 /* total size in bytes */
+	u32 size; /* total size in bytes */
 	u32 data_allocated; /* indicate whether data was allocated */
 };
 
@@ -90,9 +90,8 @@ union ia_css_dvs_statistics_host {
  * advised to map the ISP memory into a host-side pointer and use
  * the ia_css_translate_dvs_statistics() function instead.
  */
-int
-ia_css_get_dvs_statistics(struct ia_css_dvs_statistics *host_stats,
-			  const struct ia_css_isp_dvs_statistics *isp_stats);
+int ia_css_get_dvs_statistics(struct ia_css_dvs_statistics *host_stats,
+			      const struct ia_css_isp_dvs_statistics *isp_stats);
 
 /* @brief Translate DVS statistics from ISP format to host format
  * @param[in]	host_stats Host buffer
@@ -105,10 +104,9 @@ ia_css_get_dvs_statistics(struct ia_css_dvs_statistics *host_stats,
  * point to a copy of the data or be a memory mapped pointer to the
  * ISP memory pages.
  */
-void
-ia_css_translate_dvs_statistics(
-    struct ia_css_dvs_statistics *host_stats,
-    const struct ia_css_isp_dvs_statistics_map *isp_stats);
+void ia_css_translate_dvs_statistics(
+	struct ia_css_dvs_statistics *host_stats,
+	const struct ia_css_isp_dvs_statistics_map *isp_stats);
 
 /* @brief Copy DVS 2.0 statistics from an ISP buffer to a host buffer.
  * @param[in]	host_stats Host buffer
@@ -124,9 +122,9 @@ ia_css_translate_dvs_statistics(
  * advised to map the ISP memory into a host-side pointer and use
  * the ia_css_translate_dvs2_statistics() function instead.
  */
-int
-ia_css_get_dvs2_statistics(struct ia_css_dvs2_statistics *host_stats,
-			   const struct ia_css_isp_dvs_statistics *isp_stats);
+int ia_css_get_dvs2_statistics(
+	struct ia_css_dvs2_statistics *host_stats,
+	const struct ia_css_isp_dvs_statistics *isp_stats);
 
 /* @brief Translate DVS2 statistics from ISP format to host format
  * @param[in]	host_stats Host buffer
@@ -139,10 +137,9 @@ ia_css_get_dvs2_statistics(struct ia_css_dvs2_statistics *host_stats,
  * point to a copy of the data or be a memory mapped pointer to the
  * ISP memory pages.
  */
-void
-ia_css_translate_dvs2_statistics(
-    struct ia_css_dvs2_statistics	   *host_stats,
-    const struct ia_css_isp_dvs_statistics_map *isp_stats);
+void ia_css_translate_dvs2_statistics(
+	struct ia_css_dvs2_statistics *host_stats,
+	const struct ia_css_isp_dvs_statistics_map *isp_stats);
 
 /* @brief Copy DVS statistics from an ISP buffer to a host buffer.
  * @param[in] type - DVS statistics type
@@ -150,10 +147,9 @@ ia_css_translate_dvs2_statistics(
  * @param[in] isp_stats ISP buffer
  * @return None
  */
-void
-ia_css_dvs_statistics_get(enum dvs_statistics_type type,
-			  union ia_css_dvs_statistics_host  *host_stats,
-			  const union ia_css_dvs_statistics_isp *isp_stats);
+void ia_css_dvs_statistics_get(enum dvs_statistics_type type,
+			       union ia_css_dvs_statistics_host *host_stats,
+			       const union ia_css_dvs_statistics_isp *isp_stats);
 
 /* @brief Allocate the DVS statistics memory on the ISP
  * @param[in]	grid The grid.
@@ -166,8 +162,7 @@ ia_css_isp_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
  * @param[in]	me Pointer to the DVS statistics buffer on the ISP.
  * @return	None
 */
-void
-ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me);
+void ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me);
 
 /* @brief Allocate the DVS 2.0 statistics memory
  * @param[in]	grid The grid.
@@ -180,8 +175,7 @@ ia_css_isp_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
  * @param[in]	me Pointer to the DVS statistics buffer on the ISP.
  * @return	None
 */
-void
-ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me);
+void ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me);
 
 /* @brief Allocate the DVS statistics memory on the host
  * @param[in]	grid The grid.
@@ -194,8 +188,7 @@ ia_css_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
  * @param[in]	me Pointer to the DVS statistics buffer on the host.
  * @return	None
 */
-void
-ia_css_dvs_statistics_free(struct ia_css_dvs_statistics *me);
+void ia_css_dvs_statistics_free(struct ia_css_dvs_statistics *me);
 
 /* @brief Allocate the DVS coefficients memory
  * @param[in]	grid The grid.
@@ -208,8 +201,7 @@ ia_css_dvs_coefficients_allocate(const struct ia_css_dvs_grid_info *grid);
  * @param[in]	me Pointer to the DVS coefficients buffer.
  * @return	None
  */
-void
-ia_css_dvs_coefficients_free(struct ia_css_dvs_coefficients *me);
+void ia_css_dvs_coefficients_free(struct ia_css_dvs_coefficients *me);
 
 /* @brief Allocate the DVS 2.0 statistics memory on the host
  * @param[in]	grid The grid.
@@ -222,8 +214,7 @@ ia_css_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
  * @param[in]	me Pointer to the DVS 2.0 statistics buffer on the host.
  * @return	None
 */
-void
-ia_css_dvs2_statistics_free(struct ia_css_dvs2_statistics *me);
+void ia_css_dvs2_statistics_free(struct ia_css_dvs2_statistics *me);
 
 /* @brief Allocate the DVS 2.0 coefficients memory
  * @param[in]	grid The grid.
@@ -236,8 +227,7 @@ ia_css_dvs2_coefficients_allocate(const struct ia_css_dvs_grid_info *grid);
  * @param[in]	me Pointer to the DVS 2.0 coefficients buffer.
  * @return	None
 */
-void
-ia_css_dvs2_coefficients_free(struct ia_css_dvs2_coefficients *me);
+void ia_css_dvs2_coefficients_free(struct ia_css_dvs2_coefficients *me);
 
 /* @brief Allocate the DVS 2.0 6-axis config memory
  * @param[in]	stream The stream.
@@ -250,8 +240,8 @@ ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream);
  * @param[in]	dvs_6axis_config Pointer to the DVS 6axis configuration buffer
  * @return	None
  */
-void
-ia_css_dvs2_6axis_config_free(struct ia_css_dvs_6axis_config *dvs_6axis_config);
+void ia_css_dvs2_6axis_config_free(
+	struct ia_css_dvs_6axis_config *dvs_6axis_config);
 
 /* @brief Allocate a dvs statistics map structure
  * @param[in]	isp_stats pointer to ISP dvs statistis struct
@@ -269,10 +259,8 @@ ia_css_dvs2_6axis_config_free(struct ia_css_dvs_6axis_config *dvs_6axis_config);
  * Note that this function does not allocate or map any ISP
  * memory.
 */
-struct ia_css_isp_dvs_statistics_map *
-ia_css_isp_dvs_statistics_map_allocate(
-    const struct ia_css_isp_dvs_statistics *isp_stats,
-    void *data_ptr);
+struct ia_css_isp_dvs_statistics_map *ia_css_isp_dvs_statistics_map_allocate(
+	const struct ia_css_isp_dvs_statistics *isp_stats, void *data_ptr);
 
 /* @brief Free the dvs statistics map
  * @param[in]	me Pointer to the dvs statistics map
@@ -282,8 +270,8 @@ ia_css_isp_dvs_statistics_map_allocate(
  * was allocated inside ia_css_isp_dvs_statistics_map_allocate(), it
  * will be freed in this function. Otherwise it will not be freed.
  */
-void
-ia_css_isp_dvs_statistics_map_free(struct ia_css_isp_dvs_statistics_map *me);
+void ia_css_isp_dvs_statistics_map_free(
+	struct ia_css_isp_dvs_statistics_map *me);
 
 /* @brief Allocate memory for the SKC DVS statistics on the ISP
  * @return		Pointer to the allocated ACC DVS statistics buffer on the ISP
diff --git a/drivers/staging/media/atomisp/pci/ia_css_env.h b/drivers/staging/media/atomisp/pci/ia_css_env.h
index 42bf739c51f528bf11d350aa2bfc90eba050e423..1c6bc6f7e0e9861626bfc03c5077defee2d666b2 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_env.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_env.h
@@ -20,9 +20,9 @@
 
 /* Memory allocation attributes, for use in ia_css_css_mem_env. */
 enum ia_css_mem_attr {
-	IA_CSS_MEM_ATTR_CACHED     = BIT(0),
-	IA_CSS_MEM_ATTR_ZEROED     = BIT(1),
-	IA_CSS_MEM_ATTR_PAGEALIGN  = BIT(2),
+	IA_CSS_MEM_ATTR_CACHED = BIT(0),
+	IA_CSS_MEM_ATTR_ZEROED = BIT(1),
+	IA_CSS_MEM_ATTR_PAGEALIGN = BIT(2),
 	IA_CSS_MEM_ATTR_CONTIGUOUS = BIT(3),
 };
 
@@ -67,9 +67,9 @@ struct ia_css_hw_access_env {
 /* Environment with function pointers to print error and debug messages.
  */
 struct ia_css_print_env {
-	int  __printf(1, 0) (*debug_print)(const char *fmt, va_list args);
+	int __printf(1, 0) (*debug_print)(const char *fmt, va_list args);
 	/** Print a debug message. */
-	int  __printf(1, 0) (*error_print)(const char *fmt, va_list args);
+	int __printf(1, 0) (*error_print)(const char *fmt, va_list args);
 	/** Print an error message.*/
 };
 
@@ -79,9 +79,9 @@ struct ia_css_print_env {
  *  Windows and several simulation environments.
  */
 struct ia_css_env {
-	struct ia_css_cpu_mem_env   cpu_mem_env;   /** local flush. */
+	struct ia_css_cpu_mem_env cpu_mem_env; /** local flush. */
 	struct ia_css_hw_access_env hw_access_env; /** CSS HW access functions */
-	struct ia_css_print_env     print_env;     /** Message printing env. */
+	struct ia_css_print_env print_env; /** Message printing env. */
 };
 
 #endif /* __IA_CSS_ENV_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_event_public.h b/drivers/staging/media/atomisp/pci/ia_css_event_public.h
index f7215dd9673923909d8bb0fd2ad384c556969aab..dae1da531b22540f0e90def2fc1baa312d1332ef 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_event_public.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_event_public.h
@@ -11,10 +11,10 @@
  * This file contains CSS-API events functionality
  */
 
-#include <type_support.h>	/* uint8_t */
-#include <ia_css_err.h>		/* ia_css_err */
-#include <ia_css_types.h>	/* ia_css_pipe */
-#include <ia_css_timer.h>	/* ia_css_timer */
+#include <type_support.h> /* uint8_t */
+#include <ia_css_err.h> /* ia_css_err */
+#include <ia_css_types.h> /* ia_css_pipe */
+#include <ia_css_timer.h> /* ia_css_timer */
 #include <linux/bits.h>
 
 /* The event type, distinguishes the kind of events that
@@ -27,38 +27,38 @@
  * 4) "enum ia_css_event_type convert_event_sp_to_host_domain"	(sh_css.c)
  */
 enum ia_css_event_type {
-	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE		= BIT(0),
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE = BIT(0),
 	/** Output frame ready. */
-	IA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE	= BIT(1),
+	IA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE = BIT(1),
 	/** Second output frame ready. */
-	IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE		= BIT(2),
+	IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE = BIT(2),
 	/** Viewfinder Output frame ready. */
-	IA_CSS_EVENT_TYPE_SECOND_VF_OUTPUT_FRAME_DONE	= BIT(3),
+	IA_CSS_EVENT_TYPE_SECOND_VF_OUTPUT_FRAME_DONE = BIT(3),
 	/** Second viewfinder Output frame ready. */
-	IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE		= BIT(4),
+	IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE = BIT(4),
 	/** Indication that 3A statistics are available. */
-	IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE		= BIT(5),
+	IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE = BIT(5),
 	/** Indication that DIS statistics are available. */
-	IA_CSS_EVENT_TYPE_PIPELINE_DONE			= BIT(6),
+	IA_CSS_EVENT_TYPE_PIPELINE_DONE = BIT(6),
 	/** Pipeline Done event, sent after last pipeline stage. */
-	IA_CSS_EVENT_TYPE_FRAME_TAGGED			= BIT(7),
+	IA_CSS_EVENT_TYPE_FRAME_TAGGED = BIT(7),
 	/** Frame tagged. */
-	IA_CSS_EVENT_TYPE_INPUT_FRAME_DONE		= BIT(8),
+	IA_CSS_EVENT_TYPE_INPUT_FRAME_DONE = BIT(8),
 	/** Input frame ready. */
-	IA_CSS_EVENT_TYPE_METADATA_DONE			= BIT(9),
+	IA_CSS_EVENT_TYPE_METADATA_DONE = BIT(9),
 	/** Metadata ready. */
-	IA_CSS_EVENT_TYPE_LACE_STATISTICS_DONE		= BIT(10),
+	IA_CSS_EVENT_TYPE_LACE_STATISTICS_DONE = BIT(10),
 	/** Indication that LACE statistics are available. */
-	IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE		= BIT(11),
+	IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE = BIT(11),
 	/** Extension stage complete. */
-	IA_CSS_EVENT_TYPE_TIMER				= BIT(12),
+	IA_CSS_EVENT_TYPE_TIMER = BIT(12),
 	/** Timer event for measuring the SP side latencies. It contains the
 	     32-bit timer value from the SP */
-	IA_CSS_EVENT_TYPE_PORT_EOF			= BIT(13),
+	IA_CSS_EVENT_TYPE_PORT_EOF = BIT(13),
 	/** End Of Frame event, sent when in buffered sensor mode. */
-	IA_CSS_EVENT_TYPE_FW_WARNING			= BIT(14),
+	IA_CSS_EVENT_TYPE_FW_WARNING = BIT(14),
 	/** Performance warning encounter by FW */
-	IA_CSS_EVENT_TYPE_FW_ASSERT			= BIT(15),
+	IA_CSS_EVENT_TYPE_FW_ASSERT = BIT(15),
 	/** Assertion hit by FW */
 };
 
@@ -68,18 +68,17 @@ enum ia_css_event_type {
  * The other events (such as PORT_EOF) cannot be enabled/disabled
  * and are hence excluded from this macro.
  */
-#define IA_CSS_EVENT_TYPE_ALL \
-	(IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE		| \
-	 IA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE	| \
-	 IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE		| \
-	 IA_CSS_EVENT_TYPE_SECOND_VF_OUTPUT_FRAME_DONE	| \
-	 IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE		| \
-	 IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE		| \
-	 IA_CSS_EVENT_TYPE_PIPELINE_DONE		| \
-	 IA_CSS_EVENT_TYPE_FRAME_TAGGED			| \
-	 IA_CSS_EVENT_TYPE_INPUT_FRAME_DONE		| \
-	 IA_CSS_EVENT_TYPE_METADATA_DONE		| \
-	 IA_CSS_EVENT_TYPE_LACE_STATISTICS_DONE		| \
+#define IA_CSS_EVENT_TYPE_ALL                                               \
+	(IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE |                              \
+	 IA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE |                       \
+	 IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE |                           \
+	 IA_CSS_EVENT_TYPE_SECOND_VF_OUTPUT_FRAME_DONE |                    \
+	 IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE |                             \
+	 IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE |                            \
+	 IA_CSS_EVENT_TYPE_PIPELINE_DONE | IA_CSS_EVENT_TYPE_FRAME_TAGGED | \
+	 IA_CSS_EVENT_TYPE_INPUT_FRAME_DONE |                               \
+	 IA_CSS_EVENT_TYPE_METADATA_DONE |                                  \
+	 IA_CSS_EVENT_TYPE_LACE_STATISTICS_DONE |                           \
 	 IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE)
 
 /* The event struct, container for the event type and its related values.
@@ -89,14 +88,14 @@ enum ia_css_event_type {
  * filled.
  */
 struct ia_css_event {
-	struct ia_css_pipe    *pipe;
+	struct ia_css_pipe *pipe;
 	/** Pipe handle on which event happened, NULL for non pipe related
 	     events. */
 	enum ia_css_event_type type;
 	/** Type of Event, always valid/filled. */
-	u8                port;
+	u8 port;
 	/** Port number for EOF event (not valid for other events). */
-	u8                exp_id;
+	u8 exp_id;
 	/** Exposure id for EOF/FRAME_TAGGED/FW_WARNING event (not valid for other events)
 	     The exposure ID is unique only within a logical stream and it is
 	     only generated on systems that have an input system (such as 2400
@@ -112,22 +111,22 @@ struct ia_css_event {
 	     Note that in case frames are dropped, this will not be reflected
 	     in the exposure IDs. Therefor applications should not use this
 	     to detect frame drops. */
-	u32               fw_handle;
+	u32 fw_handle;
 	/** Firmware Handle for ACC_STAGE_COMPLETE event (not valid for other
 	     events). */
 	enum ia_css_fw_warning fw_warning;
 	/** Firmware warning code, only for WARNING events. */
-	u8                fw_assert_module_id;
+	u8 fw_assert_module_id;
 	/** Firmware module id, only for ASSERT events, should be logged by driver. */
-	u16               fw_assert_line_no;
+	u16 fw_assert_line_no;
 	/** Firmware line number, only for ASSERT events, should be logged by driver. */
-	clock_value_t	       timer_data;
+	clock_value_t timer_data;
 	/** For storing the full 32-bit of the timer value. Valid only for TIMER
 	     event */
-	u8                timer_code;
+	u8 timer_code;
 	/** For storing the code of the TIMER event. Valid only for
 	     TIMER event */
-	u8                timer_subcode;
+	u8 timer_subcode;
 	/** For storing the subcode of the TIMER event. Valid only
 	     for TIMER event */
 };
@@ -146,8 +145,7 @@ struct ia_css_event {
  * was available and can be used in a polling-like situation where the NO_EVENT
  * return value is used to determine whether an event was available or not.
  */
-int
-ia_css_dequeue_psys_event(struct ia_css_event *event);
+int ia_css_dequeue_psys_event(struct ia_css_event *event);
 
 /* @brief Dequeue an ISYS event from the CSS system.
  *
@@ -168,7 +166,6 @@ ia_css_dequeue_psys_event(struct ia_css_event *event);
  * incurring additional latency due to locks being held by other CSS API
  * functions.
  */
-int
-ia_css_dequeue_isys_event(struct ia_css_event *event);
+int ia_css_dequeue_isys_event(struct ia_css_event *event);
 
 #endif /* __IA_CSS_EVENT_PUBLIC_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_firmware.h b/drivers/staging/media/atomisp/pci/ia_css_firmware.h
index fcfa400cfdd1eb6bf670ca31eb31a114a6b35bc8..ac2b5987926d16c617a0cd2bef02838b57034045 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_firmware.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_firmware.h
@@ -18,7 +18,7 @@
 /* CSS firmware package structure.
  */
 struct ia_css_fw {
-	void	    *data;  /** pointer to the firmware data */
+	void *data; /** pointer to the firmware data */
 	unsigned int bytes; /** length in bytes of firmware data */
 };
 
@@ -38,9 +38,8 @@ struct device;
  * contents of this firmware package are copied into local data structures, so
  * the fw pointer could be freed after this function completes.
  */
-int
-ia_css_load_firmware(struct device *dev, const struct ia_css_env *env,
-		     const struct ia_css_fw  *fw);
+int ia_css_load_firmware(struct device *dev, const struct ia_css_env *env,
+			 const struct ia_css_fw *fw);
 
 /* @brief Unloads the firmware
  * @return	None
@@ -51,7 +50,6 @@ ia_css_load_firmware(struct device *dev, const struct ia_css_env *env,
  * This function may only be called when the CSS API is in uninitialized state
  * (e.g. after calling ia_css_uninit()).
  */
-void
-ia_css_unload_firmware(void);
+void ia_css_unload_firmware(void);
 
 #endif /* __IA_CSS_FIRMWARE_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_frame_format.h b/drivers/staging/media/atomisp/pci/ia_css_frame_format.h
index 0cb9c0fbe88cde7685794d8b4c3c6220eadb295c..0b2538c192ec68f130a8874c2bc9eab8caa1455f 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_frame_format.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_frame_format.h
@@ -40,45 +40,45 @@
 	- css/bxt_sandbox/isysapi/interface/ia_css_isysapi_fw_types.h
 */
 enum ia_css_frame_format {
-	IA_CSS_FRAME_FORMAT_NV11 = 0,   /** 12 bit YUV 411, Y, UV plane */
-	IA_CSS_FRAME_FORMAT_NV12,       /** 12 bit YUV 420, Y, UV plane */
-	IA_CSS_FRAME_FORMAT_NV12_16,    /** 16 bit YUV 420, Y, UV plane */
+	IA_CSS_FRAME_FORMAT_NV11 = 0, /** 12 bit YUV 411, Y, UV plane */
+	IA_CSS_FRAME_FORMAT_NV12, /** 12 bit YUV 420, Y, UV plane */
+	IA_CSS_FRAME_FORMAT_NV12_16, /** 16 bit YUV 420, Y, UV plane */
 	IA_CSS_FRAME_FORMAT_NV12_TILEY, /** 12 bit YUV 420, Intel proprietary tiled format, TileY */
-	IA_CSS_FRAME_FORMAT_NV16,       /** 16 bit YUV 422, Y, UV plane */
-	IA_CSS_FRAME_FORMAT_NV21,       /** 12 bit YUV 420, Y, VU plane */
-	IA_CSS_FRAME_FORMAT_NV61,       /** 16 bit YUV 422, Y, VU plane */
-	IA_CSS_FRAME_FORMAT_YV12,       /** 12 bit YUV 420, Y, V, U plane */
-	IA_CSS_FRAME_FORMAT_YV16,       /** 16 bit YUV 422, Y, V, U plane */
-	IA_CSS_FRAME_FORMAT_YUV420,     /** 12 bit YUV 420, Y, U, V plane */
-	IA_CSS_FRAME_FORMAT_YUV420_16,  /** yuv420, 16 bits per subpixel */
-	IA_CSS_FRAME_FORMAT_YUV422,     /** 16 bit YUV 422, Y, U, V plane */
-	IA_CSS_FRAME_FORMAT_YUV422_16,  /** yuv422, 16 bits per subpixel */
-	IA_CSS_FRAME_FORMAT_UYVY,       /** 16 bit YUV 422, UYVY interleaved */
-	IA_CSS_FRAME_FORMAT_YUYV,       /** 16 bit YUV 422, YUYV interleaved */
-	IA_CSS_FRAME_FORMAT_YUV444,     /** 24 bit YUV 444, Y, U, V plane */
-	IA_CSS_FRAME_FORMAT_YUV_LINE,   /** Internal format, 2 y lines followed
+	IA_CSS_FRAME_FORMAT_NV16, /** 16 bit YUV 422, Y, UV plane */
+	IA_CSS_FRAME_FORMAT_NV21, /** 12 bit YUV 420, Y, VU plane */
+	IA_CSS_FRAME_FORMAT_NV61, /** 16 bit YUV 422, Y, VU plane */
+	IA_CSS_FRAME_FORMAT_YV12, /** 12 bit YUV 420, Y, V, U plane */
+	IA_CSS_FRAME_FORMAT_YV16, /** 16 bit YUV 422, Y, V, U plane */
+	IA_CSS_FRAME_FORMAT_YUV420, /** 12 bit YUV 420, Y, U, V plane */
+	IA_CSS_FRAME_FORMAT_YUV420_16, /** yuv420, 16 bits per subpixel */
+	IA_CSS_FRAME_FORMAT_YUV422, /** 16 bit YUV 422, Y, U, V plane */
+	IA_CSS_FRAME_FORMAT_YUV422_16, /** yuv422, 16 bits per subpixel */
+	IA_CSS_FRAME_FORMAT_UYVY, /** 16 bit YUV 422, UYVY interleaved */
+	IA_CSS_FRAME_FORMAT_YUYV, /** 16 bit YUV 422, YUYV interleaved */
+	IA_CSS_FRAME_FORMAT_YUV444, /** 24 bit YUV 444, Y, U, V plane */
+	IA_CSS_FRAME_FORMAT_YUV_LINE, /** Internal format, 2 y lines followed
 					     by a uvinterleaved line */
-	IA_CSS_FRAME_FORMAT_RAW,	/** RAW, 1 plane */
-	IA_CSS_FRAME_FORMAT_RGB565,     /** 16 bit RGB, 1 plane. Each 3 sub
+	IA_CSS_FRAME_FORMAT_RAW, /** RAW, 1 plane */
+	IA_CSS_FRAME_FORMAT_RGB565, /** 16 bit RGB, 1 plane. Each 3 sub
 					     pixels are packed into one 16 bit
 					     value, 5 bits for R, 6 bits for G
 					     and 5 bits for B. */
 	IA_CSS_FRAME_FORMAT_PLANAR_RGB888, /** 24 bit RGB, 3 planes */
-	IA_CSS_FRAME_FORMAT_RGBA888,	/** 32 bit RGBA, 1 plane, A=Alpha
+	IA_CSS_FRAME_FORMAT_RGBA888, /** 32 bit RGBA, 1 plane, A=Alpha
 					     (alpha is unused) */
 	IA_CSS_FRAME_FORMAT_QPLANE6, /** Internal, for advanced ISP */
-	IA_CSS_FRAME_FORMAT_BINARY_8,	/** byte stream, used for jpeg. For
+	IA_CSS_FRAME_FORMAT_BINARY_8, /** byte stream, used for jpeg. For
 					     frames of this type, we set the
 					     height to 1 and the width to the
 					     number of allocated bytes. */
-	IA_CSS_FRAME_FORMAT_MIPI,	/** MIPI frame, 1 plane */
+	IA_CSS_FRAME_FORMAT_MIPI, /** MIPI frame, 1 plane */
 	IA_CSS_FRAME_FORMAT_RAW_PACKED, /** RAW, 1 plane, packed */
-	IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8,	      /** 8 bit per Y/U/V.
+	IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8, /** 8 bit per Y/U/V.
 							   Y odd line; UYVY
 							   interleaved even line */
 	IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8, /** Legacy YUV420. UY odd
 							   line; VY even line */
-	IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_10       /** 10 bit per Y/U/V. Y odd
+	IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_10 /** 10 bit per Y/U/V. Y odd
 							   line; UYVY interleaved
 							   even line */
 };
@@ -88,6 +88,6 @@ enum ia_css_frame_format {
 #define IA_CSS_FRAME_FORMAT_NUM (IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_10 + 1)
 
 /* Number of valid output frame formats for ISP **/
-#define IA_CSS_FRAME_OUT_FORMAT_NUM	(IA_CSS_FRAME_FORMAT_RGBA888 + 1)
+#define IA_CSS_FRAME_OUT_FORMAT_NUM (IA_CSS_FRAME_FORMAT_RGBA888 + 1)
 
 #endif /* __IA_CSS_FRAME_FORMAT_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_frame_public.h b/drivers/staging/media/atomisp/pci/ia_css_frame_public.h
index 7acfedb541d8636949f6ca6915b849b8bfc42472..2369cae9f77a6f0b218af8f92dfd44daf4c34f41 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_frame_public.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_frame_public.h
@@ -36,7 +36,7 @@ enum ia_css_bayer_order {
  */
 struct ia_css_frame_plane {
 	unsigned int height; /** height of a plane in lines */
-	unsigned int width;  /** width of a line, in DMA elements, note that
+	unsigned int width; /** width of a line, in DMA elements, note that
 				  for RGB565 the three subpixels are stored in
 				  one element. For all other formats this is
 				  the number of subpixels per line. */
@@ -49,7 +49,7 @@ struct ia_css_frame_plane {
  *  images. This is not actually a real plane.
  */
 struct ia_css_frame_binary_plane {
-	unsigned int		  size; /** number of bytes in the stream */
+	unsigned int size; /** number of bytes in the stream */
 	struct ia_css_frame_plane data; /** plane */
 };
 
@@ -64,7 +64,7 @@ struct ia_css_frame_yuv_planes {
 /* Container for semi-planar YUV frames.
   */
 struct ia_css_frame_nv_planes {
-	struct ia_css_frame_plane y;  /** Y plane */
+	struct ia_css_frame_plane y; /** Y plane */
 	struct ia_css_frame_plane uv; /** UV plane */
 };
 
@@ -80,11 +80,11 @@ struct ia_css_frame_rgb_planes {
  *  in the advanced ISP only.
  */
 struct ia_css_frame_plane6_planes {
-	struct ia_css_frame_plane r;	  /** Red plane */
+	struct ia_css_frame_plane r; /** Red plane */
 	struct ia_css_frame_plane r_at_b; /** Red at blue plane */
-	struct ia_css_frame_plane gr;	  /** Red-green plane */
-	struct ia_css_frame_plane gb;	  /** Blue-green plane */
-	struct ia_css_frame_plane b;	  /** Blue plane */
+	struct ia_css_frame_plane gr; /** Red-green plane */
+	struct ia_css_frame_plane gb; /** Blue-green plane */
+	struct ia_css_frame_plane b; /** Blue plane */
 	struct ia_css_frame_plane b_at_r; /** Blue at red plane */
 };
 
@@ -114,10 +114,11 @@ struct ia_css_frame_info {
 	struct ia_css_crop_info crop_info;
 };
 
-#define IA_CSS_BINARY_DEFAULT_FRAME_INFO { \
-	.format			= IA_CSS_FRAME_FORMAT_NUM,  \
-	.raw_bayer_order	= IA_CSS_BAYER_ORDER_NUM, \
-}
+#define IA_CSS_BINARY_DEFAULT_FRAME_INFO                   \
+	{                                                  \
+		.format = IA_CSS_FRAME_FORMAT_NUM,         \
+		.raw_bayer_order = IA_CSS_BAYER_ORDER_NUM, \
+	}
 
 /**
  *  Specifies the DVS loop delay in "frame periods"
@@ -125,7 +126,7 @@ struct ia_css_frame_info {
 enum ia_css_frame_delay {
 	IA_CSS_FRAME_DELAY_0, /** Frame delay = 0 */
 	IA_CSS_FRAME_DELAY_1, /** Frame delay = 1 */
-	IA_CSS_FRAME_DELAY_2  /** Frame delay = 2 */
+	IA_CSS_FRAME_DELAY_2 /** Frame delay = 2 */
 };
 
 /* Frame structure. This structure describes an image buffer or frame.
@@ -143,9 +144,10 @@ struct ia_css_frame {
 	struct vb2_v4l2_buffer vb;
 	/* List-head for linking into the activeq or buffers_waiting_for_param list */
 	struct list_head queue;
-	struct ia_css_frame_info frame_info; /** info struct describing the frame */
-	ia_css_ptr   data;	       /** pointer to start of image data */
-	unsigned int data_bytes;       /** size of image data in bytes */
+	struct ia_css_frame_info
+		frame_info; /** info struct describing the frame */
+	ia_css_ptr data; /** pointer to start of image data */
+	unsigned int data_bytes; /** size of image data in bytes */
 	/* LA: move this to ia_css_buffer */
 	/*
 	 * -1 if data address is static during life time of pipeline
@@ -166,7 +168,7 @@ struct ia_css_frame {
 	u32 isp_config_id; /** Unique ID to track which config was actually applied to a particular frame */
 	bool valid; /** First video output frame is not valid */
 	union {
-		unsigned int	_initialisation_dummy;
+		unsigned int _initialisation_dummy;
 		struct ia_css_frame_plane raw;
 		struct ia_css_frame_plane rgb;
 		struct ia_css_frame_rgb_planes planar_rgb;
@@ -182,11 +184,12 @@ struct ia_css_frame {
 #define vb_to_frame(vb2) \
 	container_of(to_vb2_v4l2_buffer(vb2), struct ia_css_frame, vb)
 
-#define DEFAULT_FRAME { \
-	.frame_info		= IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
-	.dynamic_queue_id	= SH_CSS_INVALID_QUEUE_ID, \
-	.buf_type		= IA_CSS_BUFFER_TYPE_INVALID, \
-}
+#define DEFAULT_FRAME                                           \
+	{                                                       \
+		.frame_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
+		.dynamic_queue_id = SH_CSS_INVALID_QUEUE_ID,    \
+		.buf_type = IA_CSS_BUFFER_TYPE_INVALID,         \
+	}
 
 /* @brief Allocate a CSS frame structure
  *
@@ -201,13 +204,9 @@ struct ia_css_frame {
  * Allocate a CSS frame structure. The memory for the frame data will be
  * allocated in the CSS address space.
  */
-int
-ia_css_frame_allocate(struct ia_css_frame **frame,
-		      unsigned int width,
-		      unsigned int height,
-		      enum ia_css_frame_format format,
-		      unsigned int stride,
-		      unsigned int raw_bit_depth);
+int ia_css_frame_allocate(struct ia_css_frame **frame, unsigned int width,
+			  unsigned int height, enum ia_css_frame_format format,
+			  unsigned int stride, unsigned int raw_bit_depth);
 
 /* @brief Initialize a CSS frame structure using a frame info structure.
  *
@@ -230,9 +229,8 @@ int ia_css_frame_init_from_info(struct ia_css_frame *frame,
  * This is a convenience function, implemented on top of
  * ia_css_frame_allocate().
  */
-int
-ia_css_frame_allocate_from_info(struct ia_css_frame **frame,
-				const struct ia_css_frame_info *info);
+int ia_css_frame_allocate_from_info(struct ia_css_frame **frame,
+				    const struct ia_css_frame_info *info);
 /* @brief Free a CSS frame structure.
  *
  * @param[in]	frame	Pointer to the frame.
@@ -241,8 +239,7 @@ ia_css_frame_allocate_from_info(struct ia_css_frame **frame,
  * Free a CSS frame structure. This will free both the frame structure
  * and the pixel data pointer contained within the frame structure.
  */
-void
-ia_css_frame_free(struct ia_css_frame *frame);
+void ia_css_frame_free(struct ia_css_frame *frame);
 
 static inline const struct ia_css_frame_info *
 ia_css_frame_get_info(const struct ia_css_frame *frame)
diff --git a/drivers/staging/media/atomisp/pci/ia_css_host_data.h b/drivers/staging/media/atomisp/pci/ia_css_host_data.h
index 0e45650cc1ab279752b9985d7293730d1f5b38ab..67f060cdbf3294205daeaa060bfdbfb843bc3378 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_host_data.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_host_data.h
@@ -8,7 +8,7 @@
 #ifndef __SH_CSS_HOST_DATA_H
 #define __SH_CSS_HOST_DATA_H
 
-#include <ia_css_types.h>	/* ia_css_pipe */
+#include <ia_css_types.h> /* ia_css_pipe */
 
 /**
  * @brief Allocate structure ia_css_host_data.
@@ -19,8 +19,7 @@
  *	- NULL, can't allocate requested size
  *	- pointer to structure, field address points to host data with size bytes
  */
-struct ia_css_host_data *
-ia_css_host_data_allocate(size_t size);
+struct ia_css_host_data *ia_css_host_data_allocate(size_t size);
 
 /**
  * @brief Free structure ia_css_host_data.
diff --git a/drivers/staging/media/atomisp/pci/ia_css_input_port.h b/drivers/staging/media/atomisp/pci/ia_css_input_port.h
index f138dfa8f6b245ecf425b7fce88d3b928e98dbfe..004ed263e999046ff3cb7ae887f30f8c781a4a0f 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_input_port.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_input_port.h
@@ -17,25 +17,25 @@
 /* Backward compatible for CSS API 2.0 only
  *  TO BE REMOVED when all drivers move to CSS	API 2.1
  */
-#define	IA_CSS_CSI2_PORT_4LANE MIPI_PORT0_ID
-#define	IA_CSS_CSI2_PORT_1LANE MIPI_PORT1_ID
-#define	IA_CSS_CSI2_PORT_2LANE MIPI_PORT2_ID
+#define IA_CSS_CSI2_PORT_4LANE MIPI_PORT0_ID
+#define IA_CSS_CSI2_PORT_1LANE MIPI_PORT1_ID
+#define IA_CSS_CSI2_PORT_2LANE MIPI_PORT2_ID
 
 /* The CSI2 interface supports 2 types of compression or can
  *  be run without compression.
  */
 enum ia_css_csi2_compression_type {
 	IA_CSS_CSI2_COMPRESSION_TYPE_NONE, /** No compression */
-	IA_CSS_CSI2_COMPRESSION_TYPE_1,    /** Compression scheme 1 */
-	IA_CSS_CSI2_COMPRESSION_TYPE_2     /** Compression scheme 2 */
+	IA_CSS_CSI2_COMPRESSION_TYPE_1, /** Compression scheme 1 */
+	IA_CSS_CSI2_COMPRESSION_TYPE_2 /** Compression scheme 2 */
 };
 
 struct ia_css_csi2_compression {
 	enum ia_css_csi2_compression_type type;
 	/** Compression used */
-	unsigned int                      compressed_bits_per_pixel;
+	unsigned int compressed_bits_per_pixel;
 	/** Compressed bits per pixel (only when compression is enabled) */
-	unsigned int                      uncompressed_bits_per_pixel;
+	unsigned int uncompressed_bits_per_pixel;
 	/** Uncompressed bits per pixel (only when compression is enabled) */
 };
 
@@ -44,8 +44,8 @@ struct ia_css_csi2_compression {
 struct ia_css_input_port {
 	enum mipi_port_id port; /** Physical CSI-2 port */
 	unsigned int num_lanes; /** Number of lanes used (4-lane port only) */
-	unsigned int timeout;   /** Timeout value */
-	unsigned int rxcount;   /** Register value, should include all lanes */
+	unsigned int timeout; /** Timeout value */
+	unsigned int rxcount; /** Register value, should include all lanes */
 	struct ia_css_csi2_compression compression; /** Compression used */
 };
 
diff --git a/drivers/staging/media/atomisp/pci/ia_css_irq.h b/drivers/staging/media/atomisp/pci/ia_css_irq.h
index 2a4f11f9d78506560718132d35e19944ecf51000..3b819fa6fb7c66382b511635e463538d1f2da6c0 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_irq.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_irq.h
@@ -19,8 +19,8 @@
 /* Interrupt types, these enumerate all supported interrupt types.
  */
 enum ia_css_irq_type {
-	IA_CSS_IRQ_TYPE_EDGE,  /** Edge (level) sensitive interrupt */
-	IA_CSS_IRQ_TYPE_PULSE  /** Pulse-shaped interrupt */
+	IA_CSS_IRQ_TYPE_EDGE, /** Edge (level) sensitive interrupt */
+	IA_CSS_IRQ_TYPE_PULSE /** Pulse-shaped interrupt */
 };
 
 /* Interrupt request type.
@@ -38,49 +38,49 @@ enum ia_css_irq_type {
  * (SW) interrupts
  */
 enum ia_css_irq_info {
-	IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR            = BIT(0),
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR = BIT(0),
 	/** the css receiver has encountered an error */
-	IA_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW    = BIT(1),
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW = BIT(1),
 	/** the FIFO in the csi receiver has overflown */
-	IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF              = BIT(2),
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF = BIT(2),
 	/** the css receiver received the start of frame */
-	IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF              = BIT(3),
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF = BIT(3),
 	/** the css receiver received the end of frame */
-	IA_CSS_IRQ_INFO_CSS_RECEIVER_SOL              = BIT(4),
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_SOL = BIT(4),
 	/** the css receiver received the start of line */
-	IA_CSS_IRQ_INFO_EVENTS_READY                  = BIT(5),
+	IA_CSS_IRQ_INFO_EVENTS_READY = BIT(5),
 	/** One or more events are available in the PSYS event queue */
-	IA_CSS_IRQ_INFO_CSS_RECEIVER_EOL              = BIT(6),
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_EOL = BIT(6),
 	/** the css receiver received the end of line */
 	IA_CSS_IRQ_INFO_CSS_RECEIVER_SIDEBAND_CHANGED = BIT(7),
 	/** the css receiver received a change in side band signals */
-	IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0      = BIT(8),
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0 = BIT(8),
 	/** generic short packets (0) */
-	IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1      = BIT(9),
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1 = BIT(9),
 	/** generic short packets (1) */
-	IA_CSS_IRQ_INFO_IF_PRIM_ERROR                 = BIT(10),
+	IA_CSS_IRQ_INFO_IF_PRIM_ERROR = BIT(10),
 	/** the primary input formatter (A) has encountered an error */
-	IA_CSS_IRQ_INFO_IF_PRIM_B_ERROR               = BIT(11),
+	IA_CSS_IRQ_INFO_IF_PRIM_B_ERROR = BIT(11),
 	/** the primary input formatter (B) has encountered an error */
-	IA_CSS_IRQ_INFO_IF_SEC_ERROR                  = BIT(12),
+	IA_CSS_IRQ_INFO_IF_SEC_ERROR = BIT(12),
 	/** the secondary input formatter has encountered an error */
-	IA_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR           = BIT(13),
+	IA_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR = BIT(13),
 	/** the stream-to-memory device has encountered an error */
-	IA_CSS_IRQ_INFO_SW_0                          = BIT(14),
+	IA_CSS_IRQ_INFO_SW_0 = BIT(14),
 	/** software interrupt 0 */
-	IA_CSS_IRQ_INFO_SW_1                          = BIT(15),
+	IA_CSS_IRQ_INFO_SW_1 = BIT(15),
 	/** software interrupt 1 */
-	IA_CSS_IRQ_INFO_SW_2                          = BIT(16),
+	IA_CSS_IRQ_INFO_SW_2 = BIT(16),
 	/** software interrupt 2 */
-	IA_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY   = BIT(17),
+	IA_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY = BIT(17),
 	/** ISP binary statistics are ready */
-	IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR            = BIT(18),
+	IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR = BIT(18),
 	/** the input system is in error */
-	IA_CSS_IRQ_INFO_IF_ERROR                      = BIT(19),
+	IA_CSS_IRQ_INFO_IF_ERROR = BIT(19),
 	/** the input formatter is in error */
-	IA_CSS_IRQ_INFO_DMA_ERROR                     = BIT(20),
+	IA_CSS_IRQ_INFO_DMA_ERROR = BIT(20),
 	/** the dma is in error */
-	IA_CSS_IRQ_INFO_ISYS_EVENTS_READY             = BIT(21),
+	IA_CSS_IRQ_INFO_ISYS_EVENTS_READY = BIT(21),
 	/** end-of-frame events are ready in the isys_event queue */
 };
 
@@ -95,23 +95,23 @@ enum ia_css_irq_info {
  * different receiver types, or possibly none in case of tests systems.
  */
 enum ia_css_rx_irq_info {
-	IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN   = BIT(0),  /** buffer overrun */
-	IA_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE = BIT(1),  /** entering sleep mode */
-	IA_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE  = BIT(2),  /** exited sleep mode */
-	IA_CSS_RX_IRQ_INFO_ECC_CORRECTED    = BIT(3),  /** ECC corrected */
-	IA_CSS_RX_IRQ_INFO_ERR_SOT          = BIT(4),
+	IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN = BIT(0), /** buffer overrun */
+	IA_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE = BIT(1), /** entering sleep mode */
+	IA_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE = BIT(2), /** exited sleep mode */
+	IA_CSS_RX_IRQ_INFO_ECC_CORRECTED = BIT(3), /** ECC corrected */
+	IA_CSS_RX_IRQ_INFO_ERR_SOT = BIT(4),
 	/** Start of transmission */
-	IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC     = BIT(5),  /** SOT sync (??) */
-	IA_CSS_RX_IRQ_INFO_ERR_CONTROL      = BIT(6),  /** Control (??) */
-	IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE   = BIT(7),  /** Double ECC */
-	IA_CSS_RX_IRQ_INFO_ERR_CRC          = BIT(8),  /** CRC error */
-	IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID   = BIT(9),  /** Unknown ID */
-	IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC   = BIT(10), /** Frame sync error */
-	IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA   = BIT(11), /** Frame data error */
+	IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC = BIT(5), /** SOT sync (??) */
+	IA_CSS_RX_IRQ_INFO_ERR_CONTROL = BIT(6), /** Control (??) */
+	IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE = BIT(7), /** Double ECC */
+	IA_CSS_RX_IRQ_INFO_ERR_CRC = BIT(8), /** CRC error */
+	IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID = BIT(9), /** Unknown ID */
+	IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC = BIT(10), /** Frame sync error */
+	IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA = BIT(11), /** Frame data error */
 	IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT = BIT(12), /** Timeout occurred */
-	IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC  = BIT(13), /** Unknown escape seq. */
-	IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC    = BIT(14), /** Line Sync error */
-	IA_CSS_RX_IRQ_INFO_INIT_TIMEOUT     = BIT(15),
+	IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC = BIT(13), /** Unknown escape seq. */
+	IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC = BIT(14), /** Line Sync error */
+	IA_CSS_RX_IRQ_INFO_INIT_TIMEOUT = BIT(15),
 };
 
 /* Interrupt info structure. This structure contains information about an
@@ -141,8 +141,7 @@ struct ia_css_irq {
  * which is needed by the IA code to properly handle the interrupt. This
  * information includes the image pipe, buffer type etc.
  */
-int
-ia_css_irq_translate(unsigned int *info);
+int ia_css_irq_translate(unsigned int *info);
 
 /* @brief Get CSI receiver error info.
  *
@@ -159,8 +158,7 @@ ia_css_irq_translate(unsigned int *info);
  *@deprecated {this function is DEPRECATED since it only works on CSI port 1.
  * Use the function below instead and specify the appropriate port.}
  */
-void
-ia_css_rx_get_irq_info(unsigned int *irq_bits);
+void ia_css_rx_get_irq_info(unsigned int *irq_bits);
 
 /* @brief Get CSI receiver error info.
  *
@@ -175,8 +173,8 @@ ia_css_rx_get_irq_info(unsigned int *irq_bits);
  * generated. It provides the detailed information (bits) on the exact error
  * that occurred.
  */
-void
-ia_css_rx_port_get_irq_info(enum mipi_port_id port, unsigned int *irq_bits);
+void ia_css_rx_port_get_irq_info(enum mipi_port_id port,
+				 unsigned int *irq_bits);
 
 /* @brief Clear CSI receiver error info.
  *
@@ -192,8 +190,7 @@ ia_css_rx_port_get_irq_info(enum mipi_port_id port, unsigned int *irq_bits);
  * @deprecated{this function is DEPRECATED since it only works on CSI port 1.
  * Use the function below instead and specify the appropriate port.}
  */
-void
-ia_css_rx_clear_irq_info(unsigned int irq_bits);
+void ia_css_rx_clear_irq_info(unsigned int irq_bits);
 
 /* @brief Clear CSI receiver error info.
  *
@@ -207,8 +204,8 @@ ia_css_rx_clear_irq_info(unsigned int irq_bits);
  * value of that function as the argument to this function to make sure no new
  * error bits get overwritten.
  */
-void
-ia_css_rx_port_clear_irq_info(enum mipi_port_id port, unsigned int irq_bits);
+void ia_css_rx_port_clear_irq_info(enum mipi_port_id port,
+				   unsigned int irq_bits);
 
 /* @brief Enable or disable specific interrupts.
  *
@@ -219,7 +216,6 @@ ia_css_rx_port_clear_irq_info(enum mipi_port_id port, unsigned int irq_bits);
  *			CSS internal interrupts. Otherwise returns
  *			0.
  */
-int
-ia_css_irq_enable(enum ia_css_irq_info type, bool enable);
+int ia_css_irq_enable(enum ia_css_irq_info type, bool enable);
 
 #endif /* __IA_CSS_IRQ_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_isp_configs.c b/drivers/staging/media/atomisp/pci/ia_css_isp_configs.c
index 38c9c62366d65e705a95edf4b41433bd83aa5f20..2ef89033213516cae14482b731fc358c468cb822 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_isp_configs.c
+++ b/drivers/staging/media/atomisp/pci/ia_css_isp_configs.c
@@ -12,11 +12,12 @@
 #include "ia_css_debug.h"
 #include "assert_support.h"
 
-int ia_css_configure_iterator(const struct ia_css_binary *binary,
-			      const struct ia_css_iterator_configuration *config_dmem)
+int ia_css_configure_iterator(
+	const struct ia_css_binary *binary,
+	const struct ia_css_iterator_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -29,17 +30,20 @@ int ia_css_configure_iterator(const struct ia_css_binary *binary,
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.iterator.offset;
 
-	ia_css_iterator_config((struct sh_css_isp_iterator_isp_config *)
-			       &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			       config_dmem, size);
+	ia_css_iterator_config(
+		(struct sh_css_isp_iterator_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
-int ia_css_configure_copy_output(const struct ia_css_binary *binary,
-				 const struct ia_css_copy_output_configuration *config_dmem)
+int ia_css_configure_copy_output(
+	const struct ia_css_binary *binary,
+	const struct ia_css_copy_output_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -50,11 +54,14 @@ int ia_css_configure_copy_output(const struct ia_css_binary *binary,
 	if (!size)
 		return 0;
 
-	offset = binary->info->mem_offsets.offsets.config->dmem.copy_output.offset;
+	offset = binary->info->mem_offsets.offsets.config->dmem.copy_output
+			 .offset;
 
-	ia_css_copy_output_config((struct sh_css_isp_copy_output_isp_config *)
-				  &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-				  config_dmem, size);
+	ia_css_copy_output_config(
+		(struct sh_css_isp_copy_output_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
@@ -64,7 +71,7 @@ int ia_css_configure_crop(const struct ia_css_binary *binary,
 			  const struct ia_css_crop_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -77,9 +84,11 @@ int ia_css_configure_crop(const struct ia_css_binary *binary,
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.crop.offset;
 
-	ia_css_crop_config((struct sh_css_isp_crop_isp_config *)
-			   &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			   config_dmem, size);
+	ia_css_crop_config(
+		(struct sh_css_isp_crop_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
@@ -87,21 +96,23 @@ int ia_css_configure_fpn(const struct ia_css_binary *binary,
 			 const struct ia_css_fpn_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
 	if (!binary->info->mem_offsets.offsets.config)
 		return 0;
 
-	size   = binary->info->mem_offsets.offsets.config->dmem.fpn.size;
+	size = binary->info->mem_offsets.offsets.config->dmem.fpn.size;
 	if (!size)
 		return 0;
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.fpn.offset;
-	ia_css_fpn_config((struct sh_css_isp_fpn_isp_config *)
-			  &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			  config_dmem, size);
+	ia_css_fpn_config(
+		(struct sh_css_isp_fpn_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
@@ -109,7 +120,7 @@ int ia_css_configure_dvs(const struct ia_css_binary *binary,
 			 const struct ia_css_dvs_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -121,17 +132,20 @@ int ia_css_configure_dvs(const struct ia_css_binary *binary,
 		return 0;
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.dvs.offset;
-	ia_css_dvs_config((struct sh_css_isp_dvs_isp_config *)
-			  &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			  config_dmem, size);
+	ia_css_dvs_config(
+		(struct sh_css_isp_dvs_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
-int ia_css_configure_qplane(const struct ia_css_binary *binary,
-			    const struct ia_css_qplane_configuration *config_dmem)
+int ia_css_configure_qplane(
+	const struct ia_css_binary *binary,
+	const struct ia_css_qplane_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -143,18 +157,21 @@ int ia_css_configure_qplane(const struct ia_css_binary *binary,
 		return 0;
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.qplane.offset;
-	ia_css_qplane_config((struct sh_css_isp_qplane_isp_config *)
-			     &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			     config_dmem, size);
+	ia_css_qplane_config(
+		(struct sh_css_isp_qplane_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 
 	return 0;
 }
 
-int ia_css_configure_output0(const struct ia_css_binary *binary,
-			     const struct ia_css_output0_configuration *config_dmem)
+int ia_css_configure_output0(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output0_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -167,17 +184,20 @@ int ia_css_configure_output0(const struct ia_css_binary *binary,
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.output0.offset;
 
-	ia_css_output0_config((struct sh_css_isp_output_isp_config *)
-			      &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			      config_dmem, size);
+	ia_css_output0_config(
+		(struct sh_css_isp_output_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
-int ia_css_configure_output1(const struct ia_css_binary *binary,
-			     const struct ia_css_output1_configuration *config_dmem)
+int ia_css_configure_output1(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output1_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -190,17 +210,20 @@ int ia_css_configure_output1(const struct ia_css_binary *binary,
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.output1.offset;
 
-	ia_css_output1_config((struct sh_css_isp_output_isp_config *)
-			      &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			      config_dmem, size);
+	ia_css_output1_config(
+		(struct sh_css_isp_output_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
-int ia_css_configure_output(const struct ia_css_binary *binary,
-			    const struct ia_css_output_configuration *config_dmem)
+int ia_css_configure_output(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -213,9 +236,11 @@ int ia_css_configure_output(const struct ia_css_binary *binary,
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.output.offset;
 
-	ia_css_output_config((struct sh_css_isp_output_isp_config *)
-			     &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-					     config_dmem, size);
+	ia_css_output_config(
+		(struct sh_css_isp_output_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
@@ -223,7 +248,7 @@ int ia_css_configure_raw(const struct ia_css_binary *binary,
 			 const struct ia_css_raw_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -236,9 +261,11 @@ int ia_css_configure_raw(const struct ia_css_binary *binary,
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.raw.offset;
 
-	ia_css_raw_config((struct sh_css_isp_raw_isp_config *)
-			  &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			  config_dmem, size);
+	ia_css_raw_config(
+		(struct sh_css_isp_raw_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
@@ -246,7 +273,7 @@ int ia_css_configure_tnr(const struct ia_css_binary *binary,
 			 const struct ia_css_tnr_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -259,9 +286,11 @@ int ia_css_configure_tnr(const struct ia_css_binary *binary,
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.tnr.offset;
 
-	ia_css_tnr_config((struct sh_css_isp_tnr_isp_config *)
-			  &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			  config_dmem, size);
+	ia_css_tnr_config(
+		(struct sh_css_isp_tnr_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
@@ -269,7 +298,7 @@ int ia_css_configure_ref(const struct ia_css_binary *binary,
 			 const struct ia_css_ref_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -282,9 +311,11 @@ int ia_css_configure_ref(const struct ia_css_binary *binary,
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.ref.offset;
 
-	ia_css_ref_config((struct sh_css_isp_ref_isp_config *)
-			  &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			  config_dmem, size);
+	ia_css_ref_config(
+		(struct sh_css_isp_ref_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
 
@@ -292,7 +323,7 @@ int ia_css_configure_vf(const struct ia_css_binary *binary,
 			const struct ia_css_vf_configuration *config_dmem)
 {
 	unsigned int offset = 0;
-	unsigned int size   = 0;
+	unsigned int size = 0;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s:\n", __func__);
 
@@ -305,8 +336,10 @@ int ia_css_configure_vf(const struct ia_css_binary *binary,
 
 	offset = binary->info->mem_offsets.offsets.config->dmem.vf.offset;
 
-	ia_css_vf_config((struct sh_css_isp_vf_isp_config *)
-			 &binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
-			 config_dmem, size);
+	ia_css_vf_config(
+		(struct sh_css_isp_vf_isp_config *)&binary->mem_params
+			.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM]
+			.address[offset],
+		config_dmem, size);
 	return 0;
 }
diff --git a/drivers/staging/media/atomisp/pci/ia_css_isp_configs.h b/drivers/staging/media/atomisp/pci/ia_css_isp_configs.h
index 226902d2100b4f771e36cee34981d92b7e0db9ac..baa76a83cd0dcbfae5eb00273008094a5283c0b4 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_isp_configs.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_isp_configs.h
@@ -64,14 +64,16 @@ struct ia_css_config_memory_offsets {
 
 #if defined(IA_CSS_INCLUDE_CONFIGURATIONS)
 
-#include "ia_css_stream.h"   /* struct ia_css_stream */
-#include "ia_css_binary.h"   /* struct ia_css_binary */
+#include "ia_css_stream.h" /* struct ia_css_stream */
+#include "ia_css_binary.h" /* struct ia_css_binary */
 
-int ia_css_configure_iterator(const struct ia_css_binary *binary,
-			      const struct ia_css_iterator_configuration *config_dmem);
+int ia_css_configure_iterator(
+	const struct ia_css_binary *binary,
+	const struct ia_css_iterator_configuration *config_dmem);
 
-int ia_css_configure_copy_output(const struct ia_css_binary *binary,
-				 const struct ia_css_copy_output_configuration *config_dmem);
+int ia_css_configure_copy_output(
+	const struct ia_css_binary *binary,
+	const struct ia_css_copy_output_configuration *config_dmem);
 
 int ia_css_configure_crop(const struct ia_css_binary *binary,
 			  const struct ia_css_crop_configuration *config_dmem);
@@ -82,16 +84,20 @@ int ia_css_configure_fpn(const struct ia_css_binary *binary,
 int ia_css_configure_dvs(const struct ia_css_binary *binary,
 			 const struct ia_css_dvs_configuration *config_dmem);
 
-int ia_css_configure_qplane(const struct ia_css_binary *binary,
-			    const struct ia_css_qplane_configuration *config_dmem);
-int ia_css_configure_output0(const struct ia_css_binary *binary,
-			     const struct ia_css_output0_configuration *config_dmem);
+int ia_css_configure_qplane(
+	const struct ia_css_binary *binary,
+	const struct ia_css_qplane_configuration *config_dmem);
+int ia_css_configure_output0(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output0_configuration *config_dmem);
 
-int ia_css_configure_output1(const struct ia_css_binary *binary,
-			     const struct ia_css_output1_configuration *config_dmem);
+int ia_css_configure_output1(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output1_configuration *config_dmem);
 
-int ia_css_configure_output(const struct ia_css_binary *binary,
-			    const struct ia_css_output_configuration *config_dmem);
+int ia_css_configure_output(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output_configuration *config_dmem);
 
 int ia_css_configure_raw(const struct ia_css_binary *binary,
 			 const struct ia_css_raw_configuration *config_dmem);
diff --git a/drivers/staging/media/atomisp/pci/ia_css_isp_params.c b/drivers/staging/media/atomisp/pci/ia_css_isp_params.c
index 1cd3322b0da051f4d2730166d85f9173a27a4acd..a272fe76ddb347290d267b2dc1a91d8e7f50f5a7 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_isp_params.c
+++ b/drivers/staging/media/atomisp/pci/ia_css_isp_params.c
@@ -57,52 +57,54 @@
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_aa(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_aa(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
-	unsigned int size   =
-	    stage->binary->info->mem_offsets.offsets.param->dmem.aa.size;
+	unsigned int size =
+		stage->binary->info->mem_offsets.offsets.param->dmem.aa.size;
 	unsigned int offset =
-	    stage->binary->info->mem_offsets.offsets.param->dmem.aa.offset;
+		stage->binary->info->mem_offsets.offsets.param->dmem.aa.offset;
 
 	if (size) {
-		struct sh_css_isp_aa_params *t =  (struct sh_css_isp_aa_params *)
-						  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset];
+		struct sh_css_isp_aa_params *t =
+			(struct sh_css_isp_aa_params *)&stage->binary->mem_params
+				.params[IA_CSS_PARAM_CLASS_PARAM]
+				       [IA_CSS_ISP_DMEM]
+				.address[offset];
 		t->strength = params->aa_config.strength;
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_anr(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_anr(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.anr.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.anr.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.anr.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.anr.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_anr() enter:\n");
 
-			ia_css_anr_encode((struct sh_css_isp_anr_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->anr_config,
-					  size);
+			ia_css_anr_encode(
+				(struct sh_css_isp_anr_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->anr_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_anr() leave:\n");
@@ -112,32 +114,33 @@ ia_css_process_anr(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_anr2(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_anr2(unsigned int pipe_id,
+				const struct ia_css_pipeline_stage *stage,
+				struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.anr2.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vmem.anr2.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.anr2.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->vmem.anr2.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_anr2() enter:\n");
 
-			ia_css_anr2_vmem_encode((struct ia_css_isp_anr2_params *)
-						&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VMEM].address[offset],
-						&params->anr_thres,
-						size);
+			ia_css_anr2_vmem_encode(
+				(struct ia_css_isp_anr2_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VMEM]
+					.address[offset],
+				&params->anr_thres, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_anr2() leave:\n");
@@ -147,79 +150,85 @@ ia_css_process_anr2(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_bh(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_bh(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.bh.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.bh.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.bh.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.bh.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_bh() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_bh() enter:\n");
 
-			ia_css_bh_encode((struct sh_css_isp_bh_params *)
-					 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					 &params->s3a_config,
-					 size);
+			ia_css_bh_encode(
+				(struct sh_css_isp_bh_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->s3a_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_bh() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_bh() leave:\n");
 		}
 	}
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->hmem0.bh.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->hmem0.bh.size;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_bh() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_bh() enter:\n");
 
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_HMEM0] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_HMEM0] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_bh() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_bh() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_cnr(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_cnr(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.cnr.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.cnr.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.cnr.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.cnr.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_cnr() enter:\n");
 
-			ia_css_cnr_encode((struct sh_css_isp_cnr_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->cnr_config,
-					  size);
+			ia_css_cnr_encode(
+				(struct sh_css_isp_cnr_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->cnr_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_cnr() leave:\n");
@@ -229,32 +238,33 @@ ia_css_process_cnr(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_crop(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_crop(unsigned int pipe_id,
+				const struct ia_css_pipeline_stage *stage,
+				struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.crop.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.crop.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.crop.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.crop.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_crop() enter:\n");
 
-			ia_css_crop_encode((struct sh_css_isp_crop_isp_params *)
-					   &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					   &params->crop_config,
-					   size);
+			ia_css_crop_encode(
+				(struct sh_css_isp_crop_isp_params *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->crop_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_crop() leave:\n");
@@ -264,32 +274,33 @@ ia_css_process_crop(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_csc(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_csc(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.csc.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.csc.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.csc.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.csc.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_csc() enter:\n");
 
-			ia_css_csc_encode((struct sh_css_isp_csc_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->cc_config,
-					  size);
+			ia_css_csc_encode(
+				(struct sh_css_isp_csc_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->cc_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_csc() leave:\n");
@@ -299,65 +310,69 @@ ia_css_process_csc(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_dp(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_dp(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.dp.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.dp.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.dp.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.dp.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_dp() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_dp() enter:\n");
 
-			ia_css_dp_encode((struct sh_css_isp_dp_params *)
-					 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					 &params->dp_config,
-					 size);
+			ia_css_dp_encode(
+				(struct sh_css_isp_dp_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->dp_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_dp() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_dp() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_bnr(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_bnr(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.bnr.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.bnr.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.bnr.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.bnr.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_bnr() enter:\n");
 
-			ia_css_bnr_encode((struct sh_css_isp_bnr_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->nr_config,
-					  size);
+			ia_css_bnr_encode(
+				(struct sh_css_isp_bnr_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->nr_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_bnr() leave:\n");
@@ -367,65 +382,69 @@ ia_css_process_bnr(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_de(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_de(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.de.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.de.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.de.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.de.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_de() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_de() enter:\n");
 
-			ia_css_de_encode((struct sh_css_isp_de_params *)
-					 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					 &params->de_config,
-					 size);
+			ia_css_de_encode(
+				(struct sh_css_isp_de_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->de_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_de() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_de() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_ecd(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_ecd(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.ecd.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.ecd.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.ecd.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.ecd.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_ecd() enter:\n");
 
-			ia_css_ecd_encode((struct sh_css_isp_ecd_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->ecd_config,
-					  size);
+			ia_css_ecd_encode(
+				(struct sh_css_isp_ecd_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->ecd_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_ecd() leave:\n");
@@ -435,67 +454,71 @@ ia_css_process_ecd(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_formats(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_formats(unsigned int pipe_id,
+				   const struct ia_css_pipeline_stage *stage,
+				   struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.formats.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.formats.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.formats.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.formats.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_formats() enter:\n");
-
-			ia_css_formats_encode((struct sh_css_isp_formats_params *)
-					      &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					      &params->formats_config,
-					      size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_formats() enter:\n");
+
+			ia_css_formats_encode(
+				(struct sh_css_isp_formats_params *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->formats_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_formats() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_formats() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_fpn(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_fpn(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.fpn.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.fpn.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.fpn.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.fpn.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_fpn() enter:\n");
 
-			ia_css_fpn_encode((struct sh_css_isp_fpn_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->fpn_config,
-					  size);
+			ia_css_fpn_encode(
+				(struct sh_css_isp_fpn_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->fpn_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_fpn() leave:\n");
@@ -505,282 +528,310 @@ ia_css_process_fpn(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_gc(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_gc(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.gc.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.gc.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.gc.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.gc.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_gc() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_gc() enter:\n");
 
-			ia_css_gc_encode((struct sh_css_isp_gc_params *)
-					 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					 &params->gc_config,
-					 size);
+			ia_css_gc_encode(
+				(struct sh_css_isp_gc_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->gc_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_gc() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_gc() leave:\n");
 		}
 	}
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vamem1.gc.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vamem1.gc.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vamem1.gc.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->vamem1.gc.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_gc() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_gc() enter:\n");
 
-			ia_css_gc_vamem_encode((struct sh_css_isp_gc_vamem_params *)
-					       &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM1].address[offset],
-					       &params->gc_table,
-					       size);
+			ia_css_gc_vamem_encode(
+				(struct sh_css_isp_gc_vamem_params *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VAMEM1]
+					.address[offset],
+				&params->gc_table, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM1] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VAMEM1] =
+				true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_gc() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_gc() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_ce(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_ce(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.ce.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.ce.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.ce.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.ce.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ce() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_ce() enter:\n");
 
-			ia_css_ce_encode((struct sh_css_isp_ce_params *)
-					 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					 &params->ce_config,
-					 size);
+			ia_css_ce_encode(
+				(struct sh_css_isp_ce_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->ce_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ce() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_ce() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_yuv2rgb(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_yuv2rgb(unsigned int pipe_id,
+				   const struct ia_css_pipeline_stage *stage,
+				   struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.yuv2rgb.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.yuv2rgb.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.yuv2rgb.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.yuv2rgb.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_yuv2rgb() enter:\n");
-
-			ia_css_yuv2rgb_encode((struct sh_css_isp_csc_params *)
-					      &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					      &params->yuv2rgb_cc_config,
-					      size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_yuv2rgb() enter:\n");
+
+			ia_css_yuv2rgb_encode(
+				(struct sh_css_isp_csc_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->yuv2rgb_cc_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_yuv2rgb() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_yuv2rgb() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_rgb2yuv(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_rgb2yuv(unsigned int pipe_id,
+				   const struct ia_css_pipeline_stage *stage,
+				   struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.rgb2yuv.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.rgb2yuv.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.rgb2yuv.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.rgb2yuv.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_rgb2yuv() enter:\n");
-
-			ia_css_rgb2yuv_encode((struct sh_css_isp_csc_params *)
-					      &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					      &params->rgb2yuv_cc_config,
-					      size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_rgb2yuv() enter:\n");
+
+			ia_css_rgb2yuv_encode(
+				(struct sh_css_isp_csc_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->rgb2yuv_cc_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_rgb2yuv() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_rgb2yuv() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_r_gamma(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_r_gamma(unsigned int pipe_id,
+				   const struct ia_css_pipeline_stage *stage,
+				   struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vamem0.r_gamma.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vamem0.r_gamma.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vamem0.r_gamma.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->vamem0.r_gamma.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_r_gamma() enter:\n");
-
-			ia_css_r_gamma_vamem_encode((struct sh_css_isp_rgb_gamma_vamem_params *)
-						    &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM0].address[offset],
-						    &params->r_gamma_table,
-						    size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_r_gamma() enter:\n");
+
+			ia_css_r_gamma_vamem_encode(
+				(struct sh_css_isp_rgb_gamma_vamem_params
+					 *)&stage->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VAMEM0]
+					.address[offset],
+				&params->r_gamma_table, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM0] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VAMEM0] =
+				true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_r_gamma() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_r_gamma() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_g_gamma(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_g_gamma(unsigned int pipe_id,
+				   const struct ia_css_pipeline_stage *stage,
+				   struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vamem1.g_gamma.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vamem1.g_gamma.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vamem1.g_gamma.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->vamem1.g_gamma.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_g_gamma() enter:\n");
-
-			ia_css_g_gamma_vamem_encode((struct sh_css_isp_rgb_gamma_vamem_params *)
-						    &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM1].address[offset],
-						    &params->g_gamma_table,
-						    size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_g_gamma() enter:\n");
+
+			ia_css_g_gamma_vamem_encode(
+				(struct sh_css_isp_rgb_gamma_vamem_params
+					 *)&stage->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VAMEM1]
+					.address[offset],
+				&params->g_gamma_table, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM1] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VAMEM1] =
+				true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_g_gamma() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_g_gamma() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_b_gamma(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_b_gamma(unsigned int pipe_id,
+				   const struct ia_css_pipeline_stage *stage,
+				   struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vamem2.b_gamma.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vamem2.b_gamma.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vamem2.b_gamma.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->vamem2.b_gamma.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_b_gamma() enter:\n");
-
-			ia_css_b_gamma_vamem_encode((struct sh_css_isp_rgb_gamma_vamem_params *)
-						    &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM2].address[offset],
-						    &params->b_gamma_table,
-						    size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_b_gamma() enter:\n");
+
+			ia_css_b_gamma_vamem_encode(
+				(struct sh_css_isp_rgb_gamma_vamem_params
+					 *)&stage->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VAMEM2]
+					.address[offset],
+				&params->b_gamma_table, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM2] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VAMEM2] =
+				true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_b_gamma() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_b_gamma() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_uds(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_uds(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.uds.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.uds.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.uds.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.uds.offset;
 
 		if (size) {
 			struct sh_css_sp_uds_params *p;
@@ -788,14 +839,17 @@ ia_css_process_uds(
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_uds() enter:\n");
 
-			p = (struct sh_css_sp_uds_params *)
-			    &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset];
+			p = (struct sh_css_sp_uds_params *)&stage->binary
+				    ->mem_params
+				    .params[IA_CSS_PARAM_CLASS_PARAM]
+					   [IA_CSS_ISP_DMEM]
+				    .address[offset];
 			p->crop_pos = params->uds_config.crop_pos;
 			p->uds = params->uds_config.uds;
 
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_uds() leave:\n");
@@ -805,32 +859,33 @@ ia_css_process_uds(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_raa(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_raa(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.raa.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.raa.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.raa.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.raa.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_raa() enter:\n");
 
-			ia_css_raa_encode((struct sh_css_isp_aa_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->raa_config,
-					  size);
+			ia_css_raa_encode(
+				(struct sh_css_isp_aa_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->raa_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_raa() leave:\n");
@@ -840,32 +895,33 @@ ia_css_process_raa(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_s3a(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_s3a(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.s3a.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.s3a.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.s3a.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.s3a.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_s3a() enter:\n");
 
-			ia_css_s3a_encode((struct sh_css_isp_s3a_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->s3a_config,
-					  size);
+			ia_css_s3a_encode(
+				(struct sh_css_isp_s3a_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->s3a_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_s3a() leave:\n");
@@ -875,86 +931,97 @@ ia_css_process_s3a(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_ob(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_ob(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.ob.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.ob.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.ob.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.ob.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ob() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_ob() enter:\n");
 
-			ia_css_ob_encode((struct sh_css_isp_ob_params *)
-					 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					 &params->ob_config,
-					 &params->stream_configs.ob, size);
+			ia_css_ob_encode(
+				(struct sh_css_isp_ob_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->ob_config, &params->stream_configs.ob,
+				size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ob() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_ob() leave:\n");
 		}
 	}
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.ob.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vmem.ob.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.ob.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->vmem.ob.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ob() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_ob() enter:\n");
 
-			ia_css_ob_vmem_encode((struct sh_css_isp_ob_vmem_params *)
-					      &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VMEM].address[offset],
-					      &params->ob_config,
-					      &params->stream_configs.ob, size);
+			ia_css_ob_vmem_encode(
+				(struct sh_css_isp_ob_vmem_params *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VMEM]
+					.address[offset],
+				&params->ob_config, &params->stream_configs.ob,
+				size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ob() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_ob() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_output(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_output(unsigned int pipe_id,
+				  const struct ia_css_pipeline_stage *stage,
+				  struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.output.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.output.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.output.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.output.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_output() enter:\n");
 
-			ia_css_output_encode((struct sh_css_isp_output_params *)
-					     &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					     &params->output_config,
-					     size);
+			ia_css_output_encode(
+				(struct sh_css_isp_output_params *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->output_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_output() leave:\n");
@@ -964,53 +1031,54 @@ ia_css_process_output(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_sc(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_sc(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.sc.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.sc.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.sc.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.sc.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_sc() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_sc() enter:\n");
 
-			ia_css_sc_encode((struct sh_css_isp_sc_params *)
-					 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					 &params->sc_config,
-					 size);
+			ia_css_sc_encode(
+				(struct sh_css_isp_sc_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->sc_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_sc() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_sc() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_bds(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_bds(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.bds.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.bds.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.bds.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.bds.offset;
 
 		if (size) {
 			struct sh_css_isp_bds_params *p;
@@ -1018,13 +1086,16 @@ ia_css_process_bds(
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_bds() enter:\n");
 
-			p = (struct sh_css_isp_bds_params *)
-			    &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset];
+			p = (struct sh_css_isp_bds_params *)&stage->binary
+				    ->mem_params
+				    .params[IA_CSS_PARAM_CLASS_PARAM]
+					   [IA_CSS_ISP_DMEM]
+				    .address[offset];
 			p->baf_strength = params->bds_config.strength;
 
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_bds() leave:\n");
@@ -1034,32 +1105,33 @@ ia_css_process_bds(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_tnr(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_tnr(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.tnr.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.tnr.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.tnr.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.tnr.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_tnr() enter:\n");
 
-			ia_css_tnr_encode((struct sh_css_isp_tnr_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->tnr_config,
-					  size);
+			ia_css_tnr_encode(
+				(struct sh_css_isp_tnr_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->tnr_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_tnr() leave:\n");
@@ -1069,32 +1141,33 @@ ia_css_process_tnr(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_macc(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_macc(unsigned int pipe_id,
+				const struct ia_css_pipeline_stage *stage,
+				struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.macc.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.macc.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.macc.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.macc.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_macc() enter:\n");
 
-			ia_css_macc_encode((struct sh_css_isp_macc_params *)
-					   &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					   &params->macc_config,
-					   size);
+			ia_css_macc_encode(
+				(struct sh_css_isp_macc_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->macc_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_macc() leave:\n");
@@ -1105,34 +1178,38 @@ ia_css_process_macc(
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
 static void
-ia_css_process_sdis_horicoef(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+ia_css_process_sdis_horicoef(unsigned int pipe_id,
+			     const struct ia_css_pipeline_stage *stage,
+			     struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.sdis_horicoef.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vmem.sdis_horicoef.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.sdis_horicoef.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->vmem.sdis_horicoef.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis_horicoef() enter:\n");
-
-			ia_css_sdis_horicoef_vmem_encode((struct sh_css_isp_sdis_hori_coef_tbl *)
-							 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VMEM].address[offset],
-							 &params->dvs_coefs,
-							 size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis_horicoef() enter:\n");
+
+			ia_css_sdis_horicoef_vmem_encode(
+				(struct sh_css_isp_sdis_hori_coef_tbl *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VMEM]
+					.address[offset],
+				&params->dvs_coefs, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis_horicoef() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis_horicoef() leave:\n");
 		}
 	}
 }
@@ -1140,34 +1217,38 @@ ia_css_process_sdis_horicoef(
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
 static void
-ia_css_process_sdis_vertcoef(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+ia_css_process_sdis_vertcoef(unsigned int pipe_id,
+			     const struct ia_css_pipeline_stage *stage,
+			     struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.sdis_vertcoef.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vmem.sdis_vertcoef.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.sdis_vertcoef.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->vmem.sdis_vertcoef.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis_vertcoef() enter:\n");
-
-			ia_css_sdis_vertcoef_vmem_encode((struct sh_css_isp_sdis_vert_coef_tbl *)
-							 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VMEM].address[offset],
-							 &params->dvs_coefs,
-							 size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis_vertcoef() enter:\n");
+
+			ia_css_sdis_vertcoef_vmem_encode(
+				(struct sh_css_isp_sdis_vert_coef_tbl *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VMEM]
+					.address[offset],
+				&params->dvs_coefs, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis_vertcoef() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis_vertcoef() leave:\n");
 		}
 	}
 }
@@ -1175,34 +1256,38 @@ ia_css_process_sdis_vertcoef(
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
 static void
-ia_css_process_sdis_horiproj(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+ia_css_process_sdis_horiproj(unsigned int pipe_id,
+			     const struct ia_css_pipeline_stage *stage,
+			     struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.sdis_horiproj.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.sdis_horiproj.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.sdis_horiproj.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.sdis_horiproj.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis_horiproj() enter:\n");
-
-			ia_css_sdis_horiproj_encode((struct sh_css_isp_sdis_hori_proj_tbl *)
-						    &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-						    &params->dvs_coefs,
-						    size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis_horiproj() enter:\n");
+
+			ia_css_sdis_horiproj_encode(
+				(struct sh_css_isp_sdis_hori_proj_tbl *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->dvs_coefs, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis_horiproj() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis_horiproj() leave:\n");
 		}
 	}
 }
@@ -1210,34 +1295,38 @@ ia_css_process_sdis_horiproj(
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
 static void
-ia_css_process_sdis_vertproj(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+ia_css_process_sdis_vertproj(unsigned int pipe_id,
+			     const struct ia_css_pipeline_stage *stage,
+			     struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.sdis_vertproj.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.sdis_vertproj.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.sdis_vertproj.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.sdis_vertproj.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis_vertproj() enter:\n");
-
-			ia_css_sdis_vertproj_encode((struct sh_css_isp_sdis_vert_proj_tbl *)
-						    &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-						    &params->dvs_coefs,
-						    size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis_vertproj() enter:\n");
+
+			ia_css_sdis_vertproj_encode(
+				(struct sh_css_isp_sdis_vert_proj_tbl *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->dvs_coefs, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis_vertproj() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis_vertproj() leave:\n");
 		}
 	}
 }
@@ -1245,34 +1334,39 @@ ia_css_process_sdis_vertproj(
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
 static void
-ia_css_process_sdis2_horicoef(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+ia_css_process_sdis2_horicoef(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.sdis2_horicoef.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vmem.sdis2_horicoef.size;
 
 		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.sdis2_horicoef.offset;
+			stage->binary->info->mem_offsets.offsets.param->vmem
+				.sdis2_horicoef.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis2_horicoef() enter:\n");
-
-			ia_css_sdis2_horicoef_vmem_encode((struct sh_css_isp_sdis_hori_coef_tbl *)
-							  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VMEM].address[offset],
-							  &params->dvs2_coefs,
-							  size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis2_horicoef() enter:\n");
+
+			ia_css_sdis2_horicoef_vmem_encode(
+				(struct sh_css_isp_sdis_hori_coef_tbl *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VMEM]
+					.address[offset],
+				&params->dvs2_coefs, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis2_horicoef() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis2_horicoef() leave:\n");
 		}
 	}
 }
@@ -1280,34 +1374,39 @@ ia_css_process_sdis2_horicoef(
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
 static void
-ia_css_process_sdis2_vertcoef(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+ia_css_process_sdis2_vertcoef(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.sdis2_vertcoef.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vmem.sdis2_vertcoef.size;
 
 		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vmem.sdis2_vertcoef.offset;
+			stage->binary->info->mem_offsets.offsets.param->vmem
+				.sdis2_vertcoef.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis2_vertcoef() enter:\n");
-
-			ia_css_sdis2_vertcoef_vmem_encode((struct sh_css_isp_sdis_vert_coef_tbl *)
-							  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VMEM].address[offset],
-							  &params->dvs2_coefs,
-							  size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis2_vertcoef() enter:\n");
+
+			ia_css_sdis2_vertcoef_vmem_encode(
+				(struct sh_css_isp_sdis_vert_coef_tbl *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VMEM]
+					.address[offset],
+				&params->dvs2_coefs, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis2_vertcoef() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis2_vertcoef() leave:\n");
 		}
 	}
 }
@@ -1315,34 +1414,39 @@ ia_css_process_sdis2_vertcoef(
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
 static void
-ia_css_process_sdis2_horiproj(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+ia_css_process_sdis2_horiproj(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.sdis2_horiproj.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.sdis2_horiproj.size;
 
 		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.sdis2_horiproj.offset;
+			stage->binary->info->mem_offsets.offsets.param->dmem
+				.sdis2_horiproj.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis2_horiproj() enter:\n");
-
-			ia_css_sdis2_horiproj_encode((struct sh_css_isp_sdis_hori_proj_tbl *)
-						     &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-						     &params->dvs2_coefs,
-						     size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis2_horiproj() enter:\n");
+
+			ia_css_sdis2_horiproj_encode(
+				(struct sh_css_isp_sdis_hori_proj_tbl *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->dvs2_coefs, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis2_horiproj() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis2_horiproj() leave:\n");
 		}
 	}
 }
@@ -1350,132 +1454,144 @@ ia_css_process_sdis2_horiproj(
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
 static void
-ia_css_process_sdis2_vertproj(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+ia_css_process_sdis2_vertproj(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.sdis2_vertproj.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.sdis2_vertproj.size;
 
 		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.sdis2_vertproj.offset;
+			stage->binary->info->mem_offsets.offsets.param->dmem
+				.sdis2_vertproj.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis2_vertproj() enter:\n");
-
-			ia_css_sdis2_vertproj_encode((struct sh_css_isp_sdis_vert_proj_tbl *)
-						     &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-						     &params->dvs2_coefs,
-						     size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis2_vertproj() enter:\n");
+
+			ia_css_sdis2_vertproj_encode(
+				(struct sh_css_isp_sdis_vert_proj_tbl *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->dvs2_coefs, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_sdis2_vertproj() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_sdis2_vertproj() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_wb(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_wb(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.wb.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.wb.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.wb.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.wb.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_wb() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_wb() enter:\n");
 
-			ia_css_wb_encode((struct sh_css_isp_wb_params *)
-					 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					 &params->wb_config,
-					 size);
+			ia_css_wb_encode(
+				(struct sh_css_isp_wb_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->wb_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_wb() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_wb() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_nr(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_nr(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.nr.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.nr.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.nr.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.nr.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_nr() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_nr() enter:\n");
 
-			ia_css_nr_encode((struct sh_css_isp_ynr_params *)
-					 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					 &params->nr_config,
-					 size);
+			ia_css_nr_encode(
+				(struct sh_css_isp_ynr_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->nr_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_nr() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_nr() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_yee(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_yee(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.yee.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.yee.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.yee.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.yee.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_yee() enter:\n");
 
-			ia_css_yee_encode((struct sh_css_isp_yee_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->yee_config,
-					  size);
+			ia_css_yee_encode(
+				(struct sh_css_isp_yee_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->yee_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_yee() leave:\n");
@@ -1485,32 +1601,33 @@ ia_css_process_yee(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_ynr(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_ynr(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.ynr.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.ynr.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.ynr.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.ynr.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_ynr() enter:\n");
 
-			ia_css_ynr_encode((struct sh_css_isp_yee2_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->ynr_config,
-					  size);
+			ia_css_ynr_encode(
+				(struct sh_css_isp_yee2_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->ynr_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_ynr() leave:\n");
@@ -1520,88 +1637,96 @@ ia_css_process_ynr(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_fc(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_fc(unsigned int pipe_id,
+			      const struct ia_css_pipeline_stage *stage,
+			      struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.fc.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.fc.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.fc.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.fc.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_fc() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_fc() enter:\n");
 
-			ia_css_fc_encode((struct sh_css_isp_fc_params *)
-					 &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					 &params->fc_config,
-					 size);
+			ia_css_fc_encode(
+				(struct sh_css_isp_fc_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->fc_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_fc() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+					    "ia_css_process_fc() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_ctc(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_ctc(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.ctc.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.ctc.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.ctc.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.ctc.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_ctc() enter:\n");
 
-			ia_css_ctc_encode((struct sh_css_isp_ctc_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->ctc_config,
-					  size);
+			ia_css_ctc_encode(
+				(struct sh_css_isp_ctc_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->ctc_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_ctc() leave:\n");
 		}
 	}
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vamem0.ctc.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vamem0.ctc.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vamem0.ctc.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->vamem0.ctc.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_ctc() enter:\n");
 
-			ia_css_ctc_vamem_encode((struct sh_css_isp_ctc_vamem_params *)
-						&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM0].address[offset],
-						&params->ctc_table,
-						size);
+			ia_css_ctc_vamem_encode(
+				(struct sh_css_isp_ctc_vamem_params *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VAMEM0]
+					.address[offset],
+				&params->ctc_table, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM0] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VAMEM0] =
+				true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_ctc() leave:\n");
@@ -1611,67 +1736,72 @@ ia_css_process_ctc(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_xnr_table(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_xnr_table(unsigned int pipe_id,
+				     const struct ia_css_pipeline_stage *stage,
+				     struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->vamem1.xnr_table.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->vamem1.xnr_table.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->vamem1.xnr_table.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->vamem1.xnr_table.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_xnr_table() enter:\n");
-
-			ia_css_xnr_table_vamem_encode((struct sh_css_isp_xnr_vamem_params *)
-						      &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM1].address[offset],
-						      &params->xnr_table,
-						      size);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_xnr_table() enter:\n");
+
+			ia_css_xnr_table_vamem_encode(
+				(struct sh_css_isp_xnr_vamem_params *)&stage
+					->binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_VAMEM1]
+					.address[offset],
+				&params->xnr_table, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM1] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_VAMEM1] =
+				true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-					    "ia_css_process_xnr_table() leave:\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE_PRIVATE,
+				"ia_css_process_xnr_table() leave:\n");
 		}
 	}
 }
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_xnr(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_xnr(unsigned int pipe_id,
+			       const struct ia_css_pipeline_stage *stage,
+			       struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.xnr.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.xnr.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.xnr.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.xnr.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_xnr() enter:\n");
 
-			ia_css_xnr_encode((struct sh_css_isp_xnr_params *)
-					  &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					  &params->xnr_config,
-					  size);
+			ia_css_xnr_encode(
+				(struct sh_css_isp_xnr_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->xnr_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_xnr() leave:\n");
@@ -1681,32 +1811,33 @@ ia_css_process_xnr(
 
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
-static void
-ia_css_process_xnr3(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params)
+static void ia_css_process_xnr3(unsigned int pipe_id,
+				const struct ia_css_pipeline_stage *stage,
+				struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	{
-		unsigned int size   =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.xnr3.size;
+		unsigned int size = stage->binary->info->mem_offsets.offsets
+					    .param->dmem.xnr3.size;
 
-		unsigned int offset =
-		    stage->binary->info->mem_offsets.offsets.param->dmem.xnr3.offset;
+		unsigned int offset = stage->binary->info->mem_offsets.offsets
+					      .param->dmem.xnr3.offset;
 
 		if (size) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_xnr3() enter:\n");
 
-			ia_css_xnr3_encode((struct sh_css_isp_xnr3_params *)
-					   &stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					   &params->xnr3_config,
-					   size);
+			ia_css_xnr3_encode(
+				(struct sh_css_isp_xnr3_params *)&stage->binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_PARAM]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				&params->xnr3_config, size);
 			params->isp_params_changed = true;
-			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] =
-			    true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num]
+						      [IA_CSS_ISP_DMEM] = true;
 
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 					    "ia_css_process_xnr3() leave:\n");
@@ -1717,9 +1848,8 @@ ia_css_process_xnr3(
 /* Code generated by genparam/gencode.c:gen_param_process_table() */
 
 void (*ia_css_kernel_process_param[IA_CSS_NUM_PARAMETER_IDS])(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params) = {
+	unsigned int pipe_id, const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params) = {
 	ia_css_process_aa,
 	ia_css_process_anr,
 	ia_css_process_anr2,
@@ -1770,9 +1900,8 @@ void (*ia_css_kernel_process_param[IA_CSS_NUM_PARAMETER_IDS])(
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_dp_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_dp_config *config)
+static void ia_css_get_dp_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_dp_config *config)
 {
 	if (!config)
 		return;
@@ -1791,15 +1920,15 @@ ia_css_get_dp_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_dp_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_dp_config *config)
+void ia_css_set_dp_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_dp_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_dp_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_dp_config() enter:\n");
 	ia_css_dp_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->dp_config = *config;
 	params->config_changed[IA_CSS_DP_ID] = true;
@@ -1809,9 +1938,8 @@ ia_css_set_dp_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_wb_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_wb_config *config)
+static void ia_css_get_wb_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_wb_config *config)
 {
 	if (!config)
 		return;
@@ -1830,15 +1958,15 @@ ia_css_get_wb_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_wb_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_wb_config *config)
+void ia_css_set_wb_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_wb_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_wb_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_wb_config() enter:\n");
 	ia_css_wb_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->wb_config = *config;
 	params->config_changed[IA_CSS_WB_ID] = true;
@@ -1848,9 +1976,8 @@ ia_css_set_wb_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_tnr_config(const struct ia_css_isp_parameters *params,
-		      struct ia_css_tnr_config *config)
+static void ia_css_get_tnr_config(const struct ia_css_isp_parameters *params,
+				  struct ia_css_tnr_config *config)
 {
 	if (!config)
 		return;
@@ -1869,15 +1996,15 @@ ia_css_get_tnr_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_tnr_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_tnr_config *config)
+void ia_css_set_tnr_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_tnr_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_tnr_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_tnr_config() enter:\n");
 	ia_css_tnr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->tnr_config = *config;
 	params->config_changed[IA_CSS_TNR_ID] = true;
@@ -1887,9 +2014,8 @@ ia_css_set_tnr_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_ob_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_ob_config *config)
+static void ia_css_get_ob_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_ob_config *config)
 {
 	if (!config)
 		return;
@@ -1908,15 +2034,15 @@ ia_css_get_ob_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_ob_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_ob_config *config)
+void ia_css_set_ob_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_ob_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_ob_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_ob_config() enter:\n");
 	ia_css_ob_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->ob_config = *config;
 	params->config_changed[IA_CSS_OB_ID] = true;
@@ -1926,9 +2052,8 @@ ia_css_set_ob_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_de_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_de_config *config)
+static void ia_css_get_de_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_de_config *config)
 {
 	if (!config)
 		return;
@@ -1947,15 +2072,15 @@ ia_css_get_de_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_de_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_de_config *config)
+void ia_css_set_de_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_de_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_de_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_de_config() enter:\n");
 	ia_css_de_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->de_config = *config;
 	params->config_changed[IA_CSS_DE_ID] = true;
@@ -1965,9 +2090,8 @@ ia_css_set_de_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_anr_config(const struct ia_css_isp_parameters *params,
-		      struct ia_css_anr_config *config)
+static void ia_css_get_anr_config(const struct ia_css_isp_parameters *params,
+				  struct ia_css_anr_config *config)
 {
 	if (!config)
 		return;
@@ -1986,15 +2110,15 @@ ia_css_get_anr_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_anr_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_anr_config *config)
+void ia_css_set_anr_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_anr_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_anr_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_anr_config() enter:\n");
 	ia_css_anr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->anr_config = *config;
 	params->config_changed[IA_CSS_ANR_ID] = true;
@@ -2004,9 +2128,8 @@ ia_css_set_anr_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_anr2_config(const struct ia_css_isp_parameters *params,
-		       struct ia_css_anr_thres *config)
+static void ia_css_get_anr2_config(const struct ia_css_isp_parameters *params,
+				   struct ia_css_anr_thres *config)
 {
 	if (!config)
 		return;
@@ -2025,15 +2148,15 @@ ia_css_get_anr2_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_anr2_config(struct ia_css_isp_parameters *params,
-		       const struct ia_css_anr_thres *config)
+void ia_css_set_anr2_config(struct ia_css_isp_parameters *params,
+			    const struct ia_css_anr_thres *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_anr2_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_anr2_config() enter:\n");
 	ia_css_anr2_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->anr_thres = *config;
 	params->config_changed[IA_CSS_ANR2_ID] = true;
@@ -2043,9 +2166,8 @@ ia_css_set_anr2_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_ce_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_ce_config *config)
+static void ia_css_get_ce_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_ce_config *config)
 {
 	if (!config)
 		return;
@@ -2064,15 +2186,15 @@ ia_css_get_ce_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_ce_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_ce_config *config)
+void ia_css_set_ce_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_ce_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_ce_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_ce_config() enter:\n");
 	ia_css_ce_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->ce_config = *config;
 	params->config_changed[IA_CSS_CE_ID] = true;
@@ -2082,9 +2204,8 @@ ia_css_set_ce_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_ecd_config(const struct ia_css_isp_parameters *params,
-		      struct ia_css_ecd_config *config)
+static void ia_css_get_ecd_config(const struct ia_css_isp_parameters *params,
+				  struct ia_css_ecd_config *config)
 {
 	if (!config)
 		return;
@@ -2103,15 +2224,15 @@ ia_css_get_ecd_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_ecd_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_ecd_config *config)
+void ia_css_set_ecd_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_ecd_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_ecd_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_ecd_config() enter:\n");
 	ia_css_ecd_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->ecd_config = *config;
 	params->config_changed[IA_CSS_ECD_ID] = true;
@@ -2121,9 +2242,8 @@ ia_css_set_ecd_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_ynr_config(const struct ia_css_isp_parameters *params,
-		      struct ia_css_ynr_config *config)
+static void ia_css_get_ynr_config(const struct ia_css_isp_parameters *params,
+				  struct ia_css_ynr_config *config)
 {
 	if (!config)
 		return;
@@ -2142,15 +2262,15 @@ ia_css_get_ynr_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_ynr_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_ynr_config *config)
+void ia_css_set_ynr_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_ynr_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_ynr_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_ynr_config() enter:\n");
 	ia_css_ynr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->ynr_config = *config;
 	params->config_changed[IA_CSS_YNR_ID] = true;
@@ -2160,9 +2280,8 @@ ia_css_set_ynr_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_fc_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_fc_config *config)
+static void ia_css_get_fc_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_fc_config *config)
 {
 	if (!config)
 		return;
@@ -2181,15 +2300,15 @@ ia_css_get_fc_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_fc_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_fc_config *config)
+void ia_css_set_fc_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_fc_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_fc_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_fc_config() enter:\n");
 	ia_css_fc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->fc_config = *config;
 	params->config_changed[IA_CSS_FC_ID] = true;
@@ -2199,9 +2318,8 @@ ia_css_set_fc_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_cnr_config(const struct ia_css_isp_parameters *params,
-		      struct ia_css_cnr_config *config)
+static void ia_css_get_cnr_config(const struct ia_css_isp_parameters *params,
+				  struct ia_css_cnr_config *config)
 {
 	if (!config)
 		return;
@@ -2220,15 +2338,15 @@ ia_css_get_cnr_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_cnr_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_cnr_config *config)
+void ia_css_set_cnr_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_cnr_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_cnr_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_cnr_config() enter:\n");
 	ia_css_cnr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->cnr_config = *config;
 	params->config_changed[IA_CSS_CNR_ID] = true;
@@ -2238,9 +2356,8 @@ ia_css_set_cnr_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_macc_config(const struct ia_css_isp_parameters *params,
-		       struct ia_css_macc_config *config)
+static void ia_css_get_macc_config(const struct ia_css_isp_parameters *params,
+				   struct ia_css_macc_config *config)
 {
 	if (!config)
 		return;
@@ -2259,15 +2376,15 @@ ia_css_get_macc_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_macc_config(struct ia_css_isp_parameters *params,
-		       const struct ia_css_macc_config *config)
+void ia_css_set_macc_config(struct ia_css_isp_parameters *params,
+			    const struct ia_css_macc_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_macc_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_macc_config() enter:\n");
 	ia_css_macc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->macc_config = *config;
 	params->config_changed[IA_CSS_MACC_ID] = true;
@@ -2277,9 +2394,8 @@ ia_css_set_macc_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_ctc_config(const struct ia_css_isp_parameters *params,
-		      struct ia_css_ctc_config *config)
+static void ia_css_get_ctc_config(const struct ia_css_isp_parameters *params,
+				  struct ia_css_ctc_config *config)
 {
 	if (!config)
 		return;
@@ -2298,15 +2414,15 @@ ia_css_get_ctc_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_ctc_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_ctc_config *config)
+void ia_css_set_ctc_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_ctc_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_ctc_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_ctc_config() enter:\n");
 	ia_css_ctc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->ctc_config = *config;
 	params->config_changed[IA_CSS_CTC_ID] = true;
@@ -2316,9 +2432,8 @@ ia_css_set_ctc_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_aa_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_aa_config *config)
+static void ia_css_get_aa_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_aa_config *config)
 {
 	if (!config)
 		return;
@@ -2336,15 +2451,15 @@ ia_css_get_aa_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_aa_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_aa_config *config)
+void ia_css_set_aa_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_aa_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_aa_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_aa_config() enter:\n");
 	params->aa_config = *config;
 	params->config_changed[IA_CSS_AA_ID] = true;
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
@@ -2374,15 +2489,15 @@ ia_css_get_yuv2rgb_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_yuv2rgb_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_cc_config *config)
+void ia_css_set_yuv2rgb_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_cc_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_yuv2rgb_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_yuv2rgb_config() enter:\n");
 	ia_css_yuv2rgb_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->yuv2rgb_cc_config = *config;
 	params->config_changed[IA_CSS_YUV2RGB_ID] = true;
@@ -2413,15 +2528,15 @@ ia_css_get_rgb2yuv_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_rgb2yuv_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_cc_config *config)
+void ia_css_set_rgb2yuv_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_cc_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_rgb2yuv_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_rgb2yuv_config() enter:\n");
 	ia_css_rgb2yuv_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->rgb2yuv_cc_config = *config;
 	params->config_changed[IA_CSS_RGB2YUV_ID] = true;
@@ -2431,9 +2546,8 @@ ia_css_set_rgb2yuv_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_csc_config(const struct ia_css_isp_parameters *params,
-		      struct ia_css_cc_config *config)
+static void ia_css_get_csc_config(const struct ia_css_isp_parameters *params,
+				  struct ia_css_cc_config *config)
 {
 	if (!config)
 		return;
@@ -2452,15 +2566,15 @@ ia_css_get_csc_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_csc_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_cc_config *config)
+void ia_css_set_csc_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_cc_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_csc_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_csc_config() enter:\n");
 	ia_css_csc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->cc_config = *config;
 	params->config_changed[IA_CSS_CSC_ID] = true;
@@ -2470,9 +2584,8 @@ ia_css_set_csc_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_nr_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_nr_config *config)
+static void ia_css_get_nr_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_nr_config *config)
 {
 	if (!config)
 		return;
@@ -2491,15 +2604,15 @@ ia_css_get_nr_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_nr_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_nr_config *config)
+void ia_css_set_nr_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_nr_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_nr_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_nr_config() enter:\n");
 	ia_css_nr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->nr_config = *config;
 	params->config_changed[IA_CSS_BNR_ID] = true;
@@ -2510,9 +2623,8 @@ ia_css_set_nr_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_gc_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_gc_config *config)
+static void ia_css_get_gc_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_gc_config *config)
 {
 	if (!config)
 		return;
@@ -2531,15 +2643,15 @@ ia_css_get_gc_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_gc_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_gc_config *config)
+void ia_css_set_gc_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_gc_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_gc_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_gc_config() enter:\n");
 	ia_css_gc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->gc_config = *config;
 	params->config_changed[IA_CSS_GC_ID] = true;
@@ -2557,9 +2669,9 @@ ia_css_get_sdis_horicoef_config(const struct ia_css_isp_parameters *params,
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_get_sdis_horicoef_config() enter: config=%p\n",
-			    config);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_get_sdis_horicoef_config() enter: config=%p\n", config);
 
 	*config = params->dvs_coefs;
 
@@ -2570,9 +2682,9 @@ ia_css_get_sdis_horicoef_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis_horicoef_config(struct ia_css_isp_parameters *params,
-				const struct ia_css_dvs_coefficients *config)
+void ia_css_set_sdis_horicoef_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_coefficients *config)
 {
 	if (!config)
 		return;
@@ -2586,8 +2698,9 @@ ia_css_set_sdis_horicoef_config(struct ia_css_isp_parameters *params,
 	params->config_changed[IA_CSS_SDIS_VERTCOEF_ID] = true;
 	params->config_changed[IA_CSS_SDIS_HORIPROJ_ID] = true;
 	params->config_changed[IA_CSS_SDIS_VERTPROJ_ID] = true;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_set_sdis_horicoef_config() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_set_sdis_horicoef_config() leave: return_void\n");
 }
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
@@ -2600,9 +2713,9 @@ ia_css_get_sdis_vertcoef_config(const struct ia_css_isp_parameters *params,
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_get_sdis_vertcoef_config() enter: config=%p\n",
-			    config);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_get_sdis_vertcoef_config() enter: config=%p\n", config);
 
 	*config = params->dvs_coefs;
 
@@ -2613,9 +2726,9 @@ ia_css_get_sdis_vertcoef_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis_vertcoef_config(struct ia_css_isp_parameters *params,
-				const struct ia_css_dvs_coefficients *config)
+void ia_css_set_sdis_vertcoef_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_coefficients *config)
 {
 	if (!config)
 		return;
@@ -2629,8 +2742,9 @@ ia_css_set_sdis_vertcoef_config(struct ia_css_isp_parameters *params,
 	params->config_changed[IA_CSS_SDIS_VERTCOEF_ID] = true;
 	params->config_changed[IA_CSS_SDIS_HORIPROJ_ID] = true;
 	params->config_changed[IA_CSS_SDIS_VERTPROJ_ID] = true;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_set_sdis_vertcoef_config() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_set_sdis_vertcoef_config() leave: return_void\n");
 }
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
@@ -2643,9 +2757,9 @@ ia_css_get_sdis_horiproj_config(const struct ia_css_isp_parameters *params,
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_get_sdis_horiproj_config() enter: config=%p\n",
-			    config);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_get_sdis_horiproj_config() enter: config=%p\n", config);
 
 	*config = params->dvs_coefs;
 
@@ -2656,9 +2770,9 @@ ia_css_get_sdis_horiproj_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis_horiproj_config(struct ia_css_isp_parameters *params,
-				const struct ia_css_dvs_coefficients *config)
+void ia_css_set_sdis_horiproj_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_coefficients *config)
 {
 	if (!config)
 		return;
@@ -2672,8 +2786,9 @@ ia_css_set_sdis_horiproj_config(struct ia_css_isp_parameters *params,
 	params->config_changed[IA_CSS_SDIS_VERTCOEF_ID] = true;
 	params->config_changed[IA_CSS_SDIS_HORIPROJ_ID] = true;
 	params->config_changed[IA_CSS_SDIS_VERTPROJ_ID] = true;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_set_sdis_horiproj_config() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_set_sdis_horiproj_config() leave: return_void\n");
 }
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
@@ -2686,9 +2801,9 @@ ia_css_get_sdis_vertproj_config(const struct ia_css_isp_parameters *params,
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_get_sdis_vertproj_config() enter: config=%p\n",
-			    config);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_get_sdis_vertproj_config() enter: config=%p\n", config);
 
 	*config = params->dvs_coefs;
 
@@ -2699,9 +2814,9 @@ ia_css_get_sdis_vertproj_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis_vertproj_config(struct ia_css_isp_parameters *params,
-				const struct ia_css_dvs_coefficients *config)
+void ia_css_set_sdis_vertproj_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_coefficients *config)
 {
 	if (!config)
 		return;
@@ -2715,8 +2830,9 @@ ia_css_set_sdis_vertproj_config(struct ia_css_isp_parameters *params,
 	params->config_changed[IA_CSS_SDIS_VERTCOEF_ID] = true;
 	params->config_changed[IA_CSS_SDIS_HORIPROJ_ID] = true;
 	params->config_changed[IA_CSS_SDIS_VERTPROJ_ID] = true;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_set_sdis_vertproj_config() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_set_sdis_vertproj_config() leave: return_void\n");
 }
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
@@ -2729,9 +2845,10 @@ ia_css_get_sdis2_horicoef_config(const struct ia_css_isp_parameters *params,
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_get_sdis2_horicoef_config() enter: config=%p\n",
-			    config);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_get_sdis2_horicoef_config() enter: config=%p\n",
+		config);
 
 	*config = params->dvs2_coefs;
 
@@ -2742,9 +2859,9 @@ ia_css_get_sdis2_horicoef_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis2_horicoef_config(struct ia_css_isp_parameters *params,
-				 const struct ia_css_dvs2_coefficients *config)
+void ia_css_set_sdis2_horicoef_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs2_coefficients *config)
 {
 	if (!config)
 		return;
@@ -2758,8 +2875,9 @@ ia_css_set_sdis2_horicoef_config(struct ia_css_isp_parameters *params,
 	params->config_changed[IA_CSS_SDIS2_VERTCOEF_ID] = true;
 	params->config_changed[IA_CSS_SDIS2_HORIPROJ_ID] = true;
 	params->config_changed[IA_CSS_SDIS2_VERTPROJ_ID] = true;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_set_sdis2_horicoef_config() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_set_sdis2_horicoef_config() leave: return_void\n");
 }
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
@@ -2772,9 +2890,10 @@ ia_css_get_sdis2_vertcoef_config(const struct ia_css_isp_parameters *params,
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_get_sdis2_vertcoef_config() enter: config=%p\n",
-			    config);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_get_sdis2_vertcoef_config() enter: config=%p\n",
+		config);
 
 	*config = params->dvs2_coefs;
 
@@ -2785,9 +2904,9 @@ ia_css_get_sdis2_vertcoef_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis2_vertcoef_config(struct ia_css_isp_parameters *params,
-				 const struct ia_css_dvs2_coefficients *config)
+void ia_css_set_sdis2_vertcoef_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs2_coefficients *config)
 {
 	if (!config)
 		return;
@@ -2801,8 +2920,9 @@ ia_css_set_sdis2_vertcoef_config(struct ia_css_isp_parameters *params,
 	params->config_changed[IA_CSS_SDIS2_VERTCOEF_ID] = true;
 	params->config_changed[IA_CSS_SDIS2_HORIPROJ_ID] = true;
 	params->config_changed[IA_CSS_SDIS2_VERTPROJ_ID] = true;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_set_sdis2_vertcoef_config() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_set_sdis2_vertcoef_config() leave: return_void\n");
 }
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
@@ -2815,9 +2935,10 @@ ia_css_get_sdis2_horiproj_config(const struct ia_css_isp_parameters *params,
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_get_sdis2_horiproj_config() enter: config=%p\n",
-			    config);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_get_sdis2_horiproj_config() enter: config=%p\n",
+		config);
 
 	*config = params->dvs2_coefs;
 
@@ -2828,9 +2949,9 @@ ia_css_get_sdis2_horiproj_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis2_horiproj_config(struct ia_css_isp_parameters *params,
-				 const struct ia_css_dvs2_coefficients *config)
+void ia_css_set_sdis2_horiproj_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs2_coefficients *config)
 {
 	if (!config)
 		return;
@@ -2844,8 +2965,9 @@ ia_css_set_sdis2_horiproj_config(struct ia_css_isp_parameters *params,
 	params->config_changed[IA_CSS_SDIS2_VERTCOEF_ID] = true;
 	params->config_changed[IA_CSS_SDIS2_HORIPROJ_ID] = true;
 	params->config_changed[IA_CSS_SDIS2_VERTPROJ_ID] = true;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_set_sdis2_horiproj_config() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_set_sdis2_horiproj_config() leave: return_void\n");
 }
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
@@ -2858,9 +2980,10 @@ ia_css_get_sdis2_vertproj_config(const struct ia_css_isp_parameters *params,
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_get_sdis2_vertproj_config() enter: config=%p\n",
-			    config);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_get_sdis2_vertproj_config() enter: config=%p\n",
+		config);
 
 	*config = params->dvs2_coefs;
 
@@ -2871,9 +2994,9 @@ ia_css_get_sdis2_vertproj_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis2_vertproj_config(struct ia_css_isp_parameters *params,
-				 const struct ia_css_dvs2_coefficients *config)
+void ia_css_set_sdis2_vertproj_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs2_coefficients *config)
 {
 	if (!config)
 		return;
@@ -2887,8 +3010,9 @@ ia_css_set_sdis2_vertproj_config(struct ia_css_isp_parameters *params,
 	params->config_changed[IA_CSS_SDIS2_VERTCOEF_ID] = true;
 	params->config_changed[IA_CSS_SDIS2_HORIPROJ_ID] = true;
 	params->config_changed[IA_CSS_SDIS2_VERTPROJ_ID] = true;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_set_sdis2_vertproj_config() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_set_sdis2_vertproj_config() leave: return_void\n");
 }
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
@@ -2914,15 +3038,15 @@ ia_css_get_r_gamma_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_r_gamma_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_rgb_gamma_table *config)
+void ia_css_set_r_gamma_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_rgb_gamma_table *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_r_gamma_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_r_gamma_config() enter:\n");
 	ia_css_r_gamma_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->r_gamma_table = *config;
 	params->config_changed[IA_CSS_R_GAMMA_ID] = true;
@@ -2953,15 +3077,15 @@ ia_css_get_g_gamma_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_g_gamma_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_rgb_gamma_table *config)
+void ia_css_set_g_gamma_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_rgb_gamma_table *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_g_gamma_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_g_gamma_config() enter:\n");
 	ia_css_g_gamma_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->g_gamma_table = *config;
 	params->config_changed[IA_CSS_G_GAMMA_ID] = true;
@@ -2992,15 +3116,15 @@ ia_css_get_b_gamma_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_b_gamma_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_rgb_gamma_table *config)
+void ia_css_set_b_gamma_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_rgb_gamma_table *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_b_gamma_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_b_gamma_config() enter:\n");
 	ia_css_b_gamma_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->b_gamma_table = *config;
 	params->config_changed[IA_CSS_B_GAMMA_ID] = true;
@@ -3031,9 +3155,8 @@ ia_css_get_xnr_table_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_xnr_table_config(struct ia_css_isp_parameters *params,
-			    const struct ia_css_xnr_table *config)
+void ia_css_set_xnr_table_config(struct ia_css_isp_parameters *params,
+				 const struct ia_css_xnr_table *config)
 {
 	if (!config)
 		return;
@@ -3044,8 +3167,9 @@ ia_css_set_xnr_table_config(struct ia_css_isp_parameters *params,
 	ia_css_xnr_table_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->xnr_table = *config;
 	params->config_changed[IA_CSS_XNR_TABLE_ID] = true;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_set_xnr_table_config() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_set_xnr_table_config() leave: return_void\n");
 }
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
@@ -3071,15 +3195,15 @@ ia_css_get_formats_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_formats_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_formats_config *config)
+void ia_css_set_formats_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_formats_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_formats_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_formats_config() enter:\n");
 	ia_css_formats_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->formats_config = *config;
 	params->config_changed[IA_CSS_FORMATS_ID] = true;
@@ -3089,9 +3213,8 @@ ia_css_set_formats_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_xnr_config(const struct ia_css_isp_parameters *params,
-		      struct ia_css_xnr_config *config)
+static void ia_css_get_xnr_config(const struct ia_css_isp_parameters *params,
+				  struct ia_css_xnr_config *config)
 {
 	if (!config)
 		return;
@@ -3110,15 +3233,15 @@ ia_css_get_xnr_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_xnr_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_xnr_config *config)
+void ia_css_set_xnr_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_xnr_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_xnr_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_xnr_config() enter:\n");
 	ia_css_xnr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->xnr_config = *config;
 	params->config_changed[IA_CSS_XNR_ID] = true;
@@ -3128,9 +3251,8 @@ ia_css_set_xnr_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_xnr3_config(const struct ia_css_isp_parameters *params,
-		       struct ia_css_xnr3_config *config)
+static void ia_css_get_xnr3_config(const struct ia_css_isp_parameters *params,
+				   struct ia_css_xnr3_config *config)
 {
 	if (!config)
 		return;
@@ -3149,15 +3271,15 @@ ia_css_get_xnr3_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_xnr3_config(struct ia_css_isp_parameters *params,
-		       const struct ia_css_xnr3_config *config)
+void ia_css_set_xnr3_config(struct ia_css_isp_parameters *params,
+			    const struct ia_css_xnr3_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_xnr3_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_xnr3_config() enter:\n");
 	ia_css_xnr3_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->xnr3_config = *config;
 	params->config_changed[IA_CSS_XNR3_ID] = true;
@@ -3167,9 +3289,8 @@ ia_css_set_xnr3_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_s3a_config(const struct ia_css_isp_parameters *params,
-		      struct ia_css_3a_config *config)
+static void ia_css_get_s3a_config(const struct ia_css_isp_parameters *params,
+				  struct ia_css_3a_config *config)
 {
 	if (!config)
 		return;
@@ -3188,15 +3309,15 @@ ia_css_get_s3a_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_s3a_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_3a_config *config)
+void ia_css_set_s3a_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_3a_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_s3a_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_s3a_config() enter:\n");
 	ia_css_s3a_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->s3a_config = *config;
 	params->config_changed[IA_CSS_BH_ID] = true;
@@ -3207,9 +3328,8 @@ ia_css_set_s3a_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_get_function() */
 
-static void
-ia_css_get_output_config(const struct ia_css_isp_parameters *params,
-			 struct ia_css_output_config *config)
+static void ia_css_get_output_config(const struct ia_css_isp_parameters *params,
+				     struct ia_css_output_config *config)
 {
 	if (!config)
 		return;
@@ -3228,15 +3348,15 @@ ia_css_get_output_config(const struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_output_config(struct ia_css_isp_parameters *params,
-			 const struct ia_css_output_config *config)
+void ia_css_set_output_config(struct ia_css_isp_parameters *params,
+			      const struct ia_css_output_config *config)
 {
 	if (!config)
 		return;
 
 	assert(params);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_output_config() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_output_config() enter:\n");
 	ia_css_output_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	params->output_config = *config;
 	params->config_changed[IA_CSS_OUTPUT_ID] = true;
@@ -3246,9 +3366,8 @@ ia_css_set_output_config(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_global_access_function() */
 
-void
-ia_css_get_configs(struct ia_css_isp_parameters *params,
-		   const struct ia_css_isp_config *config)
+void ia_css_get_configs(struct ia_css_isp_parameters *params,
+			const struct ia_css_isp_config *config)
 {
 	ia_css_get_dp_config(params, config->dp_config);
 	ia_css_get_wb_config(params, config->wb_config);
@@ -3291,9 +3410,8 @@ ia_css_get_configs(struct ia_css_isp_parameters *params,
 
 /* Code generated by genparam/gencode.c:gen_global_access_function() */
 
-void
-ia_css_set_configs(struct ia_css_isp_parameters *params,
-		   const struct ia_css_isp_config *config)
+void ia_css_set_configs(struct ia_css_isp_parameters *params,
+			const struct ia_css_isp_config *config)
 {
 	ia_css_set_dp_config(params, config->dp_config);
 	ia_css_set_wb_config(params, config->wb_config);
diff --git a/drivers/staging/media/atomisp/pci/ia_css_isp_params.h b/drivers/staging/media/atomisp/pci/ia_css_isp_params.h
index a542f8979905eeea232968d28343b1d4fb06b033..bdff6dd5c566b74ccddff77d1bd4de6def8eddd2 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_isp_params.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_isp_params.h
@@ -132,252 +132,218 @@ struct ia_css_memory_offsets {
 
 #if defined(IA_CSS_INCLUDE_PARAMETERS)
 
-#include "ia_css_stream.h"   /* struct ia_css_stream */
-#include "ia_css_binary.h"   /* struct ia_css_binary */
+#include "ia_css_stream.h" /* struct ia_css_stream */
+#include "ia_css_binary.h" /* struct ia_css_binary */
 /* Code generated by genparam/gencode.c:gen_param_process_table() */
 
 struct ia_css_pipeline_stage; /* forward declaration */
 
 extern void (*ia_css_kernel_process_param[IA_CSS_NUM_PARAMETER_IDS])(
-    unsigned int pipe_id,
-    const struct ia_css_pipeline_stage *stage,
-    struct ia_css_isp_parameters *params);
+	unsigned int pipe_id, const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_dp_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_dp_config *config);
+void ia_css_set_dp_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_dp_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_wb_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_wb_config *config);
+void ia_css_set_wb_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_wb_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_tnr_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_tnr_config *config);
+void ia_css_set_tnr_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_tnr_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_ob_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_ob_config *config);
+void ia_css_set_ob_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_ob_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_de_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_de_config *config);
+void ia_css_set_de_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_de_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_anr_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_anr_config *config);
+void ia_css_set_anr_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_anr_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_anr2_config(struct ia_css_isp_parameters *params,
-		       const struct ia_css_anr_thres *config);
+void ia_css_set_anr2_config(struct ia_css_isp_parameters *params,
+			    const struct ia_css_anr_thres *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_ce_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_ce_config *config);
+void ia_css_set_ce_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_ce_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_ecd_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_ecd_config *config);
+void ia_css_set_ecd_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_ecd_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_ynr_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_ynr_config *config);
+void ia_css_set_ynr_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_ynr_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_fc_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_fc_config *config);
+void ia_css_set_fc_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_fc_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_cnr_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_cnr_config *config);
+void ia_css_set_cnr_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_cnr_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_macc_config(struct ia_css_isp_parameters *params,
-		       const struct ia_css_macc_config *config);
+void ia_css_set_macc_config(struct ia_css_isp_parameters *params,
+			    const struct ia_css_macc_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_ctc_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_ctc_config *config);
+void ia_css_set_ctc_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_ctc_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_aa_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_aa_config *config);
+void ia_css_set_aa_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_aa_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_yuv2rgb_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_cc_config *config);
+void ia_css_set_yuv2rgb_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_cc_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_rgb2yuv_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_cc_config *config);
+void ia_css_set_rgb2yuv_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_cc_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_csc_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_cc_config *config);
+void ia_css_set_csc_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_cc_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_nr_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_nr_config *config);
+void ia_css_set_nr_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_nr_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_gc_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_gc_config *config);
+void ia_css_set_gc_config(struct ia_css_isp_parameters *params,
+			  const struct ia_css_gc_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis_horicoef_config(struct ia_css_isp_parameters *params,
-				const struct ia_css_dvs_coefficients *config);
+void ia_css_set_sdis_horicoef_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_coefficients *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis_vertcoef_config(struct ia_css_isp_parameters *params,
-				const struct ia_css_dvs_coefficients *config);
+void ia_css_set_sdis_vertcoef_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_coefficients *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis_horiproj_config(struct ia_css_isp_parameters *params,
-				const struct ia_css_dvs_coefficients *config);
+void ia_css_set_sdis_horiproj_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_coefficients *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis_vertproj_config(struct ia_css_isp_parameters *params,
-				const struct ia_css_dvs_coefficients *config);
+void ia_css_set_sdis_vertproj_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_coefficients *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis2_horicoef_config(struct ia_css_isp_parameters *params,
-				 const struct ia_css_dvs2_coefficients *config);
+void ia_css_set_sdis2_horicoef_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs2_coefficients *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis2_vertcoef_config(struct ia_css_isp_parameters *params,
-				 const struct ia_css_dvs2_coefficients *config);
+void ia_css_set_sdis2_vertcoef_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs2_coefficients *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis2_horiproj_config(struct ia_css_isp_parameters *params,
-				 const struct ia_css_dvs2_coefficients *config);
+void ia_css_set_sdis2_horiproj_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs2_coefficients *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_sdis2_vertproj_config(struct ia_css_isp_parameters *params,
-				 const struct ia_css_dvs2_coefficients *config);
+void ia_css_set_sdis2_vertproj_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs2_coefficients *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_r_gamma_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_rgb_gamma_table *config);
+void ia_css_set_r_gamma_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_rgb_gamma_table *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_g_gamma_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_rgb_gamma_table *config);
+void ia_css_set_g_gamma_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_rgb_gamma_table *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_b_gamma_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_rgb_gamma_table *config);
+void ia_css_set_b_gamma_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_rgb_gamma_table *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_xnr_table_config(struct ia_css_isp_parameters *params,
-			    const struct ia_css_xnr_table *config);
+void ia_css_set_xnr_table_config(struct ia_css_isp_parameters *params,
+				 const struct ia_css_xnr_table *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_formats_config(struct ia_css_isp_parameters *params,
-			  const struct ia_css_formats_config *config);
+void ia_css_set_formats_config(struct ia_css_isp_parameters *params,
+			       const struct ia_css_formats_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_xnr_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_xnr_config *config);
+void ia_css_set_xnr_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_xnr_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_xnr3_config(struct ia_css_isp_parameters *params,
-		       const struct ia_css_xnr3_config *config);
+void ia_css_set_xnr3_config(struct ia_css_isp_parameters *params,
+			    const struct ia_css_xnr3_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_s3a_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_3a_config *config);
+void ia_css_set_s3a_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_3a_config *config);
 
 /* Code generated by genparam/gencode.c:gen_set_function() */
 
-void
-ia_css_set_output_config(struct ia_css_isp_parameters *params,
-			 const struct ia_css_output_config *config);
+void ia_css_set_output_config(struct ia_css_isp_parameters *params,
+			      const struct ia_css_output_config *config);
 
 /* Code generated by genparam/gencode.c:gen_global_access_function() */
 
-void
-ia_css_get_configs(struct ia_css_isp_parameters *params,
-		   const struct ia_css_isp_config *config)
-;
+void ia_css_get_configs(struct ia_css_isp_parameters *params,
+			const struct ia_css_isp_config *config);
 
 /* Code generated by genparam/gencode.c:gen_global_access_function() */
 
-void
-ia_css_set_configs(struct ia_css_isp_parameters *params,
-		   const struct ia_css_isp_config *config)
-;
+void ia_css_set_configs(struct ia_css_isp_parameters *params,
+			const struct ia_css_isp_config *config);
 
 #endif /* IA_CSS_INCLUDE_PARAMETER */
 #endif /* _IA_CSS_ISP_PARAM_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_isp_states.c b/drivers/staging/media/atomisp/pci/ia_css_isp_states.c
index af17650404643ceb1c2a0a0b6c351dd3f18bc2ef..5ce157d99199babba2e8a17ef8edb7167e75b648 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_isp_states.c
+++ b/drivers/staging/media/atomisp/pci/ia_css_isp_states.c
@@ -12,20 +12,23 @@
 
 /* Code generated by genparam/genstate.c:gen_init_function() */
 
-static void
-ia_css_initialize_aa_state(
-    const struct ia_css_binary *binary)
+static void ia_css_initialize_aa_state(const struct ia_css_binary *binary)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_initialize_aa_state() enter:\n");
 
 	{
-		unsigned int size   = binary->info->mem_offsets.offsets.state->vmem.aa.size;
+		unsigned int size =
+			binary->info->mem_offsets.offsets.state->vmem.aa.size;
 
-		unsigned int offset = binary->info->mem_offsets.offsets.state->vmem.aa.offset;
+		unsigned int offset =
+			binary->info->mem_offsets.offsets.state->vmem.aa.offset;
 
 		if (size)
-			memset(&binary->mem_params.params[IA_CSS_PARAM_CLASS_STATE][IA_CSS_ISP_VMEM].address[offset],
+			memset(&binary->mem_params
+					.params[IA_CSS_PARAM_CLASS_STATE]
+					       [IA_CSS_ISP_VMEM]
+					.address[offset],
 			       0, size);
 	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
@@ -34,22 +37,25 @@ ia_css_initialize_aa_state(
 
 /* Code generated by genparam/genstate.c:gen_init_function() */
 
-static void
-ia_css_initialize_cnr_state(
-    const struct ia_css_binary *binary)
+static void ia_css_initialize_cnr_state(const struct ia_css_binary *binary)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_initialize_cnr_state() enter:\n");
 
 	{
-		unsigned int size   = binary->info->mem_offsets.offsets.state->vmem.cnr.size;
+		unsigned int size =
+			binary->info->mem_offsets.offsets.state->vmem.cnr.size;
 
-		unsigned int offset = binary->info->mem_offsets.offsets.state->vmem.cnr.offset;
+		unsigned int offset =
+			binary->info->mem_offsets.offsets.state->vmem.cnr.offset;
 
 		if (size) {
 			ia_css_init_cnr_state(
-			    &binary->mem_params.params[IA_CSS_PARAM_CLASS_STATE][IA_CSS_ISP_VMEM].address[offset],
-			    size);
+				&binary->mem_params
+					 .params[IA_CSS_PARAM_CLASS_STATE]
+						[IA_CSS_ISP_VMEM]
+					 .address[offset],
+				size);
 		}
 	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
@@ -58,22 +64,25 @@ ia_css_initialize_cnr_state(
 
 /* Code generated by genparam/genstate.c:gen_init_function() */
 
-static void
-ia_css_initialize_cnr2_state(
-    const struct ia_css_binary *binary)
+static void ia_css_initialize_cnr2_state(const struct ia_css_binary *binary)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_initialize_cnr2_state() enter:\n");
 
 	{
-		unsigned int size   = binary->info->mem_offsets.offsets.state->vmem.cnr2.size;
+		unsigned int size =
+			binary->info->mem_offsets.offsets.state->vmem.cnr2.size;
 
-		unsigned int offset = binary->info->mem_offsets.offsets.state->vmem.cnr2.offset;
+		unsigned int offset = binary->info->mem_offsets.offsets.state
+					      ->vmem.cnr2.offset;
 
 		if (size) {
 			ia_css_init_cnr2_state(
-			    &binary->mem_params.params[IA_CSS_PARAM_CLASS_STATE][IA_CSS_ISP_VMEM].address[offset],
-			    size);
+				&binary->mem_params
+					 .params[IA_CSS_PARAM_CLASS_STATE]
+						[IA_CSS_ISP_VMEM]
+					 .address[offset],
+				size);
 		}
 	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
@@ -82,22 +91,25 @@ ia_css_initialize_cnr2_state(
 
 /* Code generated by genparam/genstate.c:gen_init_function() */
 
-static void
-ia_css_initialize_dp_state(
-    const struct ia_css_binary *binary)
+static void ia_css_initialize_dp_state(const struct ia_css_binary *binary)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_initialize_dp_state() enter:\n");
 
 	{
-		unsigned int size   = binary->info->mem_offsets.offsets.state->vmem.dp.size;
+		unsigned int size =
+			binary->info->mem_offsets.offsets.state->vmem.dp.size;
 
-		unsigned int offset = binary->info->mem_offsets.offsets.state->vmem.dp.offset;
+		unsigned int offset =
+			binary->info->mem_offsets.offsets.state->vmem.dp.offset;
 
 		if (size) {
 			ia_css_init_dp_state(
-			    &binary->mem_params.params[IA_CSS_PARAM_CLASS_STATE][IA_CSS_ISP_VMEM].address[offset],
-			    size);
+				&binary->mem_params
+					 .params[IA_CSS_PARAM_CLASS_STATE]
+						[IA_CSS_ISP_VMEM]
+					 .address[offset],
+				size);
 		}
 	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
@@ -106,22 +118,25 @@ ia_css_initialize_dp_state(
 
 /* Code generated by genparam/genstate.c:gen_init_function() */
 
-static void
-ia_css_initialize_de_state(
-    const struct ia_css_binary *binary)
+static void ia_css_initialize_de_state(const struct ia_css_binary *binary)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_initialize_de_state() enter:\n");
 
 	{
-		unsigned int size   = binary->info->mem_offsets.offsets.state->vmem.de.size;
+		unsigned int size =
+			binary->info->mem_offsets.offsets.state->vmem.de.size;
 
-		unsigned int offset = binary->info->mem_offsets.offsets.state->vmem.de.offset;
+		unsigned int offset =
+			binary->info->mem_offsets.offsets.state->vmem.de.offset;
 
 		if (size) {
 			ia_css_init_de_state(
-			    &binary->mem_params.params[IA_CSS_PARAM_CLASS_STATE][IA_CSS_ISP_VMEM].address[offset],
-			    size);
+				&binary->mem_params
+					 .params[IA_CSS_PARAM_CLASS_STATE]
+						[IA_CSS_ISP_VMEM]
+					 .address[offset],
+				size);
 		}
 	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
@@ -130,22 +145,26 @@ ia_css_initialize_de_state(
 
 /* Code generated by genparam/genstate.c:gen_init_function() */
 
-static void
-ia_css_initialize_tnr_state(
-    const struct ia_css_binary *binary)
+static void ia_css_initialize_tnr_state(const struct ia_css_binary *binary)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_initialize_tnr_state() enter:\n");
 
 	{
-		unsigned int size   = binary->info->mem_offsets.offsets.state->dmem.tnr.size;
+		unsigned int size =
+			binary->info->mem_offsets.offsets.state->dmem.tnr.size;
 
-		unsigned int offset = binary->info->mem_offsets.offsets.state->dmem.tnr.offset;
+		unsigned int offset =
+			binary->info->mem_offsets.offsets.state->dmem.tnr.offset;
 
 		if (size) {
-			ia_css_init_tnr_state((struct sh_css_isp_tnr_dmem_state *)
-					      &binary->mem_params.params[IA_CSS_PARAM_CLASS_STATE][IA_CSS_ISP_DMEM].address[offset],
-					      size);
+			ia_css_init_tnr_state(
+				(struct sh_css_isp_tnr_dmem_state *)&binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_STATE]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				size);
 		}
 	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
@@ -154,22 +173,26 @@ ia_css_initialize_tnr_state(
 
 /* Code generated by genparam/genstate.c:gen_init_function() */
 
-static void
-ia_css_initialize_ref_state(
-    const struct ia_css_binary *binary)
+static void ia_css_initialize_ref_state(const struct ia_css_binary *binary)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_initialize_ref_state() enter:\n");
 
 	{
-		unsigned int size   = binary->info->mem_offsets.offsets.state->dmem.ref.size;
+		unsigned int size =
+			binary->info->mem_offsets.offsets.state->dmem.ref.size;
 
-		unsigned int offset = binary->info->mem_offsets.offsets.state->dmem.ref.offset;
+		unsigned int offset =
+			binary->info->mem_offsets.offsets.state->dmem.ref.offset;
 
 		if (size) {
-			ia_css_init_ref_state((struct sh_css_isp_ref_dmem_state *)
-					      &binary->mem_params.params[IA_CSS_PARAM_CLASS_STATE][IA_CSS_ISP_DMEM].address[offset],
-					      size);
+			ia_css_init_ref_state(
+				(struct sh_css_isp_ref_dmem_state *)&binary
+					->mem_params
+					.params[IA_CSS_PARAM_CLASS_STATE]
+					       [IA_CSS_ISP_DMEM]
+					.address[offset],
+				size);
 		}
 	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
@@ -178,22 +201,25 @@ ia_css_initialize_ref_state(
 
 /* Code generated by genparam/genstate.c:gen_init_function() */
 
-static void
-ia_css_initialize_ynr_state(
-    const struct ia_css_binary *binary)
+static void ia_css_initialize_ynr_state(const struct ia_css_binary *binary)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_initialize_ynr_state() enter:\n");
 
 	{
-		unsigned int size   = binary->info->mem_offsets.offsets.state->vmem.ynr.size;
+		unsigned int size =
+			binary->info->mem_offsets.offsets.state->vmem.ynr.size;
 
-		unsigned int offset = binary->info->mem_offsets.offsets.state->vmem.ynr.offset;
+		unsigned int offset =
+			binary->info->mem_offsets.offsets.state->vmem.ynr.offset;
 
 		if (size) {
 			ia_css_init_ynr_state(
-			    &binary->mem_params.params[IA_CSS_PARAM_CLASS_STATE][IA_CSS_ISP_VMEM].address[offset],
-			    size);
+				&binary->mem_params
+					 .params[IA_CSS_PARAM_CLASS_STATE]
+						[IA_CSS_ISP_VMEM]
+					 .address[offset],
+				size);
 		}
 	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
@@ -203,13 +229,9 @@ ia_css_initialize_ynr_state(
 /* Code generated by genparam/genstate.c:gen_state_init_table() */
 
 void (*ia_css_kernel_init_state[IA_CSS_NUM_STATE_IDS])(
-    const struct ia_css_binary *binary) = {
-	ia_css_initialize_aa_state,
-	ia_css_initialize_cnr_state,
-	ia_css_initialize_cnr2_state,
-	ia_css_initialize_dp_state,
-	ia_css_initialize_de_state,
-	ia_css_initialize_tnr_state,
-	ia_css_initialize_ref_state,
-	ia_css_initialize_ynr_state,
+	const struct ia_css_binary *binary) = {
+	ia_css_initialize_aa_state,   ia_css_initialize_cnr_state,
+	ia_css_initialize_cnr2_state, ia_css_initialize_dp_state,
+	ia_css_initialize_de_state,   ia_css_initialize_tnr_state,
+	ia_css_initialize_ref_state,  ia_css_initialize_ynr_state,
 };
diff --git a/drivers/staging/media/atomisp/pci/ia_css_isp_states.h b/drivers/staging/media/atomisp/pci/ia_css_isp_states.h
index d637ea1d13f6beae24a77261901c70507b8fca71..2bc38f95b39a4c7d14b53e1538b20c987f40fc1e 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_isp_states.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_isp_states.h
@@ -53,12 +53,12 @@ struct ia_css_state_memory_offsets {
 
 #if defined(IA_CSS_INCLUDE_STATES)
 
-#include "ia_css_stream.h"   /* struct ia_css_stream */
-#include "ia_css_binary.h"   /* struct ia_css_binary */
+#include "ia_css_stream.h" /* struct ia_css_stream */
+#include "ia_css_binary.h" /* struct ia_css_binary */
 /* Code generated by genparam/genstate.c:gen_state_init_table() */
 
 extern void (*ia_css_kernel_init_state[IA_CSS_NUM_STATE_IDS])(
-    const struct ia_css_binary *binary);
+	const struct ia_css_binary *binary);
 
 #endif /* IA_CSS_INCLUDE_STATE */
 
diff --git a/drivers/staging/media/atomisp/pci/ia_css_metadata.h b/drivers/staging/media/atomisp/pci/ia_css_metadata.h
index 348836175770016b57dff48cbe4bb25d9f8e6445..7988bbb358e51ae476011fba307cc5efb52729b5 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_metadata.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_metadata.h
@@ -25,19 +25,19 @@ struct ia_css_metadata_config {
 			data. The default value is ATOMISP_INPUT_FORMAT_EMBEDDED. For
 			certain sensors, user can choose non-default data type for embedded
 			data. */
-	struct ia_css_resolution  resolution; /** Resolution */
+	struct ia_css_resolution resolution; /** Resolution */
 };
 
 struct ia_css_metadata_info {
 	struct ia_css_resolution resolution; /** Resolution */
-	u32                 stride;     /** Stride in bytes */
-	u32                 size;       /** Total size in bytes */
+	u32 stride; /** Stride in bytes */
+	u32 size; /** Total size in bytes */
 };
 
 struct ia_css_metadata {
-	struct ia_css_metadata_info info;    /** Layout info */
-	ia_css_ptr		    address; /** CSS virtual address */
-	u32		    exp_id;
+	struct ia_css_metadata_info info; /** Layout info */
+	ia_css_ptr address; /** CSS virtual address */
+	u32 exp_id;
 	/** Exposure ID, see ia_css_event_public.h for more detail */
 };
 
@@ -62,7 +62,6 @@ ia_css_metadata_allocate(const struct ia_css_metadata_info *metadata_info);
  *
  * This function frees a metadata buffer.
  */
-void
-ia_css_metadata_free(struct ia_css_metadata *metadata);
+void ia_css_metadata_free(struct ia_css_metadata *metadata);
 
 #endif /* __IA_CSS_METADATA_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_mipi.h b/drivers/staging/media/atomisp/pci/ia_css_mipi.h
index 9fb178c8f3a5a6266140b00461ea8dee837b826c..fe4190ed6c108566e146d52a6193c6d14f90bdbb 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_mipi.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_mipi.h
@@ -28,12 +28,10 @@
  *
  * Calculate the size of a mipi frame, based on the resolution and format.
  */
-int
-ia_css_mipi_frame_calculate_size(const unsigned int width,
-				 const unsigned int height,
-				 const enum atomisp_input_format format,
-				 const bool hasSOLandEOL,
-				 const unsigned int embedded_data_size_words,
-				 unsigned int *size_mem_words);
+int ia_css_mipi_frame_calculate_size(
+	const unsigned int width, const unsigned int height,
+	const enum atomisp_input_format format, const bool hasSOLandEOL,
+	const unsigned int embedded_data_size_words,
+	unsigned int *size_mem_words);
 
 #endif /* __IA_CSS_MIPI_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_mmu.h b/drivers/staging/media/atomisp/pci/ia_css_mmu.h
index 8dc02c8f60a090d6f6510bfee3d6510750ef2e17..06ad4ae43be06dab803bfc818c71648a53e72b3b 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_mmu.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_mmu.h
@@ -18,7 +18,6 @@
  * buffer (TLB) that's inside the CSS MMU. This function should be called
  * every time the page tables used by the MMU change.
  */
-void
-ia_css_mmu_invalidate_cache(void);
+void ia_css_mmu_invalidate_cache(void);
 
 #endif /* __IA_CSS_MMU_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_mmu_private.h b/drivers/staging/media/atomisp/pci/ia_css_mmu_private.h
index 4b5e09e051b5ea713d7d1e064e6e79c63e8d516e..28003740be52d3bfdae852fed798770d33b20956 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_mmu_private.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_mmu_private.h
@@ -15,7 +15,6 @@
  * Once being set the L1 pagetable is protected against
  * further modifications.
  */
-void
-sh_css_mmu_set_page_table_base_index(hrt_data base_index);
+void sh_css_mmu_set_page_table_base_index(hrt_data base_index);
 
 #endif /* __IA_CSS_MMU_PRIVATE_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_morph.h b/drivers/staging/media/atomisp/pci/ia_css_morph.h
index 68997b26c70a8b42fe58d2b5986624eb788780b7..c3db885d115e3b2b274edaf44591c156d70b50dc 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_morph.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_morph.h
@@ -18,14 +18,13 @@
  * @param[in]	height Height of the morphing table.
  * @return		Pointer to the morphing table
 */
-struct ia_css_morph_table *
-ia_css_morph_table_allocate(unsigned int width, unsigned int height);
+struct ia_css_morph_table *ia_css_morph_table_allocate(unsigned int width,
+						       unsigned int height);
 
 /* @brief Free the morph table
  * @param[in]	me Pointer to the morph table.
  * @return		None
 */
-void
-ia_css_morph_table_free(struct ia_css_morph_table *me);
+void ia_css_morph_table_free(struct ia_css_morph_table *me);
 
 #endif /* __IA_CSS_MORPH_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_pipe.h b/drivers/staging/media/atomisp/pci/ia_css_pipe.h
index c97d2ae356fd2d65daf9281b09b4134f02740c53..d4a7d78f9f69753ddb2eea13baf19651de871804 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_pipe.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_pipe.h
@@ -14,8 +14,8 @@
 #include "ia_css_binary.h"
 #include "sh_css_legacy.h"
 
-#define PIPE_ENTRY_EMPTY_TOKEN                (~0U)
-#define PIPE_ENTRY_RESERVED_TOKEN             (0x1)
+#define PIPE_ENTRY_EMPTY_TOKEN (~0U)
+#define PIPE_ENTRY_RESERVED_TOKEN (0x1)
 
 struct ia_css_preview_settings {
 	struct ia_css_binary copy_binary;
@@ -30,11 +30,12 @@ struct ia_css_preview_settings {
 	struct ia_css_pipe *capture_pipe;
 };
 
-#define IA_CSS_DEFAULT_PREVIEW_SETTINGS { \
-	.copy_binary	= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-	.preview_binary	= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-	.vf_pp_binary	= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-}
+#define IA_CSS_DEFAULT_PREVIEW_SETTINGS                           \
+	{                                                         \
+		.copy_binary = IA_CSS_BINARY_DEFAULT_SETTINGS,    \
+		.preview_binary = IA_CSS_BINARY_DEFAULT_SETTINGS, \
+		.vf_pp_binary = IA_CSS_BINARY_DEFAULT_SETTINGS,   \
+	}
 
 struct ia_css_capture_settings {
 	struct ia_css_binary copy_binary;
@@ -54,16 +55,17 @@ struct ia_css_capture_settings {
 	unsigned int num_yuv_scaler;
 };
 
-#define IA_CSS_DEFAULT_CAPTURE_SETTINGS { \
-	.copy_binary		= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-	.primary_binary		= {IA_CSS_BINARY_DEFAULT_SETTINGS}, \
-	.pre_isp_binary		= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-	.anr_gdc_binary		= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-	.post_isp_binary	= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-	.capture_pp_binary	= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-	.vf_pp_binary		= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-	.capture_ldc_binary	= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-}
+#define IA_CSS_DEFAULT_CAPTURE_SETTINGS                               \
+	{                                                             \
+		.copy_binary = IA_CSS_BINARY_DEFAULT_SETTINGS,        \
+		.primary_binary = { IA_CSS_BINARY_DEFAULT_SETTINGS }, \
+		.pre_isp_binary = IA_CSS_BINARY_DEFAULT_SETTINGS,     \
+		.anr_gdc_binary = IA_CSS_BINARY_DEFAULT_SETTINGS,     \
+		.post_isp_binary = IA_CSS_BINARY_DEFAULT_SETTINGS,    \
+		.capture_pp_binary = IA_CSS_BINARY_DEFAULT_SETTINGS,  \
+		.vf_pp_binary = IA_CSS_BINARY_DEFAULT_SETTINGS,       \
+		.capture_ldc_binary = IA_CSS_BINARY_DEFAULT_SETTINGS, \
+	}
 
 struct ia_css_video_settings {
 	struct ia_css_binary copy_binary;
@@ -79,11 +81,12 @@ struct ia_css_video_settings {
 	unsigned int num_yuv_scaler;
 };
 
-#define IA_CSS_DEFAULT_VIDEO_SETTINGS { \
-	.copy_binary	= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-	.video_binary	= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-	.vf_pp_binary	= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-}
+#define IA_CSS_DEFAULT_VIDEO_SETTINGS                           \
+	{                                                       \
+		.copy_binary = IA_CSS_BINARY_DEFAULT_SETTINGS,  \
+		.video_binary = IA_CSS_BINARY_DEFAULT_SETTINGS, \
+		.vf_pp_binary = IA_CSS_BINARY_DEFAULT_SETTINGS, \
+	}
 
 struct ia_css_yuvpp_settings {
 	struct ia_css_binary copy_binary;
@@ -95,41 +98,42 @@ struct ia_css_yuvpp_settings {
 	unsigned int num_output;
 };
 
-#define IA_CSS_DEFAULT_YUVPP_SETTINGS { \
-	.copy_binary	= IA_CSS_BINARY_DEFAULT_SETTINGS, \
-}
+#define IA_CSS_DEFAULT_YUVPP_SETTINGS                          \
+	{                                                      \
+		.copy_binary = IA_CSS_BINARY_DEFAULT_SETTINGS, \
+	}
 
 struct osys_object;
 
 struct ia_css_pipe {
 	/* TODO: Remove stop_requested and use stop_requested in the pipeline */
-	bool                            stop_requested;
-	struct ia_css_pipe_config       config;
+	bool stop_requested;
+	struct ia_css_pipe_config config;
 	struct ia_css_pipe_extra_config extra_config;
-	struct ia_css_pipe_info         info;
-	enum ia_css_pipe_id		mode;
-	struct ia_css_shading_table	*shading_table;
-	struct ia_css_pipeline		pipeline;
-	struct ia_css_frame_info	output_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
-	struct ia_css_frame_info	bds_output_info;
-	struct ia_css_frame_info	vf_output_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
-	struct ia_css_frame_info	out_yuv_ds_input_info;
-	struct ia_css_frame_info	vf_yuv_ds_input_info;
-	struct ia_css_fw_info		*output_stage;	/* extra output stage */
-	struct ia_css_fw_info		*vf_stage;	/* extra vf_stage */
-	unsigned int			required_bds_factor;
-	unsigned int			dvs_frame_delay;
-	int				num_invalid_frames;
-	bool				enable_viewfinder[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
-	struct ia_css_stream		*stream;
-	struct ia_css_frame		in_frame_struct;
-	struct ia_css_frame		out_frame_struct;
-	struct ia_css_frame		vf_frame_struct;
-	struct ia_css_frame		*continuous_frames[NUM_CONTINUOUS_FRAMES];
-	struct ia_css_metadata	*cont_md_buffers[NUM_CONTINUOUS_FRAMES];
+	struct ia_css_pipe_info info;
+	enum ia_css_pipe_id mode;
+	struct ia_css_shading_table *shading_table;
+	struct ia_css_pipeline pipeline;
+	struct ia_css_frame_info output_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_frame_info bds_output_info;
+	struct ia_css_frame_info vf_output_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_frame_info out_yuv_ds_input_info;
+	struct ia_css_frame_info vf_yuv_ds_input_info;
+	struct ia_css_fw_info *output_stage; /* extra output stage */
+	struct ia_css_fw_info *vf_stage; /* extra vf_stage */
+	unsigned int required_bds_factor;
+	unsigned int dvs_frame_delay;
+	int num_invalid_frames;
+	bool enable_viewfinder[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_stream *stream;
+	struct ia_css_frame in_frame_struct;
+	struct ia_css_frame out_frame_struct;
+	struct ia_css_frame vf_frame_struct;
+	struct ia_css_frame *continuous_frames[NUM_CONTINUOUS_FRAMES];
+	struct ia_css_metadata *cont_md_buffers[NUM_CONTINUOUS_FRAMES];
 	union {
 		struct ia_css_preview_settings preview;
-		struct ia_css_video_settings   video;
+		struct ia_css_video_settings video;
 		struct ia_css_capture_settings capture;
 		struct ia_css_yuvpp_settings yuvpp;
 	} pipe_settings;
@@ -143,33 +147,30 @@ struct ia_css_pipe {
 	unsigned int pipe_num;
 };
 
-#define IA_CSS_DEFAULT_PIPE { \
-	.config			= DEFAULT_PIPE_CONFIG, \
-	.info			= DEFAULT_PIPE_INFO, \
-	.mode			= IA_CSS_PIPE_ID_VIDEO, /* (pipe_id) */ \
-	.pipeline		= DEFAULT_PIPELINE, \
-	.output_info		= {IA_CSS_BINARY_DEFAULT_FRAME_INFO}, \
-	.bds_output_info	= IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
-	.vf_output_info		= {IA_CSS_BINARY_DEFAULT_FRAME_INFO}, \
-	.out_yuv_ds_input_info	= IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
-	.vf_yuv_ds_input_info	= IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
-	.required_bds_factor	= SH_CSS_BDS_FACTOR_1_00, \
-	.dvs_frame_delay	= 1, \
-	.enable_viewfinder	= {true}, \
-	.in_frame_struct	= DEFAULT_FRAME, \
-	.out_frame_struct	= DEFAULT_FRAME, \
-	.vf_frame_struct	= DEFAULT_FRAME, \
-	.pipe_settings		= { \
-		.preview = IA_CSS_DEFAULT_PREVIEW_SETTINGS \
-	}, \
-	.pipe_num		= PIPE_ENTRY_EMPTY_TOKEN, \
-}
+#define IA_CSS_DEFAULT_PIPE                                                   \
+	{                                                                     \
+		.config = DEFAULT_PIPE_CONFIG, .info = DEFAULT_PIPE_INFO,     \
+		.mode = IA_CSS_PIPE_ID_VIDEO, /* (pipe_id) */                 \
+			.pipeline = DEFAULT_PIPELINE,                         \
+		.output_info = { IA_CSS_BINARY_DEFAULT_FRAME_INFO },          \
+		.bds_output_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO,          \
+		.vf_output_info = { IA_CSS_BINARY_DEFAULT_FRAME_INFO },       \
+		.out_yuv_ds_input_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO,    \
+		.vf_yuv_ds_input_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO,     \
+		.required_bds_factor = SH_CSS_BDS_FACTOR_1_00,                \
+		.dvs_frame_delay = 1, .enable_viewfinder = { true },          \
+		.in_frame_struct = DEFAULT_FRAME,                             \
+		.out_frame_struct = DEFAULT_FRAME,                            \
+		.vf_frame_struct = DEFAULT_FRAME,                             \
+		.pipe_settings = { .preview =                                 \
+					   IA_CSS_DEFAULT_PREVIEW_SETTINGS }, \
+		.pipe_num = PIPE_ENTRY_EMPTY_TOKEN,                           \
+	}
 
 void ia_css_pipe_map_queue(struct ia_css_pipe *pipe, bool map);
 
-int
-sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
-			       struct ia_css_isp_parameters *params,
-			       bool commit, struct ia_css_pipe *pipe);
+int sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
+				   struct ia_css_isp_parameters *params,
+				   bool commit, struct ia_css_pipe *pipe);
 
 #endif /* __IA_CSS_PIPE_H__ */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_pipe_public.h b/drivers/staging/media/atomisp/pci/ia_css_pipe_public.h
index 2bb06b0ff5dba5910e28ac21a667d6c328b3fe8b..a316a070160effef142cb97391c4cbc4b23dbc37 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_pipe_public.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_pipe_public.h
@@ -33,11 +33,11 @@ enum {
  *  create a continuous capture stream.
  */
 enum ia_css_pipe_mode {
-	IA_CSS_PIPE_MODE_PREVIEW,	/** Preview pipe */
-	IA_CSS_PIPE_MODE_VIDEO,		/** Video pipe */
-	IA_CSS_PIPE_MODE_CAPTURE,	/** Still capture pipe */
-	IA_CSS_PIPE_MODE_COPY,		/** Copy pipe, only used for embedded/image data copying */
-	IA_CSS_PIPE_MODE_YUVPP,		/** YUV post processing pipe, used for all use cases with YUV input,
+	IA_CSS_PIPE_MODE_PREVIEW, /** Preview pipe */
+	IA_CSS_PIPE_MODE_VIDEO, /** Video pipe */
+	IA_CSS_PIPE_MODE_CAPTURE, /** Still capture pipe */
+	IA_CSS_PIPE_MODE_COPY, /** Copy pipe, only used for embedded/image data copying */
+	IA_CSS_PIPE_MODE_YUVPP, /** YUV post processing pipe, used for all use cases with YUV input,
 									for SoC sensor and external ISP */
 };
 
@@ -49,10 +49,10 @@ enum ia_css_pipe_mode {
  * the order should match with definition in sh_css_defs.h
  */
 enum ia_css_pipe_version {
-	IA_CSS_PIPE_VERSION_1 = 1,		/** ISP1.0 pipe */
-	IA_CSS_PIPE_VERSION_2_2 = 2,		/** ISP2.2 pipe */
-	IA_CSS_PIPE_VERSION_2_6_1 = 3,		/** ISP2.6.1 pipe */
-	IA_CSS_PIPE_VERSION_2_7 = 4		/** ISP2.7 pipe */
+	IA_CSS_PIPE_VERSION_1 = 1, /** ISP1.0 pipe */
+	IA_CSS_PIPE_VERSION_2_2 = 2, /** ISP2.2 pipe */
+	IA_CSS_PIPE_VERSION_2_6_1 = 3, /** ISP2.6.1 pipe */
+	IA_CSS_PIPE_VERSION_2_7 = 4 /** ISP2.7 pipe */
 };
 
 /**
@@ -102,7 +102,7 @@ struct ia_css_pipe_config {
 	     instead of vf_pp. This only applies to viewfinder post
 	     processing stages. */
 
-/* ISP2401 */
+	/* ISP2401 */
 	bool enable_tnr;
 	/** Enabling of TNR (temporal noise reduction). This is only applicable to video
 	     pipes. Non video-pipes should always set this parameter to false. */
@@ -114,7 +114,7 @@ struct ia_css_pipe_config {
 	struct ia_css_point gdc_in_buffer_offset;
 	/** GDC in buffer offset - indicates the pixel coordinates of the first valid pixel inside the buffer */
 
-/* ISP2401 */
+	/* ISP2401 */
 	struct ia_css_coordinate internal_frame_origin_bqs_on_sctbl;
 	/** Origin of internal frame positioned on shading table at shading correction in ISP.
 	     NOTE: Shading table is larger than or equal to internal frame.
@@ -126,14 +126,14 @@ struct ia_css_pipe_config {
 /**
  * Default settings for newly created pipe configurations.
  */
-#define DEFAULT_PIPE_CONFIG { \
-	.mode			= IA_CSS_PIPE_MODE_PREVIEW, \
-	.isp_pipe_version	= 1, \
-	.output_info		= {IA_CSS_BINARY_DEFAULT_FRAME_INFO}, \
-	.vf_output_info		= {IA_CSS_BINARY_DEFAULT_FRAME_INFO}, \
-	.default_capture_config	= DEFAULT_CAPTURE_CONFIG, \
-	.dvs_frame_delay	= IA_CSS_FRAME_DELAY_1, \
-}
+#define DEFAULT_PIPE_CONFIG                                              \
+	{                                                                \
+		.mode = IA_CSS_PIPE_MODE_PREVIEW, .isp_pipe_version = 1, \
+		.output_info = { IA_CSS_BINARY_DEFAULT_FRAME_INFO },     \
+		.vf_output_info = { IA_CSS_BINARY_DEFAULT_FRAME_INFO },  \
+		.default_capture_config = DEFAULT_CAPTURE_CONFIG,        \
+		.dvs_frame_delay = IA_CSS_FRAME_DELAY_1,                 \
+	}
 
 /* Pipe info, this struct describes properties of a pipe after it's stream has
  * been created.
@@ -164,7 +164,7 @@ struct ia_css_pipe_info {
 	struct ia_css_shading_info shading_info;
 	/** After an image pipe is created, this field will contain the info
 	     for the shading correction. */
-	struct ia_css_grid_info  grid_info;
+	struct ia_css_grid_info grid_info;
 	/** After an image pipe is created, this field will contain the grid
 	     info for 3A and DVS. */
 	int num_invalid_frames;
@@ -178,13 +178,14 @@ struct ia_css_pipe_info {
 /**
  * Defaults for ia_css_pipe_info structs.
  */
-#define DEFAULT_PIPE_INFO {\
-	.output_info		= {IA_CSS_BINARY_DEFAULT_FRAME_INFO}, \
-	.vf_output_info		= {IA_CSS_BINARY_DEFAULT_FRAME_INFO}, \
-	.raw_output_info	= IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
-	.shading_info		= DEFAULT_SHADING_INFO, \
-	.grid_info		= DEFAULT_GRID_INFO, \
-}
+#define DEFAULT_PIPE_INFO                                               \
+	{                                                               \
+		.output_info = { IA_CSS_BINARY_DEFAULT_FRAME_INFO },    \
+		.vf_output_info = { IA_CSS_BINARY_DEFAULT_FRAME_INFO }, \
+		.raw_output_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO,    \
+		.shading_info = DEFAULT_SHADING_INFO,                   \
+		.grid_info = DEFAULT_GRID_INFO,                         \
+	}
 
 /* @brief Load default pipe configuration
  * @param[out]	pipe_config The pipe configuration.
@@ -225,9 +226,8 @@ void ia_css_pipe_config_defaults(struct ia_css_pipe_config *pipe_config);
  * This function will create a pipe with the given
  * configuration.
  */
-int
-ia_css_pipe_create(const struct ia_css_pipe_config *config,
-		   struct ia_css_pipe **pipe);
+int ia_css_pipe_create(const struct ia_css_pipe_config *config,
+		       struct ia_css_pipe **pipe);
 
 /* @brief Destroy a pipe
  * @param[in]	pipe The pipe.
@@ -235,8 +235,7 @@ ia_css_pipe_create(const struct ia_css_pipe_config *config,
  *
  * This function will destroy a given pipe.
  */
-int
-ia_css_pipe_destroy(struct ia_css_pipe *pipe);
+int ia_css_pipe_destroy(struct ia_css_pipe *pipe);
 
 /* @brief Provides information about a pipe
  * @param[in]	pipe The pipe.
@@ -245,9 +244,8 @@ ia_css_pipe_destroy(struct ia_css_pipe *pipe);
  *
  * This function will provide information about a given pipe.
  */
-int
-ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
-		     struct ia_css_pipe_info *pipe_info);
+int ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
+			 struct ia_css_pipe_info *pipe_info);
 
 /* @brief Configure a pipe with filter coefficients.
  * @param[in]	pipe	The pipe.
@@ -257,9 +255,8 @@ ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
  * This function configures the filter coefficients for an image
  * pipe.
  */
-int
-ia_css_pipe_set_isp_config(struct ia_css_pipe *pipe,
-			   struct ia_css_isp_config *config);
+int ia_css_pipe_set_isp_config(struct ia_css_pipe *pipe,
+			       struct ia_css_isp_config *config);
 
 /* @brief Controls when the Event generator raises an IRQ to the Host.
  *
@@ -333,10 +330,8 @@ ia_css_pipe_set_isp_config(struct ia_css_pipe *pipe,
  All other events (3A, VF output, pipeline done) will not raise an interrupt
  to the Host. These events are not lost but always stored in the event queue.
  */
-int
-ia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe,
-			 unsigned int or_mask,
-			 unsigned int and_mask);
+int ia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe, unsigned int or_mask,
+			     unsigned int and_mask);
 
 /* @brief Reads the current event IRQ mask from the CSS.
  *
@@ -354,10 +349,8 @@ Precondition:\n
 SP must be running.\n
 
 */
-int
-ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
-			  unsigned int *or_mask,
-			  unsigned int *and_mask);
+int ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
+			      unsigned int *or_mask, unsigned int *and_mask);
 
 /* @brief Queue a buffer for an image pipe.
  *
@@ -377,9 +370,8 @@ ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
  * host code via an interrupt. Buffers will be consumed in the same order they
  * get queued, but may be returned to the host out of order.
  */
-int
-ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
-			   const struct ia_css_buffer *buffer);
+int ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
+			       const struct ia_css_buffer *buffer);
 
 /* @brief Dequeue a buffer from an image pipe.
  *
@@ -397,18 +389,16 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
  * be used in a polling-like situation where the NO_BUFFER return value is used
  * to determine whether a buffer was available or not.
  */
-int
-ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
-			   struct ia_css_buffer *buffer);
+int ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
+			       struct ia_css_buffer *buffer);
 
 /* @brief Get selected configuration settings
  * @param[in]	pipe	The pipe.
  * @param[out]	config	Configuration settings.
  * @return		None
  */
-void
-ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
-			   struct ia_css_isp_config *config);
+void ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
+				struct ia_css_isp_config *config);
 
 /* @brief Set the scaler lut on this pipe. A copy of lut is made in the inuit
  *         address space. So the LUT can be freed by caller.
@@ -426,9 +416,7 @@ ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
  * 3) This function must be called before stream start
  *
  */
-int
-ia_css_pipe_set_bci_scaler_lut(struct ia_css_pipe *pipe,
-			       const void *lut);
+int ia_css_pipe_set_bci_scaler_lut(struct ia_css_pipe *pipe, const void *lut);
 /* @brief Checking of DVS statistics ability
  * @param[in]	pipe_info	The pipe info.
  * @return		true - has DVS statistics ability
@@ -456,9 +444,7 @@ bool ia_css_pipe_has_dvs_stats(struct ia_css_pipe_info *pipe_info);
  * 4) If this function is used, it MUST be called after ia_css_pipe_create.
  * 5) If this function is used, this function MUST be called before ia_css_stream_start.
  */
-int
-ia_css_pipe_override_frame_format(struct ia_css_pipe *pipe,
-				  int output_pin,
-				  enum ia_css_frame_format format);
+int ia_css_pipe_override_frame_format(struct ia_css_pipe *pipe, int output_pin,
+				      enum ia_css_frame_format format);
 
 #endif /* __IA_CSS_PIPE_PUBLIC_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_prbs.h b/drivers/staging/media/atomisp/pci/ia_css_prbs.h
index abdbcb8fda53326e5c9b20d546077d0049c377e3..f03f0286a8c0f58d64baeb0e3ec8da64cc2eed02 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_prbs.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_prbs.h
@@ -13,11 +13,7 @@
 
 /* Enumerate the PRBS IDs.
  */
-enum ia_css_prbs_id {
-	IA_CSS_PRBS_ID0,
-	IA_CSS_PRBS_ID1,
-	IA_CSS_PRBS_ID2
-};
+enum ia_css_prbs_id { IA_CSS_PRBS_ID0, IA_CSS_PRBS_ID1, IA_CSS_PRBS_ID2 };
 
 /**
  * Maximum number of PRBS IDs.
@@ -35,11 +31,11 @@ enum ia_css_prbs_id {
  * @deprecated{This interface is deprecated, it is not portable -> move to input system API}
  */
 struct ia_css_prbs_config {
-	enum ia_css_prbs_id	id;
-	unsigned int		h_blank;	/** horizontal blank */
-	unsigned int		v_blank;	/** vertical blank */
-	int			seed;	/** random seed for the 1st 2-pixel-components/clock */
-	int			seed1;	/** random seed for the 2nd 2-pixel-components/clock */
+	enum ia_css_prbs_id id;
+	unsigned int h_blank; /** horizontal blank */
+	unsigned int v_blank; /** vertical blank */
+	int seed; /** random seed for the 1st 2-pixel-components/clock */
+	int seed1; /** random seed for the 2nd 2-pixel-components/clock */
 };
 
 #endif /* __IA_CSS_PRBS_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_properties.h b/drivers/staging/media/atomisp/pci/ia_css_properties.h
index 3f087e2df99a9b435e5e1a3a37bd023d2f2d2b23..3e1ec84868862172ac3e5c25f8260ab9ebd1f3d9 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_properties.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_properties.h
@@ -15,7 +15,7 @@
 #include <ia_css_types.h> /* ia_css_vamem_type */
 
 struct ia_css_properties {
-	int  gdc_coord_one;
+	int gdc_coord_one;
 	bool l1_base_is_index; /** Indicate whether the L1 page base
 				    is a page index or a byte address. */
 	enum ia_css_vamem_type vamem_type;
@@ -27,7 +27,6 @@ struct ia_css_properties {
  *
  * This function returns a number of hardware properties.
  */
-void
-ia_css_get_properties(struct ia_css_properties *properties);
+void ia_css_get_properties(struct ia_css_properties *properties);
 
 #endif /* __IA_CSS_PROPERTIES_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_shading.h b/drivers/staging/media/atomisp/pci/ia_css_shading.h
index 99ad21c4bd680e8a1c101333fd9cc327c352cd07..62ebd7c6bc0c86db0de25ea5bfc1b2232144f718 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_shading.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_shading.h
@@ -18,15 +18,13 @@
  * @param[in]	height Height of the shading table.
  * @return		Pointer to the shading table
 */
-struct ia_css_shading_table *
-ia_css_shading_table_alloc(unsigned int width,
-			   unsigned int height);
+struct ia_css_shading_table *ia_css_shading_table_alloc(unsigned int width,
+							unsigned int height);
 
 /* @brief Free shading table
  * @param[in]	table Pointer to the shading table.
  * @return		None
 */
-void
-ia_css_shading_table_free(struct ia_css_shading_table *table);
+void ia_css_shading_table_free(struct ia_css_shading_table *table);
 
 #endif /* __IA_CSS_SHADING_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_stream.h b/drivers/staging/media/atomisp/pci/ia_css_stream.h
index c8de632a8e1253b44428c71e7fe313eec8e7e4ce..e42ff080338c08cc7366889c360baa474b0b3d8d 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_stream.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_stream.h
@@ -17,23 +17,23 @@
  * structure to hold all internal stream related information
  */
 struct ia_css_stream {
-	struct ia_css_stream_config    config;
-	struct ia_css_stream_info      info;
-	rx_cfg_t                       csi_rx_config;
-	bool                           reconfigure_css_rx;
-	struct ia_css_pipe            *last_pipe;
-	int                            num_pipes;
-	struct ia_css_pipe           **pipes;
-	struct ia_css_pipe            *continuous_pipe;
-	struct ia_css_isp_parameters  *isp_params_configs;
-	struct ia_css_isp_parameters  *per_frame_isp_params_configs;
-
-	bool                           cont_capt;
-	bool                           disable_cont_vf;
+	struct ia_css_stream_config config;
+	struct ia_css_stream_info info;
+	rx_cfg_t csi_rx_config;
+	bool reconfigure_css_rx;
+	struct ia_css_pipe *last_pipe;
+	int num_pipes;
+	struct ia_css_pipe **pipes;
+	struct ia_css_pipe *continuous_pipe;
+	struct ia_css_isp_parameters *isp_params_configs;
+	struct ia_css_isp_parameters *per_frame_isp_params_configs;
+
+	bool cont_capt;
+	bool disable_cont_vf;
 
 	/* ISP2401 */
-	bool                           stop_copy_preview;
-	bool                           started;
+	bool stop_copy_preview;
+	bool started;
 };
 
 /* @brief Get a binary in the stream, which binary has the shading correction.
@@ -54,12 +54,10 @@ ia_css_stream_get_3a_binary(const struct ia_css_stream *stream);
 unsigned int
 ia_css_stream_input_format_bits_per_pixel(struct ia_css_stream *stream);
 
-bool
-sh_css_params_set_binning_factor(struct ia_css_stream *stream,
-				 unsigned int sensor_binning);
+bool sh_css_params_set_binning_factor(struct ia_css_stream *stream,
+				      unsigned int sensor_binning);
 
-void
-sh_css_invalidate_params(struct ia_css_stream *stream);
+void sh_css_invalidate_params(struct ia_css_stream *stream);
 
 /* The following functions are used for testing purposes only */
 const struct ia_css_fpn_table *
@@ -74,26 +72,19 @@ ia_css_get_fpn_table(struct ia_css_stream *stream);
 struct ia_css_shading_table *
 ia_css_get_shading_table(struct ia_css_stream *stream);
 
-void
-ia_css_get_isp_dis_coefficients(struct ia_css_stream *stream,
-				short *horizontal_coefficients,
-				short *vertical_coefficients);
-
-void
-ia_css_get_isp_dvs2_coefficients(struct ia_css_stream *stream,
-				 short *hor_coefs_odd_real,
-				 short *hor_coefs_odd_imag,
-				 short *hor_coefs_even_real,
-				 short *hor_coefs_even_imag,
-				 short *ver_coefs_odd_real,
-				 short *ver_coefs_odd_imag,
-				 short *ver_coefs_even_real,
-				 short *ver_coefs_even_imag);
-
-int
-ia_css_stream_isp_parameters_init(struct ia_css_stream *stream);
-
-void
-ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream);
+void ia_css_get_isp_dis_coefficients(struct ia_css_stream *stream,
+				     short *horizontal_coefficients,
+				     short *vertical_coefficients);
+
+void ia_css_get_isp_dvs2_coefficients(
+	struct ia_css_stream *stream, short *hor_coefs_odd_real,
+	short *hor_coefs_odd_imag, short *hor_coefs_even_real,
+	short *hor_coefs_even_imag, short *ver_coefs_odd_real,
+	short *ver_coefs_odd_imag, short *ver_coefs_even_real,
+	short *ver_coefs_even_imag);
+
+int ia_css_stream_isp_parameters_init(struct ia_css_stream *stream);
+
+void ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream);
 
 #endif /*_IA_CSS_STREAM_H_*/
diff --git a/drivers/staging/media/atomisp/pci/ia_css_stream_format.h b/drivers/staging/media/atomisp/pci/ia_css_stream_format.h
index 6188e281189bb7dac7e33ae9f0575c41d61aaa2e..061b510e527e4b3c95e58adef2cbf3d4348defc2 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_stream_format.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_stream_format.h
@@ -14,8 +14,7 @@
 #include <type_support.h> /* bool */
 #include "../../../include/linux/atomisp_platform.h"
 
-unsigned int ia_css_util_input_format_bpp(
-    enum atomisp_input_format format,
-    bool two_ppc);
+unsigned int ia_css_util_input_format_bpp(enum atomisp_input_format format,
+					  bool two_ppc);
 
 #endif /* __ATOMISP_INPUT_FORMAT_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_stream_public.h b/drivers/staging/media/atomisp/pci/ia_css_stream_public.h
index a505f3797962fdc383b1bf2d1594cd2b9b4a07dc..a4f4e0b93d495115d331a35122d217fd7d2f3a22 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_stream_public.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_stream_public.h
@@ -26,9 +26,9 @@
  */
 enum ia_css_input_mode {
 	IA_CSS_INPUT_MODE_SENSOR, /** data from sensor */
-	IA_CSS_INPUT_MODE_FIFO,   /** data from input-fifo */
-	IA_CSS_INPUT_MODE_TPG,    /** data from test-pattern generator */
-	IA_CSS_INPUT_MODE_PRBS,   /** data from pseudo-random bit stream */
+	IA_CSS_INPUT_MODE_FIFO, /** data from input-fifo */
+	IA_CSS_INPUT_MODE_TPG, /** data from test-pattern generator */
+	IA_CSS_INPUT_MODE_PRBS, /** data from pseudo-random bit stream */
 	IA_CSS_INPUT_MODE_MEMORY, /** data from a frame in memory */
 	IA_CSS_INPUT_MODE_BUFFERED_SENSOR /** data is sent through mipi buffer */
 };
@@ -38,9 +38,10 @@ enum ia_css_input_mode {
 struct ia_css_mipi_buffer_config {
 	unsigned int size_mem_words; /** The frame size in the system memory
 					  words (32B) */
-	bool contiguous;	     /** Allocated memory physically
+	bool contiguous; /** Allocated memory physically
 					  contiguously or not. \deprecated{Will be false always.}*/
-	unsigned int nof_mipi_buffers; /** The number of MIPI buffers required for this
+	unsigned int
+		nof_mipi_buffers; /** The number of MIPI buffers required for this
 					stream */
 };
 
@@ -55,7 +56,7 @@ enum {
  *  multiple of this in one virtual channel.
  */
 struct ia_css_stream_isys_stream_config {
-	struct ia_css_resolution  input_res; /** Resolution of input data */
+	struct ia_css_resolution input_res; /** Resolution of input data */
 	enum atomisp_input_format format; /** Format of input stream. This data
 					       format will be mapped to MIPI data
 					       type internally. */
@@ -66,8 +67,8 @@ struct ia_css_stream_isys_stream_config {
 };
 
 struct ia_css_stream_input_config {
-	struct ia_css_resolution  input_res; /** Resolution of input data */
-	struct ia_css_resolution  effective_res; /** Resolution of input data.
+	struct ia_css_resolution input_res; /** Resolution of input data */
+	struct ia_css_resolution effective_res; /** Resolution of input data.
 							Used for CSS 2400/1 System and deprecated for other
 							systems (replaced by input_effective_res in
 							ia_css_pipe_config) */
@@ -81,12 +82,12 @@ struct ia_css_stream_input_config {
  *  CSS. This is used to program the CSS hardware.
  */
 struct ia_css_stream_config {
-	enum ia_css_input_mode    mode; /** Input mode */
+	enum ia_css_input_mode mode; /** Input mode */
 	union {
-		struct ia_css_input_port  port; /** Port, for sensor only. */
+		struct ia_css_input_port port; /** Port, for sensor only. */
 		struct ia_css_prbs_config prbs; /** PRBS configuration */
 	} source; /** Source of input data */
-	unsigned int	      channel_id; /** Channel on which input data
+	unsigned int channel_id; /** Channel on which input data
 						   will arrive. Use this field
 						   to specify virtual channel id.
 						   Valid values are: 0, 1, 2, 3 */
@@ -103,7 +104,8 @@ struct ia_css_stream_config {
 	unsigned int sensor_binning_factor; /** Binning factor used by sensor
 						 to produce image data. This is
 						 used for shading correction. */
-	unsigned int pixels_per_clock; /** Number of pixels per clock, which can be
+	unsigned int
+		pixels_per_clock; /** Number of pixels per clock, which can be
 					    1, 2 or 4. */
 	bool online; /** offline will activate RAW copy on SP, use this for
 			  continuous capture. */
@@ -121,7 +123,7 @@ struct ia_css_stream_config {
 	struct ia_css_mipi_buffer_config
 		mipi_buffer_config; /** mipi buffer configuration */
 	struct ia_css_metadata_config
-		metadata_config;     /** Metadata configuration. */
+		metadata_config; /** Metadata configuration. */
 	bool ia_css_enable_raw_buffer_locking; /** Enable Raw Buffer Locking for HALv3 Support */
 	bool lock_all;
 	/** Lock all RAW buffers (true) or lock only buffers processed by
@@ -166,11 +168,9 @@ void ia_css_stream_config_defaults(struct ia_css_stream_config *stream_config);
 *
 * This function will create a stream with a given configuration and given pipes.
 */
-int
-ia_css_stream_create(const struct ia_css_stream_config *stream_config,
-		     int num_pipes,
-		     struct ia_css_pipe *pipes[],
-		     struct ia_css_stream **stream);
+int ia_css_stream_create(const struct ia_css_stream_config *stream_config,
+			 int num_pipes, struct ia_css_pipe *pipes[],
+			 struct ia_css_stream **stream);
 
 /* @brief Destroys a stream
  * @param[in]	stream The stream.
@@ -178,8 +178,7 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
  *
  * This function will destroy a given stream.
  */
-int
-ia_css_stream_destroy(struct ia_css_stream *stream);
+int ia_css_stream_destroy(struct ia_css_stream *stream);
 
 /* @brief Provides information about a stream
  * @param[in]	stream The stream.
@@ -188,10 +187,8 @@ ia_css_stream_destroy(struct ia_css_stream *stream);
  *
  * This function will destroy a given stream.
  */
-int
-ia_css_stream_get_info(const struct ia_css_stream *stream,
-		       struct ia_css_stream_info *stream_info);
-
+int ia_css_stream_get_info(const struct ia_css_stream *stream,
+			   struct ia_css_stream_info *stream_info);
 
 /* @brief Starts the stream.
  * @param[in]	stream The stream.
@@ -203,8 +200,7 @@ ia_css_stream_get_info(const struct ia_css_stream *stream,
  * NOTE: this function will only send start event to corresponding
  * thread and will not start SP any more.
  */
-int
-ia_css_stream_start(struct ia_css_stream *stream);
+int ia_css_stream_start(struct ia_css_stream *stream);
 
 /* @brief Stop the stream.
  * @param[in]	stream The stream.
@@ -213,8 +209,7 @@ ia_css_stream_start(struct ia_css_stream *stream);
  * NOTE: this function will send stop event to pipes belong to this
  * stream but will not terminate threads.
  */
-int
-ia_css_stream_stop(struct ia_css_stream *stream);
+int ia_css_stream_stop(struct ia_css_stream *stream);
 
 /* @brief Check if a stream has stopped
  * @param[in]	stream The stream.
@@ -222,8 +217,7 @@ ia_css_stream_stop(struct ia_css_stream *stream);
  *
  * This function will check if the stream has stopped and return the correspondent boolean flag.
  */
-bool
-ia_css_stream_has_stopped(struct ia_css_stream *stream);
+bool ia_css_stream_has_stopped(struct ia_css_stream *stream);
 
 /* @brief	destroy a stream according to the stream seed previosly saved in the seed array.
  * @param[in]	stream The stream.
@@ -231,8 +225,7 @@ ia_css_stream_has_stopped(struct ia_css_stream *stream);
  *
  * Destroy the stream and all the pipes related to it.
  */
-int
-ia_css_stream_unload(struct ia_css_stream *stream);
+int ia_css_stream_unload(struct ia_css_stream *stream);
 
 /* @brief Returns stream format
  * @param[in]	stream The stream.
@@ -250,8 +243,7 @@ ia_css_stream_get_format(const struct ia_css_stream *stream);
  * This function will check if the stream is configured for 2 pixels per clock and
  * return the correspondent boolean flag.
  */
-bool
-ia_css_stream_get_two_pixels_per_clock(const struct ia_css_stream *stream);
+bool ia_css_stream_get_two_pixels_per_clock(const struct ia_css_stream *stream);
 
 /* @brief Sets the output frame stride (at the last pipe)
  * @param[in]	stream The stream
@@ -260,9 +252,8 @@ ia_css_stream_get_two_pixels_per_clock(const struct ia_css_stream *stream);
  *
  * This function will Set the output frame stride (at the last pipe)
  */
-int
-ia_css_stream_set_output_padded_width(struct ia_css_stream *stream,
-				      unsigned int output_padded_width);
+int ia_css_stream_set_output_padded_width(struct ia_css_stream *stream,
+					  unsigned int output_padded_width);
 
 /* @brief Return max number of continuous RAW frames.
  * @param[in]	stream The stream.
@@ -272,9 +263,8 @@ ia_css_stream_set_output_padded_width(struct ia_css_stream *stream,
  * This function will return the maximum number of continuous RAW frames
  * the system can support.
  */
-int
-ia_css_stream_get_max_buffer_depth(struct ia_css_stream *stream,
-				   int *buffer_depth);
+int ia_css_stream_get_max_buffer_depth(struct ia_css_stream *stream,
+				       int *buffer_depth);
 
 /* @brief Set nr of continuous RAW frames to use.
  *
@@ -284,8 +274,8 @@ ia_css_stream_get_max_buffer_depth(struct ia_css_stream *stream,
  *
  * Set the number of continuous frames to use during continuous modes.
  */
-int
-ia_css_stream_set_buffer_depth(struct ia_css_stream *stream, int buffer_depth);
+int ia_css_stream_set_buffer_depth(struct ia_css_stream *stream,
+				   int buffer_depth);
 
 /* @brief Get number of continuous RAW frames to use.
  * @param[in]	stream The stream.
@@ -295,8 +285,8 @@ ia_css_stream_set_buffer_depth(struct ia_css_stream *stream, int buffer_depth);
  * Get the currently set number of continuous frames
  * to use during continuous modes.
  */
-int
-ia_css_stream_get_buffer_depth(struct ia_css_stream *stream, int *buffer_depth);
+int ia_css_stream_get_buffer_depth(struct ia_css_stream *stream,
+				   int *buffer_depth);
 
 /* ===== CAPTURE ===== */
 
@@ -326,11 +316,8 @@ ia_css_stream_get_buffer_depth(struct ia_css_stream *stream, int *buffer_depth);
  *  frames and 2 subsequent frames, you would call
  *  ia_css_stream_capture(5, 0, -2).
  */
-int
-ia_css_stream_capture(struct ia_css_stream *stream,
-		      int num_captures,
-		      unsigned int skip,
-		      int offset);
+int ia_css_stream_capture(struct ia_css_stream *stream, int num_captures,
+			  unsigned int skip, int offset);
 
 /* @brief Specify which raw frame to tag based on exp_id found in frame info
  *
@@ -342,9 +329,8 @@ ia_css_stream_capture(struct ia_css_stream *stream,
  * This function allows the user to tag a raw frame based on the exposure id
  * found in the viewfinder frames' frame info.
  */
-int
-ia_css_stream_capture_frame(struct ia_css_stream *stream,
-			    unsigned int exp_id);
+int ia_css_stream_capture_frame(struct ia_css_stream *stream,
+				unsigned int exp_id);
 
 /* ===== VIDEO ===== */
 
@@ -374,11 +360,9 @@ ia_css_stream_capture_frame(struct ia_css_stream *stream,
  * These 3 functions are for testing purpose only and can be used in
  * conjunction with ia_css_stream_send_input_frame
  */
-void
-ia_css_stream_send_input_frame(const struct ia_css_stream *stream,
-			       const unsigned short *data,
-			       unsigned int width,
-			       unsigned int height);
+void ia_css_stream_send_input_frame(const struct ia_css_stream *stream,
+				    const unsigned short *data,
+				    unsigned int width, unsigned int height);
 
 /* @brief Start an input frame on the CSS input FIFO.
  *
@@ -393,8 +377,7 @@ ia_css_stream_send_input_frame(const struct ia_css_stream *stream,
  * To simulate an error, the user can provide "incorrect" values for
  * input_format and/or two_pixels_per_clock.
  */
-void
-ia_css_stream_start_input_frame(const struct ia_css_stream *stream);
+void ia_css_stream_start_input_frame(const struct ia_css_stream *stream);
 
 /* @brief Send a line of input data into the CSS input FIFO.
  *
@@ -413,12 +396,11 @@ ia_css_stream_start_input_frame(const struct ia_css_stream *stream);
  * This function blocks until the entire line has been written into the
  * input FIFO.
  */
-void
-ia_css_stream_send_input_line(const struct ia_css_stream *stream,
-			      const unsigned short *data,
-			      unsigned int width,
-			      const unsigned short *data2,
-			      unsigned int width2);
+void ia_css_stream_send_input_line(const struct ia_css_stream *stream,
+				   const unsigned short *data,
+				   unsigned int width,
+				   const unsigned short *data2,
+				   unsigned int width2);
 
 /* @brief Send a line of input embedded data into the CSS input FIFO.
  *
@@ -436,11 +418,10 @@ ia_css_stream_send_input_line(const struct ia_css_stream *stream,
  * This function blocks until the entire line has been written into the
  * input FIFO.
  */
-void
-ia_css_stream_send_input_embedded_line(const struct ia_css_stream *stream,
-				       enum atomisp_input_format format,
-				       const unsigned short *data,
-				       unsigned int width);
+void ia_css_stream_send_input_embedded_line(const struct ia_css_stream *stream,
+					    enum atomisp_input_format format,
+					    const unsigned short *data,
+					    unsigned int width);
 
 /* @brief End an input frame on the CSS input FIFO.
  *
@@ -449,8 +430,7 @@ ia_css_stream_send_input_embedded_line(const struct ia_css_stream *stream,
  *
  * Send the end-of-frame signal into the CSS input FIFO.
  */
-void
-ia_css_stream_end_input_frame(const struct ia_css_stream *stream);
+void ia_css_stream_end_input_frame(const struct ia_css_stream *stream);
 
 /* @brief Configure a stream with filter coefficients.
  *	   @deprecated {Replaced by
@@ -469,10 +449,9 @@ ia_css_stream_end_input_frame(const struct ia_css_stream *stream);
  * in fact this is the expected behavior most of the time. Proper
  * resource locking and double buffering is in place to allow for this.
  */
-int
-ia_css_stream_set_isp_config_on_pipe(struct ia_css_stream *stream,
-				     const struct ia_css_isp_config *config,
-				     struct ia_css_pipe *pipe);
+int ia_css_stream_set_isp_config_on_pipe(struct ia_css_stream *stream,
+					 const struct ia_css_isp_config *config,
+					 struct ia_css_pipe *pipe);
 
 /* @brief Configure a stream with filter coefficients.
  *	   @deprecated {Replaced by
@@ -489,19 +468,16 @@ ia_css_stream_set_isp_config_on_pipe(struct ia_css_stream *stream,
  * in fact this is the expected behaviour most of the time. Proper
  * resource locking and double buffering is in place to allow for this.
  */
-int
-ia_css_stream_set_isp_config(
-    struct ia_css_stream *stream,
-    const struct ia_css_isp_config *config);
+int ia_css_stream_set_isp_config(struct ia_css_stream *stream,
+				 const struct ia_css_isp_config *config);
 
 /* @brief Get selected configuration settings
  * @param[in]	stream	The stream.
  * @param[out]	config	Configuration settings.
  * @return		None
  */
-void
-ia_css_stream_get_isp_config(const struct ia_css_stream *stream,
-			     struct ia_css_isp_config *config);
+void ia_css_stream_get_isp_config(const struct ia_css_stream *stream,
+				  struct ia_css_isp_config *config);
 
 /* @brief allocate continuous raw frames for continuous capture
  * @param[in]	stream The stream.
@@ -512,8 +488,7 @@ ia_css_stream_get_isp_config(const struct ia_css_stream *stream,
  *  this function without locking. This function is the allocation part
  *  and next one is update part
  */
-int
-ia_css_alloc_continuous_frame_remain(struct ia_css_stream *stream);
+int ia_css_alloc_continuous_frame_remain(struct ia_css_stream *stream);
 
 /* @brief allocate continuous raw frames for continuous capture
  * @param[in]	stream The stream.
@@ -523,8 +498,7 @@ ia_css_alloc_continuous_frame_remain(struct ia_css_stream *stream);
  *  we separate the allocation part and update part to let driver call
  *  this function without locking. This function is the update part
  */
-int
-ia_css_update_continuous_frames(struct ia_css_stream *stream);
+int ia_css_update_continuous_frames(struct ia_css_stream *stream);
 
 /* @brief ia_css_unlock_raw_frame . unlock a raw frame (HALv3 Support)
  * @param[in]	stream The stream.
@@ -535,8 +509,7 @@ ia_css_update_continuous_frames(struct ia_css_stream *stream);
  * releases its reference to a raw buffer (which are managed by SP), this function allows
  * application to explicitly unlock that buffer in SP.
  */
-int
-ia_css_unlock_raw_frame(struct ia_css_stream *stream, uint32_t exp_id);
+int ia_css_unlock_raw_frame(struct ia_css_stream *stream, uint32_t exp_id);
 
 /* @brief ia_css_en_dz_capt_pipe . Enable/Disable digital zoom for capture pipe
  * @param[in]   stream The stream.
@@ -548,6 +521,5 @@ ia_css_unlock_raw_frame(struct ia_css_stream *stream, uint32_t exp_id);
  * In process_zoom_and_motion(), decision to enable or disable zoom for every stage depends
  * on this flag.
  */
-void
-ia_css_en_dz_capt_pipe(struct ia_css_stream *stream, bool enable);
+void ia_css_en_dz_capt_pipe(struct ia_css_stream *stream, bool enable);
 #endif /* __IA_CSS_STREAM_PUBLIC_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_timer.h b/drivers/staging/media/atomisp/pci/ia_css_timer.h
index da752834adf458a4802aa3deaa74700d710efe5a..6b2461fee3bb191195fa4279c4e56adaecd1304b 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_timer.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_timer.h
@@ -11,7 +11,7 @@ Copyright (c) 2010 - 2015, Intel Corporation.
 /* @file
  * Timer interface definitions
  */
-#include <type_support.h>		/* for uint32_t */
+#include <type_support.h> /* for uint32_t */
 #include "ia_css_err.h"
 
 /* @brief timer reading definition */
@@ -38,15 +38,15 @@ enum ia_css_tm_event {
 
 /* @brief code measurement common struct */
 struct ia_css_time_meas {
-	clock_value_t	start_timer_value;	/** measured time in ticks */
-	clock_value_t	end_timer_value;	/** measured time in ticks */
+	clock_value_t start_timer_value; /** measured time in ticks */
+	clock_value_t end_timer_value; /** measured time in ticks */
 };
 
 /**@brief SIZE_OF_IA_CSS_CLOCK_TICK_STRUCT checks to ensure correct alignment for struct ia_css_clock_tick. */
 #define SIZE_OF_IA_CSS_CLOCK_TICK_STRUCT sizeof(clock_value_t)
 /* @brief checks to ensure correct alignment for ia_css_time_meas. */
-#define SIZE_OF_IA_CSS_TIME_MEAS_STRUCT (sizeof(clock_value_t) \
-					+ sizeof(clock_value_t))
+#define SIZE_OF_IA_CSS_TIME_MEAS_STRUCT \
+	(sizeof(clock_value_t) + sizeof(clock_value_t))
 
 /* @brief API to fetch timer count directly
 *
@@ -54,8 +54,6 @@ struct ia_css_time_meas {
 * @return 0 if success
 *
 */
-int
-ia_css_timer_get_current_tick(
-    struct ia_css_clock_tick *curr_ts);
+int ia_css_timer_get_current_tick(struct ia_css_clock_tick *curr_ts);
 
-#endif  /* __IA_CSS_TIMER_H */
+#endif /* __IA_CSS_TIMER_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_types.h b/drivers/staging/media/atomisp/pci/ia_css_types.h
index 676d7e20b282d21ad4b9bd98d8855aa5cb2e639a..7910b6972573c17168fb0bc71bc13242a6ea0015 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_types.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_types.h
@@ -53,16 +53,16 @@
 #define IA_CSS_DVS_STAT_GRID_INFO_SUPPORTED
 /** Should be removed after Driver adaptation will be done */
 
-#define IA_CSS_VERSION_MAJOR    2
-#define IA_CSS_VERSION_MINOR    0
+#define IA_CSS_VERSION_MAJOR 2
+#define IA_CSS_VERSION_MINOR 0
 #define IA_CSS_VERSION_REVISION 2
 
-#define IA_CSS_MORPH_TABLE_NUM_PLANES  6
+#define IA_CSS_MORPH_TABLE_NUM_PLANES 6
 
 /* Min and max exposure IDs. These macros are here to allow
  * the drivers to get this information. Changing these macros
  * constitutes a CSS API change. */
-#define IA_CSS_ISYS_MIN_EXPOSURE_ID 1   /** Minimum exposure ID */
+#define IA_CSS_ISYS_MIN_EXPOSURE_ID 1 /** Minimum exposure ID */
 #define IA_CSS_ISYS_MAX_EXPOSURE_ID 250 /** Maximum exposure ID */
 
 /* opaque types */
@@ -75,20 +75,20 @@ struct ia_css_state_memory_offsets;
 /* Virtual address within the CSS address space. */
 typedef u32 ia_css_ptr;
 
-#define SIZE_OF_IA_CSS_PTR		sizeof(uint32_t)
+#define SIZE_OF_IA_CSS_PTR sizeof(uint32_t)
 
 /* Generic resolution structure.
  */
 struct ia_css_resolution {
-	u32 width;  /** Width */
+	u32 width; /** Width */
 	u32 height; /** Height */
 };
 
 /* Generic coordinate structure.
  */
 struct ia_css_coordinate {
-	s32 x;	/** Value of a coordinate on the horizontal axis */
-	s32 y;	/** Value of a coordinate on the vertical axis */
+	s32 x; /** Value of a coordinate on the horizontal axis */
+	s32 y; /** Value of a coordinate on the vertical axis */
 };
 
 /* Vector with signed values. This is used to indicate motion for
@@ -106,24 +106,24 @@ struct ia_css_vector {
 /* CSS data descriptor */
 struct ia_css_data {
 	ia_css_ptr address; /** CSS virtual address */
-	u32   size;    /** Disabled if 0 */
+	u32 size; /** Disabled if 0 */
 };
 
 /* Host data descriptor */
 struct ia_css_host_data {
-	char      *address; /** Host address */
-	u32   size;    /** Disabled if 0 */
+	char *address; /** Host address */
+	u32 size; /** Disabled if 0 */
 };
 
 /* ISP data descriptor */
 struct ia_css_isp_data {
-	u32   address; /** ISP address */
-	u32   size;    /** Disabled if 0 */
+	u32 address; /** ISP address */
+	u32 size; /** Disabled if 0 */
 };
 
 /* Shading Correction types. */
 enum ia_css_shading_correction_type {
-	IA_CSS_SHADING_CORRECTION_NONE,	 /** Shading Correction is not processed in the pipe. */
+	IA_CSS_SHADING_CORRECTION_NONE, /** Shading Correction is not processed in the pipe. */
 	IA_CSS_SHADING_CORRECTION_TYPE_1 /** Shading Correction 1.0 (pipe 1.0 on ISP2300, pipe 2.2 on ISP2400/2401) */
 
 	/** More shading correction types can be added in the future. */
@@ -133,7 +133,7 @@ enum ia_css_shading_correction_type {
 struct ia_css_shading_info {
 	enum ia_css_shading_correction_type type; /** Shading Correction type. */
 
-	union {	/* Shading Correction information of each Shading Correction types. */
+	union { /* Shading Correction information of each Shading Correction types. */
 
 		/* Shading Correction information of IA_CSS_SHADING_CORRECTION_TYPE_1.
 		 *
@@ -279,12 +279,12 @@ struct ia_css_shading_info {
 		 */
 		struct {
 			/* ISP2400 */
-			u32 enable;	/** Shading correction enabled.
+			u32 enable; /** Shading correction enabled.
 						     0:disabled, 1:enabled */
 
 			/* ISP2401 */
-			u32 num_hor_grids;	/** Number of data points per line per color on shading table. */
-			u32 num_ver_grids;	/** Number of lines of data points per color on shading table. */
+			u32 num_hor_grids; /** Number of data points per line per color on shading table. */
+			u32 num_ver_grids; /** Number of lines of data points per color on shading table. */
 			u32 bqs_per_grid_cell; /** Grid cell size in BQ unit.
 							 NOTE: bqs = size in BQ(Bayer Quad) unit.
 							       1BQ means {Gr,R,B,Gb} (2x2 pixels).
@@ -351,9 +351,10 @@ struct ia_css_shading_info {
 };
 
 /* Default Shading Correction information of Shading Correction Type 1. */
-#define DEFAULT_SHADING_INFO_TYPE_1 \
-(struct ia_css_shading_info) { \
-	.type = IA_CSS_SHADING_CORRECTION_TYPE_1, \
+#define DEFAULT_SHADING_INFO_TYPE_1                         ( \
+	(struct ia_css_shading_info)                        \
+	{                                                   \
+		.type = IA_CSS_SHADING_CORRECTION_TYPE_1, \
 	.info = { \
 		.type_1 = { \
 			.bayer_scale_hor_ratio_in	= 1, \
@@ -362,10 +363,10 @@ struct ia_css_shading_info {
 			.bayer_scale_ver_ratio_out	= 1, \
 		} \
 	} \
-}
+	})
 
 /* Default Shading Correction information. */
-#define DEFAULT_SHADING_INFO	DEFAULT_SHADING_INFO_TYPE_1
+#define DEFAULT_SHADING_INFO DEFAULT_SHADING_INFO_TYPE_1
 
 /* structure that describes the 3A and DIS grids */
 struct ia_css_grid_info {
@@ -377,7 +378,7 @@ struct ia_css_grid_info {
 	u32 isp_in_height;
 	/* @}*/
 
-	struct ia_css_3a_grid_info  s3a_grid; /** 3A grid info */
+	struct ia_css_3a_grid_info s3a_grid; /** 3A grid info */
 	union ia_css_dvs_grid_u dvs_grid;
 	/** All types of DVS statistics grid info union */
 
@@ -385,10 +386,11 @@ struct ia_css_grid_info {
 };
 
 /* defaults for ia_css_grid_info structs */
-#define DEFAULT_GRID_INFO { \
-	.dvs_grid	= DEFAULT_DVS_GRID_INFO, \
-	.vamem_type	= IA_CSS_VAMEM_TYPE_1 \
-}
+#define DEFAULT_GRID_INFO                          \
+	{                                          \
+		.dvs_grid = DEFAULT_DVS_GRID_INFO, \
+		.vamem_type = IA_CSS_VAMEM_TYPE_1  \
+	}
 
 /* Morphing table, used for geometric distortion and chromatic abberration
  *  correction (GDCAC, also called GDC).
@@ -399,7 +401,7 @@ struct ia_css_morph_table {
 	u32 enable; /** To disable GDC, set this field to false. The
 			  coordinates fields can be set to NULL in this case. */
 	u32 height; /** Table height */
-	u32 width;  /** Table width */
+	u32 width; /** Table width */
 	u16 *coordinates_x[IA_CSS_MORPH_TABLE_NUM_PLANES];
 	/** X coordinates that describe the sensor imperfection */
 	u16 *coordinates_y[IA_CSS_MORPH_TABLE_NUM_PLANES];
@@ -431,7 +433,8 @@ struct ia_css_point {
  * This specifies the region
  */
 struct ia_css_region {
-	struct ia_css_point origin; /** Starting point coordinates for the region */
+	struct ia_css_point
+		origin; /** Starting point coordinates for the region */
 	struct ia_css_resolution resolution; /** Region resolution */
 };
 
@@ -462,24 +465,25 @@ struct ia_css_dz_config {
  *  Primary ISP, the Advanced ISP (GDC) or the low-light ISP (ANR).
  */
 enum ia_css_capture_mode {
-	IA_CSS_CAPTURE_MODE_RAW,      /** no processing, copy data only */
-	IA_CSS_CAPTURE_MODE_BAYER,    /** bayer processing, up to demosaic */
-	IA_CSS_CAPTURE_MODE_PRIMARY,  /** primary ISP */
+	IA_CSS_CAPTURE_MODE_RAW, /** no processing, copy data only */
+	IA_CSS_CAPTURE_MODE_BAYER, /** bayer processing, up to demosaic */
+	IA_CSS_CAPTURE_MODE_PRIMARY, /** primary ISP */
 	IA_CSS_CAPTURE_MODE_ADVANCED, /** advanced ISP (GDC) */
 	IA_CSS_CAPTURE_MODE_LOW_LIGHT /** low light ISP (ANR) */
 };
 
 struct ia_css_capture_config {
 	enum ia_css_capture_mode mode; /** Still capture mode */
-	u32 enable_xnr;	       /** Enable/disable XNR */
+	u32 enable_xnr; /** Enable/disable XNR */
 	u32 enable_raw_output;
-	bool enable_capture_pp_bli;    /** Enable capture_pp_bli mode */
+	bool enable_capture_pp_bli; /** Enable capture_pp_bli mode */
 };
 
 /* default settings for ia_css_capture_config structs */
-#define DEFAULT_CAPTURE_CONFIG { \
-	.mode	= IA_CSS_CAPTURE_MODE_PRIMARY, \
-}
+#define DEFAULT_CAPTURE_CONFIG                       \
+	{                                            \
+		.mode = IA_CSS_CAPTURE_MODE_PRIMARY, \
+	}
 
 /* ISP filter configuration. This is a collection of configurations
  *  for each of the ISP filters (modules).
@@ -496,78 +500,78 @@ struct ia_css_capture_config {
  *    ["ISP block", 2only] : ISP block is used only for ISP2.
  */
 struct ia_css_isp_config {
-	struct ia_css_wb_config   *wb_config;	/** White Balance
+	struct ia_css_wb_config *wb_config; /** White Balance
 							[WB1, 1&2] */
-	struct ia_css_cc_config   *cc_config;	/** Color Correction
+	struct ia_css_cc_config *cc_config; /** Color Correction
 							[CSC1, 1only] */
-	struct ia_css_tnr_config  *tnr_config;	/** Temporal Noise Reduction
+	struct ia_css_tnr_config *tnr_config; /** Temporal Noise Reduction
 							[TNR1, 1&2] */
-	struct ia_css_ecd_config  *ecd_config;	/** Eigen Color Demosaicing
+	struct ia_css_ecd_config *ecd_config; /** Eigen Color Demosaicing
 							[DE2, 2only] */
-	struct ia_css_ynr_config  *ynr_config;	/** Y(Luma) Noise Reduction
+	struct ia_css_ynr_config *ynr_config; /** Y(Luma) Noise Reduction
 							[YNR2&YEE2, 2only] */
-	struct ia_css_fc_config   *fc_config;	/** Fringe Control
+	struct ia_css_fc_config *fc_config; /** Fringe Control
 							[FC2, 2only] */
 	struct ia_css_formats_config
-		*formats_config;	/** Formats Control for main output
+		*formats_config; /** Formats Control for main output
 							[FORMATS, 1&2] */
-	struct ia_css_cnr_config  *cnr_config;	/** Chroma Noise Reduction
+	struct ia_css_cnr_config *cnr_config; /** Chroma Noise Reduction
 							[CNR2, 2only] */
-	struct ia_css_macc_config *macc_config;	/** MACC
+	struct ia_css_macc_config *macc_config; /** MACC
 							[MACC2, 2only] */
-	struct ia_css_ctc_config  *ctc_config;	/** Chroma Tone Control
+	struct ia_css_ctc_config *ctc_config; /** Chroma Tone Control
 							[CTC2, 2only] */
-	struct ia_css_aa_config   *aa_config;	/** YUV Anti-Aliasing
+	struct ia_css_aa_config *aa_config; /** YUV Anti-Aliasing
 							[AA2, 2only]
 							(not used currently) */
-	struct ia_css_aa_config   *baa_config;	/** Bayer Anti-Aliasing
+	struct ia_css_aa_config *baa_config; /** Bayer Anti-Aliasing
 							[BAA2, 1&2] */
-	struct ia_css_ce_config   *ce_config;	/** Chroma Enhancement
+	struct ia_css_ce_config *ce_config; /** Chroma Enhancement
 							[CE1, 1only] */
 	struct ia_css_dvs_6axis_config *dvs_6axis_config;
-	struct ia_css_ob_config   *ob_config;  /** Objective Black
+	struct ia_css_ob_config *ob_config; /** Objective Black
 							[OB1, 1&2] */
-	struct ia_css_dp_config   *dp_config;  /** Defect Pixel Correction
+	struct ia_css_dp_config *dp_config; /** Defect Pixel Correction
 							[DPC1/DPC2, 1&2] */
-	struct ia_css_nr_config   *nr_config;  /** Noise Reduction
+	struct ia_css_nr_config *nr_config; /** Noise Reduction
 							[BNR1&YNR1&CNR1, 1&2]*/
-	struct ia_css_ee_config   *ee_config;  /** Edge Enhancement
+	struct ia_css_ee_config *ee_config; /** Edge Enhancement
 							[YEE1, 1&2] */
-	struct ia_css_de_config   *de_config;  /** Demosaic
+	struct ia_css_de_config *de_config; /** Demosaic
 							[DE1, 1only] */
-	struct ia_css_gc_config   *gc_config;  /** Gamma Correction (for YUV)
+	struct ia_css_gc_config *gc_config; /** Gamma Correction (for YUV)
 							[GC1, 1only] */
-	struct ia_css_anr_config  *anr_config; /** Advanced Noise Reduction */
-	struct ia_css_3a_config   *s3a_config; /** 3A Statistics config */
-	struct ia_css_xnr_config  *xnr_config; /** eXtra Noise Reduction */
-	struct ia_css_dz_config   *dz_config;  /** Digital Zoom */
+	struct ia_css_anr_config *anr_config; /** Advanced Noise Reduction */
+	struct ia_css_3a_config *s3a_config; /** 3A Statistics config */
+	struct ia_css_xnr_config *xnr_config; /** eXtra Noise Reduction */
+	struct ia_css_dz_config *dz_config; /** Digital Zoom */
 	struct ia_css_cc_config *yuv2rgb_cc_config; /** Color Correction
 							[CCM2, 2only] */
 	struct ia_css_cc_config *rgb2yuv_cc_config; /** Color Correction
 							[CSC2, 2only] */
-	struct ia_css_macc_table  *macc_table;	/** MACC
+	struct ia_css_macc_table *macc_table; /** MACC
 							[MACC1/MACC2, 1&2]*/
-	struct ia_css_gamma_table *gamma_table;	/** Gamma Correction (for YUV)
+	struct ia_css_gamma_table *gamma_table; /** Gamma Correction (for YUV)
 							[GC1, 1only] */
-	struct ia_css_ctc_table   *ctc_table;	/** Chroma Tone Control
+	struct ia_css_ctc_table *ctc_table; /** Chroma Tone Control
 							[CTC1, 1only] */
 
 	/* \deprecated */
-	struct ia_css_xnr_table   *xnr_table;	/** eXtra Noise Reduction
+	struct ia_css_xnr_table *xnr_table; /** eXtra Noise Reduction
 							[XNR1, 1&2] */
-	struct ia_css_rgb_gamma_table *r_gamma_table;/** sRGB Gamma Correction
+	struct ia_css_rgb_gamma_table *r_gamma_table; /** sRGB Gamma Correction
 							[GC2, 2only] */
-	struct ia_css_rgb_gamma_table *g_gamma_table;/** sRGB Gamma Correction
+	struct ia_css_rgb_gamma_table *g_gamma_table; /** sRGB Gamma Correction
 							[GC2, 2only] */
-	struct ia_css_rgb_gamma_table *b_gamma_table;/** sRGB Gamma Correction
+	struct ia_css_rgb_gamma_table *b_gamma_table; /** sRGB Gamma Correction
 							[GC2, 2only] */
-	struct ia_css_vector      *motion_vector; /** For 2-axis DVS */
+	struct ia_css_vector *motion_vector; /** For 2-axis DVS */
 	struct ia_css_shading_table *shading_table;
-	struct ia_css_morph_table   *morph_table;
+	struct ia_css_morph_table *morph_table;
 	struct ia_css_dvs_coefficients *dvs_coefs; /** DVS 1.0 coefficients */
 	struct ia_css_dvs2_coefficients *dvs2_coefs; /** DVS 2.0 coefficients */
-	struct ia_css_capture_config   *capture_config;
-	struct ia_css_anr_thres   *anr_thres;
+	struct ia_css_capture_config *capture_config;
+	struct ia_css_anr_thres *anr_thres;
 	/* @deprecated{Old shading settings, see bugzilla bz675 for details} */
 	struct ia_css_shading_settings *shading_settings;
 	struct ia_css_xnr3_config *xnr3_config; /** eXtreme Noise Reduction v3 */
@@ -578,19 +582,19 @@ struct ia_css_isp_config {
 	 *  the risk for regression is not in the individual blocks, but how they
 	 *  integrate together. */
 	struct ia_css_output_config
-		*output_config;	/** Main Output Mirroring, flipping */
+		*output_config; /** Main Output Mirroring, flipping */
 
 	struct ia_css_scaler_config
-		*scaler_config;         /** Skylake: scaler config (optional) */
-	struct ia_css_formats_config
-		*formats_config_display;/** Formats control for viewfinder/display output (optional)
+		*scaler_config; /** Skylake: scaler config (optional) */
+	struct ia_css_formats_config *
+		formats_config_display; /** Formats control for viewfinder/display output (optional)
 										[OSYS, n/a] */
-	struct ia_css_output_config
-		*output_config_display; /** Viewfinder/display output mirroring, flipping (optional) */
+	struct ia_css_output_config *
+		output_config_display; /** Viewfinder/display output mirroring, flipping (optional) */
 
-	struct ia_css_frame
-		*output_frame;          /** Output frame the config is to be applied to (optional) */
-	u32			isp_config_id;	/** Unique ID to track which config was actually applied to a particular frame */
+	struct ia_css_frame *
+		output_frame; /** Output frame the config is to be applied to (optional) */
+	u32 isp_config_id; /** Unique ID to track which config was actually applied to a particular frame */
 };
 
 #endif /* _IA_CSS_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_version.h b/drivers/staging/media/atomisp/pci/ia_css_version.h
index 13b192dec8f6d86579af9df31fdb927da61559e9..cea036d448fc06a021ebf040051cea256f4c9281 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_version.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_version.h
@@ -14,7 +14,7 @@
 #include <ia_css_err.h>
 
 /* a common size for the version arrays */
-#define MAX_VERSION_SIZE	500
+#define MAX_VERSION_SIZE 500
 
 /* @brief Retrieves the current CSS version
  * @param[out]	version		A pointer to a buffer where to put the generated
@@ -26,7 +26,6 @@
  * This function generates and returns the version string. If FW is loaded, it
  * attaches the FW version.
  */
-int
-ia_css_get_version(char *version, int max_size);
+int ia_css_get_version(char *version, int max_size);
 
 #endif /* __IA_CSS_VERSION_H */
diff --git a/drivers/staging/media/atomisp/pci/ia_css_version_data.h b/drivers/staging/media/atomisp/pci/ia_css_version_data.h
index 33fabac99bb7972946d9b89ec2d4d2eaabc35b80..65e894ec9b58bbb03b544de285f10e6c705bec80 100644
--- a/drivers/staging/media/atomisp/pci/ia_css_version_data.h
+++ b/drivers/staging/media/atomisp/pci/ia_css_version_data.h
@@ -13,7 +13,9 @@
 #ifndef __IA_CSS_VERSION_DATA_H
 #define __IA_CSS_VERSION_DATA_H
 
-#define ISP2400_CSS_VERSION_STRING "REL:20150521_21.4_0539; API:2.1.15.3; GIT:irci_candrpv_0415_20150504_35b345#35b345be52ac575f8934abb3a88fea26a94e7343; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
-#define ISP2401_CSS_VERSION_STRING "REL:20150911_37.5_1652; API:2.1.20.9; GIT:irci___#ebf437d53a8951bb7ff6d13fdb7270dab393a92a; SDK:; USER:viedifw; "
+#define ISP2400_CSS_VERSION_STRING \
+	"REL:20150521_21.4_0539; API:2.1.15.3; GIT:irci_candrpv_0415_20150504_35b345#35b345be52ac575f8934abb3a88fea26a94e7343; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
+#define ISP2401_CSS_VERSION_STRING \
+	"REL:20150911_37.5_1652; API:2.1.20.9; GIT:irci___#ebf437d53a8951bb7ff6d13fdb7270dab393a92a; SDK:; USER:viedifw; "
 
 #endif
diff --git a/drivers/staging/media/atomisp/pci/if_defs.h b/drivers/staging/media/atomisp/pci/if_defs.h
index 7a6b237485500a7a4ea357a9046600a391f5e9a6..1aaebb074c81e5f7789b165dbf0c4c92023bc21e 100644
--- a/drivers/staging/media/atomisp/pci/if_defs.h
+++ b/drivers/staging/media/atomisp/pci/if_defs.h
@@ -7,8 +7,8 @@
 #ifndef _IF_DEFS_H
 #define _IF_DEFS_H
 
-#define HIVE_IF_FRAME_REQUEST        0xA000
-#define HIVE_IF_LINES_REQUEST        0xB000
-#define HIVE_IF_VECTORS_REQUEST      0xC000
+#define HIVE_IF_FRAME_REQUEST 0xA000
+#define HIVE_IF_LINES_REQUEST 0xB000
+#define HIVE_IF_VECTORS_REQUEST 0xC000
 
 #endif /* _IF_DEFS_H */
diff --git a/drivers/staging/media/atomisp/pci/input_formatter_subsystem_defs.h b/drivers/staging/media/atomisp/pci/input_formatter_subsystem_defs.h
index f29a3cab76ee6c3ae936a8d61e1304c2caca47c1..1e1325bf4271fe12382207063f18b80b7f58f20d 100644
--- a/drivers/staging/media/atomisp/pci/input_formatter_subsystem_defs.h
+++ b/drivers/staging/media/atomisp/pci/input_formatter_subsystem_defs.h
@@ -7,39 +7,40 @@
 #ifndef _if_subsystem_defs_h__
 #define _if_subsystem_defs_h__
 
-#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_0            0
-#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_1            1
-#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_2            2
-#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_3            3
-#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_4            4
-#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_5            5
-#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_6            6
-#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_7            7
-#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_FSYNC_LUT_REG        8
-#define HIVE_IFMT_GP_REGS_SRST_IDX                          9
-#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IDX                 10
-
-#define HIVE_IFMT_GP_REGS_CH_ID_FMT_TYPE_IDX               11
-
-#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_BASE         HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_0
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_0 0
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_1 1
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_2 2
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_3 3
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_4 4
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_5 5
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_6 6
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_7 7
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_FSYNC_LUT_REG 8
+#define HIVE_IFMT_GP_REGS_SRST_IDX 9
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IDX 10
+
+#define HIVE_IFMT_GP_REGS_CH_ID_FMT_TYPE_IDX 11
+
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_BASE \
+	HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_0
 
 /* order of the input bits for the ifmt irq controller */
-#define HIVE_IFMT_IRQ_IFT_PRIM_BIT_ID                       0
-#define HIVE_IFMT_IRQ_IFT_PRIM_B_BIT_ID                     1
-#define HIVE_IFMT_IRQ_IFT_SEC_BIT_ID                        2
-#define HIVE_IFMT_IRQ_MEM_CPY_BIT_ID                        3
-#define HIVE_IFMT_IRQ_SIDEBAND_CHANGED_BIT_ID               4
+#define HIVE_IFMT_IRQ_IFT_PRIM_BIT_ID 0
+#define HIVE_IFMT_IRQ_IFT_PRIM_B_BIT_ID 1
+#define HIVE_IFMT_IRQ_IFT_SEC_BIT_ID 2
+#define HIVE_IFMT_IRQ_MEM_CPY_BIT_ID 3
+#define HIVE_IFMT_IRQ_SIDEBAND_CHANGED_BIT_ID 4
 
 /* order of the input bits for the ifmt Soft reset register */
-#define HIVE_IFMT_GP_REGS_SRST_IFT_PRIM_BIT_IDX             0
-#define HIVE_IFMT_GP_REGS_SRST_IFT_PRIM_B_BIT_IDX           1
-#define HIVE_IFMT_GP_REGS_SRST_IFT_SEC_BIT_IDX              2
-#define HIVE_IFMT_GP_REGS_SRST_MEM_CPY_BIT_IDX              3
+#define HIVE_IFMT_GP_REGS_SRST_IFT_PRIM_BIT_IDX 0
+#define HIVE_IFMT_GP_REGS_SRST_IFT_PRIM_B_BIT_IDX 1
+#define HIVE_IFMT_GP_REGS_SRST_IFT_SEC_BIT_IDX 2
+#define HIVE_IFMT_GP_REGS_SRST_MEM_CPY_BIT_IDX 3
 
 /* order of the input bits for the ifmt Soft reset register */
-#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_PRIM_BIT_IDX     0
-#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_PRIM_B_BIT_IDX   1
-#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_SEC_BIT_IDX      2
-#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_MEM_CPY_BIT_IDX      3
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_PRIM_BIT_IDX 0
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_PRIM_B_BIT_IDX 1
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_SEC_BIT_IDX 2
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_MEM_CPY_BIT_IDX 3
 
 #endif /* _if_subsystem_defs_h__ */
diff --git a/drivers/staging/media/atomisp/pci/input_selector_defs.h b/drivers/staging/media/atomisp/pci/input_selector_defs.h
index 8d67aabb898e3f592663087d51037d4d316aa3c9..68574c5e5346bf49d2a080f54e005384fc737b05 100644
--- a/drivers/staging/media/atomisp/pci/input_selector_defs.h
+++ b/drivers/staging/media/atomisp/pci/input_selector_defs.h
@@ -8,73 +8,73 @@
 #define _input_selector_defs_h
 
 #ifndef HIVE_ISP_ISEL_SEL_BITS
-#define HIVE_ISP_ISEL_SEL_BITS                                  2
+#define HIVE_ISP_ISEL_SEL_BITS 2
 #endif
 
 #ifndef HIVE_ISP_CH_ID_BITS
-#define HIVE_ISP_CH_ID_BITS                                     2
+#define HIVE_ISP_CH_ID_BITS 2
 #endif
 
 #ifndef HIVE_ISP_FMT_TYPE_BITS
-#define HIVE_ISP_FMT_TYPE_BITS                                  5
+#define HIVE_ISP_FMT_TYPE_BITS 5
 #endif
 
 /* gp_register register id's -- Outputs */
-#define HIVE_ISEL_GP_REGS_SYNCGEN_ENABLE_IDX                    0
-#define HIVE_ISEL_GP_REGS_SYNCGEN_FREE_RUNNING_IDX              1
-#define HIVE_ISEL_GP_REGS_SYNCGEN_PAUSE_IDX                     2
-#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_FRAMES_IDX                 3
-#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_PIX_IDX                    4
-#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_LINES_IDX                  5
-#define HIVE_ISEL_GP_REGS_SYNCGEN_HBLANK_CYCLES_IDX             6
-#define HIVE_ISEL_GP_REGS_SYNCGEN_VBLANK_CYCLES_IDX             7
+#define HIVE_ISEL_GP_REGS_SYNCGEN_ENABLE_IDX 0
+#define HIVE_ISEL_GP_REGS_SYNCGEN_FREE_RUNNING_IDX 1
+#define HIVE_ISEL_GP_REGS_SYNCGEN_PAUSE_IDX 2
+#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_FRAMES_IDX 3
+#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_PIX_IDX 4
+#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_LINES_IDX 5
+#define HIVE_ISEL_GP_REGS_SYNCGEN_HBLANK_CYCLES_IDX 6
+#define HIVE_ISEL_GP_REGS_SYNCGEN_VBLANK_CYCLES_IDX 7
 
-#define HIVE_ISEL_GP_REGS_SOF_IDX                               8
-#define HIVE_ISEL_GP_REGS_EOF_IDX                               9
-#define HIVE_ISEL_GP_REGS_SOL_IDX                              10
-#define HIVE_ISEL_GP_REGS_EOL_IDX                              11
+#define HIVE_ISEL_GP_REGS_SOF_IDX 8
+#define HIVE_ISEL_GP_REGS_EOF_IDX 9
+#define HIVE_ISEL_GP_REGS_SOL_IDX 10
+#define HIVE_ISEL_GP_REGS_EOL_IDX 11
 
-#define HIVE_ISEL_GP_REGS_PRBS_ENABLE                          12
-#define HIVE_ISEL_GP_REGS_PRBS_ENABLE_PORT_B                   13
-#define HIVE_ISEL_GP_REGS_PRBS_LFSR_RESET_VALUE                14
+#define HIVE_ISEL_GP_REGS_PRBS_ENABLE 12
+#define HIVE_ISEL_GP_REGS_PRBS_ENABLE_PORT_B 13
+#define HIVE_ISEL_GP_REGS_PRBS_LFSR_RESET_VALUE 14
 
-#define HIVE_ISEL_GP_REGS_TPG_ENABLE                           15
-#define HIVE_ISEL_GP_REGS_TPG_ENABLE_PORT_B                    16
-#define HIVE_ISEL_GP_REGS_TPG_HOR_CNT_MASK_IDX                 17
-#define HIVE_ISEL_GP_REGS_TPG_VER_CNT_MASK_IDX                 18
-#define HIVE_ISEL_GP_REGS_TPG_XY_CNT_MASK_IDX                  19
-#define HIVE_ISEL_GP_REGS_TPG_HOR_CNT_DELTA_IDX                20
-#define HIVE_ISEL_GP_REGS_TPG_VER_CNT_DELTA_IDX                21
-#define HIVE_ISEL_GP_REGS_TPG_MODE_IDX                         22
-#define HIVE_ISEL_GP_REGS_TPG_R1_IDX                           23
-#define HIVE_ISEL_GP_REGS_TPG_G1_IDX                           24
-#define HIVE_ISEL_GP_REGS_TPG_B1_IDX                           25
-#define HIVE_ISEL_GP_REGS_TPG_R2_IDX                           26
-#define HIVE_ISEL_GP_REGS_TPG_G2_IDX                           27
-#define HIVE_ISEL_GP_REGS_TPG_B2_IDX                           28
+#define HIVE_ISEL_GP_REGS_TPG_ENABLE 15
+#define HIVE_ISEL_GP_REGS_TPG_ENABLE_PORT_B 16
+#define HIVE_ISEL_GP_REGS_TPG_HOR_CNT_MASK_IDX 17
+#define HIVE_ISEL_GP_REGS_TPG_VER_CNT_MASK_IDX 18
+#define HIVE_ISEL_GP_REGS_TPG_XY_CNT_MASK_IDX 19
+#define HIVE_ISEL_GP_REGS_TPG_HOR_CNT_DELTA_IDX 20
+#define HIVE_ISEL_GP_REGS_TPG_VER_CNT_DELTA_IDX 21
+#define HIVE_ISEL_GP_REGS_TPG_MODE_IDX 22
+#define HIVE_ISEL_GP_REGS_TPG_R1_IDX 23
+#define HIVE_ISEL_GP_REGS_TPG_G1_IDX 24
+#define HIVE_ISEL_GP_REGS_TPG_B1_IDX 25
+#define HIVE_ISEL_GP_REGS_TPG_R2_IDX 26
+#define HIVE_ISEL_GP_REGS_TPG_G2_IDX 27
+#define HIVE_ISEL_GP_REGS_TPG_B2_IDX 28
 
-#define HIVE_ISEL_GP_REGS_CH_ID_IDX                            29
-#define HIVE_ISEL_GP_REGS_FMT_TYPE_IDX                         30
-#define HIVE_ISEL_GP_REGS_DATA_SEL_IDX                         31
-#define HIVE_ISEL_GP_REGS_SBAND_SEL_IDX                        32
-#define HIVE_ISEL_GP_REGS_SYNC_SEL_IDX                         33
-#define HIVE_ISEL_GP_REGS_SRST_IDX                             37
+#define HIVE_ISEL_GP_REGS_CH_ID_IDX 29
+#define HIVE_ISEL_GP_REGS_FMT_TYPE_IDX 30
+#define HIVE_ISEL_GP_REGS_DATA_SEL_IDX 31
+#define HIVE_ISEL_GP_REGS_SBAND_SEL_IDX 32
+#define HIVE_ISEL_GP_REGS_SYNC_SEL_IDX 33
+#define HIVE_ISEL_GP_REGS_SRST_IDX 37
 
-#define HIVE_ISEL_GP_REGS_SRST_SYNCGEN_BIT                      0
-#define HIVE_ISEL_GP_REGS_SRST_PRBS_BIT                         1
-#define HIVE_ISEL_GP_REGS_SRST_TPG_BIT                          2
-#define HIVE_ISEL_GP_REGS_SRST_FIFO_BIT                         3
+#define HIVE_ISEL_GP_REGS_SRST_SYNCGEN_BIT 0
+#define HIVE_ISEL_GP_REGS_SRST_PRBS_BIT 1
+#define HIVE_ISEL_GP_REGS_SRST_TPG_BIT 2
+#define HIVE_ISEL_GP_REGS_SRST_FIFO_BIT 3
 
 /* gp_register register id's -- Inputs   */
-#define HIVE_ISEL_GP_REGS_SYNCGEN_HOR_CNT_IDX                  34
-#define HIVE_ISEL_GP_REGS_SYNCGEN_VER_CNT_IDX                  35
-#define HIVE_ISEL_GP_REGS_SYNCGEN_FRAMES_CNT_IDX               36
+#define HIVE_ISEL_GP_REGS_SYNCGEN_HOR_CNT_IDX 34
+#define HIVE_ISEL_GP_REGS_SYNCGEN_VER_CNT_IDX 35
+#define HIVE_ISEL_GP_REGS_SYNCGEN_FRAMES_CNT_IDX 36
 
 /* irq sources isel irq controller */
-#define HIVE_ISEL_IRQ_SYNC_GEN_SOF_BIT_ID                       0
-#define HIVE_ISEL_IRQ_SYNC_GEN_EOF_BIT_ID                       1
-#define HIVE_ISEL_IRQ_SYNC_GEN_SOL_BIT_ID                       2
-#define HIVE_ISEL_IRQ_SYNC_GEN_EOL_BIT_ID                       3
-#define HIVE_ISEL_IRQ_NUM_IRQS                                  4
+#define HIVE_ISEL_IRQ_SYNC_GEN_SOF_BIT_ID 0
+#define HIVE_ISEL_IRQ_SYNC_GEN_EOF_BIT_ID 1
+#define HIVE_ISEL_IRQ_SYNC_GEN_SOL_BIT_ID 2
+#define HIVE_ISEL_IRQ_SYNC_GEN_EOL_BIT_ID 3
+#define HIVE_ISEL_IRQ_NUM_IRQS 4
 
 #endif /* _input_selector_defs_h */
diff --git a/drivers/staging/media/atomisp/pci/input_switch_2400_defs.h b/drivers/staging/media/atomisp/pci/input_switch_2400_defs.h
index c56e00913204d5b2522c5968f0ab719d3e041996..8cb8a8636bcba5a9885a8361f87efc78cc4fec95 100644
--- a/drivers/staging/media/atomisp/pci/input_switch_2400_defs.h
+++ b/drivers/staging/media/atomisp/pci/input_switch_2400_defs.h
@@ -7,16 +7,17 @@
 #ifndef _input_switch_2400_defs_h
 #define _input_switch_2400_defs_h
 
-#define _HIVE_INPUT_SWITCH_GET_LUT_REG_ID(ch_id, fmt_type) (((ch_id) * 2) + ((fmt_type) >= 16))
-#define _HIVE_INPUT_SWITCH_GET_LUT_REG_LSB(fmt_type)        (((fmt_type) % 16) * 2)
+#define _HIVE_INPUT_SWITCH_GET_LUT_REG_ID(ch_id, fmt_type) \
+	(((ch_id)*2) + ((fmt_type) >= 16))
+#define _HIVE_INPUT_SWITCH_GET_LUT_REG_LSB(fmt_type) (((fmt_type) % 16) * 2)
 
-#define HIVE_INPUT_SWITCH_SELECT_NO_OUTPUT   0
-#define HIVE_INPUT_SWITCH_SELECT_IF_PRIM     1
-#define HIVE_INPUT_SWITCH_SELECT_IF_SEC      2
-#define HIVE_INPUT_SWITCH_SELECT_STR_TO_MEM  3
-#define HIVE_INPUT_SWITCH_VSELECT_NO_OUTPUT  0
-#define HIVE_INPUT_SWITCH_VSELECT_IF_PRIM    1
-#define HIVE_INPUT_SWITCH_VSELECT_IF_SEC     2
+#define HIVE_INPUT_SWITCH_SELECT_NO_OUTPUT 0
+#define HIVE_INPUT_SWITCH_SELECT_IF_PRIM 1
+#define HIVE_INPUT_SWITCH_SELECT_IF_SEC 2
+#define HIVE_INPUT_SWITCH_SELECT_STR_TO_MEM 3
+#define HIVE_INPUT_SWITCH_VSELECT_NO_OUTPUT 0
+#define HIVE_INPUT_SWITCH_VSELECT_IF_PRIM 1
+#define HIVE_INPUT_SWITCH_VSELECT_IF_SEC 2
 #define HIVE_INPUT_SWITCH_VSELECT_STR_TO_MEM 4
 
 #endif /* _input_switch_2400_defs_h */
diff --git a/drivers/staging/media/atomisp/pci/input_system_ctrl_defs.h b/drivers/staging/media/atomisp/pci/input_system_ctrl_defs.h
index e26b9ba3356aa5f0d904807b69ba3e10985c760a..52375fe24545e7a75340dc192a69dd1351d2ba57 100644
--- a/drivers/staging/media/atomisp/pci/input_system_ctrl_defs.h
+++ b/drivers/staging/media/atomisp/pci/input_system_ctrl_defs.h
@@ -7,7 +7,7 @@
 #ifndef _input_system_ctrl_defs_h
 #define _input_system_ctrl_defs_h
 
-#define _INPUT_SYSTEM_CTRL_REG_ALIGN                    4  /* assuming 32 bit control bus width */
+#define _INPUT_SYSTEM_CTRL_REG_ALIGN 4 /* assuming 32 bit control bus width */
 
 /* --------------------------------------------------*/
 
@@ -16,82 +16,86 @@
 /* --------------------------------------------------*/
 
 // Number of registers
-#define ISYS_CTRL_NOF_REGS                              23
+#define ISYS_CTRL_NOF_REGS 23
 
 // Register id's of MMIO slave accessible registers
-#define ISYS_CTRL_CAPT_START_ADDR_A_REG_ID              0
-#define ISYS_CTRL_CAPT_START_ADDR_B_REG_ID              1
-#define ISYS_CTRL_CAPT_START_ADDR_C_REG_ID              2
-#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID         3
-#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID         4
-#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID         5
-#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID         6
-#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID         7
-#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID         8
-#define ISYS_CTRL_ACQ_START_ADDR_REG_ID                 9
-#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID            10
-#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID            11
-#define ISYS_CTRL_INIT_REG_ID                           12
-#define ISYS_CTRL_LAST_COMMAND_REG_ID                   13
-#define ISYS_CTRL_NEXT_COMMAND_REG_ID                   14
-#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_ID               15
-#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_ID               16
-#define ISYS_CTRL_FSM_STATE_INFO_REG_ID                 17
-#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_ID          18
-#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_ID          19
-#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_ID          20
-#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_ID             21
-#define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID    22
+#define ISYS_CTRL_CAPT_START_ADDR_A_REG_ID 0
+#define ISYS_CTRL_CAPT_START_ADDR_B_REG_ID 1
+#define ISYS_CTRL_CAPT_START_ADDR_C_REG_ID 2
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID 3
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID 4
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID 5
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID 6
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID 7
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID 8
+#define ISYS_CTRL_ACQ_START_ADDR_REG_ID 9
+#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID 10
+#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID 11
+#define ISYS_CTRL_INIT_REG_ID 12
+#define ISYS_CTRL_LAST_COMMAND_REG_ID 13
+#define ISYS_CTRL_NEXT_COMMAND_REG_ID 14
+#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_ID 15
+#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_ID 16
+#define ISYS_CTRL_FSM_STATE_INFO_REG_ID 17
+#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_ID 18
+#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_ID 19
+#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_ID 20
+#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_ID 21
+#define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID 22
 
 /* register reset value */
-#define ISYS_CTRL_CAPT_START_ADDR_A_REG_RSTVAL           0
-#define ISYS_CTRL_CAPT_START_ADDR_B_REG_RSTVAL           0
-#define ISYS_CTRL_CAPT_START_ADDR_C_REG_RSTVAL           0
-#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_RSTVAL      128
-#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_RSTVAL      128
-#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_RSTVAL      128
-#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_RSTVAL      3
-#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_RSTVAL      3
-#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_RSTVAL      3
-#define ISYS_CTRL_ACQ_START_ADDR_REG_RSTVAL              0
-#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_RSTVAL         128
-#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_RSTVAL         3
-#define ISYS_CTRL_INIT_REG_RSTVAL                        0
-#define ISYS_CTRL_LAST_COMMAND_REG_RSTVAL                15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
-#define ISYS_CTRL_NEXT_COMMAND_REG_RSTVAL                15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
-#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_RSTVAL            15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
-#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_RSTVAL            15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
-#define ISYS_CTRL_FSM_STATE_INFO_REG_RSTVAL              0
-#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_RSTVAL       0
-#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_RSTVAL       0
-#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_RSTVAL       0
-#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_RSTVAL          0
+#define ISYS_CTRL_CAPT_START_ADDR_A_REG_RSTVAL 0
+#define ISYS_CTRL_CAPT_START_ADDR_B_REG_RSTVAL 0
+#define ISYS_CTRL_CAPT_START_ADDR_C_REG_RSTVAL 0
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_RSTVAL 128
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_RSTVAL 128
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_RSTVAL 128
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_RSTVAL 3
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_RSTVAL 3
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_RSTVAL 3
+#define ISYS_CTRL_ACQ_START_ADDR_REG_RSTVAL 0
+#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_RSTVAL 128
+#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_RSTVAL 3
+#define ISYS_CTRL_INIT_REG_RSTVAL 0
+#define ISYS_CTRL_LAST_COMMAND_REG_RSTVAL \
+	15 //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_NEXT_COMMAND_REG_RSTVAL \
+	15 //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_RSTVAL \
+	15 //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_RSTVAL \
+	15 //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_FSM_STATE_INFO_REG_RSTVAL 0
+#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_RSTVAL 0
+#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_RSTVAL 0
+#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_RSTVAL 0
+#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_RSTVAL 0
 #define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_RSTVAL 0
 
 /* register width value */
-#define ISYS_CTRL_CAPT_START_ADDR_A_REG_WIDTH            9
-#define ISYS_CTRL_CAPT_START_ADDR_B_REG_WIDTH            9
-#define ISYS_CTRL_CAPT_START_ADDR_C_REG_WIDTH            9
-#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_WIDTH       9
-#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_WIDTH       9
-#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_WIDTH       9
-#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_WIDTH       9
-#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_WIDTH       9
-#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_WIDTH       9
-#define ISYS_CTRL_ACQ_START_ADDR_REG_WIDTH               9
-#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_WIDTH          9
-#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_WIDTH          9
-#define ISYS_CTRL_INIT_REG_WIDTH                         3
-#define ISYS_CTRL_LAST_COMMAND_REG_WIDTH                 32    /* slave data width */
-#define ISYS_CTRL_NEXT_COMMAND_REG_WIDTH                 32
-#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_WIDTH             32
-#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_WIDTH             32
-#define ISYS_CTRL_FSM_STATE_INFO_REG_WIDTH               32
-#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_WIDTH        32
-#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_WIDTH        32
-#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_WIDTH        32
-#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_WIDTH           32
-#define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_WIDTH  1
+#define ISYS_CTRL_CAPT_START_ADDR_A_REG_WIDTH 9
+#define ISYS_CTRL_CAPT_START_ADDR_B_REG_WIDTH 9
+#define ISYS_CTRL_CAPT_START_ADDR_C_REG_WIDTH 9
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_WIDTH 9
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_WIDTH 9
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_WIDTH 9
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_WIDTH 9
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_WIDTH 9
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_WIDTH 9
+#define ISYS_CTRL_ACQ_START_ADDR_REG_WIDTH 9
+#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_WIDTH 9
+#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_WIDTH 9
+#define ISYS_CTRL_INIT_REG_WIDTH 3
+#define ISYS_CTRL_LAST_COMMAND_REG_WIDTH 32 /* slave data width */
+#define ISYS_CTRL_NEXT_COMMAND_REG_WIDTH 32
+#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_WIDTH 32
+#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_WIDTH 32
+#define ISYS_CTRL_FSM_STATE_INFO_REG_WIDTH 32
+#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_WIDTH 32
+#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_WIDTH 32
+#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_WIDTH 32
+#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_WIDTH 32
+#define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_WIDTH 1
 
 /* bit definitions */
 
@@ -186,50 +190,54 @@ InpSysAckOverrule  2/0  [3:0] - 'b0101,
 */
 
 /* Command and acknowledge tokens IDs */
-#define ISYS_CTRL_CAPT_FRAMES_ACQ_TOKEN_ID        0 /* 0000b */
-#define ISYS_CTRL_CAPT_FRAME_EXT_TOKEN_ID         1 /* 0001b */
-#define ISYS_CTRL_ACQ_FRAME_TOKEN_ID              2 /* 0010b */
-#define ISYS_CTRL_OVERRULE_ON_TOKEN_ID            3 /* 0011b */
-#define ISYS_CTRL_OVERRULE_OFF_TOKEN_ID           4 /* 0100b */
-#define ISYS_CTRL_OVERRULE_TOKEN_ID               5 /* 0101b */
-
-#define ISYS_CTRL_ACK_CFA_TOKEN_ID                0
-#define ISYS_CTRL_ACK_CFE_TOKEN_ID                1
-#define ISYS_CTRL_ACK_AF_TOKEN_ID                 2
-#define ISYS_CTRL_ACK_OVERRULE_ON_TOKEN_ID        3
-#define ISYS_CTRL_ACK_OVERRULE_OFF_TOKEN_ID       4
-#define ISYS_CTRL_ACK_OVERRULE_TOKEN_ID           5
-#define ISYS_CTRL_ACK_DEVICE_ERROR_TOKEN_ID       6
-
-#define ISYS_CTRL_TOKEN_ID_MSB                    3
-#define ISYS_CTRL_TOKEN_ID_LSB                    0
-#define ISYS_CTRL_PORT_ID_TOKEN_MSB               7
-#define ISYS_CTRL_PORT_ID_TOKEN_LSB               4
-#define ISYS_CTRL_NOF_CAPT_TOKEN_MSB              31
-#define ISYS_CTRL_NOF_CAPT_TOKEN_LSB              16
-#define ISYS_CTRL_NOF_EXT_TOKEN_MSB               31
-#define ISYS_CTRL_NOF_EXT_TOKEN_LSB               8
-
-#define ISYS_CTRL_TOKEN_ID_IDX                    0
-#define ISYS_CTRL_TOKEN_ID_BITS                   (ISYS_CTRL_TOKEN_ID_MSB - ISYS_CTRL_TOKEN_ID_LSB + 1)
-#define ISYS_CTRL_PORT_ID_IDX                     (ISYS_CTRL_TOKEN_ID_IDX + ISYS_CTRL_TOKEN_ID_BITS)
-#define ISYS_CTRL_PORT_ID_BITS                    (ISYS_CTRL_PORT_ID_TOKEN_MSB - ISYS_CTRL_PORT_ID_TOKEN_LSB + 1)
-#define ISYS_CTRL_NOF_CAPT_IDX                    ISYS_CTRL_NOF_CAPT_TOKEN_LSB
-#define ISYS_CTRL_NOF_CAPT_BITS                   (ISYS_CTRL_NOF_CAPT_TOKEN_MSB - ISYS_CTRL_NOF_CAPT_TOKEN_LSB + 1)
-#define ISYS_CTRL_NOF_EXT_IDX                     ISYS_CTRL_NOF_EXT_TOKEN_LSB
-#define ISYS_CTRL_NOF_EXT_BITS                    (ISYS_CTRL_NOF_EXT_TOKEN_MSB - ISYS_CTRL_NOF_EXT_TOKEN_LSB + 1)
-
-#define ISYS_CTRL_PORT_ID_CAPT_A                  0 /* device ID for capture unit A      */
-#define ISYS_CTRL_PORT_ID_CAPT_B                  1 /* device ID for capture unit B      */
-#define ISYS_CTRL_PORT_ID_CAPT_C                  2 /* device ID for capture unit C      */
-#define ISYS_CTRL_PORT_ID_ACQUISITION             3 /* device ID for acquistion unit     */
-#define ISYS_CTRL_PORT_ID_DMA_CAPT_A              4 /* device ID for dma unit            */
-#define ISYS_CTRL_PORT_ID_DMA_CAPT_B              5 /* device ID for dma unit            */
-#define ISYS_CTRL_PORT_ID_DMA_CAPT_C              6 /* device ID for dma unit            */
-#define ISYS_CTRL_PORT_ID_DMA_ACQ                 7 /* device ID for dma unit            */
-
-#define ISYS_CTRL_NO_ACQ_ACK                      16 /* no ack from acquisition unit */
-#define ISYS_CTRL_NO_DMA_ACK                      0
-#define ISYS_CTRL_NO_CAPT_ACK                     16
+#define ISYS_CTRL_CAPT_FRAMES_ACQ_TOKEN_ID 0 /* 0000b */
+#define ISYS_CTRL_CAPT_FRAME_EXT_TOKEN_ID 1 /* 0001b */
+#define ISYS_CTRL_ACQ_FRAME_TOKEN_ID 2 /* 0010b */
+#define ISYS_CTRL_OVERRULE_ON_TOKEN_ID 3 /* 0011b */
+#define ISYS_CTRL_OVERRULE_OFF_TOKEN_ID 4 /* 0100b */
+#define ISYS_CTRL_OVERRULE_TOKEN_ID 5 /* 0101b */
+
+#define ISYS_CTRL_ACK_CFA_TOKEN_ID 0
+#define ISYS_CTRL_ACK_CFE_TOKEN_ID 1
+#define ISYS_CTRL_ACK_AF_TOKEN_ID 2
+#define ISYS_CTRL_ACK_OVERRULE_ON_TOKEN_ID 3
+#define ISYS_CTRL_ACK_OVERRULE_OFF_TOKEN_ID 4
+#define ISYS_CTRL_ACK_OVERRULE_TOKEN_ID 5
+#define ISYS_CTRL_ACK_DEVICE_ERROR_TOKEN_ID 6
+
+#define ISYS_CTRL_TOKEN_ID_MSB 3
+#define ISYS_CTRL_TOKEN_ID_LSB 0
+#define ISYS_CTRL_PORT_ID_TOKEN_MSB 7
+#define ISYS_CTRL_PORT_ID_TOKEN_LSB 4
+#define ISYS_CTRL_NOF_CAPT_TOKEN_MSB 31
+#define ISYS_CTRL_NOF_CAPT_TOKEN_LSB 16
+#define ISYS_CTRL_NOF_EXT_TOKEN_MSB 31
+#define ISYS_CTRL_NOF_EXT_TOKEN_LSB 8
+
+#define ISYS_CTRL_TOKEN_ID_IDX 0
+#define ISYS_CTRL_TOKEN_ID_BITS \
+	(ISYS_CTRL_TOKEN_ID_MSB - ISYS_CTRL_TOKEN_ID_LSB + 1)
+#define ISYS_CTRL_PORT_ID_IDX (ISYS_CTRL_TOKEN_ID_IDX + ISYS_CTRL_TOKEN_ID_BITS)
+#define ISYS_CTRL_PORT_ID_BITS \
+	(ISYS_CTRL_PORT_ID_TOKEN_MSB - ISYS_CTRL_PORT_ID_TOKEN_LSB + 1)
+#define ISYS_CTRL_NOF_CAPT_IDX ISYS_CTRL_NOF_CAPT_TOKEN_LSB
+#define ISYS_CTRL_NOF_CAPT_BITS \
+	(ISYS_CTRL_NOF_CAPT_TOKEN_MSB - ISYS_CTRL_NOF_CAPT_TOKEN_LSB + 1)
+#define ISYS_CTRL_NOF_EXT_IDX ISYS_CTRL_NOF_EXT_TOKEN_LSB
+#define ISYS_CTRL_NOF_EXT_BITS \
+	(ISYS_CTRL_NOF_EXT_TOKEN_MSB - ISYS_CTRL_NOF_EXT_TOKEN_LSB + 1)
+
+#define ISYS_CTRL_PORT_ID_CAPT_A 0 /* device ID for capture unit A      */
+#define ISYS_CTRL_PORT_ID_CAPT_B 1 /* device ID for capture unit B      */
+#define ISYS_CTRL_PORT_ID_CAPT_C 2 /* device ID for capture unit C      */
+#define ISYS_CTRL_PORT_ID_ACQUISITION 3 /* device ID for acquistion unit     */
+#define ISYS_CTRL_PORT_ID_DMA_CAPT_A 4 /* device ID for dma unit            */
+#define ISYS_CTRL_PORT_ID_DMA_CAPT_B 5 /* device ID for dma unit            */
+#define ISYS_CTRL_PORT_ID_DMA_CAPT_C 6 /* device ID for dma unit            */
+#define ISYS_CTRL_PORT_ID_DMA_ACQ 7 /* device ID for dma unit            */
+
+#define ISYS_CTRL_NO_ACQ_ACK 16 /* no ack from acquisition unit */
+#define ISYS_CTRL_NO_DMA_ACK 0
+#define ISYS_CTRL_NO_CAPT_ACK 16
 
 #endif /* _input_system_ctrl_defs_h */
diff --git a/drivers/staging/media/atomisp/pci/input_system_defs.h b/drivers/staging/media/atomisp/pci/input_system_defs.h
index ae07d195214656ccea6f09fb38a1be3e37bdee93..f814a9db16018d5e8e42ca6bee632b80a2baa49a 100644
--- a/drivers/staging/media/atomisp/pci/input_system_defs.h
+++ b/drivers/staging/media/atomisp/pci/input_system_defs.h
@@ -8,111 +8,112 @@
 #define _input_system_defs_h
 
 /* csi controller modes */
-#define HIVE_CSI_CONFIG_MAIN                   0
-#define HIVE_CSI_CONFIG_STEREO1                4
-#define HIVE_CSI_CONFIG_STEREO2                8
+#define HIVE_CSI_CONFIG_MAIN 0
+#define HIVE_CSI_CONFIG_STEREO1 4
+#define HIVE_CSI_CONFIG_STEREO2 8
 
 /* general purpose register IDs */
 
 /* Stream Multicast select modes */
-#define HIVE_ISYS_GPREG_MULTICAST_A_IDX           0
-#define HIVE_ISYS_GPREG_MULTICAST_B_IDX           1
-#define HIVE_ISYS_GPREG_MULTICAST_C_IDX           2
+#define HIVE_ISYS_GPREG_MULTICAST_A_IDX 0
+#define HIVE_ISYS_GPREG_MULTICAST_B_IDX 1
+#define HIVE_ISYS_GPREG_MULTICAST_C_IDX 2
 
 /* Stream Mux select modes */
-#define HIVE_ISYS_GPREG_MUX_IDX                   3
+#define HIVE_ISYS_GPREG_MUX_IDX 3
 
 /* streaming monitor status and control */
-#define HIVE_ISYS_GPREG_STRMON_STAT_IDX           4
-#define HIVE_ISYS_GPREG_STRMON_COND_IDX           5
-#define HIVE_ISYS_GPREG_STRMON_IRQ_EN_IDX         6
-#define HIVE_ISYS_GPREG_SRST_IDX                  7
-#define HIVE_ISYS_GPREG_SLV_REG_SRST_IDX          8
-#define HIVE_ISYS_GPREG_REG_PORT_A_IDX            9
-#define HIVE_ISYS_GPREG_REG_PORT_B_IDX            10
+#define HIVE_ISYS_GPREG_STRMON_STAT_IDX 4
+#define HIVE_ISYS_GPREG_STRMON_COND_IDX 5
+#define HIVE_ISYS_GPREG_STRMON_IRQ_EN_IDX 6
+#define HIVE_ISYS_GPREG_SRST_IDX 7
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_IDX 8
+#define HIVE_ISYS_GPREG_REG_PORT_A_IDX 9
+#define HIVE_ISYS_GPREG_REG_PORT_B_IDX 10
 
 /* Bit numbers of the soft reset register */
-#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_A_BIT      0
-#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_B_BIT      1
-#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_C_BIT      2
-#define HIVE_ISYS_GPREG_SRST_MULTICAST_A_BIT      3
-#define HIVE_ISYS_GPREG_SRST_MULTICAST_B_BIT      4
-#define HIVE_ISYS_GPREG_SRST_MULTICAST_C_BIT      5
-#define HIVE_ISYS_GPREG_SRST_CAPT_A_BIT           6
-#define HIVE_ISYS_GPREG_SRST_CAPT_B_BIT           7
-#define HIVE_ISYS_GPREG_SRST_CAPT_C_BIT           8
-#define HIVE_ISYS_GPREG_SRST_ACQ_BIT              9
+#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_A_BIT 0
+#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_B_BIT 1
+#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_C_BIT 2
+#define HIVE_ISYS_GPREG_SRST_MULTICAST_A_BIT 3
+#define HIVE_ISYS_GPREG_SRST_MULTICAST_B_BIT 4
+#define HIVE_ISYS_GPREG_SRST_MULTICAST_C_BIT 5
+#define HIVE_ISYS_GPREG_SRST_CAPT_A_BIT 6
+#define HIVE_ISYS_GPREG_SRST_CAPT_B_BIT 7
+#define HIVE_ISYS_GPREG_SRST_CAPT_C_BIT 8
+#define HIVE_ISYS_GPREG_SRST_ACQ_BIT 9
 /* For ISYS_CTRL 5bits are defined to allow soft-reset per sub-controller and top-ctrl */
-#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_BIT        10  /*LSB for 5bit vector */
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_BIT 10 /*LSB for 5bit vector */
 #define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_CAPT_A_BIT 10
 #define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_CAPT_B_BIT 11
 #define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_CAPT_C_BIT 12
-#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_ACQ_BIT    13
-#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_TOP_BIT    14
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_ACQ_BIT 13
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_TOP_BIT 14
 /* -- */
-#define HIVE_ISYS_GPREG_SRST_STR_MUX_BIT          15
-#define HIVE_ISYS_GPREG_SRST_CIO2AHB_BIT          16
-#define HIVE_ISYS_GPREG_SRST_GEN_SHORT_FIFO_BIT   17
-#define HIVE_ISYS_GPREG_SRST_WIDE_BUS_BIT         18 // includes CIO conv
-#define HIVE_ISYS_GPREG_SRST_DMA_BIT              19
-#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_A_BIT   20
-#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_B_BIT   21
-#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_C_BIT   22
-#define HIVE_ISYS_GPREG_SRST_SF_CTRL_ACQ_BIT      23
-#define HIVE_ISYS_GPREG_SRST_CSI_BE_OUT_BIT       24
+#define HIVE_ISYS_GPREG_SRST_STR_MUX_BIT 15
+#define HIVE_ISYS_GPREG_SRST_CIO2AHB_BIT 16
+#define HIVE_ISYS_GPREG_SRST_GEN_SHORT_FIFO_BIT 17
+#define HIVE_ISYS_GPREG_SRST_WIDE_BUS_BIT 18 // includes CIO conv
+#define HIVE_ISYS_GPREG_SRST_DMA_BIT 19
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_A_BIT 20
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_B_BIT 21
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_C_BIT 22
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_ACQ_BIT 23
+#define HIVE_ISYS_GPREG_SRST_CSI_BE_OUT_BIT 24
 
-#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_A_BIT    0
-#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_B_BIT    1
-#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_C_BIT    2
-#define HIVE_ISYS_GPREG_SLV_REG_SRST_ACQ_BIT       3
-#define HIVE_ISYS_GPREG_SLV_REG_SRST_DMA_BIT        4
-#define HIVE_ISYS_GPREG_SLV_REG_SRST_ISYS_CTRL_BIT  5
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_A_BIT 0
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_B_BIT 1
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_C_BIT 2
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_ACQ_BIT 3
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_DMA_BIT 4
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_ISYS_CTRL_BIT 5
 
 /* streaming monitor port id's */
-#define HIVE_ISYS_STR_MON_PORT_CAPA            0
-#define HIVE_ISYS_STR_MON_PORT_CAPB            1
-#define HIVE_ISYS_STR_MON_PORT_CAPC            2
-#define HIVE_ISYS_STR_MON_PORT_ACQ             3
-#define HIVE_ISYS_STR_MON_PORT_CSS_GENSH       4
-#define HIVE_ISYS_STR_MON_PORT_SF_GENSH        5
-#define HIVE_ISYS_STR_MON_PORT_SP2ISYS         6
-#define HIVE_ISYS_STR_MON_PORT_ISYS2SP         7
-#define HIVE_ISYS_STR_MON_PORT_PIXA            8
-#define HIVE_ISYS_STR_MON_PORT_PIXB            9
+#define HIVE_ISYS_STR_MON_PORT_CAPA 0
+#define HIVE_ISYS_STR_MON_PORT_CAPB 1
+#define HIVE_ISYS_STR_MON_PORT_CAPC 2
+#define HIVE_ISYS_STR_MON_PORT_ACQ 3
+#define HIVE_ISYS_STR_MON_PORT_CSS_GENSH 4
+#define HIVE_ISYS_STR_MON_PORT_SF_GENSH 5
+#define HIVE_ISYS_STR_MON_PORT_SP2ISYS 6
+#define HIVE_ISYS_STR_MON_PORT_ISYS2SP 7
+#define HIVE_ISYS_STR_MON_PORT_PIXA 8
+#define HIVE_ISYS_STR_MON_PORT_PIXB 9
 
 /* interrupt bit ID's        */
-#define HIVE_ISYS_IRQ_CSI_SOF_BIT_ID           0
-#define HIVE_ISYS_IRQ_CSI_EOF_BIT_ID           1
-#define HIVE_ISYS_IRQ_CSI_SOL_BIT_ID           2
-#define HIVE_ISYS_IRQ_CSI_EOL_BIT_ID           3
-#define HIVE_ISYS_IRQ_CSI_RECEIVER_BIT_ID      4
-#define HIVE_ISYS_IRQ_CSI_RECEIVER_BE_BIT_ID   5
-#define HIVE_ISYS_IRQ_CAP_UNIT_A_NO_SOP        6
-#define HIVE_ISYS_IRQ_CAP_UNIT_A_LATE_SOP      7
+#define HIVE_ISYS_IRQ_CSI_SOF_BIT_ID 0
+#define HIVE_ISYS_IRQ_CSI_EOF_BIT_ID 1
+#define HIVE_ISYS_IRQ_CSI_SOL_BIT_ID 2
+#define HIVE_ISYS_IRQ_CSI_EOL_BIT_ID 3
+#define HIVE_ISYS_IRQ_CSI_RECEIVER_BIT_ID 4
+#define HIVE_ISYS_IRQ_CSI_RECEIVER_BE_BIT_ID 5
+#define HIVE_ISYS_IRQ_CAP_UNIT_A_NO_SOP 6
+#define HIVE_ISYS_IRQ_CAP_UNIT_A_LATE_SOP 7
 /*#define HIVE_ISYS_IRQ_CAP_UNIT_A_UNDEF_PH      7*/
-#define HIVE_ISYS_IRQ_CAP_UNIT_B_NO_SOP        8
-#define HIVE_ISYS_IRQ_CAP_UNIT_B_LATE_SOP      9
+#define HIVE_ISYS_IRQ_CAP_UNIT_B_NO_SOP 8
+#define HIVE_ISYS_IRQ_CAP_UNIT_B_LATE_SOP 9
 /*#define HIVE_ISYS_IRQ_CAP_UNIT_B_UNDEF_PH     10*/
-#define HIVE_ISYS_IRQ_CAP_UNIT_C_NO_SOP       10
-#define HIVE_ISYS_IRQ_CAP_UNIT_C_LATE_SOP     11
+#define HIVE_ISYS_IRQ_CAP_UNIT_C_NO_SOP 10
+#define HIVE_ISYS_IRQ_CAP_UNIT_C_LATE_SOP 11
 /*#define HIVE_ISYS_IRQ_CAP_UNIT_C_UNDEF_PH     13*/
-#define HIVE_ISYS_IRQ_ACQ_UNIT_SOP_MISMATCH   12
+#define HIVE_ISYS_IRQ_ACQ_UNIT_SOP_MISMATCH 12
 /*#define HIVE_ISYS_IRQ_ACQ_UNIT_UNDEF_PH       15*/
-#define HIVE_ISYS_IRQ_INP_CTRL_CAPA           13
-#define HIVE_ISYS_IRQ_INP_CTRL_CAPB           14
-#define HIVE_ISYS_IRQ_INP_CTRL_CAPC           15
-#define HIVE_ISYS_IRQ_CIO2AHB                 16
-#define HIVE_ISYS_IRQ_DMA_BIT_ID              17
-#define HIVE_ISYS_IRQ_STREAM_MON_BIT_ID       18
-#define HIVE_ISYS_IRQ_NUM_BITS                19
+#define HIVE_ISYS_IRQ_INP_CTRL_CAPA 13
+#define HIVE_ISYS_IRQ_INP_CTRL_CAPB 14
+#define HIVE_ISYS_IRQ_INP_CTRL_CAPC 15
+#define HIVE_ISYS_IRQ_CIO2AHB 16
+#define HIVE_ISYS_IRQ_DMA_BIT_ID 17
+#define HIVE_ISYS_IRQ_STREAM_MON_BIT_ID 18
+#define HIVE_ISYS_IRQ_NUM_BITS 19
 
 /* DMA */
-#define HIVE_ISYS_DMA_CHANNEL                  0
-#define HIVE_ISYS_DMA_IBUF_DDR_CONN            0
-#define HIVE_ISYS_DMA_HEIGHT                   1
-#define HIVE_ISYS_DMA_ELEMS                    1 /* both master buses of same width */
-#define HIVE_ISYS_DMA_STRIDE                   0 /* no stride required as height is fixed to 1 */
-#define HIVE_ISYS_DMA_CROP                     0 /* no cropping */
-#define HIVE_ISYS_DMA_EXTENSION                0 /* no extension as elem width is same on both side */
+#define HIVE_ISYS_DMA_CHANNEL 0
+#define HIVE_ISYS_DMA_IBUF_DDR_CONN 0
+#define HIVE_ISYS_DMA_HEIGHT 1
+#define HIVE_ISYS_DMA_ELEMS 1 /* both master buses of same width */
+#define HIVE_ISYS_DMA_STRIDE 0 /* no stride required as height is fixed to 1 */
+#define HIVE_ISYS_DMA_CROP 0 /* no cropping */
+#define HIVE_ISYS_DMA_EXTENSION \
+	0 /* no extension as elem width is same on both side */
 
 #endif /* _input_system_defs_h */
diff --git a/drivers/staging/media/atomisp/pci/input_system_global.h b/drivers/staging/media/atomisp/pci/input_system_global.h
index 1450964445f66beb6e1269fbe50227aed62f88f2..6ed374093265498252a8ec642b905b1e8281c6e1 100644
--- a/drivers/staging/media/atomisp/pci/input_system_global.h
+++ b/drivers/staging/media/atomisp/pci/input_system_global.h
@@ -4,7 +4,6 @@
  *    (c) 2020 Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
  */
 
-
 #ifndef __INPUT_SYSTEM_GLOBAL_H_INCLUDED__
 #define __INPUT_SYSTEM_GLOBAL_H_INCLUDED__
 typedef enum {
diff --git a/drivers/staging/media/atomisp/pci/input_system_local.h b/drivers/staging/media/atomisp/pci/input_system_local.h
index 12f7acfeb79c94f1253b0153a90f384038989c82..5e53ee136e70c297e60e68f2697c37d7c8b18839 100644
--- a/drivers/staging/media/atomisp/pci/input_system_local.h
+++ b/drivers/staging/media/atomisp/pci/input_system_local.h
@@ -14,41 +14,41 @@ typedef enum {
 	N_INPUT_SYSTEM_PORTS
 } input_system_csi_port_t;
 
-typedef struct ctrl_unit_cfg_s			ctrl_unit_cfg_t;
-typedef struct input_system_network_cfg_s	input_system_network_cfg_t;
-typedef struct target_cfg2400_s		target_cfg2400_t;
-typedef struct channel_cfg_s			channel_cfg_t;
-typedef struct backend_channel_cfg_s		backend_channel_cfg_t;
-typedef struct input_system_cfg2400_s		input_system_cfg2400_t;
-typedef struct mipi_port_state_s		mipi_port_state_t;
-typedef struct rx_channel_state_s		rx_channel_state_t;
-typedef struct input_switch_cfg_channel_s	input_switch_cfg_channel_t;
-typedef struct input_switch_cfg_s		input_switch_cfg_t;
+typedef struct ctrl_unit_cfg_s ctrl_unit_cfg_t;
+typedef struct input_system_network_cfg_s input_system_network_cfg_t;
+typedef struct target_cfg2400_s target_cfg2400_t;
+typedef struct channel_cfg_s channel_cfg_t;
+typedef struct backend_channel_cfg_s backend_channel_cfg_t;
+typedef struct input_system_cfg2400_s input_system_cfg2400_t;
+typedef struct mipi_port_state_s mipi_port_state_t;
+typedef struct rx_channel_state_s rx_channel_state_t;
+typedef struct input_switch_cfg_channel_s input_switch_cfg_channel_t;
+typedef struct input_switch_cfg_s input_switch_cfg_t;
 
 struct ctrl_unit_cfg_s {
-	isp2400_ib_buffer_t		buffer_mipi[N_CAPTURE_UNIT_ID];
-	isp2400_ib_buffer_t		buffer_acquire[N_ACQUISITION_UNIT_ID];
+	isp2400_ib_buffer_t buffer_mipi[N_CAPTURE_UNIT_ID];
+	isp2400_ib_buffer_t buffer_acquire[N_ACQUISITION_UNIT_ID];
 };
 
 struct input_system_network_cfg_s {
-	input_system_connection_t	multicast_cfg[N_CAPTURE_UNIT_ID];
-	input_system_multiplex_t	mux_cfg;
-	ctrl_unit_cfg_t				ctrl_unit_cfg[N_CTRL_UNIT_ID];
+	input_system_connection_t multicast_cfg[N_CAPTURE_UNIT_ID];
+	input_system_multiplex_t mux_cfg;
+	ctrl_unit_cfg_t ctrl_unit_cfg[N_CTRL_UNIT_ID];
 };
 
 typedef struct {
-// TBD.
-	u32	dummy_parameter;
+	// TBD.
+	u32 dummy_parameter;
 } target_isp_cfg_t;
 
 typedef struct {
-// TBD.
-	u32	dummy_parameter;
+	// TBD.
+	u32 dummy_parameter;
 } target_sp_cfg_t;
 
 typedef struct {
-// TBD.
-	u32	dummy_parameter;
+	// TBD.
+	u32 dummy_parameter;
 } target_strm2mem_cfg_t;
 
 struct input_switch_cfg_channel_s {
@@ -57,16 +57,16 @@ struct input_switch_cfg_channel_s {
 };
 
 struct backend_channel_cfg_s {
-	u32	fmt_control_word_1; // Format config.
-	u32	fmt_control_word_2;
-	u32	no_side_band;
+	u32 fmt_control_word_1; // Format config.
+	u32 fmt_control_word_2;
+	u32 no_side_band;
 };
 
-typedef union  {
-	csi_cfg_t	csi_cfg;
-	tpg_cfg_t	tpg_cfg;
-	prbs_cfg_t	prbs_cfg;
-	gpfifo_cfg_t	gpfifo_cfg;
+typedef union {
+	csi_cfg_t csi_cfg;
+	tpg_cfg_t tpg_cfg;
+	prbs_cfg_t prbs_cfg;
+	gpfifo_cfg_t gpfifo_cfg;
 } source_cfg_t;
 
 struct input_switch_cfg_s {
@@ -97,11 +97,11 @@ typedef enum {
 	N_RX_MODE
 } rx_mode_t;
 
-#define UNCOMPRESSED_BITS_PER_PIXEL_10	10
-#define UNCOMPRESSED_BITS_PER_PIXEL_12	12
-#define COMPRESSED_BITS_PER_PIXEL_6	6
-#define COMPRESSED_BITS_PER_PIXEL_7	7
-#define COMPRESSED_BITS_PER_PIXEL_8	8
+#define UNCOMPRESSED_BITS_PER_PIXEL_10 10
+#define UNCOMPRESSED_BITS_PER_PIXEL_12 12
+#define COMPRESSED_BITS_PER_PIXEL_6 6
+#define COMPRESSED_BITS_PER_PIXEL_7 7
+#define COMPRESSED_BITS_PER_PIXEL_8 8
 enum mipi_compressor {
 	MIPI_COMPRESSOR_NONE = 0,
 	MIPI_COMPRESSOR_10_6_10,
@@ -122,20 +122,20 @@ typedef enum {
 	N_MIPI_PREDICTOR_TYPES
 } mipi_predictor_t;
 
-typedef struct rx_cfg_s		rx_cfg_t;
+typedef struct rx_cfg_s rx_cfg_t;
 
 /*
  * Applied per port
  */
 struct rx_cfg_s {
-	rx_mode_t			mode;	/* The HW config */
-	enum mipi_port_id		port;	/* The port ID to apply the control on */
-	unsigned int		timeout;
-	unsigned int		initcount;
-	unsigned int		synccount;
-	unsigned int		rxcount;
-	mipi_predictor_t	comp;	/* Just for backward compatibility */
-	bool                is_two_ppc;
+	rx_mode_t mode; /* The HW config */
+	enum mipi_port_id port; /* The port ID to apply the control on */
+	unsigned int timeout;
+	unsigned int initcount;
+	unsigned int synccount;
+	unsigned int rxcount;
+	mipi_predictor_t comp; /* Just for backward compatibility */
+	bool is_two_ppc;
 };
 
 #include "isp2401_input_system_local.h"
diff --git a/drivers/staging/media/atomisp/pci/irq_controller_defs.h b/drivers/staging/media/atomisp/pci/irq_controller_defs.h
index 4703d991a8b84e0b99df7c597e7c83c30e3c0e66..094e9a206fd09b2a8ccba0356692c363dccba0a5 100644
--- a/drivers/staging/media/atomisp/pci/irq_controller_defs.h
+++ b/drivers/staging/media/atomisp/pci/irq_controller_defs.h
@@ -7,11 +7,11 @@
 #ifndef _irq_controller_defs_h
 #define _irq_controller_defs_h
 
-#define _HRT_IRQ_CONTROLLER_EDGE_REG_IDX           0
-#define _HRT_IRQ_CONTROLLER_MASK_REG_IDX           1
-#define _HRT_IRQ_CONTROLLER_STATUS_REG_IDX         2
-#define _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX          3
-#define _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX         4
+#define _HRT_IRQ_CONTROLLER_EDGE_REG_IDX 0
+#define _HRT_IRQ_CONTROLLER_MASK_REG_IDX 1
+#define _HRT_IRQ_CONTROLLER_STATUS_REG_IDX 2
+#define _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX 3
+#define _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX 4
 #define _HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX 5
 #define _HRT_IRQ_CONTROLLER_STR_OUT_ENABLE_REG_IDX 6
 
diff --git a/drivers/staging/media/atomisp/pci/irq_types_hrt.h b/drivers/staging/media/atomisp/pci/irq_types_hrt.h
index 3579fdaee37a5cc071f2e54aa9c40bab4e09baa3..ea21320c6d509117f34decd20a5d6fa23067313b 100644
--- a/drivers/staging/media/atomisp/pci/irq_types_hrt.h
+++ b/drivers/staging/media/atomisp/pci/irq_types_hrt.h
@@ -15,38 +15,42 @@
  * The definitions are taken from <system>_defs.h
  */
 typedef enum hrt_isp_css_irq {
-	hrt_isp_css_irq_gpio_pin_0           = HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_1           = HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_2           = HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_3           = HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_4           = HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_5           = HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_6           = HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_7           = HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_8           = HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_9           = HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_10          = HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID,
-	hrt_isp_css_irq_gpio_pin_11          = HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID,
-	hrt_isp_css_irq_sp                   = HIVE_GP_DEV_IRQ_SP_BIT_ID,
-	hrt_isp_css_irq_isp                  = HIVE_GP_DEV_IRQ_ISP_BIT_ID,
-	hrt_isp_css_irq_isys                 = HIVE_GP_DEV_IRQ_ISYS_BIT_ID,
-	hrt_isp_css_irq_isel                 = HIVE_GP_DEV_IRQ_ISEL_BIT_ID,
-	hrt_isp_css_irq_ifmt                 = HIVE_GP_DEV_IRQ_IFMT_BIT_ID,
-	hrt_isp_css_irq_sp_stream_mon        = HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID,
-	hrt_isp_css_irq_isp_stream_mon       = HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID,
-	hrt_isp_css_irq_mod_stream_mon       = HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID,
-	hrt_isp_css_irq_isp_pmem_error       = HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID,
-	hrt_isp_css_irq_isp_bamem_error      = HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID,
-	hrt_isp_css_irq_isp_dmem_error       = HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID,
-	hrt_isp_css_irq_sp_icache_mem_error  = HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID,
-	hrt_isp_css_irq_sp_dmem_error        = HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID,
-	hrt_isp_css_irq_mmu_cache_mem_error  = HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID,
-	hrt_isp_css_irq_gp_timer_0           = HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID,
-	hrt_isp_css_irq_gp_timer_1           = HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID,
-	hrt_isp_css_irq_sw_pin_0             = HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID,
-	hrt_isp_css_irq_sw_pin_1             = HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID,
-	hrt_isp_css_irq_dma                  = HIVE_GP_DEV_IRQ_DMA_BIT_ID,
-	hrt_isp_css_irq_sp_stream_mon_b      = HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_0 = HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_1 = HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_2 = HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_3 = HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_4 = HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_5 = HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_6 = HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_7 = HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_8 = HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_9 = HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_10 = HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID,
+	hrt_isp_css_irq_gpio_pin_11 = HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID,
+	hrt_isp_css_irq_sp = HIVE_GP_DEV_IRQ_SP_BIT_ID,
+	hrt_isp_css_irq_isp = HIVE_GP_DEV_IRQ_ISP_BIT_ID,
+	hrt_isp_css_irq_isys = HIVE_GP_DEV_IRQ_ISYS_BIT_ID,
+	hrt_isp_css_irq_isel = HIVE_GP_DEV_IRQ_ISEL_BIT_ID,
+	hrt_isp_css_irq_ifmt = HIVE_GP_DEV_IRQ_IFMT_BIT_ID,
+	hrt_isp_css_irq_sp_stream_mon = HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID,
+	hrt_isp_css_irq_isp_stream_mon = HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID,
+	hrt_isp_css_irq_mod_stream_mon = HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID,
+	hrt_isp_css_irq_isp_pmem_error = HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID,
+	hrt_isp_css_irq_isp_bamem_error =
+		HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID,
+	hrt_isp_css_irq_isp_dmem_error = HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID,
+	hrt_isp_css_irq_sp_icache_mem_error =
+		HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID,
+	hrt_isp_css_irq_sp_dmem_error = HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID,
+	hrt_isp_css_irq_mmu_cache_mem_error =
+		HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID,
+	hrt_isp_css_irq_gp_timer_0 = HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID,
+	hrt_isp_css_irq_gp_timer_1 = HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID,
+	hrt_isp_css_irq_sw_pin_0 = HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID,
+	hrt_isp_css_irq_sw_pin_1 = HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID,
+	hrt_isp_css_irq_dma = HIVE_GP_DEV_IRQ_DMA_BIT_ID,
+	hrt_isp_css_irq_sp_stream_mon_b =
+		HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID,
 	/* this must (obviously) be the last on in the enum */
 	hrt_isp_css_irq_num_irqs
 } hrt_isp_css_irq_t;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/aa/aa_2/ia_css_aa2_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/aa/aa_2/ia_css_aa2_types.h
index 2f568a7062da726397f55b1e73dadd27fcd1f2f8..edca987ee20931cc124a9af74a14698ec12419e5 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/aa/aa_2/ia_css_aa2_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/aa/aa_2/ia_css_aa2_types.h
@@ -30,7 +30,7 @@
  *     ISP2: BAA2 is used.
  */
 struct ia_css_aa_config {
-	u16 strength;	/** Strength of the filter.
+	u16 strength; /** Strength of the filter.
 					u0.13, [0,8191],
 					default/ineffective 0 */
 };
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr.host.c
index 899d566234b9d3a35401666dcf0c7b1b80fd5b31..e247de6c55dba9a40c99e46c61c64e4078e9e8b1 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr.host.c
@@ -12,42 +12,31 @@
 
 const struct ia_css_anr_config default_anr_config = {
 	10,
-	{
-		0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
-		0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
-		0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
-		0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4
-	},
-	{10, 20, 30}
+	{ 0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4, 0, 3, 1, 2, 3, 6,
+	  4, 5, 1, 4, 2, 3, 2, 5, 3, 4, 0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3,
+	  2, 5, 3, 4, 0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4 },
+	{ 10, 20, 30 }
 };
 
-void
-ia_css_anr_encode(
-    struct sh_css_isp_anr_params *to,
-    const struct ia_css_anr_config *from,
-    unsigned int size)
+void ia_css_anr_encode(struct sh_css_isp_anr_params *to,
+		       const struct ia_css_anr_config *from, unsigned int size)
 {
 	(void)size;
 	to->threshold = from->threshold;
 }
 
-void
-ia_css_anr_dump(
-    const struct sh_css_isp_anr_params *anr,
-    unsigned int level)
+void ia_css_anr_dump(const struct sh_css_isp_anr_params *anr,
+		     unsigned int level)
 {
-	if (!anr) return;
+	if (!anr)
+		return;
 	ia_css_debug_dtrace(level, "Advance Noise Reduction:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "anr_threshold", anr->threshold);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "anr_threshold",
+			    anr->threshold);
 }
 
-void
-ia_css_anr_debug_dtrace(
-    const struct ia_css_anr_config *config,
-    unsigned int level)
+void ia_css_anr_debug_dtrace(const struct ia_css_anr_config *config,
+			     unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.threshold=%d\n",
-			    config->threshold);
+	ia_css_debug_dtrace(level, "config.threshold=%d\n", config->threshold);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr.host.h
index 4f77900871c8b9d43bdc00308aa914eda3af7fa7..1f7dbf50869a1c564fe57c6839a3b572bf5e9402 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr.host.h
@@ -12,20 +12,13 @@
 
 extern const struct ia_css_anr_config default_anr_config;
 
-void
-ia_css_anr_encode(
-    struct sh_css_isp_anr_params *to,
-    const struct ia_css_anr_config *from,
-    unsigned int size);
+void ia_css_anr_encode(struct sh_css_isp_anr_params *to,
+		       const struct ia_css_anr_config *from, unsigned int size);
 
-void
-ia_css_anr_dump(
-    const struct sh_css_isp_anr_params *anr,
-    unsigned int level);
+void ia_css_anr_dump(const struct sh_css_isp_anr_params *anr,
+		     unsigned int level);
 
-void
-ia_css_anr_debug_dtrace(
-    const struct ia_css_anr_config *config, unsigned int level)
-;
+void ia_css_anr_debug_dtrace(const struct ia_css_anr_config *config,
+			     unsigned int level);
 
 #endif /* __IA_CSS_ANR_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr_types.h
index 6e573ceaa9ea2ecd7da6517c9f2ec5996f56087f..af65a47e9cca297da945b0b77add9226b20e1b27 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_1.0/ia_css_anr_types.h
@@ -12,8 +12,8 @@
  */
 
 /* Application specific DMA settings  */
-#define ANR_BPP                 10
-#define ANR_ELEMENT_BITS        ((CEIL_DIV(ANR_BPP, 8)) * 8)
+#define ANR_BPP 10
+#define ANR_ELEMENT_BITS ((CEIL_DIV(ANR_BPP, 8)) * 8)
 
 /* Advanced Noise Reduction configuration.
  *  This is also known as Low-Light.
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2.host.c
index 09599884bdaefe32f891f437274b96110888a675..d10db2817a81d999456cfbe281bdd3f623f2b4b8 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2.host.c
@@ -10,11 +10,8 @@
 
 #include "ia_css_anr2.host.h"
 
-void
-ia_css_anr2_vmem_encode(
-    struct ia_css_isp_anr2_params *to,
-    const struct ia_css_anr_thres *from,
-    size_t size)
+void ia_css_anr2_vmem_encode(struct ia_css_isp_anr2_params *to,
+			     const struct ia_css_anr_thres *from, size_t size)
 {
 	unsigned int i;
 
@@ -28,10 +25,8 @@ ia_css_anr2_vmem_encode(
 	}
 }
 
-void
-ia_css_anr2_debug_dtrace(
-    const struct ia_css_anr_thres *config,
-    unsigned int level)
+void ia_css_anr2_debug_dtrace(const struct ia_css_anr_thres *config,
+			      unsigned int level)
 {
 	(void)config;
 	(void)level;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2.host.h
index 2b1105f21c1e2b37144083b6bb8f9dd465a2f43b..ac82ecb3e2fc72b31c42aaf714ebdb217f52dad7 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2.host.h
@@ -13,15 +13,10 @@
 #include "ia_css_anr2_param.h"
 #include "ia_css_anr2_table.host.h"
 
-void
-ia_css_anr2_vmem_encode(
-    struct ia_css_isp_anr2_params *to,
-    const struct ia_css_anr_thres *from,
-    size_t size);
+void ia_css_anr2_vmem_encode(struct ia_css_isp_anr2_params *to,
+			     const struct ia_css_anr_thres *from, size_t size);
 
-void
-ia_css_anr2_debug_dtrace(
-    const struct ia_css_anr_thres *config, unsigned int level)
-;
+void ia_css_anr2_debug_dtrace(const struct ia_css_anr_thres *config,
+			      unsigned int level);
 
 #endif /* __IA_CSS_ANR2_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_param.h
index f0e0f2a0f30b5ff2a1c83566a866b11f8f3228df..ca6349cd9408ab53629b48dbf5e3bf62a39084e9 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_param.h
@@ -13,7 +13,7 @@
 /* Advanced Noise Reduction (ANR) thresholds */
 
 struct ia_css_isp_anr2_params {
-	VMEM_ARRAY(data, ANR_PARAM_SIZE * ISP_VEC_NELEMS);
+	VMEM_ARRAY(data, ANR_PARAM_SIZE *ISP_VEC_NELEMS);
 };
 
 #endif /* __IA_CSS_ANR2_PARAM_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_table.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_table.host.c
index 87cc5cb5dd5d25820630975fe33cf4582f9bf2b9..96feb52cf6b987526d59ece625b9b6160ee98f61 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_table.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_table.host.c
@@ -10,38 +10,121 @@
 
 #if 1
 const struct ia_css_anr_thres default_anr_thres = {
-	{
-		128, 384, 640, 896, 896, 640, 384, 128, 384, 1152, 1920, 2688, 2688, 1920, 1152, 384, 640, 1920, 3200, 4480, 4480, 3200, 1920, 640, 896, 2688, 4480, 6272, 6272, 4480, 2688, 896, 896, 2688, 4480, 6272, 6272, 4480, 2688, 896, 640, 1920, 3200, 4480, 4480, 3200, 1920, 640, 384, 1152, 1920, 2688, 2688, 1920, 1152, 384, 128, 384, 640, 896, 896, 640, 384, 128,
-		0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20,
-		0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40,
-		0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60,
-		30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50,
-		60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100,
-		90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150,
-		10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30,
-		20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60,
-		30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90,
-		20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40,
-		40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80,
-		60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120
-	}
+	{ 128,	384,  640,  896,  896,	640,  384,  128,  384,	1152, 1920,
+	  2688, 2688, 1920, 1152, 384,	640,  1920, 3200, 4480, 4480, 3200,
+	  1920, 640,  896,  2688, 4480, 6272, 6272, 4480, 2688, 896,  896,
+	  2688, 4480, 6272, 6272, 4480, 2688, 896,  640,  1920, 3200, 4480,
+	  4480, 3200, 1920, 640,  384,	1152, 1920, 2688, 2688, 1920, 1152,
+	  384,	128,  384,  640,  896,	896,  640,  384,  128,	0,    0,
+	  30,	30,   10,   10,	  20,	20,   0,    0,	  30,	30,   10,
+	  10,	20,   20,   0,	  0,	30,   30,   10,	  10,	20,   20,
+	  0,	0,    30,   30,	  10,	10,   20,   20,	  0,	0,    30,
+	  30,	10,   10,   20,	  20,	0,    0,    30,	  30,	10,   10,
+	  20,	20,   0,    0,	  30,	30,   10,   10,	  20,	20,   0,
+	  0,	30,   30,   10,	  10,	20,   20,   0,	  0,	60,   60,
+	  20,	20,   40,   40,	  0,	0,    60,   60,	  20,	20,   40,
+	  40,	0,    0,    60,	  60,	20,   20,   40,	  40,	0,    0,
+	  60,	60,   20,   20,	  40,	40,   0,    0,	  60,	60,   20,
+	  20,	40,   40,   0,	  0,	60,   60,   20,	  20,	40,   40,
+	  0,	0,    60,   60,	  20,	20,   40,   40,	  0,	0,    60,
+	  60,	20,   20,   40,	  40,	0,    0,    90,	  90,	30,   30,
+	  60,	60,   0,    0,	  90,	90,   30,   30,	  60,	60,   0,
+	  0,	90,   90,   30,	  30,	60,   60,   0,	  0,	90,   90,
+	  30,	30,   60,   60,	  0,	0,    90,   90,	  30,	30,   60,
+	  60,	0,    0,    90,	  90,	30,   30,   60,	  60,	0,    0,
+	  90,	90,   30,   30,	  60,	60,   0,    0,	  90,	90,   30,
+	  30,	60,   60,   30,	  30,	60,   60,   40,	  40,	50,   50,
+	  30,	30,   60,   60,	  40,	40,   50,   50,	  30,	30,   60,
+	  60,	40,   40,   50,	  50,	30,   30,   60,	  60,	40,   40,
+	  50,	50,   30,   30,	  60,	60,   40,   40,	  50,	50,   30,
+	  30,	60,   60,   40,	  40,	50,   50,   30,	  30,	60,   60,
+	  40,	40,   50,   50,	  30,	30,   60,   60,	  40,	40,   50,
+	  50,	60,   60,   120,  120,	80,   80,   100,  100,	60,   60,
+	  120,	120,  80,   80,	  100,	100,  60,   60,	  120,	120,  80,
+	  80,	100,  100,  60,	  60,	120,  120,  80,	  80,	100,  100,
+	  60,	60,   120,  120,  80,	80,   100,  100,  60,	60,   120,
+	  120,	80,   80,   100,  100,	60,   60,   120,  120,	80,   80,
+	  100,	100,  60,   60,	  120,	120,  80,   80,	  100,	100,  90,
+	  90,	180,  180,  120,  120,	150,  150,  90,	  90,	180,  180,
+	  120,	120,  150,  150,  90,	90,   180,  180,  120,	120,  150,
+	  150,	90,   90,   180,  180,	120,  120,  150,  150,	90,   90,
+	  180,	180,  120,  120,  150,	150,  90,   90,	  180,	180,  120,
+	  120,	150,  150,  90,	  90,	180,  180,  120,  120,	150,  150,
+	  90,	90,   180,  180,  120,	120,  150,  150,  10,	10,   40,
+	  40,	20,   20,   30,	  30,	10,   10,   40,	  40,	20,   20,
+	  30,	30,   10,   10,	  40,	40,   20,   20,	  30,	30,   10,
+	  10,	40,   40,   20,	  20,	30,   30,   10,	  10,	40,   40,
+	  20,	20,   30,   30,	  10,	10,   40,   40,	  20,	20,   30,
+	  30,	10,   10,   40,	  40,	20,   20,   30,	  30,	10,   10,
+	  40,	40,   20,   20,	  30,	30,   20,   20,	  80,	80,   40,
+	  40,	60,   60,   20,	  20,	80,   80,   40,	  40,	60,   60,
+	  20,	20,   80,   80,	  40,	40,   60,   60,	  20,	20,   80,
+	  80,	40,   40,   60,	  60,	20,   20,   80,	  80,	40,   40,
+	  60,	60,   20,   20,	  80,	80,   40,   40,	  60,	60,   20,
+	  20,	80,   80,   40,	  40,	60,   60,   20,	  20,	80,   80,
+	  40,	40,   60,   60,	  30,	30,   120,  120,  60,	60,   90,
+	  90,	30,   30,   120,  120,	60,   60,   90,	  90,	30,   30,
+	  120,	120,  60,   60,	  90,	90,   30,   30,	  120,	120,  60,
+	  60,	90,   90,   30,	  30,	120,  120,  60,	  60,	90,   90,
+	  30,	30,   120,  120,  60,	60,   90,   90,	  30,	30,   120,
+	  120,	60,   60,   90,	  90,	30,   30,   120,  120,	60,   60,
+	  90,	90,   20,   20,	  50,	50,   30,   30,	  40,	40,   20,
+	  20,	50,   50,   30,	  30,	40,   40,   20,	  20,	50,   50,
+	  30,	30,   40,   40,	  20,	20,   50,   50,	  30,	30,   40,
+	  40,	20,   20,   50,	  50,	30,   30,   40,	  40,	20,   20,
+	  50,	50,   30,   30,	  40,	40,   20,   20,	  50,	50,   30,
+	  30,	40,   40,   20,	  20,	50,   50,   30,	  30,	40,   40,
+	  40,	40,   100,  100,  60,	60,   80,   80,	  40,	40,   100,
+	  100,	60,   60,   80,	  80,	40,   40,   100,  100,	60,   60,
+	  80,	80,   40,   40,	  100,	100,  60,   60,	  80,	80,   40,
+	  40,	100,  100,  60,	  60,	80,   80,   40,	  40,	100,  100,
+	  60,	60,   80,   80,	  40,	40,   100,  100,  60,	60,   80,
+	  80,	40,   40,   100,  100,	60,   60,   80,	  80,	60,   60,
+	  150,	150,  90,   90,	  120,	120,  60,   60,	  150,	150,  90,
+	  90,	120,  120,  60,	  60,	150,  150,  90,	  90,	120,  120,
+	  60,	60,   150,  150,  90,	90,   120,  120,  60,	60,   150,
+	  150,	90,   90,   120,  120,	60,   60,   150,  150,	90,   90,
+	  120,	120,  60,   60,	  150,	150,  90,   90,	  120,	120,  60,
+	  60,	150,  150,  90,	  90,	120,  120 }
 };
 #else
 const struct ia_css_anr_thres default_anr_thres = {
-	{
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-	}
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	  0, 0, 0, 0 }
 };
 #endif
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_types.h
index 2c7c3c3fd8ce544f25848cf3d81c0591f6620668..2146023e77fb8256512778791899eae67febef6f 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/anr/anr_2/ia_css_anr2_types.h
@@ -13,7 +13,7 @@
 
 #include "type_support.h"
 
-#define ANR_PARAM_SIZE          13
+#define ANR_PARAM_SIZE 13
 
 /* Advanced Noise Reduction (ANR) thresholds */
 struct ia_css_anr_thres {
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh.host.c
index 69c87e53f3c22fade6c4c7914d1550f68dd8f5c2..83898f2bfc23cd385ede94f9bb5df06fdbbc5d7c 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh.host.c
@@ -4,7 +4,6 @@
  * Copyright (c) 2015, Intel Corporation.
  */
 
-
 #include "ia_css_types.h"
 #include "sh_css_internal.h"
 #include "assert_support.h"
@@ -12,10 +11,8 @@
 
 #include "ia_css_bh.host.h"
 
-void
-ia_css_bh_hmem_decode(
-    struct ia_css_3a_rgby_output *out_ptr,
-    const struct ia_css_bh_table *hmem_buf)
+void ia_css_bh_hmem_decode(struct ia_css_3a_rgby_output *out_ptr,
+			   const struct ia_css_bh_table *hmem_buf)
 {
 	int i;
 
@@ -37,19 +34,15 @@ ia_css_bh_hmem_decode(
 	}
 }
 
-void
-ia_css_bh_encode(
-    struct sh_css_isp_bh_params *to,
-    const struct ia_css_3a_config *from,
-    unsigned int size)
+void ia_css_bh_encode(struct sh_css_isp_bh_params *to,
+		      const struct ia_css_3a_config *from, unsigned int size)
 {
 	(void)size;
 	/* coefficients to calculate Y */
 	to->y_coef_r =
-	    uDIGIT_FITTING(from->ae_y_coef_r, 16, SH_CSS_AE_YCOEF_SHIFT);
+		uDIGIT_FITTING(from->ae_y_coef_r, 16, SH_CSS_AE_YCOEF_SHIFT);
 	to->y_coef_g =
-	    uDIGIT_FITTING(from->ae_y_coef_g, 16, SH_CSS_AE_YCOEF_SHIFT);
+		uDIGIT_FITTING(from->ae_y_coef_g, 16, SH_CSS_AE_YCOEF_SHIFT);
 	to->y_coef_b =
-	    uDIGIT_FITTING(from->ae_y_coef_b, 16, SH_CSS_AE_YCOEF_SHIFT);
+		uDIGIT_FITTING(from->ae_y_coef_b, 16, SH_CSS_AE_YCOEF_SHIFT);
 }
-
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh.host.h
index 36b360cfe62e65037522e0037cf51fca0fabdfba..08d020eaa29c2b59c8a345a54d671e839e626017 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh.host.h
@@ -10,15 +10,10 @@
 #include "ia_css_bh_param.h"
 #include "s3a/s3a_1.0/ia_css_s3a_types.h"
 
-void
-ia_css_bh_hmem_decode(
-    struct ia_css_3a_rgby_output *out_ptr,
-    const struct ia_css_bh_table *hmem_buf);
+void ia_css_bh_hmem_decode(struct ia_css_3a_rgby_output *out_ptr,
+			   const struct ia_css_bh_table *hmem_buf);
 
-void
-ia_css_bh_encode(
-    struct sh_css_isp_bh_params *to,
-    const struct ia_css_3a_config *from,
-    unsigned int size);
+void ia_css_bh_encode(struct sh_css_isp_bh_params *to,
+		      const struct ia_css_3a_config *from, unsigned int size);
 
 #endif /* __IA_CSS_BH_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh_types.h
index c717c636f666b984665f9d11c494843b55ee8c92..d62cb05d201dc8c9cabda03256f1d16103c5161a 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bh/bh_2/ia_css_bh_types.h
@@ -10,14 +10,14 @@
 /* Number of elements in the BH table.
   * Should be consistent with hmem.h
   */
-#define IA_CSS_HMEM_BH_TABLE_SIZE	ISP_HIST_DEPTH
-#define IA_CSS_HMEM_BH_UNIT_SIZE	(ISP_HIST_DEPTH / ISP_HIST_COMPONENTS)
+#define IA_CSS_HMEM_BH_TABLE_SIZE ISP_HIST_DEPTH
+#define IA_CSS_HMEM_BH_UNIT_SIZE (ISP_HIST_DEPTH / ISP_HIST_COMPONENTS)
 
-#define BH_COLOR_R	(0)
-#define BH_COLOR_G	(1)
-#define BH_COLOR_B	(2)
-#define BH_COLOR_Y	(3)
-#define BH_COLOR_NUM	(4)
+#define BH_COLOR_R (0)
+#define BH_COLOR_G (1)
+#define BH_COLOR_B (2)
+#define BH_COLOR_Y (3)
+#define BH_COLOR_NUM (4)
 
 /* BH table */
 struct ia_css_bh_table {
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm.host.c
index cd867937ee13feb67b20231e9ffb69b6ef283ae4..14f6d9a053e8a937bfefc66500e90370ab1abe3a 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm.host.c
@@ -12,14 +12,15 @@
 #endif
 #include <assert_support.h>
 
-#define BNLM_DIV_LUT_SIZE	(12)
+#define BNLM_DIV_LUT_SIZE (12)
 static const s32 div_lut_nearests[BNLM_DIV_LUT_SIZE] = {
 	0, 454, 948, 1484, 2070, 2710, 3412, 4184, 5035, 5978, 7025, 8191
 };
 
-static const s32 div_lut_slopes[BNLM_DIV_LUT_SIZE] = {
-	-7760, -6960, -6216, -5536, -4912, -4344, -3832, -3360, -2936, -2552, -2208, -2208
-    };
+static const s32 div_lut_slopes[BNLM_DIV_LUT_SIZE] = { -7760, -6960, -6216,
+						       -5536, -4912, -4344,
+						       -3832, -3360, -2936,
+						       -2552, -2208, -2208 };
 
 static const s32 div_lut_intercepts[BNLM_DIV_LUT_SIZE] = {
 	8184, 7752, 7336, 6928, 6536, 6152, 5776, 5416, 5064, 4728, 4408, 4408
@@ -32,9 +33,8 @@ static const s32 div_lut_intercepts[BNLM_DIV_LUT_SIZE] = {
  *	lut_val	:	array containing output values related to lut_thr
  *	lut_size:	Size of lut_val array
  */
-static inline void
-bnlm_lut_encode(struct bnlm_lut *lut, const int32_t *lut_thr,
-		const s32 *lut_val, const uint32_t lut_size)
+static inline void bnlm_lut_encode(struct bnlm_lut *lut, const int32_t *lut_thr,
+				   const s32 *lut_val, const uint32_t lut_size)
 {
 	u32 blk, i;
 	const u32 block_size = 16;
@@ -85,30 +85,31 @@ bnlm_lut_encode(struct bnlm_lut *lut, const int32_t *lut_thr,
  * - Encodes BNLM public parameters into VMEM parameters
  * - Generates VMEM parameters which will needed internally ISP
  */
-void
-ia_css_bnlm_vmem_encode(
-    struct bnlm_vmem_params *to,
-    const struct ia_css_bnlm_config *from,
-    size_t size)
+void ia_css_bnlm_vmem_encode(struct bnlm_vmem_params *to,
+			     const struct ia_css_bnlm_config *from, size_t size)
 {
 	int i;
 	(void)size;
 
 	/* Initialize LUTs in VMEM parameters */
-	bnlm_lut_encode(&to->mu_root_lut, from->mu_root_lut_thr, from->mu_root_lut_val,
-			16);
+	bnlm_lut_encode(&to->mu_root_lut, from->mu_root_lut_thr,
+			from->mu_root_lut_val, 16);
 	bnlm_lut_encode(&to->sad_norm_lut, from->sad_norm_lut_thr,
 			from->sad_norm_lut_val, 16);
 	bnlm_lut_encode(&to->sig_detail_lut, from->sig_detail_lut_thr,
 			from->sig_detail_lut_val, 16);
-	bnlm_lut_encode(&to->sig_rad_lut, from->sig_rad_lut_thr, from->sig_rad_lut_val,
+	bnlm_lut_encode(&to->sig_rad_lut, from->sig_rad_lut_thr,
+			from->sig_rad_lut_val, 16);
+	bnlm_lut_encode(&to->rad_pow_lut, from->rad_pow_lut_thr,
+			from->rad_pow_lut_val, 16);
+	bnlm_lut_encode(&to->nl_0_lut, from->nl_0_lut_thr, from->nl_0_lut_val,
+			16);
+	bnlm_lut_encode(&to->nl_1_lut, from->nl_1_lut_thr, from->nl_1_lut_val,
+			16);
+	bnlm_lut_encode(&to->nl_2_lut, from->nl_2_lut_thr, from->nl_2_lut_val,
 			16);
-	bnlm_lut_encode(&to->rad_pow_lut, from->rad_pow_lut_thr, from->rad_pow_lut_val,
+	bnlm_lut_encode(&to->nl_3_lut, from->nl_3_lut_thr, from->nl_3_lut_val,
 			16);
-	bnlm_lut_encode(&to->nl_0_lut, from->nl_0_lut_thr, from->nl_0_lut_val, 16);
-	bnlm_lut_encode(&to->nl_1_lut, from->nl_1_lut_thr, from->nl_1_lut_val, 16);
-	bnlm_lut_encode(&to->nl_2_lut, from->nl_2_lut_thr, from->nl_2_lut_val, 16);
-	bnlm_lut_encode(&to->nl_3_lut, from->nl_3_lut_thr, from->nl_3_lut_val, 16);
 
 	/* Initialize arrays in VMEM parameters */
 	memset(to->nl_th, 0, sizeof(to->nl_th));
@@ -136,11 +137,8 @@ ia_css_bnlm_vmem_encode(
 }
 
 /* - Encodes BNLM public parameters into DMEM parameters */
-void
-ia_css_bnlm_encode(
-    struct bnlm_dmem_params *to,
-    const struct ia_css_bnlm_config *from,
-    size_t size)
+void ia_css_bnlm_encode(struct bnlm_dmem_params *to,
+			const struct ia_css_bnlm_config *from, size_t size)
 {
 	(void)size;
 	to->rad_enable = from->rad_enable;
@@ -156,23 +154,24 @@ ia_css_bnlm_encode(
 }
 
 /* Prints debug traces for BNLM public parameters */
-void
-ia_css_bnlm_debug_trace(
-    const struct ia_css_bnlm_config *config,
-    unsigned int level)
+void ia_css_bnlm_debug_trace(const struct ia_css_bnlm_config *config,
+			     unsigned int level)
 {
 	if (!config)
 		return;
 
 #ifndef IA_CSS_NO_DEBUG
 	ia_css_debug_dtrace(level, "BNLM:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "rad_enable", config->rad_enable);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "rad_enable",
+			    config->rad_enable);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "rad_x_origin",
 			    config->rad_x_origin);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "rad_y_origin",
 			    config->rad_y_origin);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "avg_min_th", config->avg_min_th);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "max_min_th", config->max_min_th);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "avg_min_th",
+			    config->avg_min_th);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "max_min_th",
+			    config->max_min_th);
 
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "exp_coeff_a",
 			    config->exp_coeff_a);
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm.host.h
index 2e47ce5e55249abcb9df6684bd9b07fba0a674ad..d8c6b19d679db51d22e6f527978a6e8e204b01c0 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm.host.h
@@ -10,23 +10,16 @@
 #include "ia_css_bnlm_types.h"
 #include "ia_css_bnlm_param.h"
 
-void
-ia_css_bnlm_vmem_encode(
-    struct bnlm_vmem_params *to,
-    const struct ia_css_bnlm_config *from,
-    size_t size);
+void ia_css_bnlm_vmem_encode(struct bnlm_vmem_params *to,
+			     const struct ia_css_bnlm_config *from,
+			     size_t size);
 
-void
-ia_css_bnlm_encode(
-    struct bnlm_dmem_params *to,
-    const struct ia_css_bnlm_config *from,
-    size_t size);
+void ia_css_bnlm_encode(struct bnlm_dmem_params *to,
+			const struct ia_css_bnlm_config *from, size_t size);
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_bnlm_debug_trace(
-    const struct ia_css_bnlm_config *config,
-    unsigned int level);
+void ia_css_bnlm_debug_trace(const struct ia_css_bnlm_config *config,
+			     unsigned int level);
 #endif
 
 #endif /* __IA_CSS_BNLM_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm_types.h
index 150d3960caee97bcfa5703b38a51989b4a17c6d0..5beaaf7aba0720d7e04eacf53defe8ea80b101bf 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bnlm/ia_css_bnlm_types.h
@@ -22,25 +22,25 @@
  * ISP2.6.1: BNLM is used.
  */
 struct ia_css_bnlm_config {
-	bool		rad_enable;	/** Enable a radial dependency in a weight calculation */
-	s32		rad_x_origin;	/** Initial x coordinate for a radius calculation */
-	s32		rad_y_origin;	/** Initial x coordinate for a radius calculation */
+	bool rad_enable; /** Enable a radial dependency in a weight calculation */
+	s32 rad_x_origin; /** Initial x coordinate for a radius calculation */
+	s32 rad_y_origin; /** Initial x coordinate for a radius calculation */
 	/* a threshold for average of weights if this < Th, do not denoise pixel */
-	s32		avg_min_th;
+	s32 avg_min_th;
 	/* minimum weight for denoising if max < th, do not denoise pixel */
-	s32		max_min_th;
+	s32 max_min_th;
 
 	/**@{*/
 	/* Coefficient for approximation, in the form of (1 + x / N)^N,
 	 * that fits the first-order exp() to default exp_lut in BNLM sheet
 	 * */
-	s32		exp_coeff_a;
-	u32	exp_coeff_b;
-	s32		exp_coeff_c;
-	u32	exp_exponent;
+	s32 exp_coeff_a;
+	u32 exp_coeff_b;
+	s32 exp_coeff_c;
+	u32 exp_exponent;
 	/**@}*/
 
-	s32 nl_th[3];	/** Detail thresholds */
+	s32 nl_th[3]; /** Detail thresholds */
 
 	/* Index for n-th maximum candidate weight for each detail group */
 	s32 match_quality_max_idx[4];
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
index b3a9b2f794a0ac2b8cf06ee4ad04aa540fa5150f..881439cdf66d2aa6b15055a1d0313d8b530b2076 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
@@ -13,36 +13,12 @@
 
 /* Default kernel parameters. */
 const struct ia_css_bnr2_2_config default_bnr2_2_config = {
-	200,
-	200,
-	200,
-	0,
-	0,
-	0,
-	200,
-	200,
-	200,
-	0,
-	0,
-	0,
-	0,
-	4096,
-	8191,
-	128,
-	1,
-	0,
-	0,
-	0,
-	8191,
-	0,
-	8191
+	200, 200,  200,	 0,   0, 0, 200, 200, 200,  0, 0,   0,
+	0,   4096, 8191, 128, 1, 0, 0,	 0,   8191, 0, 8191
 };
 
-void
-ia_css_bnr2_2_encode(
-    struct sh_css_isp_bnr2_2_params *to,
-    const struct ia_css_bnr2_2_config *from,
-    size_t size)
+void ia_css_bnr2_2_encode(struct sh_css_isp_bnr2_2_params *to,
+			  const struct ia_css_bnr2_2_config *from, size_t size)
 {
 	(void)size;
 	to->d_var_gain_r = from->d_var_gain_r;
@@ -64,7 +40,7 @@ ia_css_bnr2_2_encode(
 	to->var_offset_coef = from->var_offset_coef;
 
 	to->dir_gain = from->dir_gain;
-	to->detail_gain	= from->detail_gain;
+	to->detail_gain = from->detail_gain;
 	to->detail_gain_divisor = from->detail_gain_divisor;
 	to->detail_level_offset = from->detail_level_offset;
 
@@ -75,18 +51,19 @@ ia_css_bnr2_2_encode(
 }
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_bnr2_2_debug_dtrace(
-    const struct ia_css_bnr2_2_config *bnr,
-    unsigned int level)
+void ia_css_bnr2_2_debug_dtrace(const struct ia_css_bnr2_2_config *bnr,
+				unsigned int level)
 {
 	if (!bnr)
 		return;
 
 	ia_css_debug_dtrace(level, "Bayer Noise Reduction 2.2:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_r", bnr->d_var_gain_r);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_g", bnr->d_var_gain_g);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_b", bnr->d_var_gain_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_r",
+			    bnr->d_var_gain_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_g",
+			    bnr->d_var_gain_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_b",
+			    bnr->d_var_gain_b);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_r",
 			    bnr->d_var_gain_slope_r);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_g",
@@ -94,9 +71,12 @@ ia_css_bnr2_2_debug_dtrace(
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_b",
 			    bnr->d_var_gain_slope_b);
 
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_r", bnr->n_var_gain_r);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_g", bnr->n_var_gain_g);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_b", bnr->n_var_gain_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_r",
+			    bnr->n_var_gain_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_g",
+			    bnr->n_var_gain_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_b",
+			    bnr->n_var_gain_b);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_r",
 			    bnr->n_var_gain_slope_r);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_g",
@@ -104,20 +84,27 @@ ia_css_bnr2_2_debug_dtrace(
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_b",
 			    bnr->n_var_gain_slope_b);
 
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_thres", bnr->dir_thres);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_thres_w", bnr->dir_thres_w);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_thres",
+			    bnr->dir_thres);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_thres_w",
+			    bnr->dir_thres_w);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "var_offset_coef",
 			    bnr->var_offset_coef);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_gain", bnr->dir_gain);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_gain", bnr->detail_gain);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_gain",
+			    bnr->detail_gain);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_gain_divisor",
 			    bnr->detail_gain_divisor);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_level_offset",
 			    bnr->detail_level_offset);
 
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_th_min", bnr->d_var_th_min);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_th_max", bnr->d_var_th_max);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_th_min", bnr->n_var_th_min);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_th_max", bnr->n_var_th_max);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_th_min",
+			    bnr->d_var_th_min);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_th_max",
+			    bnr->d_var_th_max);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_th_min",
+			    bnr->n_var_th_min);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_th_max",
+			    bnr->n_var_th_max);
 }
 #endif /* IA_CSS_NO_DEBUG */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
index 08d2c4c7f493d25674a747dcd4e674abed2bd1b1..9d0581e4a1ef86087982fde84550f00a535a07e7 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
@@ -11,17 +11,12 @@
 
 extern const struct ia_css_bnr2_2_config default_bnr2_2_config;
 
-void
-ia_css_bnr2_2_encode(
-    struct sh_css_isp_bnr2_2_params *to,
-    const struct ia_css_bnr2_2_config *from,
-    size_t size);
+void ia_css_bnr2_2_encode(struct sh_css_isp_bnr2_2_params *to,
+			  const struct ia_css_bnr2_2_config *from, size_t size);
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_bnr2_2_debug_dtrace(
-    const struct ia_css_bnr2_2_config *config,
-    unsigned int level);
+void ia_css_bnr2_2_debug_dtrace(const struct ia_css_bnr2_2_config *config,
+				unsigned int level);
 #endif
 
 #endif /* __IA_CSS_BNR2_2_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
index 387909c35c1ab960e623617aa4284fb90bc78f9a..5c714e5a5f058fbaee5bca530d926b07f883886f 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
@@ -47,17 +47,17 @@ struct ia_css_bnr2_2_config {
 	s32 n_var_gain_slope_b;
 	/**@}*/
 
-	s32 dir_thres;		/** Threshold for directional filtering */
-	s32 dir_thres_w;		/** Threshold width for directional filtering */
-	s32 var_offset_coef;	/** Variance offset coefficient */
-	s32 dir_gain;		/** Gain for directional coefficient */
-	s32 detail_gain;		/** Gain for low contrast texture control */
-	s32 detail_gain_divisor;	/** Gain divisor for low contrast texture control */
-	s32 detail_level_offset;	/** Bias value for low contrast texture control */
-	s32 d_var_th_min;		/** Minimum clipping value for directional variance*/
-	s32 d_var_th_max;		/** Maximum clipping value for diretional variance*/
-	s32 n_var_th_min;		/** Minimum clipping value for non-directional variance*/
-	s32 n_var_th_max;		/** Maximum clipping value for non-directional variance*/
+	s32 dir_thres; /** Threshold for directional filtering */
+	s32 dir_thres_w; /** Threshold width for directional filtering */
+	s32 var_offset_coef; /** Variance offset coefficient */
+	s32 dir_gain; /** Gain for directional coefficient */
+	s32 detail_gain; /** Gain for low contrast texture control */
+	s32 detail_gain_divisor; /** Gain divisor for low contrast texture control */
+	s32 detail_level_offset; /** Bias value for low contrast texture control */
+	s32 d_var_th_min; /** Minimum clipping value for directional variance*/
+	s32 d_var_th_max; /** Maximum clipping value for diretional variance*/
+	s32 n_var_th_min; /** Minimum clipping value for non-directional variance*/
+	s32 n_var_th_max; /** Maximum clipping value for non-directional variance*/
 };
 
 #endif /* __IA_CSS_BNR2_2_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.c
index 0c08077c741b71019fd7737f11b67b3108b680d8..e5fecdc337c463cf3353c21eaf61813cea8ed48d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.c
@@ -11,47 +11,37 @@
 
 #include "ia_css_bnr.host.h"
 
-void
-ia_css_bnr_encode(
-    struct sh_css_isp_bnr_params *to,
-    const struct ia_css_nr_config *from,
-    unsigned int size)
+void ia_css_bnr_encode(struct sh_css_isp_bnr_params *to,
+		       const struct ia_css_nr_config *from, unsigned int size)
 {
 	(void)size;
 	/* BNR (Bayer Noise Reduction) */
 	to->threshold_low =
-	    uDIGIT_FITTING(from->direction, 16, SH_CSS_BAYER_BITS);
+		uDIGIT_FITTING(from->direction, 16, SH_CSS_BAYER_BITS);
 	to->threshold_width_log2 = uFRACTION_BITS_FITTING(8);
-	to->threshold_width =
-	    1 << to->threshold_width_log2;
+	to->threshold_width = 1 << to->threshold_width_log2;
 	to->gain_all =
-	    uDIGIT_FITTING(from->bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
+		uDIGIT_FITTING(from->bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
 	to->gain_dir =
-	    uDIGIT_FITTING(from->bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
+		uDIGIT_FITTING(from->bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
 	to->clip = uDIGIT_FITTING(16384U, 16, SH_CSS_BAYER_BITS);
 }
 
-void
-ia_css_bnr_dump(
-    const struct sh_css_isp_bnr_params *bnr,
-    unsigned int level)
+void ia_css_bnr_dump(const struct sh_css_isp_bnr_params *bnr,
+		     unsigned int level)
 {
 	if (!bnr)
 		return;
 	ia_css_debug_dtrace(level, "Bayer Noise Reduction:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "bnr_gain_all", bnr->gain_all);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "bnr_gain_dir", bnr->gain_dir);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "bnr_threshold_low",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "bnr_gain_all",
+			    bnr->gain_all);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "bnr_gain_dir",
+			    bnr->gain_dir);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "bnr_threshold_low",
 			    bnr->threshold_low);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "bnr_threshold_width_log2",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "bnr_threshold_width_log2",
 			    bnr->threshold_width_log2);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "bnr_threshold_width",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "bnr_threshold_width",
 			    bnr->threshold_width);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "bnr_clip", bnr->clip);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "bnr_clip", bnr->clip);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h
index a5f0a12f42b1db6b832406c1640d5f4b011d53a2..64084520b69ec5fd42afd8ed91d483564822c60d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h
@@ -12,15 +12,10 @@
 #include "ynr/ynr_1.0/ia_css_ynr_types.h"
 #include "ia_css_bnr_param.h"
 
-void
-ia_css_bnr_encode(
-    struct sh_css_isp_bnr_params *to,
-    const struct ia_css_nr_config *from,
-    unsigned int size);
+void ia_css_bnr_encode(struct sh_css_isp_bnr_params *to,
+		       const struct ia_css_nr_config *from, unsigned int size);
 
-void
-ia_css_bnr_dump(
-    const struct sh_css_isp_bnr_params *bnr,
-    unsigned int level);
+void ia_css_bnr_dump(const struct sh_css_isp_bnr_params *bnr,
+		     unsigned int level);
 
 #endif /* __IA_CSS_DP_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.c
index 54789d28a9bcd484cc47e9037c415fc1bd151c25..08684bf59782c46dae07461ca779b4f0ade3bf58 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.c
@@ -11,10 +11,8 @@
 #include "ia_css_cnr.host.h"
 
 /* keep the interface here, it is not enabled yet because host doesn't know the size of individual state */
-void
-ia_css_init_cnr_state(
-    void/*struct sh_css_isp_cnr_vmem_state*/ * state,
-    size_t size)
+void ia_css_init_cnr_state(void /*struct sh_css_isp_cnr_vmem_state*/ *state,
+			   size_t size)
 {
 	memset(state, 0, size);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.h
index d4ffe59ff8a01bced7db0b6c4a484a94fd3c96b9..8ffefd86c98286e7197aa0be857a9c4585937bfc 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.h
@@ -9,9 +9,7 @@
 
 #include "ia_css_cnr_param.h"
 
-void
-ia_css_init_cnr_state(
-    void/*struct sh_css_isp_cnr_vmem_state*/ * state,
-    size_t size);
+void ia_css_init_cnr_state(void /*struct sh_css_isp_cnr_vmem_state*/ *state,
+			   size_t size);
 
 #endif /* __IA_CSS_CNR_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr_param.h
index 6a8daab667a1bbaab122d6675222027bec1f1fd5..8dad3203aa5f5b1f333dc2d1e3817b02dd330873 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_1.0/ia_css_cnr_param.h
@@ -11,6 +11,6 @@
 
 /* CNR (Chroma Noise Reduction) */
 /* Reuse YNR1 param structure */
-#include  "../../ynr/ynr_1.0/ia_css_ynr_param.h"
+#include "../../ynr/ynr_1.0/ia_css_ynr_param.h"
 
 #endif /* __IA_CSS_CNR_PARAM_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.c
index a333c3aa57096e88bf40e7f92b056211d467dd12..947d624ff656169eca808c63ea84321eaf057142 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.c
@@ -10,22 +10,11 @@
 
 #include "ia_css_cnr2.host.h"
 
-const struct ia_css_cnr_config default_cnr_config = {
-	0,
-	0,
-	100,
-	100,
-	100,
-	50,
-	50,
-	50
-};
+const struct ia_css_cnr_config default_cnr_config = { 0,   0,  100, 100,
+						      100, 50, 50,  50 };
 
-void
-ia_css_cnr_encode(
-    struct sh_css_isp_cnr_params *to,
-    const struct ia_css_cnr_config *from,
-    unsigned int size)
+void ia_css_cnr_encode(struct sh_css_isp_cnr_params *to,
+		       const struct ia_css_cnr_config *from, unsigned int size)
 {
 	(void)size;
 	to->coring_u = from->coring_u;
@@ -38,28 +27,23 @@ ia_css_cnr_encode(
 	to->sense_gain_hv = from->sense_gain_hv;
 }
 
-void
-ia_css_cnr_dump(
-    const struct sh_css_isp_cnr_params *cnr,
-    unsigned int level);
+void ia_css_cnr_dump(const struct sh_css_isp_cnr_params *cnr,
+		     unsigned int level);
 
-void
-ia_css_cnr_debug_dtrace(
-    const struct ia_css_cnr_config *config,
-    unsigned int level)
+void ia_css_cnr_debug_dtrace(const struct ia_css_cnr_config *config,
+			     unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.coring_u=%d, config.coring_v=%d, config.sense_gain_vy=%d, config.sense_gain_hy=%d, config.sense_gain_vu=%d, config.sense_gain_hu=%d, config.sense_gain_vv=%d, config.sense_gain_hv=%d\n",
-			    config->coring_u, config->coring_v,
-			    config->sense_gain_vy, config->sense_gain_hy,
-			    config->sense_gain_vu, config->sense_gain_hu,
-			    config->sense_gain_vv, config->sense_gain_hv);
+	ia_css_debug_dtrace(
+		level,
+		"config.coring_u=%d, config.coring_v=%d, config.sense_gain_vy=%d, config.sense_gain_hy=%d, config.sense_gain_vu=%d, config.sense_gain_hu=%d, config.sense_gain_vv=%d, config.sense_gain_hv=%d\n",
+		config->coring_u, config->coring_v, config->sense_gain_vy,
+		config->sense_gain_hy, config->sense_gain_vu,
+		config->sense_gain_hu, config->sense_gain_vv,
+		config->sense_gain_hv);
 }
 
-void
-ia_css_init_cnr2_state(
-    void/*struct sh_css_isp_cnr_vmem_state*/ * state,
-    size_t size)
+void ia_css_init_cnr2_state(void /*struct sh_css_isp_cnr_vmem_state*/ *state,
+			    size_t size)
 {
 	memset(state, 0, size);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h
index 213009192f09c146d3f000acdc4e3b492ff9eec4..78728ea5ef28efe5ae64859d775b49a272c87193 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h
@@ -12,24 +12,15 @@
 
 extern const struct ia_css_cnr_config default_cnr_config;
 
-void
-ia_css_cnr_encode(
-    struct sh_css_isp_cnr_params *to,
-    const struct ia_css_cnr_config *from,
-    unsigned int size);
+void ia_css_cnr_encode(struct sh_css_isp_cnr_params *to,
+		       const struct ia_css_cnr_config *from, unsigned int size);
 
-void
-ia_css_cnr_dump(
-    const struct sh_css_isp_cnr_params *cnr,
-    unsigned int level);
+void ia_css_cnr_dump(const struct sh_css_isp_cnr_params *cnr,
+		     unsigned int level);
 
-void
-ia_css_cnr_debug_dtrace(
-    const struct ia_css_cnr_config *config,
-    unsigned int level);
+void ia_css_cnr_debug_dtrace(const struct ia_css_cnr_config *config,
+			     unsigned int level);
 
-void
-ia_css_init_cnr2_state(
-    void/*struct sh_css_isp_cnr_vmem_state*/ * state,
-    size_t size);
+void ia_css_init_cnr2_state(void /*struct sh_css_isp_cnr_vmem_state*/ *state,
+			    size_t size);
 #endif /* __IA_CSS_CNR2_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
index 9bb9ca7f7ad298018838bbc30c0d469b37b880b7..20920c3f25c0f19dcb4e6a73fb859aac9b82c039 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
@@ -25,21 +25,21 @@
  *  ISP2: CNR2 is used for Still.
  */
 struct ia_css_cnr_config {
-	u16 coring_u;	/** Coring level of U.
+	u16 coring_u; /** Coring level of U.
 				u0.13, [0,8191], default/ineffective 0 */
-	u16 coring_v;	/** Coring level of V.
+	u16 coring_v; /** Coring level of V.
 				u0.13, [0,8191], default/ineffective 0 */
-	u16 sense_gain_vy;	/** Sensitivity of horizontal edge of Y.
+	u16 sense_gain_vy; /** Sensitivity of horizontal edge of Y.
 				u13.0, [0,8191], default 100, ineffective 8191 */
-	u16 sense_gain_vu;	/** Sensitivity of horizontal edge of U.
+	u16 sense_gain_vu; /** Sensitivity of horizontal edge of U.
 				u13.0, [0,8191], default 100, ineffective 8191 */
-	u16 sense_gain_vv;	/** Sensitivity of horizontal edge of V.
+	u16 sense_gain_vv; /** Sensitivity of horizontal edge of V.
 				u13.0, [0,8191], default 100, ineffective 8191 */
-	u16 sense_gain_hy;	/** Sensitivity of vertical edge of Y.
+	u16 sense_gain_hy; /** Sensitivity of vertical edge of Y.
 				u13.0, [0,8191], default 50, ineffective 8191 */
-	u16 sense_gain_hu;	/** Sensitivity of vertical edge of U.
+	u16 sense_gain_hu; /** Sensitivity of vertical edge of U.
 				u13.0, [0,8191], default 50, ineffective 8191 */
-	u16 sense_gain_hv;	/** Sensitivity of vertical edge of V.
+	u16 sense_gain_hv; /** Sensitivity of vertical edge of V.
 				u13.0, [0,8191], default 50, ineffective 8191 */
 };
 
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion.host.c
index 958120b82e479601b53f89582992b7653278dc9e..3d574d1112ebf348cd240fcc274e09e3705a1659 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion.host.c
@@ -14,14 +14,12 @@ const struct ia_css_conversion_config default_conversion_config = {
 	0,
 };
 
-void
-ia_css_conversion_encode(
-    struct sh_css_isp_conversion_params *to,
-    const struct ia_css_conversion_config *from,
-    unsigned int size)
+void ia_css_conversion_encode(struct sh_css_isp_conversion_params *to,
+			      const struct ia_css_conversion_config *from,
+			      unsigned int size)
 {
 	(void)size;
-	to->en     = from->en;
+	to->en = from->en;
 	to->dummy0 = from->dummy0;
 	to->dummy1 = from->dummy1;
 	to->dummy2 = from->dummy2;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion.host.h
index 69eadaffa4cee70c3e70b028bcd7a854e0f2d135..b1767ae94bc1a1c8e22b16d1d63ce36985fc2df1 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion.host.h
@@ -12,10 +12,8 @@
 
 extern const struct ia_css_conversion_config default_conversion_config;
 
-void
-ia_css_conversion_encode(
-    struct sh_css_isp_conversion_params *to,
-    const struct ia_css_conversion_config *from,
-    unsigned int size);
+void ia_css_conversion_encode(struct sh_css_isp_conversion_params *to,
+			      const struct ia_css_conversion_config *from,
+			      unsigned int size);
 
 #endif /* __IA_CSS_CONVERSION_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion_types.h
index 374261d25520eea379c2f8a272fe7c892f36a783..81827eb12adffec3abaa340f5c409cbd26e401c3 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/conversion/conversion_1.0/ia_css_conversion_types.h
@@ -15,7 +15,7 @@
  *
  */
 struct ia_css_conversion_config {
-	u32 en;     /** en parameter */
+	u32 en; /** en parameter */
 	u32 dummy0; /** dummy0 dummy parameter 0 */
 	u32 dummy1; /** dummy1 dummy parameter 1 */
 	u32 dummy2; /** dummy2 dummy parameter 2 */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
index a42064dd1c851f375d62b01683d21d54090b761a..f0270a720e3b166350be623ef36b80c2ef86ce47 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
@@ -15,11 +15,9 @@ static const struct ia_css_copy_output_configuration default_config = {
 	.enable = false,
 };
 
-void
-ia_css_copy_output_config(
-    struct sh_css_isp_copy_output_isp_config      *to,
-    const struct ia_css_copy_output_configuration *from,
-    unsigned int size)
+void ia_css_copy_output_config(
+	struct sh_css_isp_copy_output_isp_config *to,
+	const struct ia_css_copy_output_configuration *from, unsigned int size)
 {
 	(void)size;
 	to->enable = from->enable;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.h
index 9257b99bf8ddde7124b6e23ad6e5b66203dd3b7b..62259edc312355f36425c9f73ca8350e0727a15d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.h
@@ -12,13 +12,11 @@
 
 #include "ia_css_copy_output_param.h"
 
-void
-ia_css_copy_output_config(
-    struct sh_css_isp_copy_output_isp_config      *to,
-    const struct ia_css_copy_output_configuration *from,
-    unsigned int size);
+void ia_css_copy_output_config(
+	struct sh_css_isp_copy_output_isp_config *to,
+	const struct ia_css_copy_output_configuration *from, unsigned int size);
 
-int ia_css_copy_output_configure(const struct ia_css_binary     *binary,
+int ia_css_copy_output_configure(const struct ia_css_binary *binary,
 				 bool enable);
 
 #endif /* __IA_CSS_COPY_OUTPUT_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/crop/crop_1.0/ia_css_crop.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
index 7ec23098687202049ce4a03dc3d82765633f1927..9c88afbaf07ecc8bd305237fe4b81fc9532d267d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
@@ -17,11 +17,9 @@ static const struct ia_css_crop_configuration default_config = {
 	.info = (struct ia_css_frame_info *)NULL,
 };
 
-void
-ia_css_crop_encode(
-    struct sh_css_isp_crop_isp_params *to,
-    const struct ia_css_crop_config *from,
-    unsigned int size)
+void ia_css_crop_encode(struct sh_css_isp_crop_isp_params *to,
+			const struct ia_css_crop_config *from,
+			unsigned int size)
 {
 	(void)size;
 	to->crop_pos = from->crop_pos;
@@ -47,7 +45,7 @@ int ia_css_crop_config(struct sh_css_isp_crop_isp_config *to,
 	return 0;
 }
 
-int ia_css_crop_configure(const struct ia_css_binary     *binary,
+int ia_css_crop_configure(const struct ia_css_binary *binary,
 			  const struct ia_css_frame_info *info)
 {
 	struct ia_css_crop_configuration config = default_config;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/crop/crop_1.0/ia_css_crop.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/crop/crop_1.0/ia_css_crop.host.h
index 9f51ecfdad14814d7eb2e2e3c52a0648e484dce2..362cb971d04d8dd1c6e6a2e89eccb0a178893e00 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/crop/crop_1.0/ia_css_crop.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/crop/crop_1.0/ia_css_crop.host.h
@@ -13,17 +13,15 @@
 #include "ia_css_crop_types.h"
 #include "ia_css_crop_param.h"
 
-void
-ia_css_crop_encode(
-    struct sh_css_isp_crop_isp_params *to,
-    const struct ia_css_crop_config *from,
-    unsigned int size);
+void ia_css_crop_encode(struct sh_css_isp_crop_isp_params *to,
+			const struct ia_css_crop_config *from,
+			unsigned int size);
 
-int ia_css_crop_config(struct sh_css_isp_crop_isp_config      *to,
+int ia_css_crop_config(struct sh_css_isp_crop_isp_config *to,
 		       const struct ia_css_crop_configuration *from,
 		       unsigned int size);
 
-int ia_css_crop_configure(const struct ia_css_binary     *binary,
+int ia_css_crop_configure(const struct ia_css_binary *binary,
 			  const struct ia_css_frame_info *from);
 
 #endif /* __IA_CSS_CROP_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc.host.c
index 0f5ea8b3e5b3e50576fdad8a88fc022e1fd7c9c0..9e9e0a930fdc10c1c53479f6b805f634f24ceeae 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc.host.c
@@ -15,21 +15,19 @@
 
 const struct ia_css_cc_config default_cc_config = {
 	8,
-	{255, 29, 120, 0, -374, -342, 0, -672, 301},
+	{ 255, 29, 120, 0, -374, -342, 0, -672, 301 },
 };
 
-void
-ia_css_encode_cc(
-    struct sh_css_isp_csc_params *to,
-    const struct ia_css_cc_config *from,
-    unsigned int size)
+void ia_css_encode_cc(struct sh_css_isp_csc_params *to,
+		      const struct ia_css_cc_config *from, unsigned int size)
 {
 	(void)size;
 #ifndef IA_CSS_NO_DEBUG
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_encode_cc() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_encode_cc() enter:\n");
 #endif
 
-	to->m_shift    = (int16_t)from->fraction_bits;
+	to->m_shift = (int16_t)from->fraction_bits;
 	to->m00 = (int16_t)from->matrix[0];
 	to->m01 = (int16_t)from->matrix[1];
 	to->m02 = (int16_t)from->matrix[2];
@@ -41,79 +39,50 @@ ia_css_encode_cc(
 	to->m22 = (int16_t)from->matrix[8];
 
 #ifndef IA_CSS_NO_DEBUG
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_encode_cc() leave:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_encode_cc() leave:\n");
 #endif
 }
 
-void
-ia_css_csc_encode(
-    struct sh_css_isp_csc_params *to,
-    const struct ia_css_cc_config *from,
-    unsigned int size)
+void ia_css_csc_encode(struct sh_css_isp_csc_params *to,
+		       const struct ia_css_cc_config *from, unsigned int size)
 {
 	ia_css_encode_cc(to, from, size);
 }
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_cc_dump(
-    const struct sh_css_isp_csc_params *csc,
-    unsigned int level,
-    const char *name)
+void ia_css_cc_dump(const struct sh_css_isp_csc_params *csc, unsigned int level,
+		    const char *name)
 {
-	if (!csc) return;
+	if (!csc)
+		return;
 	ia_css_debug_dtrace(level, "%s\n", name);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "m_shift",
-			    csc->m_shift);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "m00",
-			    csc->m00);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "m01",
-			    csc->m01);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "m02",
-			    csc->m02);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "m10",
-			    csc->m10);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "m11",
-			    csc->m11);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "m12",
-			    csc->m12);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "m20",
-			    csc->m20);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "m21",
-			    csc->m21);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "m22",
-			    csc->m22);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "m_shift", csc->m_shift);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "m00", csc->m00);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "m01", csc->m01);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "m02", csc->m02);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "m10", csc->m10);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "m11", csc->m11);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "m12", csc->m12);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "m20", csc->m20);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "m21", csc->m21);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "m22", csc->m22);
 }
 
-void
-ia_css_csc_dump(
-    const struct sh_css_isp_csc_params *csc,
-    unsigned int level)
+void ia_css_csc_dump(const struct sh_css_isp_csc_params *csc,
+		     unsigned int level)
 {
 	ia_css_cc_dump(csc, level, "Color Space Conversion");
 }
 
-void
-ia_css_cc_config_debug_dtrace(
-    const struct ia_css_cc_config *config,
-    unsigned int level)
+void ia_css_cc_config_debug_dtrace(const struct ia_css_cc_config *config,
+				   unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.m[0]=%d, config.m[1]=%d, config.m[2]=%d, config.m[3]=%d, config.m[4]=%d, config.m[5]=%d, config.m[6]=%d, config.m[7]=%d, config.m[8]=%d\n",
-			    config->matrix[0],
-			    config->matrix[1], config->matrix[2],
-			    config->matrix[3], config->matrix[4],
-			    config->matrix[5], config->matrix[6],
-			    config->matrix[7], config->matrix[8]);
+	ia_css_debug_dtrace(
+		level,
+		"config.m[0]=%d, config.m[1]=%d, config.m[2]=%d, config.m[3]=%d, config.m[4]=%d, config.m[5]=%d, config.m[6]=%d, config.m[7]=%d, config.m[8]=%d\n",
+		config->matrix[0], config->matrix[1], config->matrix[2],
+		config->matrix[3], config->matrix[4], config->matrix[5],
+		config->matrix[6], config->matrix[7], config->matrix[8]);
 }
 #endif
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc.host.h
index 9dcef66939396ab325846003d3993d07cc2d52e0..a44d492c42386f2deda90bf80b9477542b4ea0c2 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc.host.h
@@ -12,33 +12,21 @@
 
 extern const struct ia_css_cc_config default_cc_config;
 
-void
-ia_css_encode_cc(
-    struct sh_css_isp_csc_params *to,
-    const struct ia_css_cc_config *from,
-    unsigned int size);
-
-void
-ia_css_csc_encode(
-    struct sh_css_isp_csc_params *to,
-    const struct ia_css_cc_config *from,
-    unsigned int size);
+void ia_css_encode_cc(struct sh_css_isp_csc_params *to,
+		      const struct ia_css_cc_config *from, unsigned int size);
+
+void ia_css_csc_encode(struct sh_css_isp_csc_params *to,
+		       const struct ia_css_cc_config *from, unsigned int size);
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_cc_dump(
-    const struct sh_css_isp_csc_params *csc, unsigned int level,
-    const char *name);
-
-void
-ia_css_csc_dump(
-    const struct sh_css_isp_csc_params *csc,
-    unsigned int level);
-
-void
-ia_css_cc_config_debug_dtrace(
-    const struct ia_css_cc_config *config,
-    unsigned int level);
+void ia_css_cc_dump(const struct sh_css_isp_csc_params *csc, unsigned int level,
+		    const char *name);
+
+void ia_css_csc_dump(const struct sh_css_isp_csc_params *csc,
+		     unsigned int level);
+
+void ia_css_cc_config_debug_dtrace(const struct ia_css_cc_config *config,
+				   unsigned int level);
 
 #define ia_css_csc_debug_dtrace ia_css_cc_config_debug_dtrace
 #endif
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc_param.h
index f0380b2c571df7c7859435e614dba938bf4e8df1..47b9dbf9448b255fc4e7407d10431859e69a28b5 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc_param.h
@@ -10,16 +10,16 @@
 #include "type_support.h"
 /* CSC (Color Space Conversion) */
 struct sh_css_isp_csc_params {
-	u16	m_shift;
-	s16		m00;
-	s16		m01;
-	s16		m02;
-	s16		m10;
-	s16		m11;
-	s16		m12;
-	s16		m20;
-	s16		m21;
-	s16		m22;
+	u16 m_shift;
+	s16 m00;
+	s16 m01;
+	s16 m02;
+	s16 m10;
+	s16 m11;
+	s16 m12;
+	s16 m20;
+	s16 m21;
+	s16 m22;
 };
 
 #endif /* __IA_CSS_CSC_PARAM_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc_types.h
index 1e56d78e5ab9ac7eaf97084085a49fdcd4695617..b7f7195fede6bdccedfdf4e6911f161462959b0c 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/csc/csc_1.0/ia_css_csc_types.h
@@ -60,7 +60,7 @@
  *	4096	-3430	-666
  */
 struct ia_css_cc_config {
-	u32 fraction_bits;/** Fractional bits of matrix.
+	u32 fraction_bits; /** Fractional bits of matrix.
 					u8.0, [0,13] */
 	s32 matrix[3 * 3]; /** Conversion matrix.
 					s[13-fraction_bits].[fraction_bits],
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
index 0089402bc12d8372d647b97e0978773e83aa7ec9..2d37818afc349befdc43d6a5e8cffa5b4ebeda21 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
@@ -12,9 +12,7 @@
 #include "ctc/ctc_1.0/ia_css_ctc.host.h"
 #include "ia_css_ctc1_5.host.h"
 
-static void ctc_gradient(
-    int *dydx, int *shift,
-    int y1, int y0, int x1, int x0)
+static void ctc_gradient(int *dydx, int *shift, int y1, int y0, int x1, int x0)
 {
 	int frc_bits = max(IA_CSS_CTC_COEF_SHIFT, 16);
 	int dy = y1 - y0;
@@ -26,8 +24,9 @@ static void ctc_gradient(
 	int max_dydx = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;
 
 	if (dx == 0) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "ctc_gradient() error, illegal division operation\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ctc_gradient() error, illegal division operation\n");
 		return;
 	} else {
 		dydx_int = dy / dx;
@@ -40,15 +39,16 @@ static void ctc_gradient(
 	assert(dydx);
 	assert(shift);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ctc_gradient() enter:\n");
 
 	/* search "sft" which meets this condition:
 		   (1 << (IA_CSS_CTC_COEF_SHIFT - 1))
 		<= (((float)dy / (float)dx) * (1 << sft))
 		<= ((1 << IA_CSS_CTC_COEF_SHIFT) - 1) */
 	for (sft = 0; sft <= IA_CSS_CTC_COEF_SHIFT; sft++) {
-		int tmp_dydx = (dydx_int << sft)
-			       + (dydx_frc >> (frc_bits - sft));
+		int tmp_dydx =
+			(dydx_int << sft) + (dydx_frc >> (frc_bits - sft));
 		if (tmp_dydx <= max_dydx) {
 			*dydx = tmp_dydx;
 			*shift = sft;
@@ -57,14 +57,12 @@ static void ctc_gradient(
 			break;
 	}
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() leave:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ctc_gradient() leave:\n");
 }
 
-void
-ia_css_ctc_encode(
-    struct sh_css_isp_ctc_params *to,
-    const struct ia_css_ctc_config *from,
-    unsigned int size)
+void ia_css_ctc_encode(struct sh_css_isp_ctc_params *to,
+		       const struct ia_css_ctc_config *from, unsigned int size)
 {
 	(void)size;
 	to->y0 = from->y0;
@@ -81,33 +79,21 @@ ia_css_ctc_encode(
 	to->x3 = from->x3;
 	to->x4 = from->x4;
 
-	ctc_gradient(&to->dydx0,
-		     &to->dydx0_shift,
-		     from->y1, from->y0,
-		     from->x1, 0);
-
-	ctc_gradient(&to->dydx1,
-		     &to->dydx1_shift,
-		     from->y2, from->y1,
-		     from->x2, from->x1);
-
-	ctc_gradient(&to->dydx2,
-		     &to->dydx2_shift,
-		     from->y3, from->y2,
-		     from->x3, from->x2);
-
-	ctc_gradient(&to->dydx3,
-		     &to->dydx3_shift,
-		     from->y4, from->y3,
-		     from->x4, from->x3);
-
-	ctc_gradient(&to->dydx4,
-		     &to->dydx4_shift,
-		     from->y5, from->y4,
+	ctc_gradient(&to->dydx0, &to->dydx0_shift, from->y1, from->y0, from->x1,
+		     0);
+
+	ctc_gradient(&to->dydx1, &to->dydx1_shift, from->y2, from->y1, from->x2,
+		     from->x1);
+
+	ctc_gradient(&to->dydx2, &to->dydx2_shift, from->y3, from->y2, from->x3,
+		     from->x2);
+
+	ctc_gradient(&to->dydx3, &to->dydx3_shift, from->y4, from->y3, from->x4,
+		     from->x3);
+
+	ctc_gradient(&to->dydx4, &to->dydx4_shift, from->y5, from->y4,
 		     SH_CSS_BAYER_MAXVAL, from->x4);
 }
 
-void
-ia_css_ctc_dump(
-    const struct sh_css_isp_ctc_params *ctc,
-    unsigned int level);
+void ia_css_ctc_dump(const struct sh_css_isp_ctc_params *ctc,
+		     unsigned int level);
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
index 6dba55261c08376e6252d66652864f98c1f7e95c..fc15000ff230ea93e36f6fe4f6e40870ec29f436 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
@@ -11,15 +11,10 @@
 
 #include "ia_css_ctc1_5_param.h"
 
-void
-ia_css_ctc_encode(
-    struct sh_css_isp_ctc_params *to,
-    const struct ia_css_ctc_config *from,
-    unsigned int size);
+void ia_css_ctc_encode(struct sh_css_isp_ctc_params *to,
+		       const struct ia_css_ctc_config *from, unsigned int size);
 
-void
-ia_css_ctc_dump(
-    const struct sh_css_isp_ctc_params *ctc,
-    unsigned int level);
+void ia_css_ctc_dump(const struct sh_css_isp_ctc_params *ctc,
+		     unsigned int level);
 
 #endif /* __IA_CSS_CTC1_5_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
index 38751b8e9e6aca5f3934e4b55a241bd5874c916c..b2b0108badebca8259e9df290bd8193967b04f4c 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
@@ -15,11 +15,10 @@
 
 /*Default configuration of parameters for Ctc2*/
 const struct ia_css_ctc2_config default_ctc2_config = {
-	INEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
-	INEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
-	BASIC_VAL * 2, BASIC_VAL * 4, BASIC_VAL * 6,
-	BASIC_VAL * 8, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
-	BASIC_VAL >> 1, BASIC_VAL
+	INEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	INEFFECTIVE_VAL, INEFFECTIVE_VAL, BASIC_VAL * 2,   BASIC_VAL * 4,
+	BASIC_VAL * 6,	 BASIC_VAL * 8,	  INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	BASIC_VAL >> 1,	 BASIC_VAL
 };
 
 /* (dydx) = ctc2_slope(y1, y0, x1, x0)
@@ -68,8 +67,7 @@ static int ctc2_slope(int y1, int y0, int x1, int x0)
  * VMEM Encode Function to translate Y parameters from userspace into ISP space
  */
 void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
-			     const struct ia_css_ctc2_config *from,
-			     size_t size)
+			     const struct ia_css_ctc2_config *from, size_t size)
 {
 	unsigned int i, j;
 	const unsigned int shffl_blck = 4;
@@ -81,16 +79,12 @@ void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
 	*  Calculation of slopes of lines interconnecting
 	*  0.0 -> y_x1 -> y_x2 -> y _x3 -> y_x4 -> 1.0
 	*/
-	dydx0 = ctc2_slope(from->y_y1, from->y_y0,
-			   from->y_x1, 0);
-	dydx1 = ctc2_slope(from->y_y2, from->y_y1,
-			   from->y_x2, from->y_x1);
-	dydx2 = ctc2_slope(from->y_y3, from->y_y2,
-			   from->y_x3, from->y_x2);
-	dydx3 = ctc2_slope(from->y_y4, from->y_y3,
-			   from->y_x4, from->y_x3);
-	dydx4 = ctc2_slope(from->y_y5, from->y_y4,
-			   SH_CSS_BAYER_MAXVAL, from->y_x4);
+	dydx0 = ctc2_slope(from->y_y1, from->y_y0, from->y_x1, 0);
+	dydx1 = ctc2_slope(from->y_y2, from->y_y1, from->y_x2, from->y_x1);
+	dydx2 = ctc2_slope(from->y_y3, from->y_y2, from->y_x3, from->y_x2);
+	dydx3 = ctc2_slope(from->y_y4, from->y_y3, from->y_x4, from->y_x3);
+	dydx4 = ctc2_slope(from->y_y5, from->y_y4, SH_CSS_BAYER_MAXVAL,
+			   from->y_x4);
 
 	/*Fill 3 arrays with:
 	 * - Luma input gain values y_y0, y_y1, y_y2, y_3, y_y4
@@ -102,19 +96,19 @@ void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
 	 * - All blocks of the same array will contain the same data
 	 */
 	for (i = 0; i < shffl_blck; i++) {
-		to->y_x[0][(i << shffl_blck)]     = 0;
+		to->y_x[0][(i << shffl_blck)] = 0;
 		to->y_x[0][(i << shffl_blck) + 1] = from->y_x1;
 		to->y_x[0][(i << shffl_blck) + 2] = from->y_x2;
 		to->y_x[0][(i << shffl_blck) + 3] = from->y_x3;
 		to->y_x[0][(i << shffl_blck) + 4] = from->y_x4;
 
-		to->y_y[0][(i << shffl_blck)]     = from->y_y0;
+		to->y_y[0][(i << shffl_blck)] = from->y_y0;
 		to->y_y[0][(i << shffl_blck) + 1] = from->y_y1;
 		to->y_y[0][(i << shffl_blck) + 2] = from->y_y2;
 		to->y_y[0][(i << shffl_blck) + 3] = from->y_y3;
 		to->y_y[0][(i << shffl_blck) + 4] = from->y_y4;
 
-		to->e_y_slope[0][(i << shffl_blck)]    = dydx0;
+		to->e_y_slope[0][(i << shffl_blck)] = dydx0;
 		to->e_y_slope[0][(i << shffl_blck) + 1] = dydx1;
 		to->e_y_slope[0][(i << shffl_blck) + 2] = dydx2;
 		to->e_y_slope[0][(i << shffl_blck) + 3] = dydx3;
@@ -133,8 +127,7 @@ void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
  * DMEM Encode Function to translate UV parameters from userspace into ISP space
  */
 void ia_css_ctc2_encode(struct ia_css_isp_ctc2_dmem_params *to,
-			struct ia_css_ctc2_config *from,
-			size_t size)
+			struct ia_css_ctc2_config *from, size_t size)
 {
 	(void)size;
 
@@ -144,6 +137,6 @@ void ia_css_ctc2_encode(struct ia_css_isp_ctc2_dmem_params *to,
 	to->uv_x1 = from->uv_x1;
 
 	/*Slope Calculation*/
-	to->uv_dydx = ctc2_slope(from->uv_y1, from->uv_y0,
-				 from->uv_x1, from->uv_x0);
+	to->uv_dydx =
+		ctc2_slope(from->uv_y1, from->uv_y0, from->uv_x1, from->uv_x0);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
index 84ab060d6c888d1a9cbfeae71b9a1e3b97a41a15..ebb436cf84b2b369dd09e8bfd84fd3aa41b4a971 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
@@ -19,7 +19,6 @@ void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
 			     size_t size);
 
 void ia_css_ctc2_encode(struct ia_css_isp_ctc2_dmem_params *to,
-			struct ia_css_ctc2_config *from,
-			size_t size);
+			struct ia_css_ctc2_config *from, size_t size);
 
 #endif /* __IA_CSS_CTC2_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
index 41337538abbbe2a9384c3d3a298b044250d2091f..9b4c331823a96f6417933b9e9daa50f922a17f39 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
@@ -7,7 +7,7 @@
 #ifndef __IA_CSS_CTC2_PARAM_H
 #define __IA_CSS_CTC2_PARAM_H
 
-#define IA_CSS_CTC_COEF_SHIFT          13
+#define IA_CSS_CTC_COEF_SHIFT 13
 #include "vmem.h" /* needed for VMEM_ARRAY */
 
 /* CTC (Chroma Tone Control)ISP Parameters */
@@ -35,6 +35,5 @@ struct ia_css_isp_ctc2_dmem_params {
 
 	/* Slope of line interconnecting uv_x0 -> uv_x1*/
 	s32 uv_dydx;
-
 };
 #endif /* __IA_CSS_CTC2_PARAM_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.c
index f60cbe49ffab3d4aebeb72a1e9dd76bab1aa4d54..dbcf653670f46ddeccc1f2e06dfe9bbd8a8dbf4b 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.c
@@ -12,39 +12,34 @@
 #include "ia_css_ctc.host.h"
 
 const struct ia_css_ctc_config default_ctc_config = {
-	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2, /* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2, /* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2, /* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2, /* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2, /* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2, /* 0.5 */
 	1,
-	SH_CSS_BAYER_MAXVAL / 5,	/* To be implemented */
-	SH_CSS_BAYER_MAXVAL * 2 / 5,	/* To be implemented */
-	SH_CSS_BAYER_MAXVAL * 3 / 5,	/* To be implemented */
-	SH_CSS_BAYER_MAXVAL * 4 / 5,	/* To be implemented */
+	SH_CSS_BAYER_MAXVAL / 5, /* To be implemented */
+	SH_CSS_BAYER_MAXVAL * 2 / 5, /* To be implemented */
+	SH_CSS_BAYER_MAXVAL * 3 / 5, /* To be implemented */
+	SH_CSS_BAYER_MAXVAL * 4 / 5, /* To be implemented */
 };
 
-void
-ia_css_ctc_vamem_encode(
-    struct sh_css_isp_ctc_vamem_params *to,
-    const struct ia_css_ctc_table *from,
-    unsigned int size)
+void ia_css_ctc_vamem_encode(struct sh_css_isp_ctc_vamem_params *to,
+			     const struct ia_css_ctc_table *from,
+			     unsigned int size)
 {
 	(void)size;
-	memcpy(&to->ctc,  &from->data, sizeof(to->ctc));
+	memcpy(&to->ctc, &from->data, sizeof(to->ctc));
 }
 
-void
-ia_css_ctc_debug_dtrace(
-    const struct ia_css_ctc_config *config,
-    unsigned int level)
+void ia_css_ctc_debug_dtrace(const struct ia_css_ctc_config *config,
+			     unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.ce_gain_exp=%d, config.y0=%d, config.x1=%d, config.y1=%d, config.x2=%d, config.y2=%d, config.x3=%d, config.y3=%d, config.x4=%d, config.y4=%d\n",
-			    config->ce_gain_exp, config->y0,
-			    config->x1, config->y1,
-			    config->x2, config->y2,
-			    config->x3, config->y3,
-			    config->x4, config->y4);
+	ia_css_debug_dtrace(
+		level,
+		"config.ce_gain_exp=%d, config.y0=%d, config.x1=%d, config.y1=%d, config.x2=%d, config.y2=%d, config.x3=%d, config.y3=%d, config.x4=%d, config.y4=%d\n",
+		config->ce_gain_exp, config->y0, config->x1, config->y1,
+		config->x2, config->y2, config->x3, config->y3, config->x4,
+		config->y4);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h
index 6ed1fe8b0b3c4c803196515155ec81ac03f7a242..1f3db8b9e0e5ad0fb6003a2ff82cc9ae74723889 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h
@@ -14,15 +14,11 @@
 
 extern const struct ia_css_ctc_config default_ctc_config;
 
-void
-ia_css_ctc_vamem_encode(
-    struct sh_css_isp_ctc_vamem_params *to,
-    const struct ia_css_ctc_table *from,
-    unsigned int size);
+void ia_css_ctc_vamem_encode(struct sh_css_isp_ctc_vamem_params *to,
+			     const struct ia_css_ctc_table *from,
+			     unsigned int size);
 
-void
-ia_css_ctc_debug_dtrace(
-    const struct ia_css_ctc_config *config, unsigned int level)
-;
+void ia_css_ctc_debug_dtrace(const struct ia_css_ctc_config *config,
+			     unsigned int level);
 
 #endif /* __IA_CSS_CTC_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_param.h
index ae3d183b41420592027327ff65af5bbc95dcaa31..930388ace04b2bb4cfdfad1da84e12c844f4c478 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_param.h
@@ -13,8 +13,8 @@
 #include "ia_css_ctc_types.h"
 
 #ifndef PIPE_GENERATION
-#define SH_CSS_ISP_CTC_TABLE_SIZE_LOG2       IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2
-#define SH_CSS_ISP_CTC_TABLE_SIZE            IA_CSS_VAMEM_2_CTC_TABLE_SIZE
+#define SH_CSS_ISP_CTC_TABLE_SIZE_LOG2 IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_CTC_TABLE_SIZE IA_CSS_VAMEM_2_CTC_TABLE_SIZE
 
 #else
 /* For pipe generation, the size is not relevant */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_table.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_table.host.c
index 632807fbbd1d665256538d2eb2356b2a4e4a554b..302dc018d8d906c4960b609041300c5dfd546dcb 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_table.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_table.host.c
@@ -12,51 +12,36 @@
 #include "ia_css_types.h"
 #include "ia_css_ctc_table.host.h"
 
-struct ia_css_ctc_table       default_ctc_table;
+struct ia_css_ctc_table default_ctc_table;
 
-
-static const uint16_t
-default_ctc_table_data[IA_CSS_VAMEM_2_CTC_TABLE_SIZE] = {
-	0,  384,  837,  957, 1011, 1062, 1083, 1080,
-	1078, 1077, 1053, 1039, 1012,  992,  969,  951,
-	929,  906,  886,  866,  845,  823,  809,  790,
-	772,  758,  741,  726,  711,  701,  688,  675,
-	666,  656,  648,  639,  633,  626,  618,  612,
-	603,  594,  582,  572,  557,  545,  529,  516,
-	504,  491,  480,  467,  459,  447,  438,  429,
-	419,  412,  404,  397,  389,  382,  376,  368,
-	363,  357,  351,  345,  340,  336,  330,  326,
-	321,  318,  312,  308,  304,  300,  297,  294,
-	291,  286,  284,  281,  278,  275,  271,  268,
-	261,  257,  251,  245,  240,  235,  232,  225,
-	223,  218,  213,  209,  206,  204,  199,  197,
-	193,  189,  186,  185,  183,  179,  177,  175,
-	172,  170,  169,  167,  164,  164,  162,  160,
-	158,  157,  156,  154,  154,  152,  151,  150,
-	149,  148,  146,  147,  146,  144,  143,  143,
-	142,  141,  140,  141,  139,  138,  138,  138,
-	137,  136,  136,  135,  134,  134,  134,  133,
-	132,  132,  131,  130,  131,  130,  129,  128,
-	129,  127,  127,  127,  127,  125,  125,  125,
-	123,  123,  122,  120,  118,  115,  114,  111,
-	110,  108,  106,  105,  103,  102,  100,   99,
-	97,   97,   96,   95,   94,   93,   93,   91,
-	91,   91,   90,   90,   89,   89,   88,   88,
-	89,   88,   88,   87,   87,   87,   87,   86,
-	87,   87,   86,   87,   86,   86,   84,   84,
-	82,   80,   78,   76,   74,   72,   70,   68,
-	67,   65,   62,   60,   58,   56,   55,   54,
-	53,   51,   49,   49,   47,   45,   45,   45,
-	41,   40,   39,   39,   34,   33,   34,   32,
-	25,   23,   24,   20,   13,    9,   12,    0,
-	0
+static const uint16_t default_ctc_table_data[IA_CSS_VAMEM_2_CTC_TABLE_SIZE] = {
+	0,    384, 837, 957, 1011, 1062, 1083, 1080, 1078, 1077, 1053, 1039,
+	1012, 992, 969, 951, 929,  906,	 886,  866,  845,  823,	 809,  790,
+	772,  758, 741, 726, 711,  701,	 688,  675,  666,  656,	 648,  639,
+	633,  626, 618, 612, 603,  594,	 582,  572,  557,  545,	 529,  516,
+	504,  491, 480, 467, 459,  447,	 438,  429,  419,  412,	 404,  397,
+	389,  382, 376, 368, 363,  357,	 351,  345,  340,  336,	 330,  326,
+	321,  318, 312, 308, 304,  300,	 297,  294,  291,  286,	 284,  281,
+	278,  275, 271, 268, 261,  257,	 251,  245,  240,  235,	 232,  225,
+	223,  218, 213, 209, 206,  204,	 199,  197,  193,  189,	 186,  185,
+	183,  179, 177, 175, 172,  170,	 169,  167,  164,  164,	 162,  160,
+	158,  157, 156, 154, 154,  152,	 151,  150,  149,  148,	 146,  147,
+	146,  144, 143, 143, 142,  141,	 140,  141,  139,  138,	 138,  138,
+	137,  136, 136, 135, 134,  134,	 134,  133,  132,  132,	 131,  130,
+	131,  130, 129, 128, 129,  127,	 127,  127,  127,  125,	 125,  125,
+	123,  123, 122, 120, 118,  115,	 114,  111,  110,  108,	 106,  105,
+	103,  102, 100, 99,  97,   97,	 96,   95,   94,   93,	 93,   91,
+	91,   91,  90,	90,  89,   89,	 88,   88,   89,   88,	 88,   87,
+	87,   87,  87,	86,  87,   87,	 86,   87,   86,   86,	 84,   84,
+	82,   80,  78,	76,  74,   72,	 70,   68,   67,   65,	 62,   60,
+	58,   56,  55,	54,  53,   51,	 49,   49,   47,   45,	 45,   45,
+	41,   40,  39,	39,  34,   33,	 34,   32,   25,   23,	 24,   20,
+	13,   9,   12,	0,   0
 };
 
-
-void
-ia_css_config_ctc_table(void)
+void ia_css_config_ctc_table(void)
 {
 	memcpy(default_ctc_table.data.vamem_2, default_ctc_table_data,
 	       sizeof(default_ctc_table_data));
-	default_ctc_table.vamem_type     = IA_CSS_VAMEM_TYPE_2;
+	default_ctc_table.vamem_type = IA_CSS_VAMEM_TYPE_2;
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h
index 67f4e01a3197117e4b100a2f47a2c27208e1f37e..4cb24090508cbcb18f374d325523c12309557baa 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h
@@ -24,22 +24,20 @@
  *    Output(Chorma): s0.7  (8bit precision)
  *    Output = (Input * Gain) >> IA_CSS_CTC_COEF_SHIFT
  */
-#define IA_CSS_CTC_COEF_SHIFT          13
+#define IA_CSS_CTC_COEF_SHIFT 13
 
 /* Number of elements in the CTC table. */
-#define IA_CSS_VAMEM_1_CTC_TABLE_SIZE_LOG2      10
+#define IA_CSS_VAMEM_1_CTC_TABLE_SIZE_LOG2 10
 /* Number of elements in the CTC table. */
-#define IA_CSS_VAMEM_1_CTC_TABLE_SIZE           BIT(IA_CSS_VAMEM_1_CTC_TABLE_SIZE_LOG2)
+#define IA_CSS_VAMEM_1_CTC_TABLE_SIZE BIT(IA_CSS_VAMEM_1_CTC_TABLE_SIZE_LOG2)
 
 /* Number of elements in the CTC table. */
-#define IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2      8
+#define IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2 8
 /* Number of elements in the CTC table. */
-#define IA_CSS_VAMEM_2_CTC_TABLE_SIZE           ((1U << IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2) + 1)
+#define IA_CSS_VAMEM_2_CTC_TABLE_SIZE \
+	((1U << IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2) + 1)
 
-enum ia_css_vamem_type {
-	IA_CSS_VAMEM_TYPE_1,
-	IA_CSS_VAMEM_TYPE_2
-};
+enum ia_css_vamem_type { IA_CSS_VAMEM_TYPE_1, IA_CSS_VAMEM_TYPE_2 };
 
 /* Chroma Tone Control configuration.
  *
@@ -48,37 +46,37 @@ enum ia_css_vamem_type {
  *  ISP2: CTC2 is used.
  */
 struct ia_css_ctc_config {
-	u16 y0;	/** 1st kneepoint gain.
+	u16 y0; /** 1st kneepoint gain.
 				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
 				default/ineffective 4096(0.5) */
-	u16 y1;	/** 2nd kneepoint gain.
+	u16 y1; /** 2nd kneepoint gain.
 				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
 				default/ineffective 4096(0.5) */
-	u16 y2;	/** 3rd kneepoint gain.
+	u16 y2; /** 3rd kneepoint gain.
 				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
 				default/ineffective 4096(0.5) */
-	u16 y3;	/** 4th kneepoint gain.
+	u16 y3; /** 4th kneepoint gain.
 				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
 				default/ineffective 4096(0.5) */
-	u16 y4;	/** 5th kneepoint gain.
+	u16 y4; /** 5th kneepoint gain.
 				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
 				default/ineffective 4096(0.5) */
-	u16 y5;	/** 6th kneepoint gain.
+	u16 y5; /** 6th kneepoint gain.
 				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
 				default/ineffective 4096(0.5) */
-	u16 ce_gain_exp;	/** Common exponent of y-axis gain.
+	u16 ce_gain_exp; /** Common exponent of y-axis gain.
 				u8.0, [0,13],
 				default/ineffective 1 */
-	u16 x1;	/** 2nd kneepoint luma.
+	u16 x1; /** 2nd kneepoint luma.
 				u0.13, [0,8191], constraints: 0<x1<x2,
 				default/ineffective 1024 */
-	u16 x2;	/** 3rd kneepoint luma.
+	u16 x2; /** 3rd kneepoint luma.
 				u0.13, [0,8191], constraints: x1<x2<x3,
 				default/ineffective 2048 */
-	u16 x3;	/** 4th kneepoint luma.
+	u16 x3; /** 4th kneepoint luma.
 				u0.13, [0,8191], constraints: x2<x3<x4,
 				default/ineffective 6144 */
-	u16 x4;	/** 5tn kneepoint luma.
+	u16 x4; /** 5tn kneepoint luma.
 				u0.13, [0,8191], constraints: x3<x4<8191,
 				default/ineffective 7168 */
 };
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/de/de_1.0/ia_css_de.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/de/de_1.0/ia_css_de.host.c
index 52a07feb48ec6caad4e7859ea7c095f9131e4bcf..de643f0e8161c496e9f2a0f6f4d6b080dbbd0311 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/de/de_1.0/ia_css_de.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/de/de_1.0/ia_css_de.host.c
@@ -10,62 +10,45 @@
 #include "sh_css_frac.h"
 #include "ia_css_de.host.h"
 
-const struct ia_css_de_config default_de_config = {
-	0,
-	0,
-	0
-};
+const struct ia_css_de_config default_de_config = { 0, 0, 0 };
 
-void
-ia_css_de_encode(
-    struct sh_css_isp_de_params *to,
-    const struct ia_css_de_config *from,
-    unsigned int size)
+void ia_css_de_encode(struct sh_css_isp_de_params *to,
+		      const struct ia_css_de_config *from, unsigned int size)
 {
 	(void)size;
 	to->pixelnoise =
-	    uDIGIT_FITTING(from->pixelnoise, 16, SH_CSS_BAYER_BITS);
-	to->c1_coring_threshold =
-	    uDIGIT_FITTING(from->c1_coring_threshold, 16,
-			   SH_CSS_BAYER_BITS);
-	to->c2_coring_threshold =
-	    uDIGIT_FITTING(from->c2_coring_threshold, 16,
-			   SH_CSS_BAYER_BITS);
+		uDIGIT_FITTING(from->pixelnoise, 16, SH_CSS_BAYER_BITS);
+	to->c1_coring_threshold = uDIGIT_FITTING(from->c1_coring_threshold, 16,
+						 SH_CSS_BAYER_BITS);
+	to->c2_coring_threshold = uDIGIT_FITTING(from->c2_coring_threshold, 16,
+						 SH_CSS_BAYER_BITS);
 }
 
-void
-ia_css_de_dump(
-    const struct sh_css_isp_de_params *de,
-    unsigned int level)
+void ia_css_de_dump(const struct sh_css_isp_de_params *de, unsigned int level)
 {
 	if (!de)
 		return;
 	ia_css_debug_dtrace(level, "Demosaic:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "de_pixelnoise", de->pixelnoise);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "de_c1_coring_threshold",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "de_pixelnoise",
+			    de->pixelnoise);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "de_c1_coring_threshold",
 			    de->c1_coring_threshold);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "de_c2_coring_threshold",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "de_c2_coring_threshold",
 			    de->c2_coring_threshold);
 }
 
-void
-ia_css_de_debug_dtrace(
-    const struct ia_css_de_config *config,
-    unsigned int level)
+void ia_css_de_debug_dtrace(const struct ia_css_de_config *config,
+			    unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.pixelnoise=%d, config.c1_coring_threshold=%d, config.c2_coring_threshold=%d\n",
-			    config->pixelnoise,
-			    config->c1_coring_threshold, config->c2_coring_threshold);
+	ia_css_debug_dtrace(
+		level,
+		"config.pixelnoise=%d, config.c1_coring_threshold=%d, config.c2_coring_threshold=%d\n",
+		config->pixelnoise, config->c1_coring_threshold,
+		config->c2_coring_threshold);
 }
 
-void
-ia_css_init_de_state(
-    void/*struct sh_css_isp_de_vmem_state*/ * state,
-    size_t size)
+void ia_css_init_de_state(void /*struct sh_css_isp_de_vmem_state*/ *state,
+			  size_t size)
 {
 	memset(state, 0, size);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/de/de_1.0/ia_css_de.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/de/de_1.0/ia_css_de.host.h
index b00d1c0fa249347bb63781692051a220335b6b43..b360f326ab5a8f822c4b8ec3e78767ad4697a96e 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/de/de_1.0/ia_css_de.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/de/de_1.0/ia_css_de.host.h
@@ -12,25 +12,15 @@
 
 extern const struct ia_css_de_config default_de_config;
 
-void
-ia_css_de_encode(
-    struct sh_css_isp_de_params *to,
-    const struct ia_css_de_config *from,
-    unsigned int size);
-
-void
-ia_css_de_dump(
-    const struct sh_css_isp_de_params *de,
-    unsigned int level);
-
-void
-ia_css_de_debug_dtrace(
-    const struct ia_css_de_config *config,
-    unsigned int level);
-
-void
-ia_css_init_de_state(
-    void/*struct sh_css_isp_de_vmem_state*/ * state,
-    size_t size);
+void ia_css_de_encode(struct sh_css_isp_de_params *to,
+		      const struct ia_css_de_config *from, unsigned int size);
+
+void ia_css_de_dump(const struct sh_css_isp_de_params *de, unsigned int level);
+
+void ia_css_de_debug_dtrace(const struct ia_css_de_config *config,
+			    unsigned int level);
+
+void ia_css_init_de_state(void /*struct sh_css_isp_de_vmem_state*/ *state,
+			  size_t size);
 
 #endif /* __IA_CSS_DE_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2.host.c
index 16426b2cbfb4b49eaf105a9a9d532c90914bc367..a1c1c137b46bad1824b07930a155f998f1c8160a 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2.host.c
@@ -11,35 +11,28 @@
 #include "ia_css_de2.host.h"
 
 const struct ia_css_ecd_config default_ecd_config = {
-	(1 << (ISP_VEC_ELEMBITS - 1)) * 2 / 3,	/* 2/3 */
-	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1.0 */
-	0,					/* 0.0 */
+	(1 << (ISP_VEC_ELEMBITS - 1)) * 2 / 3, /* 2/3 */
+	(1 << (ISP_VEC_ELEMBITS - 1)) - 1, /* 1.0 */
+	0, /* 0.0 */
 };
 
-void
-ia_css_ecd_encode(
-    struct sh_css_isp_ecd_params *to,
-    const struct ia_css_ecd_config *from,
-    unsigned int size)
+void ia_css_ecd_encode(struct sh_css_isp_ecd_params *to,
+		       const struct ia_css_ecd_config *from, unsigned int size)
 {
 	(void)size;
 	to->zip_strength = from->zip_strength;
-	to->fc_strength  = from->fc_strength;
-	to->fc_debias    = from->fc_debias;
+	to->fc_strength = from->fc_strength;
+	to->fc_debias = from->fc_debias;
 }
 
-void
-ia_css_ecd_dump(
-    const struct sh_css_isp_ecd_params *ecd,
-    unsigned int level);
+void ia_css_ecd_dump(const struct sh_css_isp_ecd_params *ecd,
+		     unsigned int level);
 
-void
-ia_css_ecd_debug_dtrace(
-    const struct ia_css_ecd_config *config,
-    unsigned int level)
+void ia_css_ecd_debug_dtrace(const struct ia_css_ecd_config *config,
+			     unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.zip_strength=%d, config.fc_strength=%d, config.fc_debias=%d\n",
-			    config->zip_strength,
-			    config->fc_strength, config->fc_debias);
+	ia_css_debug_dtrace(
+		level,
+		"config.zip_strength=%d, config.fc_strength=%d, config.fc_debias=%d\n",
+		config->zip_strength, config->fc_strength, config->fc_debias);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2.host.h
index 0ce9e363aa2c3c93e686e0823a9a0c504641bd05..30c5b7adf827eb40bc16486a0c02b13d6873f40a 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2.host.h
@@ -12,19 +12,13 @@
 
 extern const struct ia_css_ecd_config default_ecd_config;
 
-void
-ia_css_ecd_encode(
-    struct sh_css_isp_ecd_params *to,
-    const struct ia_css_ecd_config *from,
-    unsigned int size);
+void ia_css_ecd_encode(struct sh_css_isp_ecd_params *to,
+		       const struct ia_css_ecd_config *from, unsigned int size);
 
-void
-ia_css_ecd_dump(
-    const struct sh_css_isp_ecd_params *ecd,
-    unsigned int level);
+void ia_css_ecd_dump(const struct sh_css_isp_ecd_params *ecd,
+		     unsigned int level);
 
-void
-ia_css_ecd_debug_dtrace(
-    const struct ia_css_ecd_config *config, unsigned int level);
+void ia_css_ecd_debug_dtrace(const struct ia_css_ecd_config *config,
+			     unsigned int level);
 
 #endif /* __IA_CSS_DE2_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2_types.h
index ca36c001607c39b0a768e010fcde2051af3536bb..1204a1634b5da9f72015648ea990163dce592b7d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/de/de_2/ia_css_de2_types.h
@@ -18,13 +18,13 @@
  *  ISP2: DE2 is used.
  */
 struct ia_css_ecd_config {
-	u16 zip_strength;	/** Strength of zipper reduction.
+	u16 zip_strength; /** Strength of zipper reduction.
 				u0.13, [0,8191],
 				default 5489(0.67), ineffective 0 */
-	u16 fc_strength;	/** Strength of false color reduction.
+	u16 fc_strength; /** Strength of false color reduction.
 				u0.13, [0,8191],
 				default 8191(almost 1.0), ineffective 0 */
-	u16 fc_debias;	/** Prevent color change
+	u16 fc_debias; /** Prevent color change
 				     on noise or Gr/Gb imbalance.
 				u0.13, [0,8191],
 				default 0, ineffective 0 */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp.host.c
index 98144a1a9db445055842f37b4552cfcd43889db8..f418bbe253808f48fe94de428b0e1d9daebe3756 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp.host.c
@@ -15,68 +15,41 @@
  * DPC is used before OBC and NORM. Currently these parameters
  * are used in usecases which selects both BDS and DPC.
  **/
-const struct ia_css_dp_config default_dp_10bpp_config = {
-	1024,
-	2048,
-	32768,
-	32768,
-	32768,
-	32768
-};
+const struct ia_css_dp_config default_dp_10bpp_config = { 1024,	 2048,	32768,
+							  32768, 32768, 32768 };
 
-const struct ia_css_dp_config default_dp_config = {
-	8192,
-	2048,
-	32768,
-	32768,
-	32768,
-	32768
-};
+const struct ia_css_dp_config default_dp_config = { 8192,  2048,  32768,
+						    32768, 32768, 32768 };
 
-void
-ia_css_dp_encode(
-    struct sh_css_isp_dp_params *to,
-    const struct ia_css_dp_config *from,
-    unsigned int size)
+void ia_css_dp_encode(struct sh_css_isp_dp_params *to,
+		      const struct ia_css_dp_config *from, unsigned int size)
 {
 	int gain = from->gain;
-	int gr   = from->gr;
-	int r    = from->r;
-	int b    = from->b;
-	int gb   = from->gb;
+	int gr = from->gr;
+	int r = from->r;
+	int b = from->b;
+	int gb = from->gb;
 
 	(void)size;
-	to->threshold_single =
-	    SH_CSS_BAYER_MAXVAL;
+	to->threshold_single = SH_CSS_BAYER_MAXVAL;
 	to->threshold_2adjacent =
-	    uDIGIT_FITTING(from->threshold, 16, SH_CSS_BAYER_BITS);
-	to->gain =
-	    uDIGIT_FITTING(from->gain, 8, SH_CSS_DP_GAIN_SHIFT);
+		uDIGIT_FITTING(from->threshold, 16, SH_CSS_BAYER_BITS);
+	to->gain = uDIGIT_FITTING(from->gain, 8, SH_CSS_DP_GAIN_SHIFT);
 
-	to->coef_rr_gr =
-	    uDIGIT_FITTING(gain * gr / r, 8, SH_CSS_DP_GAIN_SHIFT);
-	to->coef_rr_gb =
-	    uDIGIT_FITTING(gain * gb / r, 8, SH_CSS_DP_GAIN_SHIFT);
-	to->coef_bb_gb =
-	    uDIGIT_FITTING(gain * gb / b, 8, SH_CSS_DP_GAIN_SHIFT);
-	to->coef_bb_gr =
-	    uDIGIT_FITTING(gain * gr / b, 8, SH_CSS_DP_GAIN_SHIFT);
-	to->coef_gr_rr =
-	    uDIGIT_FITTING(gain * r / gr, 8, SH_CSS_DP_GAIN_SHIFT);
-	to->coef_gr_bb =
-	    uDIGIT_FITTING(gain * b / gr, 8, SH_CSS_DP_GAIN_SHIFT);
-	to->coef_gb_bb =
-	    uDIGIT_FITTING(gain * b / gb, 8, SH_CSS_DP_GAIN_SHIFT);
-	to->coef_gb_rr =
-	    uDIGIT_FITTING(gain * r / gb, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_rr_gr = uDIGIT_FITTING(gain * gr / r, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_rr_gb = uDIGIT_FITTING(gain * gb / r, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_bb_gb = uDIGIT_FITTING(gain * gb / b, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_bb_gr = uDIGIT_FITTING(gain * gr / b, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_gr_rr = uDIGIT_FITTING(gain * r / gr, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_gr_bb = uDIGIT_FITTING(gain * b / gr, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_gb_bb = uDIGIT_FITTING(gain * b / gb, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_gb_rr = uDIGIT_FITTING(gain * r / gb, 8, SH_CSS_DP_GAIN_SHIFT);
 }
 
-void
-ia_css_dp_dump(
-    const struct sh_css_isp_dp_params *dp,
-    unsigned int level)
+void ia_css_dp_dump(const struct sh_css_isp_dp_params *dp, unsigned int level)
 {
-	if (!dp) return;
+	if (!dp)
+		return;
 	ia_css_debug_dtrace(level, "Defect Pixel Correction:\n");
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
 			    "dp_threshold_single_w_2adj_on",
@@ -84,40 +57,34 @@ ia_css_dp_dump(
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
 			    "dp_threshold_2adj_w_2adj_on",
 			    dp->threshold_2adjacent);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "dp_gain", dp->gain);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "dpc_coef_rr_gr", dp->coef_rr_gr);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "dpc_coef_rr_gb", dp->coef_rr_gb);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "dpc_coef_bb_gb", dp->coef_bb_gb);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "dpc_coef_bb_gr", dp->coef_bb_gr);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "dpc_coef_gr_rr", dp->coef_gr_rr);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "dpc_coef_gr_bb", dp->coef_gr_bb);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "dpc_coef_gb_bb", dp->coef_gb_bb);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "dpc_coef_gb_rr", dp->coef_gb_rr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dp_gain", dp->gain);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dpc_coef_rr_gr",
+			    dp->coef_rr_gr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dpc_coef_rr_gb",
+			    dp->coef_rr_gb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dpc_coef_bb_gb",
+			    dp->coef_bb_gb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dpc_coef_bb_gr",
+			    dp->coef_bb_gr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dpc_coef_gr_rr",
+			    dp->coef_gr_rr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dpc_coef_gr_bb",
+			    dp->coef_gr_bb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dpc_coef_gb_bb",
+			    dp->coef_gb_bb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dpc_coef_gb_rr",
+			    dp->coef_gb_rr);
 }
 
-void
-ia_css_dp_debug_dtrace(
-    const struct ia_css_dp_config *config,
-    unsigned int level)
+void ia_css_dp_debug_dtrace(const struct ia_css_dp_config *config,
+			    unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.threshold=%d, config.gain=%d\n",
+	ia_css_debug_dtrace(level, "config.threshold=%d, config.gain=%d\n",
 			    config->threshold, config->gain);
 }
 
-void
-ia_css_init_dp_state(
-    void/*struct sh_css_isp_dp_vmem_state*/ * state,
-    size_t size)
+void ia_css_init_dp_state(void /*struct sh_css_isp_dp_vmem_state*/ *state,
+			  size_t size)
 {
 	memset(state, 0, size);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp.host.h
index 93c48de872ccaa9a82d1ae11ec4c83bbbe83379c..508fb7039d76557f079f65c98d143cc10aa42444 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp.host.h
@@ -15,25 +15,15 @@ extern const struct ia_css_dp_config default_dp_config;
 /* ISP2401 */
 extern const struct ia_css_dp_config default_dp_10bpp_config;
 
-void
-ia_css_dp_encode(
-    struct sh_css_isp_dp_params *to,
-    const struct ia_css_dp_config *from,
-    unsigned int size);
-
-void
-ia_css_dp_dump(
-    const struct sh_css_isp_dp_params *dp,
-    unsigned int level);
-
-void
-ia_css_dp_debug_dtrace(
-    const struct ia_css_dp_config *config,
-    unsigned int level);
-
-void
-ia_css_init_dp_state(
-    void/*struct sh_css_isp_dp_vmem_state*/ * state,
-    size_t size);
+void ia_css_dp_encode(struct sh_css_isp_dp_params *to,
+		      const struct ia_css_dp_config *from, unsigned int size);
+
+void ia_css_dp_dump(const struct sh_css_isp_dp_params *dp, unsigned int level);
+
+void ia_css_dp_debug_dtrace(const struct ia_css_dp_config *config,
+			    unsigned int level);
+
+void ia_css_init_dp_state(void /*struct sh_css_isp_dp_vmem_state*/ *state,
+			  size_t size);
 
 #endif /* __IA_CSS_DP_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp_types.h
index 036727f3772d8efcd5c3beb73d8eade8482984fa..b308ee8a7a61919952124438f76712307756ddf0 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/dp/dp_1.0/ia_css_dp_types.h
@@ -26,15 +26,15 @@ struct ia_css_dp_config {
 				in more frequent pixel corrections.
 				u0.16, [0,65535],
 				default 8192, ineffective 65535 */
-	ia_css_u8_8 gain;	 /** The sensitivity of mis-correction. ISP will
+	ia_css_u8_8 gain; /** The sensitivity of mis-correction. ISP will
 			      miss a lot of defects if the value is set
 				too large.
 				u8.8, [0,65535],
 				default 4096, ineffective 65535 */
-	u32 gr;	/* unsigned <integer_bits>.<16-integer_bits> */
-	u32 r;	/* unsigned <integer_bits>.<16-integer_bits> */
-	u32 b;	/* unsigned <integer_bits>.<16-integer_bits> */
-	u32 gb;	/* unsigned <integer_bits>.<16-integer_bits> */
+	u32 gr; /* unsigned <integer_bits>.<16-integer_bits> */
+	u32 r; /* unsigned <integer_bits>.<16-integer_bits> */
+	u32 b; /* unsigned <integer_bits>.<16-integer_bits> */
+	u32 gb; /* unsigned <integer_bits>.<16-integer_bits> */
 };
 
 #endif /* __IA_CSS_DP_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2.host.c
index 82521aed7aff98391507fa3e28d450069468fb57..96234c254ced847cc07b581381282c0c891bac03 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2.host.c
@@ -7,11 +7,8 @@
 #include "ia_css_dpc2.host.h"
 #include "assert_support.h"
 
-void
-ia_css_dpc2_encode(
-    struct ia_css_isp_dpc2_params *to,
-    const struct ia_css_dpc2_config *from,
-    size_t size)
+void ia_css_dpc2_encode(struct ia_css_isp_dpc2_params *to,
+			const struct ia_css_dpc2_config *from, size_t size)
 {
 	(void)size;
 
@@ -19,26 +16,25 @@ ia_css_dpc2_encode(
 	assert((from->metric3 >= 0) && (from->metric3 <= METRIC3_ONE_FP));
 	assert((from->metric2 >= METRIC2_ONE_FP) &&
 	       (from->metric2 < 256 * METRIC2_ONE_FP));
-	assert((from->wb_gain_gr > 0) && (from->wb_gain_gr < 16 * WBGAIN_ONE_FP));
-	assert((from->wb_gain_r  > 0) && (from->wb_gain_r  < 16 * WBGAIN_ONE_FP));
-	assert((from->wb_gain_b  > 0) && (from->wb_gain_b  < 16 * WBGAIN_ONE_FP));
-	assert((from->wb_gain_gb > 0) && (from->wb_gain_gb < 16 * WBGAIN_ONE_FP));
+	assert((from->wb_gain_gr > 0) &&
+	       (from->wb_gain_gr < 16 * WBGAIN_ONE_FP));
+	assert((from->wb_gain_r > 0) && (from->wb_gain_r < 16 * WBGAIN_ONE_FP));
+	assert((from->wb_gain_b > 0) && (from->wb_gain_b < 16 * WBGAIN_ONE_FP));
+	assert((from->wb_gain_gb > 0) &&
+	       (from->wb_gain_gb < 16 * WBGAIN_ONE_FP));
 
 	to->metric1 = from->metric1;
 	to->metric2 = from->metric2;
 	to->metric3 = from->metric3;
 
 	to->wb_gain_gr = from->wb_gain_gr;
-	to->wb_gain_r  = from->wb_gain_r;
-	to->wb_gain_b  = from->wb_gain_b;
+	to->wb_gain_r = from->wb_gain_r;
+	to->wb_gain_b = from->wb_gain_b;
 	to->wb_gain_gb = from->wb_gain_gb;
 }
 
 /* TODO: AM: This needs a proper implementation. */
-void
-ia_css_init_dpc2_state(
-    void *state,
-    size_t size)
+void ia_css_init_dpc2_state(void *state, size_t size)
 {
 	(void)state;
 	(void)size;
@@ -46,10 +42,8 @@ ia_css_init_dpc2_state(
 
 #ifndef IA_CSS_NO_DEBUG
 /* TODO: AM: This needs a proper implementation. */
-void
-ia_css_dpc2_debug_dtrace(
-    const struct ia_css_dpc2_config *config,
-    unsigned int level)
+void ia_css_dpc2_debug_dtrace(const struct ia_css_dpc2_config *config,
+			      unsigned int level)
 {
 	(void)config;
 	(void)level;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2.host.h
index 85419182c1f5a78567cf6ab5ce6f41492840d787..7b2aa972a073b487a48e80b631cd879df954cd5b 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2.host.h
@@ -10,22 +10,14 @@
 #include "ia_css_dpc2_types.h"
 #include "ia_css_dpc2_param.h"
 
-void
-ia_css_dpc2_encode(
-    struct ia_css_isp_dpc2_params *to,
-    const struct ia_css_dpc2_config *from,
-    size_t size);
+void ia_css_dpc2_encode(struct ia_css_isp_dpc2_params *to,
+			const struct ia_css_dpc2_config *from, size_t size);
 
-void
-ia_css_init_dpc2_state(
-    void *state,
-    size_t size);
+void ia_css_init_dpc2_state(void *state, size_t size);
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_dpc2_debug_dtrace(
-    const struct ia_css_dpc2_config *config,
-    unsigned int level);
+void ia_css_dpc2_debug_dtrace(const struct ia_css_dpc2_config *config,
+			      unsigned int level);
 #endif
 
 #endif /* __IA_CSS_DPC2_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2_param.h
index 099f32b8de1a6b35bd9189af862cd02878ccc4b9..46849cd5d312b028ca80fb2104d43626f79c509f 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2_param.h
@@ -11,24 +11,24 @@
 #include "vmem.h" /* for VMEM_ARRAY*/
 
 /* 4 planes : GR, R, B, GB */
-#define NUM_PLANES		4
+#define NUM_PLANES 4
 
 /* ToDo: Move this to testsetup */
-#define MAX_FRAME_SIMDWIDTH	30
+#define MAX_FRAME_SIMDWIDTH 30
 
 /* 3 lines state per color plane input_line_state */
-#define DPC2_STATE_INPUT_BUFFER_HEIGHT	(3 * NUM_PLANES)
+#define DPC2_STATE_INPUT_BUFFER_HEIGHT (3 * NUM_PLANES)
 /* Each plane has width equal to half frame line */
-#define DPC2_STATE_INPUT_BUFFER_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define DPC2_STATE_INPUT_BUFFER_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 1 line state per color plane for local deviation state*/
-#define DPC2_STATE_LOCAL_DEVIATION_BUFFER_HEIGHT	(1 * NUM_PLANES)
+#define DPC2_STATE_LOCAL_DEVIATION_BUFFER_HEIGHT (1 * NUM_PLANES)
 /* Each plane has width equal to half frame line */
-#define DPC2_STATE_LOCAL_DEVIATION_BUFFER_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define DPC2_STATE_LOCAL_DEVIATION_BUFFER_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* MINMAX state buffer stores 1 full input line (GR-R color line) */
-#define DPC2_STATE_SECOND_MINMAX_BUFFER_HEIGHT	1
-#define DPC2_STATE_SECOND_MINMAX_BUFFER_WIDTH	MAX_FRAME_SIMDWIDTH
+#define DPC2_STATE_SECOND_MINMAX_BUFFER_HEIGHT 1
+#define DPC2_STATE_SECOND_MINMAX_BUFFER_WIDTH MAX_FRAME_SIMDWIDTH
 
 struct ia_css_isp_dpc2_params {
 	s32 metric1;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2_types.h
index c261899bcaa02f1f097669e0fb371406e1ff3950..81ad562465dde9360918c2dd5e39d7274d428d57 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/dpc2/ia_css_dpc2_types.h
@@ -15,10 +15,10 @@
 
 /**@{*/
 /* Floating point constants for different metrics. */
-#define METRIC1_ONE_FP	BIT(12)
-#define METRIC2_ONE_FP	BIT(5)
-#define METRIC3_ONE_FP	BIT(12)
-#define WBGAIN_ONE_FP	BIT(9)
+#define METRIC1_ONE_FP BIT(12)
+#define METRIC2_ONE_FP BIT(5)
+#define METRIC3_ONE_FP BIT(12)
+#define WBGAIN_ONE_FP BIT(9)
 /**@}*/
 
 /**@{*/
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
index 30c84639d7e88adc42cd9ba6c294f4d2efef8eca..07d6706fa77480b4f2e77d8e7edabba1042780b3 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
@@ -24,20 +24,16 @@ static const struct ia_css_dvs_configuration default_config = {
 	.info = (struct ia_css_frame_info *)NULL,
 };
 
-void
-ia_css_dvs_config(
-    struct sh_css_isp_dvs_isp_config *to,
-    const struct ia_css_dvs_configuration  *from,
-    unsigned int size)
+void ia_css_dvs_config(struct sh_css_isp_dvs_isp_config *to,
+		       const struct ia_css_dvs_configuration *from,
+		       unsigned int size)
 {
 	(void)size;
-	to->num_horizontal_blocks =
-	    DVS_NUM_BLOCKS_X(from->info->res.width);
-	to->num_vertical_blocks =
-	    DVS_NUM_BLOCKS_Y(from->info->res.height);
+	to->num_horizontal_blocks = DVS_NUM_BLOCKS_X(from->info->res.width);
+	to->num_vertical_blocks = DVS_NUM_BLOCKS_Y(from->info->res.height);
 }
 
-int ia_css_dvs_configure(const struct ia_css_binary     *binary,
+int ia_css_dvs_configure(const struct ia_css_binary *binary,
 			 const struct ia_css_frame_info *info)
 {
 	struct ia_css_dvs_configuration config = default_config;
@@ -48,31 +44,32 @@ int ia_css_dvs_configure(const struct ia_css_binary     *binary,
 }
 
 static void
-convert_coords_to_ispparams(
-    struct ia_css_host_data *gdc_warp_table,
-    const struct ia_css_dvs_6axis_config *config,
-    unsigned int i_stride,
-    unsigned int o_width,
-    unsigned int o_height,
-    unsigned int uv_flag)
+convert_coords_to_ispparams(struct ia_css_host_data *gdc_warp_table,
+			    const struct ia_css_dvs_6axis_config *config,
+			    unsigned int i_stride, unsigned int o_width,
+			    unsigned int o_height, unsigned int uv_flag)
 {
 	unsigned int i, j;
 	gdc_warp_param_mem_t s = { 0 };
-	unsigned int x00, x01, x10, x11,
-		 y00, y01, y10, y11;
+	unsigned int x00, x01, x10, x11, y00, y01, y10, y11;
 
 	unsigned int xmin, ymin, xmax, ymax;
-	unsigned int topleft_x, topleft_y, bottom_x, bottom_y,
-		 topleft_x_frac, topleft_y_frac;
-	unsigned int dvs_interp_envelope = (DVS_GDC_INTERP_METHOD == HRT_GDC_BLI_MODE ?
-					    DVS_GDC_BLI_INTERP_ENVELOPE : DVS_GDC_BCI_INTERP_ENVELOPE);
+	unsigned int topleft_x, topleft_y, bottom_x, bottom_y, topleft_x_frac,
+		topleft_y_frac;
+	unsigned int dvs_interp_envelope =
+		(DVS_GDC_INTERP_METHOD == HRT_GDC_BLI_MODE ?
+			 DVS_GDC_BLI_INTERP_ENVELOPE :
+			 DVS_GDC_BCI_INTERP_ENVELOPE);
 
 	/* number of blocks per height and width */
-	unsigned int num_blocks_y =  (uv_flag ? DVS_NUM_BLOCKS_Y_CHROMA(
-					  o_height) : DVS_NUM_BLOCKS_Y(o_height));
-	unsigned int num_blocks_x =  (uv_flag ? DVS_NUM_BLOCKS_X_CHROMA(
-					  o_width)  : DVS_NUM_BLOCKS_X(
-					  o_width)); // round num_x up to blockdim_x, if it concerns the Y0Y1 block (uv_flag==0) round up to even
+	unsigned int num_blocks_y = (uv_flag ?
+					     DVS_NUM_BLOCKS_Y_CHROMA(o_height) :
+					     DVS_NUM_BLOCKS_Y(o_height));
+	unsigned int num_blocks_x =
+		(uv_flag ?
+			 DVS_NUM_BLOCKS_X_CHROMA(o_width) :
+			 DVS_NUM_BLOCKS_X(
+				 o_width)); // round num_x up to blockdim_x, if it concerns the Y0Y1 block (uv_flag==0) round up to even
 
 	unsigned int in_stride = i_stride * DVS_INPUT_BYTES_PER_PIXEL;
 	unsigned int width, height;
@@ -86,7 +83,8 @@ convert_coords_to_ispparams(
 
 	ptr = (struct gdc_warp_param_mem_s *)gdc_warp_table->address;
 
-	ptr += (2 * uv_flag); /* format is Y0 Y1 UV, so UV starts at 3rd position */
+	ptr += (2 *
+		uv_flag); /* format is Y0 Y1 UV, so UV starts at 3rd position */
 
 	if (uv_flag == 0) {
 		xbuff = config->xcoords_y;
@@ -100,13 +98,15 @@ convert_coords_to_ispparams(
 		height = config->height_uv;
 	}
 
-	IA_CSS_LOG("blockdim_x %d blockdim_y %d",
-		   DVS_BLOCKDIM_X, DVS_BLOCKDIM_Y_LUMA >> uv_flag);
-	IA_CSS_LOG("num_blocks_x %d num_blocks_y %d", num_blocks_x, num_blocks_y);
+	IA_CSS_LOG("blockdim_x %d blockdim_y %d", DVS_BLOCKDIM_X,
+		   DVS_BLOCKDIM_Y_LUMA >> uv_flag);
+	IA_CSS_LOG("num_blocks_x %d num_blocks_y %d", num_blocks_x,
+		   num_blocks_y);
 	IA_CSS_LOG("width %d height %d", width, height);
 
-	assert(width == num_blocks_x +
-	       1); // the width and height of the provided morphing table should be 1 more than the number of blocks
+	assert(width ==
+	       num_blocks_x +
+		       1); // the width and height of the provided morphing table should be 1 more than the number of blocks
 	assert(height == num_blocks_y + 1);
 
 	for (j = 0; j < num_blocks_y; j++) {
@@ -134,18 +134,20 @@ convert_coords_to_ispparams(
 			assert(y11 >= ymin);
 
 			topleft_y = ymin >> DVS_COORD_FRAC_BITS;
-			topleft_x = ((xmin >> DVS_COORD_FRAC_BITS)
-				     >> XMEM_ALIGN_LOG2)
+			topleft_x = ((xmin >> DVS_COORD_FRAC_BITS) >>
+				     XMEM_ALIGN_LOG2)
 				    << (XMEM_ALIGN_LOG2);
 			s.in_addr_offset = topleft_y * in_stride + topleft_x;
 
 			/* similar to topleft_y calculation, but round up if ymax
 			 * has any fraction bits */
 			bottom_y = CEIL_DIV(ymax, 1 << DVS_COORD_FRAC_BITS);
-			s.in_block_height = bottom_y - topleft_y + dvs_interp_envelope;
+			s.in_block_height =
+				bottom_y - topleft_y + dvs_interp_envelope;
 
 			bottom_x = CEIL_DIV(xmax, 1 << DVS_COORD_FRAC_BITS);
-			s.in_block_width = bottom_x - topleft_x + dvs_interp_envelope;
+			s.in_block_width =
+				bottom_x - topleft_x + dvs_interp_envelope;
 
 			topleft_x_frac = topleft_x << (DVS_COORD_FRAC_BITS);
 			topleft_y_frac = topleft_y << (DVS_COORD_FRAC_BITS);
@@ -161,14 +163,22 @@ convert_coords_to_ispparams(
 			s.p3_y = y11 - topleft_y_frac;
 
 			// block should fit within the boundingbox.
-			assert(s.p0_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
-			assert(s.p1_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
-			assert(s.p2_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
-			assert(s.p3_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
-			assert(s.p0_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
-			assert(s.p1_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
-			assert(s.p2_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
-			assert(s.p3_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
+			assert(s.p0_x <
+			       (s.in_block_width << DVS_COORD_FRAC_BITS));
+			assert(s.p1_x <
+			       (s.in_block_width << DVS_COORD_FRAC_BITS));
+			assert(s.p2_x <
+			       (s.in_block_width << DVS_COORD_FRAC_BITS));
+			assert(s.p3_x <
+			       (s.in_block_width << DVS_COORD_FRAC_BITS));
+			assert(s.p0_y <
+			       (s.in_block_height << DVS_COORD_FRAC_BITS));
+			assert(s.p1_y <
+			       (s.in_block_height << DVS_COORD_FRAC_BITS));
+			assert(s.p2_y <
+			       (s.in_block_height << DVS_COORD_FRAC_BITS));
+			assert(s.p3_y <
+			       (s.in_block_height << DVS_COORD_FRAC_BITS));
 
 			// block size should be greater than zero.
 			assert(s.p0_x < s.p1_x);
@@ -213,11 +223,10 @@ convert_coords_to_ispparams(
 	}
 }
 
-struct ia_css_host_data *
-convert_allocate_dvs_6axis_config(
-    const struct ia_css_dvs_6axis_config *dvs_6axis_config,
-    const struct ia_css_binary *binary,
-    const struct ia_css_frame_info *dvs_in_frame_info)
+struct ia_css_host_data *convert_allocate_dvs_6axis_config(
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info)
 {
 	unsigned int i_stride;
 	unsigned int o_width;
@@ -228,23 +237,24 @@ convert_allocate_dvs_6axis_config(
 	assert(dvs_6axis_config);
 	assert(dvs_in_frame_info);
 
-	me = ia_css_host_data_allocate((size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3));
+	me = ia_css_host_data_allocate(
+		(size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3));
 
 	if (!me)
 		return NULL;
 
 	/*DVS only supports input frame of YUV420 or NV12. Fail for all other cases*/
-	assert((dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_NV12)
-	       || (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420));
+	assert((dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_NV12) ||
+	       (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420));
 
-	i_stride  = dvs_in_frame_info->padded_width;
+	i_stride = dvs_in_frame_info->padded_width;
 
-	o_width  = binary->out_frame_info[0].res.width;
+	o_width = binary->out_frame_info[0].res.width;
 	o_height = binary->out_frame_info[0].res.height;
 
 	/* Y plane */
-	convert_coords_to_ispparams(me, dvs_6axis_config,
-				    i_stride, o_width, o_height, 0);
+	convert_coords_to_ispparams(me, dvs_6axis_config, i_stride, o_width,
+				    o_height, 0);
 
 	if (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420) {
 		/*YUV420 has half the stride for U/V plane*/
@@ -252,37 +262,33 @@ convert_allocate_dvs_6axis_config(
 	}
 
 	/* UV plane (packed inside the y plane) */
-	convert_coords_to_ispparams(me, dvs_6axis_config,
-				    i_stride, o_width / 2, o_height / 2, 1);
+	convert_coords_to_ispparams(me, dvs_6axis_config, i_stride, o_width / 2,
+				    o_height / 2, 1);
 
 	return me;
 }
 
-int
-store_dvs_6axis_config(
-    const struct ia_css_dvs_6axis_config *dvs_6axis_config,
-    const struct ia_css_binary *binary,
-    const struct ia_css_frame_info *dvs_in_frame_info,
-    ia_css_ptr ddr_addr_y) {
+int store_dvs_6axis_config(
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info,
+	ia_css_ptr ddr_addr_y)
+{
 	struct ia_css_host_data *me;
 
 	assert(dvs_6axis_config);
 	assert(ddr_addr_y != mmgr_NULL);
 	assert(dvs_in_frame_info);
 
-	me = convert_allocate_dvs_6axis_config(dvs_6axis_config,
-					       binary,
+	me = convert_allocate_dvs_6axis_config(dvs_6axis_config, binary,
 					       dvs_in_frame_info);
 
-	if (!me)
-	{
+	if (!me) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-ENOMEM);
 		return -ENOMEM;
 	}
 
-	ia_css_params_store_ia_css_host_data(
-	    ddr_addr_y,
-	    me);
+	ia_css_params_store_ia_css_host_data(ddr_addr_y, me);
 	ia_css_host_data_free(me);
 
 	return 0;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
index 98995c9ed0a1b911c6973c86ec0bc220d6e83d30..ca71678c9ebb1a9a4e36f938cb50edf9d620eb15 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
@@ -20,31 +20,25 @@
 #define DVS_GDC_BLI_INTERP_ENVELOPE 1
 #define DVS_GDC_BCI_INTERP_ENVELOPE 3
 
-void
-ia_css_dvs_config(
-    struct sh_css_isp_dvs_isp_config      *to,
-    const struct ia_css_dvs_configuration *from,
-    unsigned int size);
+void ia_css_dvs_config(struct sh_css_isp_dvs_isp_config *to,
+		       const struct ia_css_dvs_configuration *from,
+		       unsigned int size);
 
-int ia_css_dvs_configure(const struct ia_css_binary     *binary,
+int ia_css_dvs_configure(const struct ia_css_binary *binary,
 			 const struct ia_css_frame_info *from);
 
-void
-convert_dvs_6axis_config(
-    struct ia_css_isp_parameters *params,
-    const struct ia_css_binary *binary);
-
-struct ia_css_host_data *
-convert_allocate_dvs_6axis_config(
-    const struct ia_css_dvs_6axis_config *dvs_6axis_config,
-    const struct ia_css_binary *binary,
-    const struct ia_css_frame_info *dvs_in_frame_info);
-
-int
-store_dvs_6axis_config(
-    const struct ia_css_dvs_6axis_config *dvs_6axis_config,
-    const struct ia_css_binary *binary,
-    const struct ia_css_frame_info *dvs_in_frame_info,
-    ia_css_ptr ddr_addr_y);
+void convert_dvs_6axis_config(struct ia_css_isp_parameters *params,
+			      const struct ia_css_binary *binary);
+
+struct ia_css_host_data *convert_allocate_dvs_6axis_config(
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info);
+
+int store_dvs_6axis_config(
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info,
+	ia_css_ptr ddr_addr_y);
 
 #endif /* __IA_CSS_DVS_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs_param.h
index 368f5b2b1ee83a85c35472b6d434d4300996312b..12557646f586de71b5bc6ba652f1daf6b57f2ec3 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/dvs/dvs_1.0/ia_css_dvs_param.h
@@ -9,7 +9,8 @@
 
 #include <type_support.h>
 
-#if !defined(ENABLE_TPROXY) && !defined(ENABLE_CRUN_FOR_TD) && !defined(PARAMBIN_GENERATION)
+#if !defined(ENABLE_TPROXY) && !defined(ENABLE_CRUN_FOR_TD) && \
+	!defined(PARAMBIN_GENERATION)
 #include "dma.h"
 #endif /* !defined(ENABLE_TPROXY) && !defined(ENABLE_CRUN_FOR_TD) */
 
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8.host.c
index 8e4451fcc8e33198ca1c129c0a0778a4c01331be..8c812aa9549f586fe05f5485265618082da87a04 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8.host.c
@@ -24,63 +24,50 @@
 #define NUMBER_OF_TCINV_POINTS 9
 #define NUMBER_OF_FCINV_POINTS 9
 
-static const s16 chgrinv_x[NUMBER_OF_CHGRINV_POINTS] = {
-	0, 16, 64, 144, 272, 448, 672, 976,
-	1376, 1888, 2528, 3312, 4256, 5376, 6688
-};
+static const s16 chgrinv_x[NUMBER_OF_CHGRINV_POINTS] = { 0,    16,   64,   144,
+							 272,  448,  672,  976,
+							 1376, 1888, 2528, 3312,
+							 4256, 5376, 6688 };
 
 static const s16 chgrinv_a[NUMBER_OF_CHGRINV_POINTS] = {
 	-7171, -256, -29, -3456, -1071, -475, -189, -102,
-	    -48, -38, -10, -9, -7, -6, 0
-    };
+	-48,   -38,  -10, -9,	 -7,	-6,   0
+};
 
 static const s16 chgrinv_b[NUMBER_OF_CHGRINV_POINTS] = {
-	8191, 1021, 256, 114, 60, 37, 24, 17,
-	12, 9, 6, 5, 4, 3, 2
+	8191, 1021, 256, 114, 60, 37, 24, 17, 12, 9, 6, 5, 4, 3, 2
 };
 
-static const s16 chgrinv_c[NUMBER_OF_CHGRINV_POINTS] = {
-	1, 1, 1, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0
-};
+static const s16 chgrinv_c[NUMBER_OF_CHGRINV_POINTS] = { 1, 1, 1, 0, 0, 0, 0, 0,
+							 0, 0, 0, 0, 0, 0, 0 };
 
-static const s16 tcinv_x[NUMBER_OF_TCINV_POINTS] = {
-	0, 4, 11, 23, 42, 68, 102, 148, 205
-};
+static const s16 tcinv_x[NUMBER_OF_TCINV_POINTS] = { 0,	 4,   11,  23, 42,
+						     68, 102, 148, 205 };
 
-static const s16 tcinv_a[NUMBER_OF_TCINV_POINTS] = {
-	-6364, -631, -126, -34, -13, -6, -4452, -2156, 0
-    };
+static const s16 tcinv_a[NUMBER_OF_TCINV_POINTS] = { -6364, -631,  -126,
+						     -34,   -13,   -6,
+						     -4452, -2156, 0 };
 
-static const s16 tcinv_b[NUMBER_OF_TCINV_POINTS] = {
-	8191, 1828, 726, 352, 197, 121, 80, 55, 40
-};
+static const s16 tcinv_b[NUMBER_OF_TCINV_POINTS] = { 8191, 1828, 726, 352, 197,
+						     121,  80,	 55,  40 };
 
-static const s16 tcinv_c[NUMBER_OF_TCINV_POINTS] = {
-	1, 1, 1, 1, 1, 1, 0, 0, 0
-};
+static const s16 tcinv_c[NUMBER_OF_TCINV_POINTS] = { 1, 1, 1, 1, 1, 1, 0, 0, 0 };
 
-static const s16 fcinv_x[NUMBER_OF_FCINV_POINTS] = {
-	0, 80, 216, 456, 824, 1344, 2040, 2952, 4096
-};
+static const s16 fcinv_x[NUMBER_OF_FCINV_POINTS] = { 0,	   80,	 216,  456, 824,
+						     1344, 2040, 2952, 4096 };
 
-static const s16 fcinv_a[NUMBER_OF_FCINV_POINTS] = {
-	-5244, -486, -86, -2849, -961, -400, -180, -86, 0
-    };
+static const s16 fcinv_a[NUMBER_OF_FCINV_POINTS] = { -5244, -486, -86,
+						     -2849, -961, -400,
+						     -180,  -86,  0 };
 
-static const s16 fcinv_b[NUMBER_OF_FCINV_POINTS] = {
-	8191, 1637, 607, 287, 159, 98, 64, 44, 32
-};
+static const s16 fcinv_b[NUMBER_OF_FCINV_POINTS] = { 8191, 1637, 607, 287, 159,
+						     98,   64,	 44,  32 };
 
-static const s16 fcinv_c[NUMBER_OF_FCINV_POINTS] = {
-	1, 1, 1, 0, 0, 0, 0, 0, 0
-};
+static const s16 fcinv_c[NUMBER_OF_FCINV_POINTS] = { 1, 1, 1, 0, 0, 0, 0, 0, 0 };
 
-void
-ia_css_eed1_8_vmem_encode(
-    struct eed1_8_vmem_params *to,
-    const struct ia_css_eed1_8_config *from,
-    size_t size)
+void ia_css_eed1_8_vmem_encode(struct eed1_8_vmem_params *to,
+			       const struct ia_css_eed1_8_config *from,
+			       size_t size)
 {
 	unsigned int i, j, base;
 	const unsigned int total_blocks = 4;
@@ -124,8 +111,10 @@ ia_css_eed1_8_vmem_encode(
 	}
 
 	for (j = 1; j < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; j++) {
-		assert(from->dew_enhance_seg_x[j] > from->dew_enhance_seg_x[j - 1]);
-		assert(from->dew_enhance_seg_y[j] > from->dew_enhance_seg_y[j - 1]);
+		assert(from->dew_enhance_seg_x[j] >
+		       from->dew_enhance_seg_x[j - 1]);
+		assert(from->dew_enhance_seg_y[j] >
+		       from->dew_enhance_seg_y[j - 1]);
 	}
 
 	assert(from->dew_enhance_seg_x[0] == 0);
@@ -163,29 +152,34 @@ ia_css_eed1_8_vmem_encode(
 		base = shuffle_block * i;
 
 		for (j = 0; j < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; j++) {
-			to->e_dew_enh_x[0][base + j] = clamp(from->dew_enhance_seg_x[j],
-							     0, 8191);
-			to->e_dew_enh_y[0][base + j] = clamp(from->dew_enhance_seg_y[j],
-							     -8192, 8191);
+			to->e_dew_enh_x[0][base + j] =
+				clamp(from->dew_enhance_seg_x[j], 0, 8191);
+			to->e_dew_enh_y[0][base + j] =
+				clamp(from->dew_enhance_seg_y[j], -8192, 8191);
 		}
 
-		for (j = 0; j < (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1); j++) {
-			to->e_dew_enh_a[0][base + j] = clamp(from->dew_enhance_seg_slope[j],
-							     -8192, 8191);
+		for (j = 0; j < (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1);
+		     j++) {
+			to->e_dew_enh_a[0][base + j] = clamp(
+				from->dew_enhance_seg_slope[j], -8192, 8191);
 			/* Convert dew_enhance_seg_exp to flag:
 			 * 0 -> 0
 			 * 1...13 -> 1
 			 */
-			to->e_dew_enh_f[0][base + j] = clamp(from->dew_enhance_seg_exp[j],
-							     0, 13) > 0;
+			to->e_dew_enh_f[0][base + j] =
+				clamp(from->dew_enhance_seg_exp[j], 0, 13) > 0;
 		}
 
 		/* Hard-coded to 0, in order to be able to handle out of
 		 * range input in the same way as the other segments.
 		 * See KFS for more details.
 		 */
-		to->e_dew_enh_a[0][base + (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)] = 0;
-		to->e_dew_enh_f[0][base + (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)] = 0;
+		to->e_dew_enh_a[0][base +
+				   (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)] =
+			0;
+		to->e_dew_enh_f[0][base +
+				   (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)] =
+			0;
 
 		for (j = 0; j < NUMBER_OF_CHGRINV_POINTS; j++) {
 			to->chgrinv_x[0][base + j] = chgrinv_x[j];
@@ -210,11 +204,8 @@ ia_css_eed1_8_vmem_encode(
 	}
 }
 
-void
-ia_css_eed1_8_encode(
-    struct eed1_8_dmem_params *to,
-    const struct ia_css_eed1_8_config *from,
-    size_t size)
+void ia_css_eed1_8_encode(struct eed1_8_dmem_params *to,
+			  const struct ia_css_eed1_8_config *from, size_t size)
 {
 	int i;
 	int min_exp = 0;
@@ -268,19 +259,14 @@ ia_css_eed1_8_encode(
 	to->dedgew_max = from->dedgew_max;
 }
 
-void
-ia_css_init_eed1_8_state(
-    void *state,
-    size_t size)
+void ia_css_init_eed1_8_state(void *state, size_t size)
 {
 	memset(state, 0, size);
 }
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_eed1_8_debug_dtrace(
-    const struct ia_css_eed1_8_config *eed,
-    unsigned int level)
+void ia_css_eed1_8_debug_dtrace(const struct ia_css_eed1_8_config *eed,
+				unsigned int level)
 {
 	if (!eed)
 		return;
@@ -288,39 +274,64 @@ ia_css_eed1_8_debug_dtrace(
 	ia_css_debug_dtrace(level, "Edge Enhancing Demosaic 1.8:\n");
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "rbzp_strength",
 			    eed->rbzp_strength);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fcstrength", eed->fcstrength);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fcthres_0", eed->fcthres_0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fcthres_1", eed->fcthres_1);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fc_sat_coef", eed->fc_sat_coef);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fcstrength",
+			    eed->fcstrength);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fcthres_0",
+			    eed->fcthres_0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fcthres_1",
+			    eed->fcthres_1);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fc_sat_coef",
+			    eed->fc_sat_coef);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fc_coring_prm",
 			    eed->fc_coring_prm);
 
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "aerel_thres0", eed->aerel_thres0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "aerel_gain0", eed->aerel_gain0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "aerel_thres1", eed->aerel_thres1);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "aerel_gain1", eed->aerel_gain1);
-
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "derel_thres0", eed->derel_thres0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "derel_gain0", eed->derel_gain0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "derel_thres1", eed->derel_thres1);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "derel_gain1", eed->derel_gain1);
-
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "coring_pos0", eed->coring_pos0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "coring_pos1", eed->coring_pos1);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "coring_neg0", eed->coring_neg0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "coring_neg1", eed->coring_neg1);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "aerel_thres0",
+			    eed->aerel_thres0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "aerel_gain0",
+			    eed->aerel_gain0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "aerel_thres1",
+			    eed->aerel_thres1);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "aerel_gain1",
+			    eed->aerel_gain1);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "derel_thres0",
+			    eed->derel_thres0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "derel_gain0",
+			    eed->derel_gain0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "derel_thres1",
+			    eed->derel_thres1);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "derel_gain1",
+			    eed->derel_gain1);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "coring_pos0",
+			    eed->coring_pos0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "coring_pos1",
+			    eed->coring_pos1);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "coring_neg0",
+			    eed->coring_neg0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "coring_neg1",
+			    eed->coring_neg1);
 
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gain_exp", eed->gain_exp);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gain_pos0", eed->gain_pos0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gain_pos1", eed->gain_pos1);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gain_neg0", eed->gain_neg0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gain_neg1", eed->gain_neg1);
-
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "pos_margin0", eed->pos_margin0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "pos_margin1", eed->pos_margin1);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "neg_margin0", eed->neg_margin0);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "neg_margin1", eed->neg_margin1);
-
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dedgew_max", eed->dedgew_max);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gain_pos0",
+			    eed->gain_pos0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gain_pos1",
+			    eed->gain_pos1);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gain_neg0",
+			    eed->gain_neg0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gain_neg1",
+			    eed->gain_neg1);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "pos_margin0",
+			    eed->pos_margin0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "pos_margin1",
+			    eed->pos_margin1);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "neg_margin0",
+			    eed->neg_margin0);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "neg_margin1",
+			    eed->neg_margin1);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dedgew_max",
+			    eed->dedgew_max);
 }
 #endif
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8.host.h
index 4af4bae1519057eb80a69f70b3b8b4a2dbf9debe..7389f0fae91845787429c8387f6c41409d8bb952 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8.host.h
@@ -10,28 +10,18 @@
 #include "ia_css_eed1_8_types.h"
 #include "ia_css_eed1_8_param.h"
 
-void
-ia_css_eed1_8_vmem_encode(
-    struct eed1_8_vmem_params *to,
-    const struct ia_css_eed1_8_config *from,
-    size_t size);
+void ia_css_eed1_8_vmem_encode(struct eed1_8_vmem_params *to,
+			       const struct ia_css_eed1_8_config *from,
+			       size_t size);
 
-void
-ia_css_eed1_8_encode(
-    struct eed1_8_dmem_params *to,
-    const struct ia_css_eed1_8_config *from,
-    size_t size);
+void ia_css_eed1_8_encode(struct eed1_8_dmem_params *to,
+			  const struct ia_css_eed1_8_config *from, size_t size);
 
-void
-ia_css_init_eed1_8_state(
-    void *state,
-    size_t size);
+void ia_css_init_eed1_8_state(void *state, size_t size);
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_eed1_8_debug_dtrace(
-    const struct ia_css_eed1_8_config *config,
-    unsigned int level);
+void ia_css_eed1_8_debug_dtrace(const struct ia_css_eed1_8_config *config,
+				unsigned int level);
 #endif
 
 #endif /* __IA_CSS_EED1_8_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8_param.h
index df87770446dd65ddbcf9c4a616b40bf7cb47fa24..cb0550d0e93dfeaddf148d21e773371f6fabb0fa 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8_param.h
@@ -19,68 +19,68 @@
  * 1: Use median
  * Default: 1
  */
-#define EED1_8_FC_ENABLE_MEDIAN		1
+#define EED1_8_FC_ENABLE_MEDIAN 1
 
 /* Coring Threshold minima
  * Used in Tint color suppression.
  * Default: 1
  */
-#define EED1_8_CORINGTHMIN	1
+#define EED1_8_CORINGTHMIN 1
 
 /* Define size of the state..... TODO: check if this is the correct place */
 /* 4 planes : GR, R, B, GB */
-#define NUM_PLANES	4
+#define NUM_PLANES 4
 
 /* 5 lines state per color plane input_line_state */
-#define EED1_8_STATE_INPUT_BUFFER_HEIGHT	(5 * NUM_PLANES)
+#define EED1_8_STATE_INPUT_BUFFER_HEIGHT (5 * NUM_PLANES)
 
 /* Each plane has width equal to half frame line */
-#define EED1_8_STATE_INPUT_BUFFER_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define EED1_8_STATE_INPUT_BUFFER_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 1 line state per color plane LD_H state */
-#define EED1_8_STATE_LD_H_HEIGHT	(1 * NUM_PLANES)
-#define EED1_8_STATE_LD_H_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define EED1_8_STATE_LD_H_HEIGHT (1 * NUM_PLANES)
+#define EED1_8_STATE_LD_H_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 1 line state per color plane LD_V state */
-#define EED1_8_STATE_LD_V_HEIGHT	(1 * NUM_PLANES)
-#define EED1_8_STATE_LD_V_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define EED1_8_STATE_LD_V_HEIGHT (1 * NUM_PLANES)
+#define EED1_8_STATE_LD_V_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 1 line (single plane) state for D_Hr state */
-#define EED1_8_STATE_D_HR_HEIGHT	1
-#define EED1_8_STATE_D_HR_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define EED1_8_STATE_D_HR_HEIGHT 1
+#define EED1_8_STATE_D_HR_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 1 line (single plane) state for D_Hb state */
-#define EED1_8_STATE_D_HB_HEIGHT	1
-#define EED1_8_STATE_D_HB_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define EED1_8_STATE_D_HB_HEIGHT 1
+#define EED1_8_STATE_D_HB_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 2 lines (single plane) state for D_Vr state */
-#define EED1_8_STATE_D_VR_HEIGHT	2
-#define EED1_8_STATE_D_VR_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define EED1_8_STATE_D_VR_HEIGHT 2
+#define EED1_8_STATE_D_VR_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 2 line (single plane) state for D_Vb state */
-#define EED1_8_STATE_D_VB_HEIGHT	2
-#define EED1_8_STATE_D_VB_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define EED1_8_STATE_D_VB_HEIGHT 2
+#define EED1_8_STATE_D_VB_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 2 lines state for R and B (= 2 planes) rb_zipped_state */
-#define EED1_8_STATE_RB_ZIPPED_HEIGHT	(2 * 2)
-#define EED1_8_STATE_RB_ZIPPED_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define EED1_8_STATE_RB_ZIPPED_HEIGHT (2 * 2)
+#define EED1_8_STATE_RB_ZIPPED_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 #if EED1_8_FC_ENABLE_MEDIAN
 /* 1 full input line (GR-R color line) for Yc state */
-#define EED1_8_STATE_YC_HEIGHT	1
-#define EED1_8_STATE_YC_WIDTH	MAX_FRAME_SIMDWIDTH
+#define EED1_8_STATE_YC_HEIGHT 1
+#define EED1_8_STATE_YC_WIDTH MAX_FRAME_SIMDWIDTH
 
 /* 1 line state per color plane Cg_state */
-#define EED1_8_STATE_CG_HEIGHT	(1 * NUM_PLANES)
-#define EED1_8_STATE_CG_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define EED1_8_STATE_CG_HEIGHT (1 * NUM_PLANES)
+#define EED1_8_STATE_CG_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 1 line state per color plane Co_state */
-#define EED1_8_STATE_CO_HEIGHT	(1 * NUM_PLANES)
-#define EED1_8_STATE_CO_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+#define EED1_8_STATE_CO_HEIGHT (1 * NUM_PLANES)
+#define EED1_8_STATE_CO_WIDTH CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 1 full input line (GR-R color line) for AbsK state */
-#define EED1_8_STATE_ABSK_HEIGHT	1
-#define EED1_8_STATE_ABSK_WIDTH		MAX_FRAME_SIMDWIDTH
+#define EED1_8_STATE_ABSK_HEIGHT 1
+#define EED1_8_STATE_ABSK_WIDTH MAX_FRAME_SIMDWIDTH
 #endif
 
 struct eed1_8_vmem_params {
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8_types.h
index 0b977eb7ad717a27ac8cf4d3d7e69d9557c2e9d5..17c162c8e8c57163f30f12e24321486011ccd8c9 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/eed1_8/ia_css_eed1_8_types.h
@@ -25,7 +25,7 @@
  * Ineffective: N/A
  * Default:	9
  */
-#define IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS	9
+#define IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS 9
 
 /* Edge Enhanced Demosaic configuration
  *
@@ -33,47 +33,51 @@
  */
 
 struct ia_css_eed1_8_config {
-	s32 rbzp_strength;	/** Strength of zipper reduction. */
-
-	s32 fcstrength;	/** Strength of false color reduction. */
-	s32 fcthres_0;	/** Threshold to prevent chroma coring due to noise or green disparity in dark region. */
-	s32 fcthres_1;	/** Threshold to prevent chroma coring due to noise or green disparity in bright region. */
-	s32 fc_sat_coef;	/** How much color saturation to maintain in high color saturation region. */
-	s32 fc_coring_prm;	/** Chroma coring coefficient for tint color suppression. */
-
-	s32 aerel_thres0;	/** Threshold for Non-Directional Reliability at dark region. */
-	s32 aerel_gain0;	/** Gain for Non-Directional Reliability at dark region. */
-	s32 aerel_thres1;	/** Threshold for Non-Directional Reliability at bright region. */
-	s32 aerel_gain1;	/** Gain for Non-Directional Reliability at bright region. */
-
-	s32 derel_thres0;	/** Threshold for Directional Reliability at dark region. */
-	s32 derel_gain0;	/** Gain for Directional Reliability at dark region. */
-	s32 derel_thres1;	/** Threshold for Directional Reliability at bright region. */
-	s32 derel_gain1;	/** Gain for Directional Reliability at bright region. */
-
-	s32 coring_pos0;	/** Positive Edge Coring Threshold in dark region. */
-	s32 coring_pos1;	/** Positive Edge Coring Threshold in bright region. */
-	s32 coring_neg0;	/** Negative Edge Coring Threshold in dark region. */
-	s32 coring_neg1;	/** Negative Edge Coring Threshold in bright region. */
-
-	s32 gain_exp;	/** Common Exponent of Gain. */
-	s32 gain_pos0;	/** Gain for Positive Edge in dark region. */
-	s32 gain_pos1;	/** Gain for Positive Edge in bright region. */
-	s32 gain_neg0;	/** Gain for Negative Edge in dark region. */
-	s32 gain_neg1;	/** Gain for Negative Edge in bright region. */
-
-	s32 pos_margin0;	/** Margin for Positive Edge in dark region. */
-	s32 pos_margin1;	/** Margin for Positive Edge in bright region. */
-	s32 neg_margin0;	/** Margin for Negative Edge in dark region. */
-	s32 neg_margin1;	/** Margin for Negative Edge in bright region. */
-
-	s32 dew_enhance_seg_x[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];		/** Segment data for directional edge weight: X. */
-	s32 dew_enhance_seg_y[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];		/** Segment data for directional edge weight: Y. */
-	s32 dew_enhance_seg_slope[(IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS -
-				   1)];	/** Segment data for directional edge weight: Slope. */
-	s32 dew_enhance_seg_exp[(IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS -
-				 1)];	/** Segment data for directional edge weight: Exponent. */
-	s32 dedgew_max;	/** Max Weight for Directional Edge. */
+	s32 rbzp_strength; /** Strength of zipper reduction. */
+
+	s32 fcstrength; /** Strength of false color reduction. */
+	s32 fcthres_0; /** Threshold to prevent chroma coring due to noise or green disparity in dark region. */
+	s32 fcthres_1; /** Threshold to prevent chroma coring due to noise or green disparity in bright region. */
+	s32 fc_sat_coef; /** How much color saturation to maintain in high color saturation region. */
+	s32 fc_coring_prm; /** Chroma coring coefficient for tint color suppression. */
+
+	s32 aerel_thres0; /** Threshold for Non-Directional Reliability at dark region. */
+	s32 aerel_gain0; /** Gain for Non-Directional Reliability at dark region. */
+	s32 aerel_thres1; /** Threshold for Non-Directional Reliability at bright region. */
+	s32 aerel_gain1; /** Gain for Non-Directional Reliability at bright region. */
+
+	s32 derel_thres0; /** Threshold for Directional Reliability at dark region. */
+	s32 derel_gain0; /** Gain for Directional Reliability at dark region. */
+	s32 derel_thres1; /** Threshold for Directional Reliability at bright region. */
+	s32 derel_gain1; /** Gain for Directional Reliability at bright region. */
+
+	s32 coring_pos0; /** Positive Edge Coring Threshold in dark region. */
+	s32 coring_pos1; /** Positive Edge Coring Threshold in bright region. */
+	s32 coring_neg0; /** Negative Edge Coring Threshold in dark region. */
+	s32 coring_neg1; /** Negative Edge Coring Threshold in bright region. */
+
+	s32 gain_exp; /** Common Exponent of Gain. */
+	s32 gain_pos0; /** Gain for Positive Edge in dark region. */
+	s32 gain_pos1; /** Gain for Positive Edge in bright region. */
+	s32 gain_neg0; /** Gain for Negative Edge in dark region. */
+	s32 gain_neg1; /** Gain for Negative Edge in bright region. */
+
+	s32 pos_margin0; /** Margin for Positive Edge in dark region. */
+	s32 pos_margin1; /** Margin for Positive Edge in bright region. */
+	s32 neg_margin0; /** Margin for Negative Edge in dark region. */
+	s32 neg_margin1; /** Margin for Negative Edge in bright region. */
+
+	s32 dew_enhance_seg_x
+		[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS]; /** Segment data for directional edge weight: X. */
+	s32 dew_enhance_seg_y
+		[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS]; /** Segment data for directional edge weight: Y. */
+	s32 dew_enhance_seg_slope[(
+		IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS -
+		1)]; /** Segment data for directional edge weight: Slope. */
+	s32 dew_enhance_seg_exp[(
+		IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS -
+		1)]; /** Segment data for directional edge weight: Exponent. */
+	s32 dedgew_max; /** Max Weight for Directional Edge. */
 };
 
 #endif /* __IA_CSS_EED1_8_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/fc/fc_1.0/ia_css_formats.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/fc/fc_1.0/ia_css_formats.host.c
index 6a10d3545278e79f5e4cddc566bac8c6f2211022..9f84a65fa9ff989d1a76e65f84248e010c10bcf3 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/fc/fc_1.0/ia_css_formats.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/fc/fc_1.0/ia_css_formats.host.c
@@ -14,15 +14,11 @@
 #include "ia_css_debug.h"
 #endif
 
-const struct ia_css_formats_config default_formats_config = {
-	1
-};
+const struct ia_css_formats_config default_formats_config = { 1 };
 
-void
-ia_css_formats_encode(
-    struct sh_css_isp_formats_params *to,
-    const struct ia_css_formats_config *from,
-    unsigned int size)
+void ia_css_formats_encode(struct sh_css_isp_formats_params *to,
+			   const struct ia_css_formats_config *from,
+			   unsigned int size)
 {
 	(void)size;
 	to->video_full_range_flag = from->video_full_range_flag;
@@ -30,26 +26,22 @@ ia_css_formats_encode(
 
 #ifndef IA_CSS_NO_DEBUG
 /* FIXME: See BZ 4427 */
-void
-ia_css_formats_dump(
-    const struct sh_css_isp_formats_params *formats,
-    unsigned int level)
+void ia_css_formats_dump(const struct sh_css_isp_formats_params *formats,
+			 unsigned int level)
 {
-	if (!formats) return;
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "video_full_range_flag", formats->video_full_range_flag);
+	if (!formats)
+		return;
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "video_full_range_flag",
+			    formats->video_full_range_flag);
 }
 #endif
 
 #ifndef IA_CSS_NO_DEBUG
 /* FIXME: See BZ 4427 */
-void
-ia_css_formats_debug_dtrace(
-    const struct ia_css_formats_config *config,
-    unsigned int level)
+void ia_css_formats_debug_dtrace(const struct ia_css_formats_config *config,
+				 unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.video_full_range_flag=%d\n",
+	ia_css_debug_dtrace(level, "config.video_full_range_flag=%d\n",
 			    config->video_full_range_flag);
 }
 #endif
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/fc/fc_1.0/ia_css_formats.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/fc/fc_1.0/ia_css_formats.host.h
index 17a57ddaa3212c630ea75e2ba90a046402fd1da4..89761f1fa27aa3334040205075425eff50c22dcf 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/fc/fc_1.0/ia_css_formats.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/fc/fc_1.0/ia_css_formats.host.h
@@ -12,25 +12,19 @@
 
 extern const struct ia_css_formats_config default_formats_config;
 
-void
-ia_css_formats_encode(
-    struct sh_css_isp_formats_params *to,
-    const struct ia_css_formats_config *from,
-    unsigned int size);
+void ia_css_formats_encode(struct sh_css_isp_formats_params *to,
+			   const struct ia_css_formats_config *from,
+			   unsigned int size);
 #ifndef IA_CSS_NO_DEBUG
 /* FIXME: See BZ 4427 */
-void
-ia_css_formats_dump(
-    const struct sh_css_isp_formats_params *formats,
-    unsigned int level);
+void ia_css_formats_dump(const struct sh_css_isp_formats_params *formats,
+			 unsigned int level);
 #endif
 
 #ifndef IA_CSS_NO_DEBUG
 /* FIXME: See BZ 4427 */
-void
-ia_css_formats_debug_dtrace(
-    const struct ia_css_formats_config *formats,
-    unsigned int level);
+void ia_css_formats_debug_dtrace(const struct ia_css_formats_config *formats,
+				 unsigned int level);
 #endif /*IA_CSS_NO_DEBUG*/
 
 #endif /* __IA_CSS_FORMATS_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
index 7626dfe82642e177579dddf0ece08ad394cc0437..c3513f24aceb34ad1d00c2c4d7b714828ebd1b97 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
@@ -13,4 +13,4 @@ struct sh_css_bds_factor {
 	unsigned int bds_factor;
 };
 
-#endif	/*__IA_CSS_FIXEDBDS_TYPES_H*/
+#endif /*__IA_CSS_FIXEDBDS_TYPES_H*/
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
index b34feba5340bc8359297aa8da91b4fbf4b96c162..37b2707698ded58560bce862604a83d997c5e86d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
@@ -18,29 +18,23 @@
 
 #include "ia_css_fpn.host.h"
 
-void
-ia_css_fpn_encode(
-    struct sh_css_isp_fpn_params *to,
-    const struct ia_css_fpn_table *from,
-    unsigned int size)
+void ia_css_fpn_encode(struct sh_css_isp_fpn_params *to,
+		       const struct ia_css_fpn_table *from, unsigned int size)
 {
 	(void)size;
 	to->shift = from->shift;
 	to->enabled = from->data != NULL;
 }
 
-void
-ia_css_fpn_dump(
-    const struct sh_css_isp_fpn_params *fpn,
-    unsigned int level)
+void ia_css_fpn_dump(const struct sh_css_isp_fpn_params *fpn,
+		     unsigned int level)
 {
 	if (!fpn)
 		return;
 	ia_css_debug_dtrace(level, "Fixed Pattern Noise Reduction:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "fpn_shift", fpn->shift);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "fpn_enabled", fpn->enabled);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fpn_shift", fpn->shift);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "fpn_enabled",
+			    fpn->enabled);
 }
 
 int ia_css_fpn_config(struct sh_css_isp_fpn_isp_config *to,
@@ -63,21 +57,20 @@ int ia_css_fpn_config(struct sh_css_isp_fpn_isp_config *to,
 	return 0;
 }
 
-int ia_css_fpn_configure(const struct ia_css_binary     *binary,
+int ia_css_fpn_configure(const struct ia_css_binary *binary,
 			 const struct ia_css_frame_info *info)
 {
 	struct ia_css_frame_info my_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;
-	const struct ia_css_fpn_configuration config = {
-		&my_info
-	};
+	const struct ia_css_fpn_configuration config = { &my_info };
 
-	my_info.res.width       = CEIL_DIV(info->res.width, 2);		/* Packed by 2x */
-	my_info.res.height      = info->res.height;
-	my_info.padded_width    = CEIL_DIV(info->padded_width, 2);	/* Packed by 2x */
-	my_info.format          = info->format;
-	my_info.raw_bit_depth   = FPN_BITS_PER_PIXEL;
+	my_info.res.width = CEIL_DIV(info->res.width, 2); /* Packed by 2x */
+	my_info.res.height = info->res.height;
+	my_info.padded_width =
+		CEIL_DIV(info->padded_width, 2); /* Packed by 2x */
+	my_info.format = info->format;
+	my_info.raw_bit_depth = FPN_BITS_PER_PIXEL;
 	my_info.raw_bayer_order = info->raw_bayer_order;
-	my_info.crop_info       = info->crop_info;
+	my_info.crop_info = info->crop_info;
 
 	return ia_css_configure_fpn(binary, &config);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h
index cdd4350c082cad68dd63dce5eece11933b0f9197..fd584e15146c9207e12b83166f895e7ba8504657 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h
@@ -11,22 +11,17 @@
 #include "ia_css_fpn_types.h"
 #include "ia_css_fpn_param.h"
 
-void
-ia_css_fpn_encode(
-    struct sh_css_isp_fpn_params *to,
-    const struct ia_css_fpn_table *from,
-    unsigned int size);
+void ia_css_fpn_encode(struct sh_css_isp_fpn_params *to,
+		       const struct ia_css_fpn_table *from, unsigned int size);
 
-void
-ia_css_fpn_dump(
-    const struct sh_css_isp_fpn_params *fpn,
-    unsigned int level);
+void ia_css_fpn_dump(const struct sh_css_isp_fpn_params *fpn,
+		     unsigned int level);
 
-int ia_css_fpn_config(struct sh_css_isp_fpn_isp_config      *to,
+int ia_css_fpn_config(struct sh_css_isp_fpn_isp_config *to,
 		      const struct ia_css_fpn_configuration *from,
 		      unsigned int size);
 
-int ia_css_fpn_configure(const struct ia_css_binary     *binary,
+int ia_css_fpn_configure(const struct ia_css_binary *binary,
 			 const struct ia_css_frame_info *from);
 
 #endif /* __IA_CSS_FPN_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn_param.h
index 94edd1d21e9adf2c4681575f45519fdce4e01300..10349c8c53912019a4b3c81b1979cde6ef82834c 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn_param.h
@@ -11,7 +11,7 @@
 
 #include "dma.h"
 
-#define FPN_BITS_PER_PIXEL	16
+#define FPN_BITS_PER_PIXEL 16
 
 /* FPNR (Fixed Pattern Noise Reduction) */
 struct sh_css_isp_fpn_params {
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn_types.h
index 8b246c80e105e4f041ce9aa19474d5e77ebb5a8f..140f24ac7e891f81affbf0737da154bb4b3dd93f 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/fpn/fpn_1.0/ia_css_fpn_types.h
@@ -25,15 +25,15 @@
  */
 
 struct ia_css_fpn_table {
-	s16 *data;		/** Table content (fixed patterns noise).
+	s16 *data; /** Table content (fixed patterns noise).
 					u0.[13-shift], [0,63] */
-	u32 width;		/** Table width (in pixels).
+	u32 width; /** Table width (in pixels).
 					This is the input frame width. */
-	u32 height;	/** Table height (in pixels).
+	u32 height; /** Table height (in pixels).
 					This is the input frame height. */
-	u32 shift;		/** Common exponent of table content.
+	u32 shift; /** Common exponent of table content.
 					u8.0, [0,13] */
-	u32 enabled;	/** Fpn is enabled.
+	u32 enabled; /** Fpn is enabled.
 					bool */
 };
 
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc.host.c
index afef48ebd8180a99a9895076dd4bd7caf8e11c67..9636638abddc6c7c216c3788222e81372b860ab6 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc.host.c
@@ -15,92 +15,66 @@
 
 #include "ia_css_gc.host.h"
 
-const struct ia_css_gc_config default_gc_config = {
-	0,
-	0
-};
+const struct ia_css_gc_config default_gc_config = { 0, 0 };
 
-const struct ia_css_ce_config default_ce_config = {
-	0,
-	255
-};
+const struct ia_css_ce_config default_ce_config = { 0, 255 };
 
-void
-ia_css_gc_encode(
-    struct sh_css_isp_gc_params *to,
-    const struct ia_css_gc_config *from,
-    unsigned int size)
+void ia_css_gc_encode(struct sh_css_isp_gc_params *to,
+		      const struct ia_css_gc_config *from, unsigned int size)
 {
 	(void)size;
-	to->gain_k1 =
-	    uDIGIT_FITTING((int)from->gain_k1, 16,
-			   IA_CSS_GAMMA_GAIN_K_SHIFT);
-	to->gain_k2 =
-	    uDIGIT_FITTING((int)from->gain_k2, 16,
-			   IA_CSS_GAMMA_GAIN_K_SHIFT);
+	to->gain_k1 = uDIGIT_FITTING((int)from->gain_k1, 16,
+				     IA_CSS_GAMMA_GAIN_K_SHIFT);
+	to->gain_k2 = uDIGIT_FITTING((int)from->gain_k2, 16,
+				     IA_CSS_GAMMA_GAIN_K_SHIFT);
 }
 
-void
-ia_css_ce_encode(
-    struct sh_css_isp_ce_params *to,
-    const struct ia_css_ce_config *from,
-    unsigned int size)
+void ia_css_ce_encode(struct sh_css_isp_ce_params *to,
+		      const struct ia_css_ce_config *from, unsigned int size)
 {
 	(void)size;
 	to->uv_level_min = from->uv_level_min;
 	to->uv_level_max = from->uv_level_max;
 }
 
-void
-ia_css_gc_vamem_encode(
-    struct sh_css_isp_gc_vamem_params *to,
-    const struct ia_css_gamma_table *from,
-    unsigned int size)
+void ia_css_gc_vamem_encode(struct sh_css_isp_gc_vamem_params *to,
+			    const struct ia_css_gamma_table *from,
+			    unsigned int size)
 {
 	(void)size;
-	memcpy(&to->gc,  &from->data, sizeof(to->gc));
+	memcpy(&to->gc, &from->data, sizeof(to->gc));
 }
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_gc_dump(
-    const struct sh_css_isp_gc_params *gc,
-    unsigned int level)
+void ia_css_gc_dump(const struct sh_css_isp_gc_params *gc, unsigned int level)
 {
-	if (!gc) return;
+	if (!gc)
+		return;
 	ia_css_debug_dtrace(level, "Gamma Correction:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "gamma_gain_k1", gc->gain_k1);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "gamma_gain_k2", gc->gain_k2);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gamma_gain_k1",
+			    gc->gain_k1);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "gamma_gain_k2",
+			    gc->gain_k2);
 }
 
-void
-ia_css_ce_dump(
-    const struct sh_css_isp_ce_params *ce,
-    unsigned int level)
+void ia_css_ce_dump(const struct sh_css_isp_ce_params *ce, unsigned int level)
 {
 	ia_css_debug_dtrace(level, "Chroma Enhancement:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ce_uv_level_min", ce->uv_level_min);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ce_uv_level_max", ce->uv_level_max);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ce_uv_level_min",
+			    ce->uv_level_min);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ce_uv_level_max",
+			    ce->uv_level_max);
 }
 
-void
-ia_css_gc_debug_dtrace(
-    const struct ia_css_gc_config *config,
-    unsigned int level)
+void ia_css_gc_debug_dtrace(const struct ia_css_gc_config *config,
+			    unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.gain_k1=%d, config.gain_k2=%d\n",
+	ia_css_debug_dtrace(level, "config.gain_k1=%d, config.gain_k2=%d\n",
 			    config->gain_k1, config->gain_k2);
 }
 
-void
-ia_css_ce_debug_dtrace(
-    const struct ia_css_ce_config *config,
-    unsigned int level)
+void ia_css_ce_debug_dtrace(const struct ia_css_ce_config *config,
+			    unsigned int level)
 {
 	ia_css_debug_dtrace(level,
 			    "config.uv_level_min=%d, config.uv_level_max=%d\n",
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc.host.h
index 785bc5329dd3f9942020a4f88818fda7d23515e2..815769714ca516125be2a74dd50f57af529b079d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc.host.h
@@ -13,44 +13,26 @@
 extern const struct ia_css_gc_config default_gc_config;
 extern const struct ia_css_ce_config default_ce_config;
 
-void
-ia_css_gc_encode(
-    struct sh_css_isp_gc_params *to,
-    const struct ia_css_gc_config *from,
-    unsigned int size);
-
-void
-ia_css_gc_vamem_encode(
-    struct sh_css_isp_gc_vamem_params *to,
-    const struct ia_css_gamma_table *from,
-    unsigned int size);
-
-void
-ia_css_ce_encode(
-    struct sh_css_isp_ce_params *to,
-    const struct ia_css_ce_config *from,
-    unsigned int size);
+void ia_css_gc_encode(struct sh_css_isp_gc_params *to,
+		      const struct ia_css_gc_config *from, unsigned int size);
+
+void ia_css_gc_vamem_encode(struct sh_css_isp_gc_vamem_params *to,
+			    const struct ia_css_gamma_table *from,
+			    unsigned int size);
+
+void ia_css_ce_encode(struct sh_css_isp_ce_params *to,
+		      const struct ia_css_ce_config *from, unsigned int size);
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_gc_dump(
-    const struct sh_css_isp_gc_params *gc,
-    unsigned int level);
-
-void
-ia_css_ce_dump(
-    const struct sh_css_isp_ce_params *ce,
-    unsigned int level);
-
-void
-ia_css_gc_debug_dtrace(
-    const struct ia_css_gc_config *config,
-    unsigned int level);
-
-void
-ia_css_ce_debug_dtrace(
-    const struct ia_css_ce_config *config,
-    unsigned int level);
+void ia_css_gc_dump(const struct sh_css_isp_gc_params *gc, unsigned int level);
+
+void ia_css_ce_dump(const struct sh_css_isp_ce_params *ce, unsigned int level);
+
+void ia_css_gc_debug_dtrace(const struct ia_css_gc_config *config,
+			    unsigned int level);
+
+void ia_css_ce_debug_dtrace(const struct ia_css_ce_config *config,
+			    unsigned int level);
 
 #endif
 
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_param.h
index fcd16196cc5ab826f41bc3081f3e2ac7fcb20b31..767422469cc8fb4a39516c38346530368f5fcc75 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_param.h
@@ -17,10 +17,10 @@
 
 #if defined(IS_VAMEM_VERSION_1)
 #define SH_CSS_ISP_GAMMA_TABLE_SIZE_LOG2 IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2
-#define SH_CSS_ISP_GC_TABLE_SIZE	 IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE
+#define SH_CSS_ISP_GC_TABLE_SIZE IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE
 #elif defined(IS_VAMEM_VERSION_2)
 #define SH_CSS_ISP_GAMMA_TABLE_SIZE_LOG2 IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2
-#define SH_CSS_ISP_GC_TABLE_SIZE	 IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE
+#define SH_CSS_ISP_GC_TABLE_SIZE IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE
 #else
 #error "Undefined vamem version"
 #endif
@@ -30,8 +30,8 @@
 #define SH_CSS_ISP_GC_TABLE_SIZE 0
 #endif
 
-#define GAMMA_OUTPUT_BITS		8
-#define GAMMA_OUTPUT_MAX_VAL		((1 << GAMMA_OUTPUT_BITS) - 1)
+#define GAMMA_OUTPUT_BITS 8
+#define GAMMA_OUTPUT_MAX_VAL ((1 << GAMMA_OUTPUT_BITS) - 1)
 
 /* GC (Gamma Correction) */
 struct sh_css_isp_gc_params {
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_table.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_table.host.c
index b0427a9d6628dff28e7d912d52deeaad6c1460a8..d5313d7cab5e31058110d27a1a0efc77329e46b0 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_table.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_table.host.c
@@ -12,51 +12,35 @@
 #include "ia_css_types.h"
 #include "ia_css_gc_table.host.h"
 
-
 struct ia_css_gamma_table default_gamma_table;
 
 static const uint16_t
-default_gamma_table_data[IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE] = {
-	0,   4,   8,  12,  17,  21,  27,  32,
-	38,  44,  49,  55,  61,  66,  71,  76,
-	80,  84,  88,  92,  95,  98, 102, 105,
-	108, 110, 113, 116, 118, 121, 123, 126,
-	128, 130, 132, 135, 137, 139, 141, 143,
-	145, 146, 148, 150, 152, 153, 155, 156,
-	158, 160, 161, 162, 164, 165, 166, 168,
-	169, 170, 171, 172, 174, 175, 176, 177,
-	178, 179, 180, 181, 182, 183, 184, 184,
-	185, 186, 187, 188, 189, 189, 190, 191,
-	192, 192, 193, 194, 195, 195, 196, 197,
-	197, 198, 198, 199, 200, 200, 201, 201,
-	202, 203, 203, 204, 204, 205, 205, 206,
-	206, 207, 207, 208, 208, 209, 209, 210,
-	210, 210, 211, 211, 212, 212, 213, 213,
-	214, 214, 214, 215, 215, 216, 216, 216,
-	217, 217, 218, 218, 218, 219, 219, 220,
-	220, 220, 221, 221, 222, 222, 222, 223,
-	223, 223, 224, 224, 225, 225, 225, 226,
-	226, 226, 227, 227, 227, 228, 228, 228,
-	229, 229, 229, 230, 230, 230, 231, 231,
-	231, 232, 232, 232, 233, 233, 233, 234,
-	234, 234, 234, 235, 235, 235, 236, 236,
-	236, 237, 237, 237, 237, 238, 238, 238,
-	239, 239, 239, 239, 240, 240, 240, 241,
-	241, 241, 241, 242, 242, 242, 242, 243,
-	243, 243, 243, 244, 244, 244, 245, 245,
-	245, 245, 246, 246, 246, 246, 247, 247,
-	247, 247, 248, 248, 248, 248, 249, 249,
-	249, 249, 250, 250, 250, 250, 251, 251,
-	251, 251, 252, 252, 252, 252, 253, 253,
-	253, 253, 254, 254, 254, 254, 255, 255,
-	255
-};
-
+	default_gamma_table_data[IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE] = {
+		0,   4,	  8,   12,  17,	 21,  27,  32,	38,  44,  49,  55,  61,
+		66,  71,  76,  80,  84,	 88,  92,  95,	98,  102, 105, 108, 110,
+		113, 116, 118, 121, 123, 126, 128, 130, 132, 135, 137, 139, 141,
+		143, 145, 146, 148, 150, 152, 153, 155, 156, 158, 160, 161, 162,
+		164, 165, 166, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178,
+		179, 180, 181, 182, 183, 184, 184, 185, 186, 187, 188, 189, 189,
+		190, 191, 192, 192, 193, 194, 195, 195, 196, 197, 197, 198, 198,
+		199, 200, 200, 201, 201, 202, 203, 203, 204, 204, 205, 205, 206,
+		206, 207, 207, 208, 208, 209, 209, 210, 210, 210, 211, 211, 212,
+		212, 213, 213, 214, 214, 214, 215, 215, 216, 216, 216, 217, 217,
+		218, 218, 218, 219, 219, 220, 220, 220, 221, 221, 222, 222, 222,
+		223, 223, 223, 224, 224, 225, 225, 225, 226, 226, 226, 227, 227,
+		227, 228, 228, 228, 229, 229, 229, 230, 230, 230, 231, 231, 231,
+		232, 232, 232, 233, 233, 233, 234, 234, 234, 234, 235, 235, 235,
+		236, 236, 236, 237, 237, 237, 237, 238, 238, 238, 239, 239, 239,
+		239, 240, 240, 240, 241, 241, 241, 241, 242, 242, 242, 242, 243,
+		243, 243, 243, 244, 244, 244, 245, 245, 245, 245, 246, 246, 246,
+		246, 247, 247, 247, 247, 248, 248, 248, 248, 249, 249, 249, 249,
+		250, 250, 250, 250, 251, 251, 251, 251, 252, 252, 252, 252, 253,
+		253, 253, 253, 254, 254, 254, 254, 255, 255, 255
+	};
 
-void
-ia_css_config_gamma_table(void)
+void ia_css_config_gamma_table(void)
 {
 	memcpy(default_gamma_table.data.vamem_2, default_gamma_table_data,
 	       sizeof(default_gamma_table_data));
-	default_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_2;
+	default_gamma_table.vamem_type = IA_CSS_VAMEM_TYPE_2;
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_types.h
index 09d3fb41b73fdb67d675153d564f736cb1940ea2..abb972938add7c0d866686b77b656ed695a74fec 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_1.0/ia_css_gc_types.h
@@ -11,18 +11,20 @@
 * CSS-API header file for Gamma Correction parameters.
 */
 
-#include "isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h"  /* FIXME: Needed for ia_css_vamem_type */
+#include "isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h" /* FIXME: Needed for ia_css_vamem_type */
 
 /* Fractional bits for GAMMA gain */
-#define IA_CSS_GAMMA_GAIN_K_SHIFT      13
+#define IA_CSS_GAMMA_GAIN_K_SHIFT 13
 
 /* Number of elements in the gamma table. */
-#define IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2    10
-#define IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE         BIT(IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2)
+#define IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2 10
+#define IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE \
+	BIT(IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2)
 
 /* Number of elements in the gamma table. */
-#define IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2    8
-#define IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE         ((1U << IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2) + 1)
+#define IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2 8
+#define IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE \
+	((1U << IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2) + 1)
 
 /* Gamma table, used for Y(Luma) Gamma Correction.
  *
@@ -82,7 +84,7 @@ struct ia_css_ce_config {
  *  ISP2: MACC2 is used.
  */
 struct ia_css_macc_config {
-	u8 exp;	/** Common exponent of ia_css_macc_table.
+	u8 exp; /** Common exponent of ia_css_macc_table.
 				u8.0, [0,13], default 1, ineffective 1 */
 };
 
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2.host.c
index 3a32026a8f602146330fb7669a880db17d774a60..bf4bc5ea4b91e50b82a0fda42fc0647c8a1fe7fd 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2.host.c
@@ -17,83 +17,67 @@
 
 const struct ia_css_cc_config default_yuv2rgb_cc_config = {
 	12,
-	{4096, -4096, 4096, 4096, 4096, 0, 4096, -4096, -4096}
+	{ 4096, -4096, 4096, 4096, 4096, 0, 4096, -4096, -4096 }
 };
 
 const struct ia_css_cc_config default_rgb2yuv_cc_config = {
 	13,
-	{2449, 4809, 934, -1382, -2714, 4096, 4096, -3430, -666}
+	{ 2449, 4809, 934, -1382, -2714, 4096, 4096, -3430, -666 }
 };
 
-void
-ia_css_yuv2rgb_encode(
-    struct sh_css_isp_csc_params *to,
-    const struct ia_css_cc_config *from,
-    unsigned int size)
+void ia_css_yuv2rgb_encode(struct sh_css_isp_csc_params *to,
+			   const struct ia_css_cc_config *from,
+			   unsigned int size)
 {
 	ia_css_encode_cc(to, from, size);
 }
 
-void
-ia_css_rgb2yuv_encode(
-    struct sh_css_isp_csc_params *to,
-    const struct ia_css_cc_config *from,
-    unsigned int size)
+void ia_css_rgb2yuv_encode(struct sh_css_isp_csc_params *to,
+			   const struct ia_css_cc_config *from,
+			   unsigned int size)
 {
 	ia_css_encode_cc(to, from, size);
 }
 
-void
-ia_css_r_gamma_vamem_encode(
-    struct sh_css_isp_rgb_gamma_vamem_params *to,
-    const struct ia_css_rgb_gamma_table *from,
-    unsigned int size)
+void ia_css_r_gamma_vamem_encode(struct sh_css_isp_rgb_gamma_vamem_params *to,
+				 const struct ia_css_rgb_gamma_table *from,
+				 unsigned int size)
 {
 	(void)size;
-	memcpy(&to->gc,  &from->data, sizeof(to->gc));
+	memcpy(&to->gc, &from->data, sizeof(to->gc));
 }
 
-void
-ia_css_g_gamma_vamem_encode(
-    struct sh_css_isp_rgb_gamma_vamem_params *to,
-    const struct ia_css_rgb_gamma_table *from,
-    unsigned int size)
+void ia_css_g_gamma_vamem_encode(struct sh_css_isp_rgb_gamma_vamem_params *to,
+				 const struct ia_css_rgb_gamma_table *from,
+				 unsigned int size)
 {
 	(void)size;
-	memcpy(&to->gc,  &from->data, sizeof(to->gc));
+	memcpy(&to->gc, &from->data, sizeof(to->gc));
 }
 
-void
-ia_css_b_gamma_vamem_encode(
-    struct sh_css_isp_rgb_gamma_vamem_params *to,
-    const struct ia_css_rgb_gamma_table *from,
-    unsigned int size)
+void ia_css_b_gamma_vamem_encode(struct sh_css_isp_rgb_gamma_vamem_params *to,
+				 const struct ia_css_rgb_gamma_table *from,
+				 unsigned int size)
 {
 	(void)size;
-	memcpy(&to->gc,  &from->data, sizeof(to->gc));
+	memcpy(&to->gc, &from->data, sizeof(to->gc));
 }
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_yuv2rgb_dump(
-    const struct sh_css_isp_csc_params *yuv2rgb,
-    unsigned int level)
+void ia_css_yuv2rgb_dump(const struct sh_css_isp_csc_params *yuv2rgb,
+			 unsigned int level)
 {
 	ia_css_cc_dump(yuv2rgb, level, "YUV to RGB Conversion");
 }
 
-void
-ia_css_rgb2yuv_dump(
-    const struct sh_css_isp_csc_params *rgb2yuv,
-    unsigned int level)
+void ia_css_rgb2yuv_dump(const struct sh_css_isp_csc_params *rgb2yuv,
+			 unsigned int level)
 {
 	ia_css_cc_dump(rgb2yuv, level, "RGB to YUV Conversion");
 }
 
-void
-ia_css_rgb_gamma_table_debug_dtrace(
-    const struct ia_css_rgb_gamma_table *config,
-    unsigned int level)
+void ia_css_rgb_gamma_table_debug_dtrace(
+	const struct ia_css_rgb_gamma_table *config, unsigned int level)
 {
 	(void)config;
 	(void)level;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2.host.h
index a7ac7241d477970cddd4307c801ad3acaefb23db..cf17e721fcc3c8cbd5ce99569d6e194fa2361f2f 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2.host.h
@@ -14,51 +14,35 @@
 extern const struct ia_css_cc_config default_yuv2rgb_cc_config;
 extern const struct ia_css_cc_config default_rgb2yuv_cc_config;
 
-void
-ia_css_yuv2rgb_encode(
-    struct sh_css_isp_csc_params *to,
-    const struct ia_css_cc_config *from,
-    unsigned int size);
+void ia_css_yuv2rgb_encode(struct sh_css_isp_csc_params *to,
+			   const struct ia_css_cc_config *from,
+			   unsigned int size);
 
-void
-ia_css_rgb2yuv_encode(
-    struct sh_css_isp_csc_params *to,
-    const struct ia_css_cc_config *from,
-    unsigned int size);
+void ia_css_rgb2yuv_encode(struct sh_css_isp_csc_params *to,
+			   const struct ia_css_cc_config *from,
+			   unsigned int size);
 
-void
-ia_css_r_gamma_vamem_encode(
-    struct sh_css_isp_rgb_gamma_vamem_params *to,
-    const struct ia_css_rgb_gamma_table *from,
-    unsigned int size);
+void ia_css_r_gamma_vamem_encode(struct sh_css_isp_rgb_gamma_vamem_params *to,
+				 const struct ia_css_rgb_gamma_table *from,
+				 unsigned int size);
 
-void
-ia_css_g_gamma_vamem_encode(
-    struct sh_css_isp_rgb_gamma_vamem_params *to,
-    const struct ia_css_rgb_gamma_table *from,
-    unsigned int size);
+void ia_css_g_gamma_vamem_encode(struct sh_css_isp_rgb_gamma_vamem_params *to,
+				 const struct ia_css_rgb_gamma_table *from,
+				 unsigned int size);
 
-void
-ia_css_b_gamma_vamem_encode(
-    struct sh_css_isp_rgb_gamma_vamem_params *to,
-    const struct ia_css_rgb_gamma_table *from,
-    unsigned int size);
+void ia_css_b_gamma_vamem_encode(struct sh_css_isp_rgb_gamma_vamem_params *to,
+				 const struct ia_css_rgb_gamma_table *from,
+				 unsigned int size);
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_yuv2rgb_dump(
-    const struct sh_css_isp_csc_params *yuv2rgb,
-    unsigned int level);
+void ia_css_yuv2rgb_dump(const struct sh_css_isp_csc_params *yuv2rgb,
+			 unsigned int level);
 
-void
-ia_css_rgb2yuv_dump(
-    const struct sh_css_isp_csc_params *rgb2yuv,
-    unsigned int level);
+void ia_css_rgb2yuv_dump(const struct sh_css_isp_csc_params *rgb2yuv,
+			 unsigned int level);
 
-void
-ia_css_rgb_gamma_table_debug_dtrace(
-    const struct ia_css_rgb_gamma_table *config,
-    unsigned int level);
+void ia_css_rgb_gamma_table_debug_dtrace(
+	const struct ia_css_rgb_gamma_table *config, unsigned int level);
 
 #define ia_css_yuv2rgb_debug_dtrace ia_css_cc_config_debug_dtrace
 #define ia_css_rgb2yuv_debug_dtrace ia_css_cc_config_debug_dtrace
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2_table.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2_table.host.c
index 101f703443ec218662c7f6617a8b7481d799dc3f..04a941ce99180b77d3f039b1d062e408b2f38a53 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2_table.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2_table.host.c
@@ -18,50 +18,41 @@ struct ia_css_rgb_gamma_table default_b_gamma_table;
 
 /* Identical default gamma table for R, G, and B. */
 
-
 static const uint16_t
-default_gamma_table_data[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE] = {
-	0,   72,  144,  216,  288,  360,  426,  486,
-	541,  592,  641,  687,  730,  772,  812,  850,
-	887,  923,  958,  991, 1024, 1055, 1086, 1117,
-	1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
-	1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
-	1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
-	1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
-	1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
-	2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
-	2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
-	2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
-	2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
-	2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
-	2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
-	2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
-	2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
-	2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
-	2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
-	3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
-	3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
-	3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
-	3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
-	3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
-	3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
-	3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
-	3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
-	3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
-	3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
-	3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
-	3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
-	3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
-	4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
-	4095
-};
+	default_gamma_table_data[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE] = {
+		0,    72,   144,  216,	288,  360,  426,  486,	541,  592,
+		641,  687,  730,  772,	812,  850,  887,  923,	958,  991,
+		1024, 1055, 1086, 1117, 1146, 1175, 1203, 1230, 1257, 1284,
+		1310, 1335, 1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
+		1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694, 1714, 1734,
+		1753, 1772, 1792, 1811, 1829, 1848, 1866, 1884, 1902, 1920,
+		1938, 1955, 1973, 1990, 2007, 2024, 2040, 2057, 2074, 2090,
+		2106, 2122, 2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
+		2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364, 2378, 2393,
+		2407, 2421, 2435, 2449, 2462, 2476, 2490, 2503, 2517, 2530,
+		2543, 2557, 2570, 2583, 2596, 2609, 2622, 2634, 2647, 2660,
+		2673, 2685, 2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
+		2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878, 2890, 2901,
+		2913, 2924, 2936, 2947, 2958, 2970, 2981, 2992, 3003, 3014,
+		3025, 3036, 3047, 3058, 3069, 3080, 3091, 3102, 3112, 3123,
+		3134, 3144, 3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
+		3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309, 3319, 3329,
+		3339, 3349, 3358, 3368, 3378, 3388, 3398, 3407, 3417, 3427,
+		3436, 3446, 3455, 3465, 3474, 3484, 3493, 3503, 3512, 3521,
+		3531, 3540, 3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
+		3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686, 3694, 3703,
+		3712, 3721, 3730, 3739, 3747, 3756, 3765, 3773, 3782, 3791,
+		3799, 3808, 3816, 3825, 3833, 3842, 3850, 3859, 3867, 3876,
+		3884, 3893, 3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
+		3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024, 4032, 4040,
+		4048, 4056, 4064, 4072, 4080, 4088, 4095
+	};
 
-void
-ia_css_config_rgb_gamma_tables(void)
+void ia_css_config_rgb_gamma_tables(void)
 {
-	default_r_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_2;
-	default_g_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_2;
-	default_b_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_2;
+	default_r_gamma_table.vamem_type = IA_CSS_VAMEM_TYPE_2;
+	default_g_gamma_table.vamem_type = IA_CSS_VAMEM_TYPE_2;
+	default_b_gamma_table.vamem_type = IA_CSS_VAMEM_TYPE_2;
 	memcpy(default_r_gamma_table.data.vamem_2, default_gamma_table_data,
 	       sizeof(default_gamma_table_data));
 	memcpy(default_g_gamma_table.data.vamem_2, default_gamma_table_data,
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2_types.h
index abb0d3d871b3111268f62b3a2544126232454de0..9f875a4cd77846b3896997000314cf6d6aff4a00 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/gc/gc_2/ia_css_gc2_types.h
@@ -7,7 +7,7 @@
 #ifndef __IA_CSS_GC2_TYPES_H
 #define __IA_CSS_GC2_TYPES_H
 
-#include "isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h"  /* FIXME: needed for ia_css_vamem_type */
+#include "isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h" /* FIXME: needed for ia_css_vamem_type */
 
 /* @file
 * CSS-API header file for Gamma Correction parameters.
@@ -22,11 +22,13 @@
 
 /* Number of elements in the sRGB gamma table. */
 #define IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE_LOG2 8
-#define IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE      BIT(IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE_LOG2)
+#define IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE \
+	BIT(IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE_LOG2)
 
 /* Number of elements in the sRGB gamma table. */
-#define IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE_LOG2    8
-#define IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE     ((1U << IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE_LOG2) + 1)
+#define IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE_LOG2 8
+#define IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE \
+	((1U << IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE_LOG2) + 1)
 
 /** IA_CSS_VAMEM_TYPE_1(ISP2300) or
      IA_CSS_VAMEM_TYPE_2(ISP2400) */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr.host.c
index 7a53928ef26c6bcd6d61cb95974f1795229d43fc..d9fc7d67884ea29ef426bf89b5fd761ae4803d86 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr.host.c
@@ -7,26 +7,24 @@
 
 #include "ia_css_hdr.host.h"
 
-void
-ia_css_hdr_init_config(
-    struct sh_css_isp_hdr_params *to,
-    const struct ia_css_hdr_config *from,
-    unsigned int size)
+void ia_css_hdr_init_config(struct sh_css_isp_hdr_params *to,
+			    const struct ia_css_hdr_config *from,
+			    unsigned int size)
 {
 	int i;
 	(void)size;
 
 	for (i = 0; i < HDR_NUM_INPUT_FRAMES - 1; i++) {
 		to->irradiance.match_shift[i] = from->irradiance.match_shift[i];
-		to->irradiance.match_mul[i]   = from->irradiance.match_mul[i];
-		to->irradiance.thr_low[i]     = from->irradiance.thr_low[i];
-		to->irradiance.thr_high[i]    = from->irradiance.thr_high[i];
-		to->irradiance.thr_coeff[i]   = from->irradiance.thr_coeff[i];
-		to->irradiance.thr_shift[i]   = from->irradiance.thr_shift[i];
+		to->irradiance.match_mul[i] = from->irradiance.match_mul[i];
+		to->irradiance.thr_low[i] = from->irradiance.thr_low[i];
+		to->irradiance.thr_high[i] = from->irradiance.thr_high[i];
+		to->irradiance.thr_coeff[i] = from->irradiance.thr_coeff[i];
+		to->irradiance.thr_shift[i] = from->irradiance.thr_shift[i];
 	}
-	to->irradiance.test_irr    = from->irradiance.test_irr;
-	to->irradiance.weight_bpp  = from->irradiance.weight_bpp;
+	to->irradiance.test_irr = from->irradiance.test_irr;
+	to->irradiance.weight_bpp = from->irradiance.weight_bpp;
 
-	to->deghost.test_deg    = from->deghost.test_deg;
+	to->deghost.test_deg = from->deghost.test_deg;
 	to->exclusion.test_excl = from->exclusion.test_excl;
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr.host.h
index 916b72b082ecfd7a394557c3b74f88d6c12d2385..1bd79ac74ebea872ba3a5cf3d140ff8ab06c9efa 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr.host.h
@@ -13,10 +13,8 @@
 
 extern const struct ia_css_hdr_config default_hdr_config;
 
-void
-ia_css_hdr_init_config(
-    struct sh_css_isp_hdr_params *to,
-    const struct ia_css_hdr_config *from,
-    unsigned int size);
+void ia_css_hdr_init_config(struct sh_css_isp_hdr_params *to,
+			    const struct ia_css_hdr_config *from,
+			    unsigned int size);
 
 #endif /* __IA_CSS_HDR_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr_param.h
index da787654440cd845e28cb53acee3707ef2346ca0..ea2329a2594824074cc013325facf68f6f178254 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr_param.h
@@ -10,24 +10,24 @@
 
 #include "type_support.h"
 
-#define HDR_NUM_INPUT_FRAMES         (3)
+#define HDR_NUM_INPUT_FRAMES (3)
 
 /* HDR irradiance map parameters on ISP. */
 struct sh_css_hdr_irradiance_params {
 	s32 test_irr;
 	s32 match_shift[HDR_NUM_INPUT_FRAMES -
-					     1];  /* Histogram matching shift parameter */
+			1]; /* Histogram matching shift parameter */
 	s32 match_mul[HDR_NUM_INPUT_FRAMES -
-					   1];    /* Histogram matching multiplication parameter */
+		      1]; /* Histogram matching multiplication parameter */
 	s32 thr_low[HDR_NUM_INPUT_FRAMES -
-					 1];      /* Weight map soft threshold low bound parameter */
+		    1]; /* Weight map soft threshold low bound parameter */
 	s32 thr_high[HDR_NUM_INPUT_FRAMES -
-					  1];     /* Weight map soft threshold high bound parameter */
+		     1]; /* Weight map soft threshold high bound parameter */
 	s32 thr_coeff[HDR_NUM_INPUT_FRAMES -
-					   1];    /* Soft threshold linear function coefficient */
+		      1]; /* Soft threshold linear function coefficient */
 	s32 thr_shift[HDR_NUM_INPUT_FRAMES -
-					   1];    /* Soft threshold precision shift parameter */
-	s32 weight_bpp;                             /* Weight map bits per pixel */
+		      1]; /* Soft threshold precision shift parameter */
+	s32 weight_bpp; /* Weight map bits per pixel */
 };
 
 /* HDR deghosting parameters on ISP */
@@ -43,8 +43,8 @@ struct sh_css_hdr_exclusion_params {
 /* HDR ISP parameters */
 struct sh_css_isp_hdr_params {
 	struct sh_css_hdr_irradiance_params irradiance;
-	struct sh_css_hdr_deghost_params    deghost;
-	struct sh_css_hdr_exclusion_params  exclusion;
+	struct sh_css_hdr_deghost_params deghost;
+	struct sh_css_hdr_exclusion_params exclusion;
 };
 
 #endif /* __IA_CSS_HDR_PARAMS_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr_types.h
index e32290d1c86b0922f1391a90e2f9d4f4be49f6b0..078e14afa1cc2f398b9d55285014078844af19ae 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/hdr/ia_css_hdr_types.h
@@ -8,27 +8,27 @@
 #ifndef __IA_CSS_HDR_TYPES_H
 #define __IA_CSS_HDR_TYPES_H
 
-#define IA_CSS_HDR_MAX_NUM_INPUT_FRAMES         (3)
+#define IA_CSS_HDR_MAX_NUM_INPUT_FRAMES (3)
 
 /**
  * \brief HDR Irradiance Parameters
  * \detail Currently HDR parameters are used only for testing purposes
  */
 struct ia_css_hdr_irradiance_params {
-	int test_irr;                                          /** Test parameter */
+	int test_irr; /** Test parameter */
 	int match_shift[IA_CSS_HDR_MAX_NUM_INPUT_FRAMES -
-							1];  /** Histogram matching shift parameter */
+			1]; /** Histogram matching shift parameter */
 	int match_mul[IA_CSS_HDR_MAX_NUM_INPUT_FRAMES -
-						      1];    /** Histogram matching multiplication parameter */
+		      1]; /** Histogram matching multiplication parameter */
 	int thr_low[IA_CSS_HDR_MAX_NUM_INPUT_FRAMES -
-						    1];      /** Weight map soft threshold low bound parameter */
+		    1]; /** Weight map soft threshold low bound parameter */
 	int thr_high[IA_CSS_HDR_MAX_NUM_INPUT_FRAMES -
-						     1];     /** Weight map soft threshold high bound parameter */
+		     1]; /** Weight map soft threshold high bound parameter */
 	int thr_coeff[IA_CSS_HDR_MAX_NUM_INPUT_FRAMES -
-						      1];    /** Soft threshold linear function coefficien */
+		      1]; /** Soft threshold linear function coefficien */
 	int thr_shift[IA_CSS_HDR_MAX_NUM_INPUT_FRAMES -
-						      1];    /** Soft threshold precision shift parameter */
-	int weight_bpp;                                        /** Weight map bits per pixel */
+		      1]; /** Soft threshold precision shift parameter */
+	int weight_bpp; /** Weight map bits per pixel */
 };
 
 /**
@@ -53,9 +53,11 @@ struct ia_css_hdr_exclusion_params {
  * the CSS API. Currently, only test parameters are defined.
  */
 struct ia_css_hdr_config {
-	struct ia_css_hdr_irradiance_params irradiance; /** HDR irradiance parameters */
-	struct ia_css_hdr_deghost_params    deghost;    /** HDR deghosting parameters */
-	struct ia_css_hdr_exclusion_params  exclusion; /** HDR exclusion parameters */
+	struct ia_css_hdr_irradiance_params
+		irradiance; /** HDR irradiance parameters */
+	struct ia_css_hdr_deghost_params deghost; /** HDR deghosting parameters */
+	struct ia_css_hdr_exclusion_params
+		exclusion; /** HDR exclusion parameters */
 };
 
 #endif /* __IA_CSS_HDR_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.c
index 38f371b6d6d5860d1e61ba0edbe9d2fc017d6de7..5be15760ec73f3559816fba22488af5cb8549318 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.c
@@ -15,13 +15,14 @@
 #include "ia_css_isp_params.h"
 #include "ia_css_frame.h"
 
-int ia_css_bayer_io_config(const struct ia_css_binary      *binary,
+int ia_css_bayer_io_config(const struct ia_css_binary *binary,
 			   const struct sh_css_binary_args *args)
 {
 	const struct ia_css_frame *in_frame = args->in_frame;
-	const struct ia_css_frame **out_frames = (const struct ia_css_frame **)
-		&args->out_frame;
-	const struct ia_css_frame_info *in_frame_info = ia_css_frame_get_info(in_frame);
+	const struct ia_css_frame **out_frames =
+		(const struct ia_css_frame **)&args->out_frame;
+	const struct ia_css_frame_info *in_frame_info =
+		ia_css_frame_get_info(in_frame);
 	const unsigned int ddr_elems_per_word =
 		DIV_ROUND_UP(HIVE_ISP_DDR_WORD_BITS, BITS_PER_TYPE(short));
 	unsigned int size_get = 0, size_put = 0;
@@ -29,17 +30,23 @@ int ia_css_bayer_io_config(const struct ia_css_binary      *binary,
 	int ret;
 
 	if (binary->info->mem_offsets.offsets.param) {
-		size_get = binary->info->mem_offsets.offsets.param->dmem.get.size;
-		offset = binary->info->mem_offsets.offsets.param->dmem.get.offset;
+		size_get =
+			binary->info->mem_offsets.offsets.param->dmem.get.size;
+		offset =
+			binary->info->mem_offsets.offsets.param->dmem.get.offset;
 	}
 
 	if (size_get) {
-		struct ia_css_common_io_config *to = (struct ia_css_common_io_config *)
-						     &binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset];
+		struct ia_css_common_io_config *to =
+			(struct ia_css_common_io_config *)&binary->mem_params
+				.params[IA_CSS_PARAM_CLASS_PARAM]
+				       [IA_CSS_ISP_DMEM]
+				.address[offset];
 		struct dma_port_config config;
 #ifndef IA_CSS_NO_DEBUG
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "ia_css_bayer_io_config() get part enter:\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_bayer_io_config() get part enter:\n");
 #endif
 
 		ret = ia_css_dma_configure_from_info(&config, in_frame_info);
@@ -51,26 +58,34 @@ int ia_css_bayer_io_config(const struct ia_css_binary      *binary,
 		to->stride = config.stride;
 		to->ddr_elems_per_word = ddr_elems_per_word;
 #ifndef IA_CSS_NO_DEBUG
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "ia_css_bayer_io_config() get part leave:\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_bayer_io_config() get part leave:\n");
 #endif
 	}
 
 	if (binary->info->mem_offsets.offsets.param) {
-		size_put = binary->info->mem_offsets.offsets.param->dmem.put.size;
-		offset = binary->info->mem_offsets.offsets.param->dmem.put.offset;
+		size_put =
+			binary->info->mem_offsets.offsets.param->dmem.put.size;
+		offset =
+			binary->info->mem_offsets.offsets.param->dmem.put.offset;
 	}
 
 	if (size_put) {
-		struct ia_css_common_io_config *to = (struct ia_css_common_io_config *)
-						     &binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset];
+		struct ia_css_common_io_config *to =
+			(struct ia_css_common_io_config *)&binary->mem_params
+				.params[IA_CSS_PARAM_CLASS_PARAM]
+				       [IA_CSS_ISP_DMEM]
+				.address[offset];
 		struct dma_port_config config;
 #ifndef IA_CSS_NO_DEBUG
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "ia_css_bayer_io_config() put part enter:\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_bayer_io_config() put part enter:\n");
 #endif
 
-		ret = ia_css_dma_configure_from_info(&config, &out_frames[0]->frame_info);
+		ret = ia_css_dma_configure_from_info(
+			&config, &out_frames[0]->frame_info);
 		if (ret)
 			return ret;
 		to->base_address = out_frames[0]->data;
@@ -80,8 +95,9 @@ int ia_css_bayer_io_config(const struct ia_css_binary      *binary,
 		to->ddr_elems_per_word = ddr_elems_per_word;
 
 #ifndef IA_CSS_NO_DEBUG
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "ia_css_bayer_io_config() put part leave:\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_bayer_io_config() put part leave:\n");
 #endif
 	}
 	return 0;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.h
index 3c82bbd79c4ca9704fb1115bc40fbdcf888a71dc..66fd3f3ba88c44f6e944b570d125fa3ce4cc6a37 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.h
@@ -12,7 +12,7 @@
 #include "ia_css_binary.h"
 #include "sh_css_internal.h"
 
-int ia_css_bayer_io_config(const struct ia_css_binary     *binary,
+int ia_css_bayer_io_config(const struct ia_css_binary *binary,
 			   const struct sh_css_binary_args *args);
 
 #endif /*__BAYER_IO_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/yuv444_io_ls/ia_css_yuv444_io.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/yuv444_io_ls/ia_css_yuv444_io.host.c
index 13054ffc0b358f76f07ceb470aac69858cb5b821..5f93d31686b94c20212d8b67ad99a6a3d3fd957c 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/yuv444_io_ls/ia_css_yuv444_io.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/yuv444_io_ls/ia_css_yuv444_io.host.c
@@ -16,13 +16,14 @@ Copyright (c) 2010 - 2015, Intel Corporation.
 #include "ia_css_isp_params.h"
 #include "ia_css_frame.h"
 
-int ia_css_yuv444_io_config(const struct ia_css_binary      *binary,
+int ia_css_yuv444_io_config(const struct ia_css_binary *binary,
 			    const struct sh_css_binary_args *args)
 {
 	const struct ia_css_frame *in_frame = args->in_frame;
-	const struct ia_css_frame **out_frames = (const struct ia_css_frame **)
-		&args->out_frame;
-	const struct ia_css_frame_info *in_frame_info = ia_css_frame_get_info(in_frame);
+	const struct ia_css_frame **out_frames =
+		(const struct ia_css_frame **)&args->out_frame;
+	const struct ia_css_frame_info *in_frame_info =
+		ia_css_frame_get_info(in_frame);
 	const unsigned int ddr_elems_per_word =
 		DIV_ROUND_UP(HIVE_ISP_DDR_WORD_BITS, BITS_PER_TYPE(short));
 	unsigned int size_get = 0, size_put = 0;
@@ -30,17 +31,23 @@ int ia_css_yuv444_io_config(const struct ia_css_binary      *binary,
 	int ret;
 
 	if (binary->info->mem_offsets.offsets.param) {
-		size_get = binary->info->mem_offsets.offsets.param->dmem.get.size;
-		offset = binary->info->mem_offsets.offsets.param->dmem.get.offset;
+		size_get =
+			binary->info->mem_offsets.offsets.param->dmem.get.size;
+		offset =
+			binary->info->mem_offsets.offsets.param->dmem.get.offset;
 	}
 
 	if (size_get) {
-		struct ia_css_common_io_config *to = (struct ia_css_common_io_config *)
-						     &binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset];
+		struct ia_css_common_io_config *to =
+			(struct ia_css_common_io_config *)&binary->mem_params
+				.params[IA_CSS_PARAM_CLASS_PARAM]
+				       [IA_CSS_ISP_DMEM]
+				.address[offset];
 		struct dma_port_config config;
 #ifndef IA_CSS_NO_DEBUG
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "ia_css_yuv444_io_config() get part enter:\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_yuv444_io_config() get part enter:\n");
 #endif
 
 		ret = ia_css_dma_configure_from_info(&config, in_frame_info);
@@ -53,26 +60,34 @@ int ia_css_yuv444_io_config(const struct ia_css_binary      *binary,
 		to->stride = config.stride;
 		to->ddr_elems_per_word = ddr_elems_per_word;
 #ifndef IA_CSS_NO_DEBUG
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "ia_css_yuv444_io_config() get part leave:\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_yuv444_io_config() get part leave:\n");
 #endif
 	}
 
 	if (binary->info->mem_offsets.offsets.param) {
-		size_put = binary->info->mem_offsets.offsets.param->dmem.put.size;
-		offset = binary->info->mem_offsets.offsets.param->dmem.put.offset;
+		size_put =
+			binary->info->mem_offsets.offsets.param->dmem.put.size;
+		offset =
+			binary->info->mem_offsets.offsets.param->dmem.put.offset;
 	}
 
 	if (size_put) {
-		struct ia_css_common_io_config *to = (struct ia_css_common_io_config *)
-						     &binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset];
+		struct ia_css_common_io_config *to =
+			(struct ia_css_common_io_config *)&binary->mem_params
+				.params[IA_CSS_PARAM_CLASS_PARAM]
+				       [IA_CSS_ISP_DMEM]
+				.address[offset];
 		struct dma_port_config config;
 #ifndef IA_CSS_NO_DEBUG
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "ia_css_yuv444_io_config() put part enter:\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_yuv444_io_config() put part enter:\n");
 #endif
 
-		ret = ia_css_dma_configure_from_info(&config, &out_frames[0]->frame_info);
+		ret = ia_css_dma_configure_from_info(
+			&config, &out_frames[0]->frame_info);
 		if (ret)
 			return ret;
 
@@ -83,8 +98,9 @@ int ia_css_yuv444_io_config(const struct ia_css_binary      *binary,
 		to->ddr_elems_per_word = ddr_elems_per_word;
 
 #ifndef IA_CSS_NO_DEBUG
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "ia_css_yuv444_io_config() put part leave:\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_yuv444_io_config() put part leave:\n");
 #endif
 	}
 	return 0;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/yuv444_io_ls/ia_css_yuv444_io.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/yuv444_io_ls/ia_css_yuv444_io.host.h
index e6ce0cba44b95210402cde21e8918a4b6fcdae3b..af7c9703fb7f37c00e0a3d3ca2130425b0edfbea 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/yuv444_io_ls/ia_css_yuv444_io.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ipu2_io_ls/yuv444_io_ls/ia_css_yuv444_io.host.h
@@ -13,7 +13,7 @@ Copyright (c) 2010 - 2015, Intel Corporation.
 #include "ia_css_binary.h"
 #include "sh_css_internal.h"
 
-int ia_css_yuv444_io_config(const struct ia_css_binary     *binary,
+int ia_css_yuv444_io_config(const struct ia_css_binary *binary,
 			    const struct sh_css_binary_args *args);
 
 #endif /*__YUV44_IO_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
index b8ba26f56cfabe34f8733d7fc5eebeb854e12c62..5b2f01b3f7d00d086a33a841c060b5bf7d8bdae8 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
@@ -15,18 +15,18 @@ static const struct ia_css_iterator_configuration default_config = {
 	.input_info = (struct ia_css_frame_info *)NULL,
 };
 
-void
-ia_css_iterator_config(
-    struct sh_css_isp_iterator_isp_config *to,
-    const struct ia_css_iterator_configuration *from,
-    unsigned int size)
+void ia_css_iterator_config(struct sh_css_isp_iterator_isp_config *to,
+			    const struct ia_css_iterator_configuration *from,
+			    unsigned int size)
 {
 	(void)size;
-	ia_css_frame_info_to_frame_sp_info(&to->input_info,    from->input_info);
-	ia_css_frame_info_to_frame_sp_info(&to->internal_info, from->internal_info);
-	ia_css_frame_info_to_frame_sp_info(&to->output_info,   from->output_info);
-	ia_css_frame_info_to_frame_sp_info(&to->vf_info,       from->vf_info);
-	ia_css_resolution_to_sp_resolution(&to->dvs_envelope,  from->dvs_envelope);
+	ia_css_frame_info_to_frame_sp_info(&to->input_info, from->input_info);
+	ia_css_frame_info_to_frame_sp_info(&to->internal_info,
+					   from->internal_info);
+	ia_css_frame_info_to_frame_sp_info(&to->output_info, from->output_info);
+	ia_css_frame_info_to_frame_sp_info(&to->vf_info, from->vf_info);
+	ia_css_resolution_to_sp_resolution(&to->dvs_envelope,
+					   from->dvs_envelope);
 }
 
 int ia_css_iterator_configure(const struct ia_css_binary *binary,
@@ -35,11 +35,11 @@ int ia_css_iterator_configure(const struct ia_css_binary *binary,
 	struct ia_css_frame_info my_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;
 	struct ia_css_iterator_configuration config = default_config;
 
-	config.input_info    = &binary->in_frame_info;
+	config.input_info = &binary->in_frame_info;
 	config.internal_info = &binary->internal_frame_info;
-	config.output_info   = &binary->out_frame_info[0];
-	config.vf_info       = &binary->vf_frame_info;
-	config.dvs_envelope  = &binary->dvs_envelope;
+	config.output_info = &binary->out_frame_info[0];
+	config.vf_info = &binary->vf_frame_info;
+	config.dvs_envelope = &binary->dvs_envelope;
 
 	/* Use in_info iso binary->in_frame_info.
 	 * They can differ in padded width in case of scaling, e.g. for capture_pp.
@@ -60,8 +60,8 @@ int ia_css_iterator_configure(const struct ia_css_binary *binary,
 		/* TODO: Remove this after preview output decimation is fixed
 		 * by configuring out&vf info files properly */
 		my_info.padded_width <<= binary->vf_downscale_log2;
-		my_info.res.width    <<= binary->vf_downscale_log2;
-		my_info.res.height   <<= binary->vf_downscale_log2;
+		my_info.res.width <<= binary->vf_downscale_log2;
+		my_info.res.height <<= binary->vf_downscale_log2;
 	}
 
 	return ia_css_configure_iterator(binary, &config);
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
index 01b1dc76651a8270d0ac7d9afa9da465887f54d7..90fb3246b4dcee09b9c820704be10f65af7c738d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
@@ -12,15 +12,11 @@
 #include "ia_css_err.h"
 #include "ia_css_iterator_param.h"
 
-void
-ia_css_iterator_config(
-    struct sh_css_isp_iterator_isp_config *to,
-    const struct ia_css_iterator_configuration *from,
-    unsigned int size);
+void ia_css_iterator_config(struct sh_css_isp_iterator_isp_config *to,
+			    const struct ia_css_iterator_configuration *from,
+			    unsigned int size);
 
-int
-ia_css_iterator_configure(
-    const struct ia_css_binary *binary,
-    const struct ia_css_frame_info *in_info);
+int ia_css_iterator_configure(const struct ia_css_binary *binary,
+			      const struct ia_css_frame_info *in_info);
 
 #endif /* __IA_CSS_ITERATOR_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5.host.c
index c4f3afb8582858b52b38d2c630da5de00bef510a..f0d4c3fc6ac01a5e5bf5e0fa91d67c0c9a3f2c3e 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5.host.c
@@ -14,37 +14,30 @@
 
 #include "ia_css_macc1_5.host.h"
 
-const struct ia_css_macc1_5_config default_macc1_5_config = {
-	1
-};
+const struct ia_css_macc1_5_config default_macc1_5_config = { 1 };
 
-void
-ia_css_macc1_5_encode(
-    struct sh_css_isp_macc1_5_params *to,
-    const struct ia_css_macc1_5_config *from,
-    unsigned int size)
+void ia_css_macc1_5_encode(struct sh_css_isp_macc1_5_params *to,
+			   const struct ia_css_macc1_5_config *from,
+			   unsigned int size)
 {
 	(void)size;
 	to->exp = from->exp;
 }
 
-void
-ia_css_macc1_5_vmem_encode(
-    struct sh_css_isp_macc1_5_vmem_params *params,
-    const struct ia_css_macc1_5_table *from,
-    unsigned int size)
+void ia_css_macc1_5_vmem_encode(struct sh_css_isp_macc1_5_vmem_params *params,
+				const struct ia_css_macc1_5_table *from,
+				unsigned int size)
 {
 	unsigned int i, j, k, idx;
-	static const unsigned int idx_map[] = {
-		0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8
-	};
+	static const unsigned int idx_map[] = { 0,  1,	3,  2,	6,  7,	5, 4,
+						12, 13, 15, 14, 10, 11, 9, 8 };
 
 	(void)size;
 
 	for (k = 0; k < 4; k++)
 		for (i = 0; i < IA_CSS_MACC_NUM_AXES; i++) {
 			idx = idx_map[i] + (k * IA_CSS_MACC_NUM_AXES);
-			j   = 4 * i;
+			j = 4 * i;
 
 			params->data[0][(idx)] = from->data[j];
 			params->data[1][(idx)] = from->data[j + 1];
@@ -54,13 +47,9 @@ ia_css_macc1_5_vmem_encode(
 }
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_macc1_5_debug_dtrace(
-    const struct ia_css_macc1_5_config *config,
-    unsigned int level)
+void ia_css_macc1_5_debug_dtrace(const struct ia_css_macc1_5_config *config,
+				 unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.exp=%d\n",
-			    config->exp);
+	ia_css_debug_dtrace(level, "config.exp=%d\n", config->exp);
 }
 #endif
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5.host.h
index 631839aa3c5726cd7d365604966378ce9c82f764..89623118023c5fbea944a217de2927dec32e3fee 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5.host.h
@@ -12,22 +12,16 @@
 
 extern const struct ia_css_macc1_5_config default_macc1_5_config;
 
-void
-ia_css_macc1_5_encode(
-    struct sh_css_isp_macc1_5_params *to,
-    const struct ia_css_macc1_5_config *from,
-    unsigned int size);
+void ia_css_macc1_5_encode(struct sh_css_isp_macc1_5_params *to,
+			   const struct ia_css_macc1_5_config *from,
+			   unsigned int size);
 
-void
-ia_css_macc1_5_vmem_encode(
-    struct sh_css_isp_macc1_5_vmem_params *params,
-    const struct ia_css_macc1_5_table *from,
-    unsigned int size);
+void ia_css_macc1_5_vmem_encode(struct sh_css_isp_macc1_5_vmem_params *params,
+				const struct ia_css_macc1_5_table *from,
+				unsigned int size);
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_macc1_5_debug_dtrace(
-    const struct ia_css_macc1_5_config *config,
-    unsigned int level);
+void ia_css_macc1_5_debug_dtrace(const struct ia_css_macc1_5_config *config,
+				 unsigned int level);
 #endif
 #endif /* __IA_CSS_MACC1_5_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_param.h
index 0f38cd7ea9b183b1b49dfd8f18de94972f39cc44..1e985ca96244db74cde042853d1b3fd88523ee48 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_param.h
@@ -17,7 +17,7 @@ struct sh_css_isp_macc1_5_params {
 };
 
 struct sh_css_isp_macc1_5_vmem_params {
-	VMEM_ARRAY(data, IA_CSS_MACC_NUM_COEFS * ISP_NWAY);
+	VMEM_ARRAY(data, IA_CSS_MACC_NUM_COEFS *ISP_NWAY);
 };
 
 #endif /* __IA_CSS_MACC1_5_PARAM_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_table.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_table.host.c
index aea74be18fe9549a2cfe56ede7b9a5bbada40f11..53a3c368dd98aeee9631e20e1c5505b289c1d40d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_table.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_table.host.c
@@ -13,14 +13,10 @@
  *	ineffective: 16 of "identity 2x2 matix" {4096,0,0,4096}
  */
 const struct ia_css_macc1_5_table default_macc1_5_table = {
-	{
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096
-	}
+	{ 4096, 0,    0,    4096, 4096, 0,    0,    4096, 4096, 0,    0,
+	  4096, 4096, 0,    0,	  4096, 4096, 0,    0,	  4096, 4096, 0,
+	  0,	4096, 4096, 0,	  0,	4096, 4096, 0,	  0,	4096, 4096,
+	  0,	0,    4096, 4096, 0,	0,    4096, 4096, 0,	0,    4096,
+	  4096, 0,    0,    4096, 4096, 0,    0,    4096, 4096, 0,    0,
+	  4096, 4096, 0,    0,	  4096, 4096, 0,    0,	  4096 }
 };
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h
index b0538808ae561be4a43c6fa724202eccc8b149ff..9014890fa914cb29a1105b8e6a286a9cc299fcbe 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h
@@ -17,9 +17,9 @@
  */
 
 /* Number of axes in the MACC table. */
-#define IA_CSS_MACC_NUM_AXES           16
+#define IA_CSS_MACC_NUM_AXES 16
 /* Number of coefficients per MACC axes. */
-#define IA_CSS_MACC_NUM_COEFS          4
+#define IA_CSS_MACC_NUM_COEFS 4
 
 /* Multi-Axes Color Correction (MACC) table.
  *
@@ -58,7 +58,7 @@ struct ia_css_macc1_5_table {
  *  ISP2: MACC1_5 is used.
  */
 struct ia_css_macc1_5_config {
-	u8 exp;	/** Common exponent of ia_css_macc_table.
+	u8 exp; /** Common exponent of ia_css_macc_table.
 				u8.0, [0,13], default 1, ineffective 1 */
 };
 
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc.host.c
index 6e2159f7b395b9d32f802d7991dd3d01dc216fcf..491f90f37c49c23d8e59a8c055214a332a90f8fa 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc.host.c
@@ -15,27 +15,19 @@ const struct ia_css_macc_config default_macc_config = {
 	1,
 };
 
-void
-ia_css_macc_encode(
-    struct sh_css_isp_macc_params *to,
-    const struct ia_css_macc_config *from,
-    unsigned int size)
+void ia_css_macc_encode(struct sh_css_isp_macc_params *to,
+			const struct ia_css_macc_config *from,
+			unsigned int size)
 {
 	(void)size;
 	to->exp = from->exp;
 }
 
-void
-ia_css_macc_dump(
-    const struct sh_css_isp_macc_params *macc,
-    unsigned int level);
+void ia_css_macc_dump(const struct sh_css_isp_macc_params *macc,
+		      unsigned int level);
 
-void
-ia_css_macc_debug_dtrace(
-    const struct ia_css_macc_config *config,
-    unsigned int level)
+void ia_css_macc_debug_dtrace(const struct ia_css_macc_config *config,
+			      unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.exp=%d\n",
-			    config->exp);
+	ia_css_debug_dtrace(level, "config.exp=%d\n", config->exp);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc.host.h
index faba2dc79ed3f1284a6c6db09f5c787188b2e731..dbda201e64877187b1c992dd673c31305efea964 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc.host.h
@@ -14,20 +14,14 @@
 
 extern const struct ia_css_macc_config default_macc_config;
 
-void
-ia_css_macc_encode(
-    struct sh_css_isp_macc_params *to,
-    const struct ia_css_macc_config *from,
-    unsigned int size);
-
-void
-ia_css_macc_dump(
-    const struct sh_css_isp_macc_params *macc,
-    unsigned int level);
-
-void
-ia_css_macc_debug_dtrace(
-    const struct ia_css_macc_config *config,
-    unsigned int level);
+void ia_css_macc_encode(struct sh_css_isp_macc_params *to,
+			const struct ia_css_macc_config *from,
+			unsigned int size);
+
+void ia_css_macc_dump(const struct sh_css_isp_macc_params *macc,
+		      unsigned int level);
+
+void ia_css_macc_debug_dtrace(const struct ia_css_macc_config *config,
+			      unsigned int level);
 
 #endif /* __IA_CSS_MACC_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc_table.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc_table.host.c
index 1720fa9d4f7244c71e277486dea1f0c57a5c7a02..8f7730dc6631577c46368927b355e6961492a166 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc_table.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc_table.host.c
@@ -13,16 +13,12 @@
  *	ineffective: 16 of "identity 2x2 matrix" {8192,0,0,8192}
  */
 const struct ia_css_macc_table default_macc_table = {
-	{
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192
-	}
+	{ 8192, 0,    0,    8192, 8192, 0,    0,    8192, 8192, 0,    0,
+	  8192, 8192, 0,    0,	  8192, 8192, 0,    0,	  8192, 8192, 0,
+	  0,	8192, 8192, 0,	  0,	8192, 8192, 0,	  0,	8192, 8192,
+	  0,	0,    8192, 8192, 0,	0,    8192, 8192, 0,	0,    8192,
+	  8192, 0,    0,    8192, 8192, 0,    0,    8192, 8192, 0,    0,
+	  8192, 8192, 0,    0,	  8192, 8192, 0,    0,	  8192 }
 };
 
 /* Multi-Axes Color Correction table for ISP2.
@@ -30,14 +26,10 @@ const struct ia_css_macc_table default_macc_table = {
  *	ineffective: 16 of "identity 2x2 matrix" {4096,0,0,4096}
  */
 const struct ia_css_macc_table default_macc2_table = {
-	{
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096,
-		4096, 0, 0, 4096, 4096, 0, 0, 4096
-	}
+	{ 4096, 0,    0,    4096, 4096, 0,    0,    4096, 4096, 0,    0,
+	  4096, 4096, 0,    0,	  4096, 4096, 0,    0,	  4096, 4096, 0,
+	  0,	4096, 4096, 0,	  0,	4096, 4096, 0,	  0,	4096, 4096,
+	  0,	0,    4096, 4096, 0,	0,    4096, 4096, 0,	0,    4096,
+	  4096, 0,    0,    4096, 4096, 0,    0,    4096, 4096, 0,    0,
+	  4096, 4096, 0,    0,	  4096, 4096, 0,    0,	  4096 }
 };
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc_types.h
index 20e34f53bec248245367a0bdf8c21a8106cf55f3..9dec00bc25b65d11d483415bb54d5a506308ac91 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/macc/macc_1.0/ia_css_macc_types.h
@@ -12,9 +12,9 @@
 */
 
 /* Number of axes in the MACC table. */
-#define IA_CSS_MACC_NUM_AXES           16
+#define IA_CSS_MACC_NUM_AXES 16
 /* Number of coefficients per MACC axes. */
-#define IA_CSS_MACC_NUM_COEFS          4
+#define IA_CSS_MACC_NUM_COEFS 4
 /* The number of planes in the morphing table. */
 
 /* Multi-Axis Color Correction (MACC) table.
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2.host.c
index 5c9e56a0bd599f4c0bfea242e15c11f322247c28..245262b8eb2cc12b4c9c3d8bff3c3b34b49d9c51 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2.host.c
@@ -13,56 +13,47 @@
 #include "isp.h"
 #include "ia_css_ob2.host.h"
 
-const struct ia_css_ob2_config default_ob2_config = {
-	0,
-	0,
-	0,
-	0
-};
+const struct ia_css_ob2_config default_ob2_config = { 0, 0, 0, 0 };
 
-void
-ia_css_ob2_encode(
-    struct sh_css_isp_ob2_params *to,
-    const struct ia_css_ob2_config *from,
-    unsigned int size)
+void ia_css_ob2_encode(struct sh_css_isp_ob2_params *to,
+		       const struct ia_css_ob2_config *from, unsigned int size)
 {
 	(void)size;
 
 	/* Blacklevels types are u0_16 */
-	to->blacklevel_gr = uDIGIT_FITTING(from->level_gr, 16, SH_CSS_BAYER_BITS);
-	to->blacklevel_r  = uDIGIT_FITTING(from->level_r,  16, SH_CSS_BAYER_BITS);
-	to->blacklevel_b  = uDIGIT_FITTING(from->level_b,  16, SH_CSS_BAYER_BITS);
-	to->blacklevel_gb = uDIGIT_FITTING(from->level_gb, 16, SH_CSS_BAYER_BITS);
+	to->blacklevel_gr =
+		uDIGIT_FITTING(from->level_gr, 16, SH_CSS_BAYER_BITS);
+	to->blacklevel_r = uDIGIT_FITTING(from->level_r, 16, SH_CSS_BAYER_BITS);
+	to->blacklevel_b = uDIGIT_FITTING(from->level_b, 16, SH_CSS_BAYER_BITS);
+	to->blacklevel_gb =
+		uDIGIT_FITTING(from->level_gb, 16, SH_CSS_BAYER_BITS);
 }
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_ob2_dump(
-    const struct sh_css_isp_ob2_params *ob2,
-    unsigned int level)
+void ia_css_ob2_dump(const struct sh_css_isp_ob2_params *ob2,
+		     unsigned int level)
 {
 	if (!ob2)
 		return;
 
 	ia_css_debug_dtrace(level, "Optical Black 2:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ob2_blacklevel_gr", ob2->blacklevel_gr);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ob2_blacklevel_r", ob2->blacklevel_r);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ob2_blacklevel_b", ob2->blacklevel_b);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ob2_blacklevel_gb", ob2->blacklevel_gb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ob2_blacklevel_gr",
+			    ob2->blacklevel_gr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ob2_blacklevel_r",
+			    ob2->blacklevel_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ob2_blacklevel_b",
+			    ob2->blacklevel_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ob2_blacklevel_gb",
+			    ob2->blacklevel_gb);
 }
 
-void
-ia_css_ob2_debug_dtrace(
-    const struct ia_css_ob2_config *config,
-    unsigned int level)
+void ia_css_ob2_debug_dtrace(const struct ia_css_ob2_config *config,
+			     unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.level_gr=%d, config.level_r=%d, config.level_b=%d,  config.level_gb=%d, ",
-			    config->level_gr, config->level_r,
-			    config->level_b, config->level_gb);
+	ia_css_debug_dtrace(
+		level,
+		"config.level_gr=%d, config.level_r=%d, config.level_b=%d,  config.level_gb=%d, ",
+		config->level_gr, config->level_r, config->level_b,
+		config->level_gb);
 }
 #endif
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2.host.h
index 3bb192250d685563649dbafea3c5ee0cc027e68b..0d32f37ce8d78f85c8d4a595196bfbb4faa41d74 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2.host.h
@@ -12,21 +12,15 @@
 
 extern const struct ia_css_ob2_config default_ob2_config;
 
-void
-ia_css_ob2_encode(
-    struct sh_css_isp_ob2_params *to,
-    const struct ia_css_ob2_config *from,
-    unsigned int size);
+void ia_css_ob2_encode(struct sh_css_isp_ob2_params *to,
+		       const struct ia_css_ob2_config *from, unsigned int size);
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_ob2_dump(
-    const struct sh_css_isp_ob2_params *ob2,
-    unsigned int level);
+void ia_css_ob2_dump(const struct sh_css_isp_ob2_params *ob2,
+		     unsigned int level);
 
-void
-ia_css_ob2_debug_dtrace(
-    const struct ia_css_ob2_config *config, unsigned int level);
+void ia_css_ob2_debug_dtrace(const struct ia_css_ob2_config *config,
+			     unsigned int level);
 #endif
 
 #endif /* __IA_CSS_OB2_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2_types.h
index 9e5cd58df56312a6871d8ce9e289755cf7bac871..39de7bb11964955f49564a43225680fb468e484a 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob2/ia_css_ob2_types.h
@@ -19,16 +19,16 @@
 #include "ia_css_frac.h"
 
 struct ia_css_ob2_config {
-	ia_css_u0_16 level_gr;    /** Black level for GR pixels.
+	ia_css_u0_16 level_gr; /** Black level for GR pixels.
 					u0.16, [0,65535],
 					default/ineffective 0 */
-	ia_css_u0_16  level_r;     /** Black level for R pixels.
+	ia_css_u0_16 level_r; /** Black level for R pixels.
 					u0.16, [0,65535],
 					default/ineffective 0 */
-	ia_css_u0_16  level_b;     /** Black level for B pixels.
+	ia_css_u0_16 level_b; /** Black level for B pixels.
 					u0.16, [0,65535],
 					default/ineffective 0 */
-	ia_css_u0_16  level_gb;    /** Black level for GB pixels.
+	ia_css_u0_16 level_gb; /** Black level for GB pixels.
 					u0.16, [0,65535],
 					default/ineffective 0 */
 };
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
index 6801a5d605137484fe4e5936180c62bf264bfb3d..4ddecf1975451374f6da0351c870bde1b08ea005 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
@@ -12,45 +12,36 @@
 #include "ia_css_ob.host.h"
 
 const struct ia_css_ob_config default_ob_config = {
-	IA_CSS_OB_MODE_NONE,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0
+	IA_CSS_OB_MODE_NONE, 0, 0, 0, 0, 0, 0
 };
 
 /* TODO: include ob.isp.h to get isp knowledge and
    add assert on platform restrictions */
 
-void
-ia_css_ob_configure(
-    struct sh_css_isp_ob_stream_config *config,
-    unsigned int isp_pipe_version,
-    unsigned int raw_bit_depth)
+void ia_css_ob_configure(struct sh_css_isp_ob_stream_config *config,
+			 unsigned int isp_pipe_version,
+			 unsigned int raw_bit_depth)
 {
 	config->isp_pipe_version = isp_pipe_version;
-	config->raw_bit_depth    = raw_bit_depth;
+	config->raw_bit_depth = raw_bit_depth;
 }
 
-void
-ia_css_ob_encode(
-    struct sh_css_isp_ob_params *to,
-    const struct ia_css_ob_config *from,
-    const struct sh_css_isp_ob_stream_config *config,
-    unsigned int size)
+void ia_css_ob_encode(struct sh_css_isp_ob_params *to,
+		      const struct ia_css_ob_config *from,
+		      const struct sh_css_isp_ob_stream_config *config,
+		      unsigned int size)
 {
-	unsigned int ob_bit_depth
-	    = config->isp_pipe_version == 2 ? SH_CSS_BAYER_BITS : config->raw_bit_depth;
+	unsigned int ob_bit_depth = config->isp_pipe_version == 2 ?
+					    SH_CSS_BAYER_BITS :
+					    config->raw_bit_depth;
 	unsigned int scale = 16 - ob_bit_depth;
 
 	(void)size;
 	switch (from->mode) {
 	case IA_CSS_OB_MODE_FIXED:
 		to->blacklevel_gr = from->level_gr >> scale;
-		to->blacklevel_r  = from->level_r  >> scale;
-		to->blacklevel_b  = from->level_b  >> scale;
+		to->blacklevel_r = from->level_r >> scale;
+		to->blacklevel_b = from->level_b >> scale;
 		to->blacklevel_gb = from->level_gb >> scale;
 		to->area_start_bq = 0;
 		to->area_length_bq = 0;
@@ -63,8 +54,9 @@ ia_css_ob_encode(
 		to->blacklevel_gb = 0;
 		to->area_start_bq = from->start_position;
 		to->area_length_bq =
-		    (from->end_position - from->start_position) + 1;
-		to->area_length_bq_inverse = AREA_LENGTH_UNIT / to->area_length_bq;
+			(from->end_position - from->start_position) + 1;
+		to->area_length_bq_inverse =
+			AREA_LENGTH_UNIT / to->area_length_bq;
 		break;
 	default:
 		to->blacklevel_gr = 0;
@@ -78,12 +70,10 @@ ia_css_ob_encode(
 	}
 }
 
-void
-ia_css_ob_vmem_encode(
-    struct sh_css_isp_ob_vmem_params *to,
-    const struct ia_css_ob_config *from,
-    const struct sh_css_isp_ob_stream_config *config,
-    unsigned int size)
+void ia_css_ob_vmem_encode(struct sh_css_isp_ob_vmem_params *to,
+			   const struct ia_css_ob_config *from,
+			   const struct sh_css_isp_ob_stream_config *config,
+			   unsigned int size)
 {
 	struct sh_css_isp_ob_params tmp;
 	struct sh_css_isp_ob_params *ob = &tmp;
@@ -93,7 +83,7 @@ ia_css_ob_vmem_encode(
 
 	{
 		unsigned int i;
-		unsigned int sp_obarea_start_bq  = ob->area_start_bq;
+		unsigned int sp_obarea_start_bq = ob->area_start_bq;
 		unsigned int sp_obarea_length_bq = ob->area_length_bq;
 		unsigned int low = sp_obarea_start_bq;
 		unsigned int high = low + sp_obarea_length_bq;
@@ -101,46 +91,43 @@ ia_css_ob_vmem_encode(
 
 		for (i = 0; i < OBAREA_MASK_SIZE; i++) {
 			if (i >= low && i < high)
-				to->vmask[i / ISP_VEC_NELEMS][i % ISP_VEC_NELEMS] = all_ones;
+				to->vmask[i / ISP_VEC_NELEMS]
+					 [i % ISP_VEC_NELEMS] = all_ones;
 			else
-				to->vmask[i / ISP_VEC_NELEMS][i % ISP_VEC_NELEMS] = 0;
+				to->vmask[i / ISP_VEC_NELEMS]
+					 [i % ISP_VEC_NELEMS] = 0;
 		}
 	}
 }
 
-void
-ia_css_ob_dump(
-    const struct sh_css_isp_ob_params *ob,
-    unsigned int level)
+void ia_css_ob_dump(const struct sh_css_isp_ob_params *ob, unsigned int level)
 {
-	if (!ob) return;
+	if (!ob)
+		return;
 	ia_css_debug_dtrace(level, "Optical Black:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ob_blacklevel_gr", ob->blacklevel_gr);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ob_blacklevel_r", ob->blacklevel_r);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ob_blacklevel_b", ob->blacklevel_b);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ob_blacklevel_gb", ob->blacklevel_gb);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "obarea_start_bq", ob->area_start_bq);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "obarea_length_bq", ob->area_length_bq);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "obarea_length_bq_inverse",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ob_blacklevel_gr",
+			    ob->blacklevel_gr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ob_blacklevel_r",
+			    ob->blacklevel_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ob_blacklevel_b",
+			    ob->blacklevel_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ob_blacklevel_gb",
+			    ob->blacklevel_gb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "obarea_start_bq",
+			    ob->area_start_bq);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "obarea_length_bq",
+			    ob->area_length_bq);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "obarea_length_bq_inverse",
 			    ob->area_length_bq_inverse);
 }
 
-void
-ia_css_ob_debug_dtrace(
-    const struct ia_css_ob_config *config,
-    unsigned int level)
+void ia_css_ob_debug_dtrace(const struct ia_css_ob_config *config,
+			    unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.mode=%d, config.level_gr=%d, config.level_r=%d, config.level_b=%d,  config.level_gb=%d, config.start_position=%d, config.end_position=%d\n",
-			    config->mode,
-			    config->level_gr, config->level_r,
-			    config->level_b, config->level_gb,
-			    config->start_position, config->end_position);
+	ia_css_debug_dtrace(
+		level,
+		"config.mode=%d, config.level_gr=%d, config.level_r=%d, config.level_b=%d,  config.level_gb=%d, config.start_position=%d, config.end_position=%d\n",
+		config->mode, config->level_gr, config->level_r,
+		config->level_b, config->level_gb, config->start_position,
+		config->end_position);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob.host.h
index 636c6d5242f7408ac302db86296a7b30a898a009..d2a6a38e274904b23da30a208d43f3ff475e48c7 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob.host.h
@@ -12,34 +12,23 @@
 
 extern const struct ia_css_ob_config default_ob_config;
 
-void
-ia_css_ob_configure(
-    struct sh_css_isp_ob_stream_config *config,
-    unsigned int isp_pipe_version,
-    unsigned int raw_bit_depth);
-
-void
-ia_css_ob_encode(
-    struct sh_css_isp_ob_params *to,
-    const struct ia_css_ob_config *from,
-    const struct sh_css_isp_ob_stream_config *config,
-    unsigned int size);
-
-void
-ia_css_ob_vmem_encode(
-    struct sh_css_isp_ob_vmem_params *to,
-    const struct ia_css_ob_config *from,
-    const struct sh_css_isp_ob_stream_config *config,
-    unsigned int size);
-
-void
-ia_css_ob_dump(
-    const struct sh_css_isp_ob_params *ob,
-    unsigned int level);
-
-void
-ia_css_ob_debug_dtrace(
-    const struct ia_css_ob_config *config, unsigned int level)
-;
+void ia_css_ob_configure(struct sh_css_isp_ob_stream_config *config,
+			 unsigned int isp_pipe_version,
+			 unsigned int raw_bit_depth);
+
+void ia_css_ob_encode(struct sh_css_isp_ob_params *to,
+		      const struct ia_css_ob_config *from,
+		      const struct sh_css_isp_ob_stream_config *config,
+		      unsigned int size);
+
+void ia_css_ob_vmem_encode(struct sh_css_isp_ob_vmem_params *to,
+			   const struct ia_css_ob_config *from,
+			   const struct sh_css_isp_ob_stream_config *config,
+			   unsigned int size);
+
+void ia_css_ob_dump(const struct sh_css_isp_ob_params *ob, unsigned int level);
+
+void ia_css_ob_debug_dtrace(const struct ia_css_ob_config *config,
+			    unsigned int level);
 
 #endif /* __IA_CSS_OB_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob_param.h
index 366b5900fd2852635af0b90575052e840bf959a1..b56eae2b9537861aa50258e9348011bef725424d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob_param.h
@@ -11,7 +11,7 @@
 #include "vmem.h"
 
 #define OBAREA_MASK_SIZE 64
-#define OBAREA_LENGTHBQ_INVERSE_SHIFT     12
+#define OBAREA_LENGTHBQ_INVERSE_SHIFT 12
 
 /* AREA_LENGTH_UNIT is dependent on NWAY, requires rewrite */
 #define AREA_LENGTH_UNIT BIT(12)
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob_types.h
index b1470f8b424c907e86de55583af65516fda50df0..8af4a86b7cd98cd09238f735e0725e5bbc149d2a 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ob/ob_1.0/ia_css_ob_types.h
@@ -16,9 +16,9 @@
 /* Optical black mode.
  */
 enum ia_css_ob_mode {
-	IA_CSS_OB_MODE_NONE,	/** OB has no effect. */
-	IA_CSS_OB_MODE_FIXED,	/** Fixed OB */
-	IA_CSS_OB_MODE_RASTER	/** Raster OB */
+	IA_CSS_OB_MODE_NONE, /** OB has no effect. */
+	IA_CSS_OB_MODE_FIXED, /** Fixed OB */
+	IA_CSS_OB_MODE_RASTER /** Raster OB */
 };
 
 /* Optical Black level configuration.
@@ -31,19 +31,19 @@ struct ia_css_ob_config {
 	enum ia_css_ob_mode mode; /** Mode (None / Fixed / Raster).
 					enum, [0,2],
 					default 1, ineffective 0 */
-	ia_css_u0_16 level_gr;    /** Black level for GR pixels
+	ia_css_u0_16 level_gr; /** Black level for GR pixels
 					(used for Fixed Mode only).
 					u0.16, [0,65535],
 					default/ineffective 0 */
-	ia_css_u0_16 level_r;     /** Black level for R pixels
+	ia_css_u0_16 level_r; /** Black level for R pixels
 					(used for Fixed Mode only).
 					u0.16, [0,65535],
 					default/ineffective 0 */
-	ia_css_u0_16 level_b;     /** Black level for B pixels
+	ia_css_u0_16 level_b; /** Black level for B pixels
 					(used for Fixed Mode only).
 					u0.16, [0,65535],
 					default/ineffective 0 */
-	ia_css_u0_16 level_gb;    /** Black level for GB pixels
+	ia_css_u0_16 level_gb; /** Black level for GB pixels
 					(used for Fixed Mode only).
 					u0.16, [0,65535],
 					default/ineffective 0 */
@@ -51,7 +51,7 @@ struct ia_css_ob_config {
 					(used for Raster Mode only).
 					u16.0, [0,63],
 					default/ineffective 0 */
-	u16 end_position;  /** End position of OB area
+	u16 end_position; /** End position of OB area
 					(used for Raster Mode only).
 					u16.0, [0,63],
 					default/ineffective 0 */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output.host.c
index d09365e0c47104dbffbd455bfd649b9079f88c9c..db5c51506a8e3d6b7a9546dcd703cee8a7238869 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output.host.c
@@ -13,30 +13,23 @@
 
 #include "assert_support.h"
 
-const struct ia_css_output_config default_output_config = {
-	0,
-	0
-};
+const struct ia_css_output_config default_output_config = { 0, 0 };
 
 static const struct ia_css_output_configuration default_output_configuration = {
 	.info = (struct ia_css_frame_info *)NULL,
 };
 
-static const struct ia_css_output0_configuration default_output0_configuration
-	= {
+static const struct ia_css_output0_configuration default_output0_configuration = {
 	.info = (struct ia_css_frame_info *)NULL,
 };
 
-static const struct ia_css_output1_configuration default_output1_configuration
-	= {
+static const struct ia_css_output1_configuration default_output1_configuration = {
 	.info = (struct ia_css_frame_info *)NULL,
 };
 
-void
-ia_css_output_encode(
-    struct sh_css_isp_output_params *to,
-    const struct ia_css_output_config *from,
-    unsigned int size)
+void ia_css_output_encode(struct sh_css_isp_output_params *to,
+			  const struct ia_css_output_config *from,
+			  unsigned int size)
 {
 	(void)size;
 	to->enable_hflip = from->enable_hflip;
@@ -44,7 +37,7 @@ ia_css_output_encode(
 }
 
 int ia_css_output_config(struct sh_css_isp_output_isp_config *to,
-			 const struct ia_css_output_configuration  *from,
+			 const struct ia_css_output_configuration *from,
 			 unsigned int size)
 {
 	unsigned int elems_a = ISP_VEC_NELEMS;
@@ -66,26 +59,28 @@ int ia_css_output_config(struct sh_css_isp_output_isp_config *to,
 	return 0;
 }
 
-int ia_css_output0_config(struct sh_css_isp_output_isp_config       *to,
+int ia_css_output0_config(struct sh_css_isp_output_isp_config *to,
 			  const struct ia_css_output0_configuration *from,
 			  unsigned int size)
 {
-	return ia_css_output_config(to, (const struct ia_css_output_configuration *)from, size);
+	return ia_css_output_config(
+		to, (const struct ia_css_output_configuration *)from, size);
 }
 
-int ia_css_output1_config(struct sh_css_isp_output_isp_config       *to,
-		          const struct ia_css_output1_configuration *from,
+int ia_css_output1_config(struct sh_css_isp_output_isp_config *to,
+			  const struct ia_css_output1_configuration *from,
 			  unsigned int size)
 {
-	return ia_css_output_config(to, (const struct ia_css_output_configuration *)from, size);
+	return ia_css_output_config(
+		to, (const struct ia_css_output_configuration *)from, size);
 }
 
-int ia_css_output_configure(const struct ia_css_binary     *binary,
+int ia_css_output_configure(const struct ia_css_binary *binary,
 			    const struct ia_css_frame_info *info)
 {
 	if (info) {
 		struct ia_css_output_configuration config =
-			    default_output_configuration;
+			default_output_configuration;
 
 		config.info = info;
 
@@ -94,12 +89,12 @@ int ia_css_output_configure(const struct ia_css_binary     *binary,
 	return 0;
 }
 
-int ia_css_output0_configure(const struct ia_css_binary    *binary,
-			    const struct ia_css_frame_info *info)
+int ia_css_output0_configure(const struct ia_css_binary *binary,
+			     const struct ia_css_frame_info *info)
 {
 	if (info) {
 		struct ia_css_output0_configuration config =
-			    default_output0_configuration;
+			default_output0_configuration;
 
 		config.info = info;
 
@@ -108,12 +103,12 @@ int ia_css_output0_configure(const struct ia_css_binary    *binary,
 	return 0;
 }
 
-int ia_css_output1_configure(const struct ia_css_binary     *binary,
+int ia_css_output1_configure(const struct ia_css_binary *binary,
 			     const struct ia_css_frame_info *info)
 {
 	if (info) {
 		struct ia_css_output1_configuration config =
-			    default_output1_configuration;
+			default_output1_configuration;
 
 		config.info = info;
 
@@ -122,29 +117,24 @@ int ia_css_output1_configure(const struct ia_css_binary     *binary,
 	return 0;
 }
 
-void
-ia_css_output_dump(
-    const struct sh_css_isp_output_params *output,
-    unsigned int level)
+void ia_css_output_dump(const struct sh_css_isp_output_params *output,
+			unsigned int level)
 {
-	if (!output) return;
+	if (!output)
+		return;
 	ia_css_debug_dtrace(level, "Horizontal Output Flip:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "enable", output->enable_hflip);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "enable",
+			    output->enable_hflip);
 	ia_css_debug_dtrace(level, "Vertical Output Flip:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "enable", output->enable_vflip);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "enable",
+			    output->enable_vflip);
 }
 
-void
-ia_css_output_debug_dtrace(
-    const struct ia_css_output_config *config,
-    unsigned int level)
+void ia_css_output_debug_dtrace(const struct ia_css_output_config *config,
+				unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.enable_hflip=%d",
+	ia_css_debug_dtrace(level, "config.enable_hflip=%d",
 			    config->enable_hflip);
-	ia_css_debug_dtrace(level,
-			    "config.enable_vflip=%d",
+	ia_css_debug_dtrace(level, "config.enable_vflip=%d",
 			    config->enable_vflip);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output.host.h
index 25408f1aede55a61a33a55ad38d5afc3a594a756..bbef381446426927c1e86746c4425c6a2e01b556 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output.host.h
@@ -15,41 +15,35 @@
 
 extern const struct ia_css_output_config default_output_config;
 
-void
-ia_css_output_encode(
-    struct sh_css_isp_output_params *to,
-    const struct ia_css_output_config *from,
-    unsigned int size);
+void ia_css_output_encode(struct sh_css_isp_output_params *to,
+			  const struct ia_css_output_config *from,
+			  unsigned int size);
 
-int ia_css_output_config(struct sh_css_isp_output_isp_config      *to,
+int ia_css_output_config(struct sh_css_isp_output_isp_config *to,
 			 const struct ia_css_output_configuration *from,
 			 unsigned int size);
 
-int ia_css_output0_config(struct sh_css_isp_output_isp_config       *to,
+int ia_css_output0_config(struct sh_css_isp_output_isp_config *to,
 			  const struct ia_css_output0_configuration *from,
 			  unsigned int size);
 
-int ia_css_output1_config(struct sh_css_isp_output_isp_config       *to,
+int ia_css_output1_config(struct sh_css_isp_output_isp_config *to,
 			  const struct ia_css_output1_configuration *from,
 			  unsigned int size);
 
-int ia_css_output_configure(const struct ia_css_binary     *binary,
+int ia_css_output_configure(const struct ia_css_binary *binary,
 			    const struct ia_css_frame_info *from);
 
-int ia_css_output0_configure(const struct ia_css_binary     *binary,
+int ia_css_output0_configure(const struct ia_css_binary *binary,
 			     const struct ia_css_frame_info *from);
 
-int ia_css_output1_configure(const struct ia_css_binary     *binary,
+int ia_css_output1_configure(const struct ia_css_binary *binary,
 			     const struct ia_css_frame_info *from);
 
-void
-ia_css_output_dump(
-    const struct sh_css_isp_output_params *output,
-    unsigned int level);
+void ia_css_output_dump(const struct sh_css_isp_output_params *output,
+			unsigned int level);
 
-void
-ia_css_output_debug_dtrace(
-    const struct ia_css_output_config *config,
-    unsigned int level);
+void ia_css_output_debug_dtrace(const struct ia_css_output_config *config,
+				unsigned int level);
 
 #endif /* __IA_CSS_OUTPUT_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output_types.h
index 7c17ef200571ea6063c7504f16684ad0c8b226da..21d92c2501aa538bd7fddc8d984c438fd59e439a 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/output/output_1.0/ia_css_output_types.h
@@ -32,8 +32,8 @@ struct ia_css_output1_configuration {
 };
 
 struct ia_css_output_config {
-	u8 enable_hflip;  /** enable horizontal output mirroring */
-	u8 enable_vflip;  /** enable vertical output mirroring */
+	u8 enable_hflip; /** enable horizontal output mirroring */
+	u8 enable_vflip; /** enable vertical output mirroring */
 };
 
 #endif /* __IA_CSS_OUTPUT_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
index 6296deb72bd4fc5279b004f7478ab9ab61b95864..fb6d11bec3b4ccd417e21edf4c249e1ae251ce03 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
@@ -20,7 +20,7 @@ static const struct ia_css_qplane_configuration default_config = {
 };
 
 int ia_css_qplane_config(struct sh_css_isp_qplane_isp_config *to,
-			 const struct ia_css_qplane_configuration  *from,
+			 const struct ia_css_qplane_configuration *from,
 			 unsigned int size)
 {
 	unsigned int elems_a = ISP_VEC_NELEMS;
@@ -43,8 +43,8 @@ int ia_css_qplane_config(struct sh_css_isp_qplane_isp_config *to,
 }
 
 int ia_css_qplane_configure(const struct sh_css_sp_pipeline *pipe,
-			    const struct ia_css_binary      *binary,
-			    const struct ia_css_frame_info  *info)
+			    const struct ia_css_binary *binary,
+			    const struct ia_css_frame_info *info)
 {
 	struct ia_css_qplane_configuration config = default_config;
 
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane.host.h
index 2fa1de5e3633b5907ddbcf4f9112f0ecc5ff59bd..45121dc1f1f401985d60a0412979487cad1b8f32 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane.host.h
@@ -14,18 +14,18 @@
 /* Cannot be included, since sh_css_internal.h is too generic
  * e.g. for FW generation.
 */
-#include "sh_css_internal.h"	/* sh_css_sp_pipeline */
+#include "sh_css_internal.h" /* sh_css_sp_pipeline */
 #endif
 
 #include "ia_css_qplane_types.h"
 #include "ia_css_qplane_param.h"
 
-int ia_css_qplane_config(struct sh_css_isp_qplane_isp_config      *to,
+int ia_css_qplane_config(struct sh_css_isp_qplane_isp_config *to,
 			 const struct ia_css_qplane_configuration *from,
 			 unsigned int size);
 
 int ia_css_qplane_configure(const struct sh_css_sp_pipeline *pipe,
-			    const struct ia_css_binary      *binary,
-			    const struct ia_css_frame_info  *from);
+			    const struct ia_css_binary *binary,
+			    const struct ia_css_frame_info *from);
 
 #endif /* __IA_CSS_QPLANE_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane_types.h
index ae9707e1f76190c2e202f3ee4e0254918ab4e2ef..67cc4f9ceae549dfdda91e5b502571304d6c51ee 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/qplane/qplane_2/ia_css_qplane_types.h
@@ -17,7 +17,7 @@
 
 struct ia_css_qplane_configuration {
 	const struct sh_css_sp_pipeline *pipe;
-	const struct ia_css_frame_info  *info;
+	const struct ia_css_frame_info *info;
 };
 
 #endif /* __IA_CSS_QPLANE_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
index a00f8d049a3369457c80586cd899ca3caaebd77a..dce5d13e2ab69f4e4dcf718855cc213a1be54757 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
@@ -22,11 +22,11 @@ static const struct ia_css_raw_configuration default_config = {
 
 /* MW: These areMIPI / ISYS properties, not camera function properties */
 static enum sh_stream_format
-css2isp_stream_format(enum atomisp_input_format from) {
-	switch (from)
-	{
+css2isp_stream_format(enum atomisp_input_format from)
+{
+	switch (from) {
 	case ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY:
-				return sh_stream_format_yuv420_legacy;
+		return sh_stream_format_yuv420_legacy;
 	case ATOMISP_INPUT_FORMAT_YUV420_8:
 	case ATOMISP_INPUT_FORMAT_YUV420_10:
 	case ATOMISP_INPUT_FORMAT_YUV420_16:
@@ -56,7 +56,7 @@ css2isp_stream_format(enum atomisp_input_format from) {
 }
 
 int ia_css_raw_config(struct sh_css_isp_raw_isp_config *to,
-		      const struct ia_css_raw_configuration  *from,
+		      const struct ia_css_raw_configuration *from,
 		      unsigned int size)
 {
 	unsigned int elems_a = ISP_VEC_NELEMS;
@@ -75,17 +75,17 @@ int ia_css_raw_config(struct sh_css_isp_raw_isp_config *to,
 	assert((in_info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED) ||
 	       (elems_a % to->port_b.elems == 0));
 
-	to->width_a_over_b      = elems_a / to->port_b.elems;
-	to->inout_port_config   = from->pipe->inout_port_config;
-	to->format              = in_info->format;
+	to->width_a_over_b = elems_a / to->port_b.elems;
+	to->inout_port_config = from->pipe->inout_port_config;
+	to->format = in_info->format;
 	to->required_bds_factor = from->pipe->required_bds_factor;
-	to->two_ppc             = from->two_ppc;
-	to->stream_format       = css2isp_stream_format(from->stream_format);
-	to->deinterleaved       = from->deinterleaved;
+	to->two_ppc = from->two_ppc;
+	to->stream_format = css2isp_stream_format(from->stream_format);
+	to->deinterleaved = from->deinterleaved;
 
 	if (IS_ISP2401) {
-		to->start_column        = in_info->crop_info.start_column;
-		to->start_line          = in_info->crop_info.start_line;
+		to->start_column = in_info->crop_info.start_column;
+		to->start_line = in_info->crop_info.start_line;
 		to->enable_left_padding = from->enable_left_padding;
 	}
 
@@ -93,21 +93,20 @@ int ia_css_raw_config(struct sh_css_isp_raw_isp_config *to,
 }
 
 int ia_css_raw_configure(const struct sh_css_sp_pipeline *pipe,
-			 const struct ia_css_binary      *binary,
-			 const struct ia_css_frame_info  *in_info,
-			 const struct ia_css_frame_info  *internal_info,
-			 bool two_ppc,
-			 bool deinterleaved)
+			 const struct ia_css_binary *binary,
+			 const struct ia_css_frame_info *in_info,
+			 const struct ia_css_frame_info *internal_info,
+			 bool two_ppc, bool deinterleaved)
 {
 	u8 enable_left_padding = (uint8_t)((binary->left_padding) ? 1 : 0);
 	struct ia_css_raw_configuration config = default_config;
 
-	config.pipe                = pipe;
-	config.in_info             = in_info;
-	config.internal_info       = internal_info;
-	config.two_ppc             = two_ppc;
-	config.stream_format       = binary->input_format;
-	config.deinterleaved       = deinterleaved;
+	config.pipe = pipe;
+	config.in_info = in_info;
+	config.internal_info = internal_info;
+	config.two_ppc = two_ppc;
+	config.stream_format = binary->input_format;
+	config.deinterleaved = deinterleaved;
 	config.enable_left_padding = enable_left_padding;
 
 	return ia_css_configure_raw(binary, &config);
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw.host.h
index cae9c7fcb7f1d18d36c686c26f74830f42f6e414..52fda13d140b63914105a8e80d39671c35e0d74c 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw.host.h
@@ -12,15 +12,14 @@
 #include "ia_css_raw_types.h"
 #include "ia_css_raw_param.h"
 
-int ia_css_raw_config(struct sh_css_isp_raw_isp_config      *to,
+int ia_css_raw_config(struct sh_css_isp_raw_isp_config *to,
 		      const struct ia_css_raw_configuration *from,
 		      unsigned int size);
 
 int ia_css_raw_configure(const struct sh_css_sp_pipeline *pipe,
-			 const struct ia_css_binary     *binary,
+			 const struct ia_css_binary *binary,
 			 const struct ia_css_frame_info *in_info,
 			 const struct ia_css_frame_info *internal_info,
-			 bool two_ppc,
-			 bool deinterleaved);
+			 bool two_ppc, bool deinterleaved);
 
 #endif /* __IA_CSS_RAW_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw_types.h
index ee25414ea8cdee35e1f2535334c6f6ee51c1b434..2f94102896f28e0b5c9a4bb64fe79536dc857560 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/raw/raw_1.0/ia_css_raw_types.h
@@ -17,8 +17,8 @@
 
 struct ia_css_raw_configuration {
 	const struct sh_css_sp_pipeline *pipe;
-	const struct ia_css_frame_info  *in_info;
-	const struct ia_css_frame_info  *internal_info;
+	const struct ia_css_frame_info *in_info;
+	const struct ia_css_frame_info *internal_info;
 	bool two_ppc;
 	enum atomisp_input_format stream_format;
 	bool deinterleaved;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.c
index cd7d1c13605a191e0f37d4a543bc6bb96966d1d3..4e3d6fba8554cdbaee48a44fdf0b8a23706f91f3 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.c
@@ -4,21 +4,16 @@
  * Copyright (c) 2015, Intel Corporation.
  */
 
-
 #include "ia_css_types.h"
 #include "sh_css_internal.h"
 #include "sh_css_frac.h"
 
 #include "ia_css_raa.host.h"
 
-void
-ia_css_raa_encode(
-    struct sh_css_isp_aa_params *to,
-    const struct ia_css_aa_config *from,
-    unsigned int size)
+void ia_css_raa_encode(struct sh_css_isp_aa_params *to,
+		       const struct ia_css_aa_config *from, unsigned int size)
 {
 	(void)size;
 	(void)to;
 	(void)from;
 }
-
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.h
index f800a05fe1dd5ddb4b22d34fe8624aac418335aa..56ab8bc3e56cd0522360f1318ccedf482904130d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.h
@@ -10,10 +10,7 @@
 #include "aa/aa_2/ia_css_aa2_types.h"
 #include "aa/aa_2/ia_css_aa2_param.h"
 
-void
-ia_css_raa_encode(
-    struct sh_css_isp_aa_params *to,
-    const struct ia_css_aa_config *from,
-    unsigned int size);
+void ia_css_raa_encode(struct sh_css_isp_aa_params *to,
+		       const struct ia_css_aa_config *from, unsigned int size);
 
 #endif /* __IA_CSS_RAA_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ref/ref_1.0/ia_css_ref.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ref/ref_1.0/ia_css_ref.host.c
index d9b68b08dd3c1a809686b6eb37c71f90add8aace..2d2db877051f82422cd592db783383d8d9ccc748 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ref/ref_1.0/ia_css_ref.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ref/ref_1.0/ia_css_ref.host.c
@@ -14,14 +14,15 @@
 #include "ia_css_ref.host.h"
 
 int ia_css_ref_config(struct sh_css_isp_ref_isp_config *to,
-		      const struct ia_css_ref_configuration  *from,
+		      const struct ia_css_ref_configuration *from,
 		      unsigned int size)
 {
 	unsigned int elems_a = ISP_VEC_NELEMS, i;
 	int ret;
 
 	if (from->ref_frames[0]) {
-		ret = ia_css_dma_configure_from_info(&to->port_b, &from->ref_frames[0]->frame_info);
+		ret = ia_css_dma_configure_from_info(
+			&to->port_b, &from->ref_frames[0]->frame_info);
 		if (ret)
 			return ret;
 		to->width_a_over_b = elems_a / to->port_b.elems;
@@ -33,10 +34,12 @@ int ia_css_ref_config(struct sh_css_isp_ref_isp_config *to,
 	}
 	for (i = 0; i < MAX_NUM_VIDEO_DELAY_FRAMES; i++) {
 		if (from->ref_frames[i]) {
-			to->ref_frame_addr_y[i] = from->ref_frames[i]->data +
-						  from->ref_frames[i]->planes.yuv.y.offset;
-			to->ref_frame_addr_c[i] = from->ref_frames[i]->data +
-						  from->ref_frames[i]->planes.yuv.u.offset;
+			to->ref_frame_addr_y[i] =
+				from->ref_frames[i]->data +
+				from->ref_frames[i]->planes.yuv.y.offset;
+			to->ref_frame_addr_c[i] =
+				from->ref_frames[i]->data +
+				from->ref_frames[i]->planes.yuv.u.offset;
 		} else {
 			to->ref_frame_addr_y[i] = 0;
 			to->ref_frame_addr_c[i] = 0;
@@ -50,8 +53,8 @@ int ia_css_ref_config(struct sh_css_isp_ref_isp_config *to,
 	return 0;
 }
 
-int ia_css_ref_configure(const struct ia_css_binary        *binary,
-			 const struct ia_css_frame * const *ref_frames,
+int ia_css_ref_configure(const struct ia_css_binary *binary,
+			 const struct ia_css_frame *const *ref_frames,
 			 const uint32_t dvs_frame_delay)
 {
 	struct ia_css_ref_configuration config;
@@ -65,10 +68,8 @@ int ia_css_ref_configure(const struct ia_css_binary        *binary,
 	return ia_css_configure_ref(binary, &config);
 }
 
-void
-ia_css_init_ref_state(
-    struct sh_css_isp_ref_dmem_state *state,
-    unsigned int size)
+void ia_css_init_ref_state(struct sh_css_isp_ref_dmem_state *state,
+			   unsigned int size)
 {
 	(void)size;
 	assert(MAX_NUM_VIDEO_DELAY_FRAMES >= 2);
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ref/ref_1.0/ia_css_ref.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/ref/ref_1.0/ia_css_ref.host.h
index f0556bbcc86879a188abb3b3a979517965f9439d..882a3d08c0e018b443a18a71e94a412b10f79464 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ref/ref_1.0/ia_css_ref.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ref/ref_1.0/ia_css_ref.host.h
@@ -14,16 +14,14 @@
 #include "ia_css_ref_param.h"
 #include "ia_css_ref_state.h"
 
-int ia_css_ref_config(struct sh_css_isp_ref_isp_config      *to,
+int ia_css_ref_config(struct sh_css_isp_ref_isp_config *to,
 		      const struct ia_css_ref_configuration *from,
 		      unsigned int size);
 
-int ia_css_ref_configure(const struct ia_css_binary        *binary,
-			 const struct ia_css_frame * const *ref_frames,
-			 const uint32_t                    dvs_frame_delay);
+int ia_css_ref_configure(const struct ia_css_binary *binary,
+			 const struct ia_css_frame *const *ref_frames,
+			 const uint32_t dvs_frame_delay);
 
-void
-ia_css_init_ref_state(
-    struct sh_css_isp_ref_dmem_state *state,
-    unsigned int size);
+void ia_css_init_ref_state(struct sh_css_isp_ref_dmem_state *state,
+			   unsigned int size);
 #endif /* __IA_CSS_REF_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.c
index 13678138c48c42792bd8027d63f256643f105da1..6d21a7a6c07ee2df864e1f27699290e85393aa93 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.c
@@ -22,81 +22,67 @@ const struct ia_css_3a_config default_3a_config = {
 	65535,
 	0,
 	65535,
-	{-3344, -6104, -19143, 19143, 6104, 3344, 0},
-	{1027, 0, -9219, 16384, -9219, 1027, 0}
+	{ -3344, -6104, -19143, 19143, 6104, 3344, 0 },
+	{ 1027, 0, -9219, 16384, -9219, 1027, 0 }
 };
 
 static unsigned int s3a_raw_bit_depth;
 
-void
-ia_css_s3a_configure(unsigned int raw_bit_depth)
+void ia_css_s3a_configure(unsigned int raw_bit_depth)
 {
 	s3a_raw_bit_depth = raw_bit_depth;
 }
 
-static void
-ia_css_ae_encode(
-    struct sh_css_isp_ae_params *to,
-    const struct ia_css_3a_config *from,
-    unsigned int size)
+static void ia_css_ae_encode(struct sh_css_isp_ae_params *to,
+			     const struct ia_css_3a_config *from,
+			     unsigned int size)
 {
 	(void)size;
 	/* coefficients to calculate Y */
 	to->y_coef_r =
-	    uDIGIT_FITTING(from->ae_y_coef_r, 16, SH_CSS_AE_YCOEF_SHIFT);
+		uDIGIT_FITTING(from->ae_y_coef_r, 16, SH_CSS_AE_YCOEF_SHIFT);
 	to->y_coef_g =
-	    uDIGIT_FITTING(from->ae_y_coef_g, 16, SH_CSS_AE_YCOEF_SHIFT);
+		uDIGIT_FITTING(from->ae_y_coef_g, 16, SH_CSS_AE_YCOEF_SHIFT);
 	to->y_coef_b =
-	    uDIGIT_FITTING(from->ae_y_coef_b, 16, SH_CSS_AE_YCOEF_SHIFT);
+		uDIGIT_FITTING(from->ae_y_coef_b, 16, SH_CSS_AE_YCOEF_SHIFT);
 }
 
-static void
-ia_css_awb_encode(
-    struct sh_css_isp_awb_params *to,
-    const struct ia_css_3a_config *from,
-    unsigned int size)
+static void ia_css_awb_encode(struct sh_css_isp_awb_params *to,
+			      const struct ia_css_3a_config *from,
+			      unsigned int size)
 {
 	(void)size;
 	/* AWB level gate */
 	to->lg_high_raw =
-	    uDIGIT_FITTING(from->awb_lg_high_raw, 16, s3a_raw_bit_depth);
-	to->lg_low =
-	    uDIGIT_FITTING(from->awb_lg_low, 16, SH_CSS_BAYER_BITS);
-	to->lg_high =
-	    uDIGIT_FITTING(from->awb_lg_high, 16, SH_CSS_BAYER_BITS);
+		uDIGIT_FITTING(from->awb_lg_high_raw, 16, s3a_raw_bit_depth);
+	to->lg_low = uDIGIT_FITTING(from->awb_lg_low, 16, SH_CSS_BAYER_BITS);
+	to->lg_high = uDIGIT_FITTING(from->awb_lg_high, 16, SH_CSS_BAYER_BITS);
 }
 
-static void
-ia_css_af_encode(
-    struct sh_css_isp_af_params *to,
-    const struct ia_css_3a_config *from,
-    unsigned int size)
+static void ia_css_af_encode(struct sh_css_isp_af_params *to,
+			     const struct ia_css_3a_config *from,
+			     unsigned int size)
 {
 	unsigned int i;
 	(void)size;
 
 	/* af fir coefficients */
 	for (i = 0; i < 7; ++i) {
-		to->fir1[i] =
-		    sDIGIT_FITTING(from->af_fir1_coef[i], 15,
-				   SH_CSS_AF_FIR_SHIFT);
-		to->fir2[i] =
-		    sDIGIT_FITTING(from->af_fir2_coef[i], 15,
-				   SH_CSS_AF_FIR_SHIFT);
+		to->fir1[i] = sDIGIT_FITTING(from->af_fir1_coef[i], 15,
+					     SH_CSS_AF_FIR_SHIFT);
+		to->fir2[i] = sDIGIT_FITTING(from->af_fir2_coef[i], 15,
+					     SH_CSS_AF_FIR_SHIFT);
 	}
 }
 
-void
-ia_css_s3a_encode(
-    struct sh_css_isp_s3a_params *to,
-    const struct ia_css_3a_config *from,
-    unsigned int size)
+void ia_css_s3a_encode(struct sh_css_isp_s3a_params *to,
+		       const struct ia_css_3a_config *from, unsigned int size)
 {
 	(void)size;
 
-	ia_css_ae_encode(&to->ae,   from, sizeof(to->ae));
+	ia_css_ae_encode(&to->ae, from, sizeof(to->ae));
 	ia_css_awb_encode(&to->awb, from, sizeof(to->awb));
-	ia_css_af_encode(&to->af,   from, sizeof(to->af));
+	ia_css_af_encode(&to->af, from, sizeof(to->af));
 }
 
 #if 0
@@ -127,72 +113,48 @@ ia_css_process_s3a(
 #endif
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_ae_dump(
-    const struct sh_css_isp_ae_params *ae,
-    unsigned int level)
+void ia_css_ae_dump(const struct sh_css_isp_ae_params *ae, unsigned int level)
 {
-	if (!ae) return;
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ae_y_coef_r", ae->y_coef_r);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ae_y_coef_g", ae->y_coef_g);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ae_y_coef_b", ae->y_coef_b);
+	if (!ae)
+		return;
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ae_y_coef_r",
+			    ae->y_coef_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ae_y_coef_g",
+			    ae->y_coef_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ae_y_coef_b",
+			    ae->y_coef_b);
 }
 
-void
-ia_css_awb_dump(
-    const struct sh_css_isp_awb_params *awb,
-    unsigned int level)
+void ia_css_awb_dump(const struct sh_css_isp_awb_params *awb,
+		     unsigned int level)
 {
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "awb_lg_high_raw", awb->lg_high_raw);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "awb_lg_low", awb->lg_low);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "awb_lg_high", awb->lg_high);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "awb_lg_high_raw",
+			    awb->lg_high_raw);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "awb_lg_low", awb->lg_low);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "awb_lg_high",
+			    awb->lg_high);
 }
 
-void
-ia_css_af_dump(
-    const struct sh_css_isp_af_params *af,
-    unsigned int level)
+void ia_css_af_dump(const struct sh_css_isp_af_params *af, unsigned int level)
 {
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir1[0]", af->fir1[0]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir1[1]", af->fir1[1]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir1[2]", af->fir1[2]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir1[3]", af->fir1[3]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir1[4]", af->fir1[4]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir1[5]", af->fir1[5]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir1[6]", af->fir1[6]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir2[0]", af->fir2[0]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir2[1]", af->fir2[1]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir2[2]", af->fir2[2]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir2[3]", af->fir2[3]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir2[4]", af->fir2[4]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir2[5]", af->fir2[5]);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "af_fir2[6]", af->fir2[6]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir1[0]", af->fir1[0]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir1[1]", af->fir1[1]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir1[2]", af->fir1[2]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir1[3]", af->fir1[3]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir1[4]", af->fir1[4]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir1[5]", af->fir1[5]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir1[6]", af->fir1[6]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir2[0]", af->fir2[0]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir2[1]", af->fir2[1]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir2[2]", af->fir2[2]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir2[3]", af->fir2[3]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir2[4]", af->fir2[4]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir2[5]", af->fir2[5]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "af_fir2[6]", af->fir2[6]);
 }
 
-void
-ia_css_s3a_dump(
-    const struct sh_css_isp_s3a_params *s3a,
-    unsigned int level)
+void ia_css_s3a_dump(const struct sh_css_isp_s3a_params *s3a,
+		     unsigned int level)
 {
 	ia_css_debug_dtrace(level, "S3A Support:\n");
 	ia_css_ae_dump(&s3a->ae, level);
@@ -200,26 +162,23 @@ ia_css_s3a_dump(
 	ia_css_af_dump(&s3a->af, level);
 }
 
-void
-ia_css_s3a_debug_dtrace(
-    const struct ia_css_3a_config *config,
-    unsigned int level)
+void ia_css_s3a_debug_dtrace(const struct ia_css_3a_config *config,
+			     unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.ae_y_coef_r=%d, config.ae_y_coef_g=%d, config.ae_y_coef_b=%d, config.awb_lg_high_raw=%d, config.awb_lg_low=%d, config.awb_lg_high=%d\n",
-			    config->ae_y_coef_r, config->ae_y_coef_g,
-			    config->ae_y_coef_b, config->awb_lg_high_raw,
-			    config->awb_lg_low, config->awb_lg_high);
+	ia_css_debug_dtrace(
+		level,
+		"config.ae_y_coef_r=%d, config.ae_y_coef_g=%d, config.ae_y_coef_b=%d, config.awb_lg_high_raw=%d, config.awb_lg_low=%d, config.awb_lg_high=%d\n",
+		config->ae_y_coef_r, config->ae_y_coef_g, config->ae_y_coef_b,
+		config->awb_lg_high_raw, config->awb_lg_low,
+		config->awb_lg_high);
 }
 #endif
 
-void
-ia_css_s3a_hmem_decode(
-    struct ia_css_3a_statistics *host_stats,
-    const struct ia_css_bh_table *hmem_buf)
+void ia_css_s3a_hmem_decode(struct ia_css_3a_statistics *host_stats,
+			    const struct ia_css_bh_table *hmem_buf)
 {
-	struct ia_css_3a_rgby_output	*out_ptr;
-	int			i;
+	struct ia_css_3a_rgby_output *out_ptr;
+	int i;
 
 	/* pixel counts(BQ) for 3A area */
 	int count_for_3a;
@@ -229,9 +188,9 @@ ia_css_s3a_hmem_decode(
 	assert(host_stats->rgby_data);
 	assert(hmem_buf);
 
-	count_for_3a = host_stats->grid.width * host_stats->grid.height
-		       * host_stats->grid.bqs_per_grid_cell
-		       * host_stats->grid.bqs_per_grid_cell;
+	count_for_3a = host_stats->grid.width * host_stats->grid.height *
+		       host_stats->grid.bqs_per_grid_cell *
+		       host_stats->grid.bqs_per_grid_cell;
 
 	out_ptr = host_stats->rgby_data;
 
@@ -280,10 +239,8 @@ ia_css_s3a_hmem_decode(
 	out_ptr[0].y -= diff;
 }
 
-void
-ia_css_s3a_dmem_decode(
-    struct ia_css_3a_statistics *host_stats,
-    const struct ia_css_3a_output *isp_stats)
+void ia_css_s3a_dmem_decode(struct ia_css_3a_statistics *host_stats,
+			    const struct ia_css_3a_output *isp_stats)
 {
 	int isp_width, host_width, height, i;
 	struct ia_css_3a_output *host_ptr;
@@ -292,10 +249,10 @@ ia_css_s3a_dmem_decode(
 	assert(host_stats->data);
 	assert(isp_stats);
 
-	isp_width  = host_stats->grid.aligned_width;
+	isp_width = host_stats->grid.aligned_width;
 	host_width = host_stats->grid.width;
-	height     = host_stats->grid.height;
-	host_ptr   = host_stats->data;
+	height = host_stats->grid.height;
+	host_ptr = host_stats->data;
 
 	/* Getting 3A statistics from DMEM does not involve any
 	 * transformation (like the VMEM version), we just copy the data
@@ -308,21 +265,19 @@ ia_css_s3a_dmem_decode(
 }
 
 /* MW: this is an ISP function */
-static inline int
-merge_hi_lo_14(unsigned short hi, unsigned short lo)
+static inline int merge_hi_lo_14(unsigned short hi, unsigned short lo)
 {
 	int val = (int)((((unsigned int)hi << 14) & 0xfffc000) |
 			((unsigned int)lo & 0x3fff));
 	return val;
 }
 
-void
-ia_css_s3a_vmem_decode(
-    struct ia_css_3a_statistics *host_stats,
-    const u16 *isp_stats_hi,
-    const uint16_t *isp_stats_lo)
+void ia_css_s3a_vmem_decode(struct ia_css_3a_statistics *host_stats,
+			    const u16 *isp_stats_hi,
+			    const uint16_t *isp_stats_lo)
 {
-	int out_width, out_height, chunk, rest, kmax, y, x, k, elm_start, elm, ofs;
+	int out_width, out_height, chunk, rest, kmax, y, x, k, elm_start, elm,
+		ofs;
 	const u16 *hi, *lo;
 	struct ia_css_3a_output *output;
 
@@ -332,7 +287,7 @@ ia_css_s3a_vmem_decode(
 	assert(isp_stats_lo);
 
 	output = host_stats->data;
-	out_width  = host_stats->grid.width;
+	out_width = host_stats->grid.width;
 	out_height = host_stats->grid.height;
 	hi = isp_stats_hi;
 	lo = isp_stats_lo;
@@ -349,22 +304,30 @@ ia_css_s3a_vmem_decode(
 			ofs = y * out_width + x;
 			elm = elm_start + x * sizeof(*output) / sizeof(int32_t);
 			for (k = 0; k < kmax; k++, elm++) {
-				output[ofs + k].ae_y    = merge_hi_lo_14(
-							      hi[elm + chunk * 0], lo[elm + chunk * 0]);
-				output[ofs + k].awb_cnt = merge_hi_lo_14(
-							      hi[elm + chunk * 1], lo[elm + chunk * 1]);
-				output[ofs + k].awb_gr  = merge_hi_lo_14(
-							      hi[elm + chunk * 2], lo[elm + chunk * 2]);
-				output[ofs + k].awb_r   = merge_hi_lo_14(
-							      hi[elm + chunk * 3], lo[elm + chunk * 3]);
-				output[ofs + k].awb_b   = merge_hi_lo_14(
-							      hi[elm + chunk * 4], lo[elm + chunk * 4]);
-				output[ofs + k].awb_gb  = merge_hi_lo_14(
-							      hi[elm + chunk * 5], lo[elm + chunk * 5]);
-				output[ofs + k].af_hpf1 = merge_hi_lo_14(
-							      hi[elm + chunk * 6], lo[elm + chunk * 6]);
-				output[ofs + k].af_hpf2 = merge_hi_lo_14(
-							      hi[elm + chunk * 7], lo[elm + chunk * 7]);
+				output[ofs + k].ae_y =
+					merge_hi_lo_14(hi[elm + chunk * 0],
+						       lo[elm + chunk * 0]);
+				output[ofs + k].awb_cnt =
+					merge_hi_lo_14(hi[elm + chunk * 1],
+						       lo[elm + chunk * 1]);
+				output[ofs + k].awb_gr =
+					merge_hi_lo_14(hi[elm + chunk * 2],
+						       lo[elm + chunk * 2]);
+				output[ofs + k].awb_r =
+					merge_hi_lo_14(hi[elm + chunk * 3],
+						       lo[elm + chunk * 3]);
+				output[ofs + k].awb_b =
+					merge_hi_lo_14(hi[elm + chunk * 4],
+						       lo[elm + chunk * 4]);
+				output[ofs + k].awb_gb =
+					merge_hi_lo_14(hi[elm + chunk * 5],
+						       lo[elm + chunk * 5]);
+				output[ofs + k].af_hpf1 =
+					merge_hi_lo_14(hi[elm + chunk * 6],
+						       lo[elm + chunk * 6]);
+				output[ofs + k].af_hpf2 =
+					merge_hi_lo_14(hi[elm + chunk * 7],
+						       lo[elm + chunk * 7]);
 			}
 			x += chunk;
 			rest -= chunk;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h
index f000b4347472fed7df1673a36b58c837e64f0d6b..16f0dea635aad1920ec6ae7ef31efd6888c3bc42 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h
@@ -13,57 +13,34 @@
 
 extern const struct ia_css_3a_config default_3a_config;
 
-void
-ia_css_s3a_configure(
-    unsigned int raw_bit_depth);
+void ia_css_s3a_configure(unsigned int raw_bit_depth);
 
-void
-ia_css_s3a_encode(
-    struct sh_css_isp_s3a_params *to,
-    const struct ia_css_3a_config *from,
-    unsigned int size);
+void ia_css_s3a_encode(struct sh_css_isp_s3a_params *to,
+		       const struct ia_css_3a_config *from, unsigned int size);
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_ae_dump(
-    const struct sh_css_isp_ae_params *ae,
-    unsigned int level);
+void ia_css_ae_dump(const struct sh_css_isp_ae_params *ae, unsigned int level);
 
-void
-ia_css_awb_dump(
-    const struct sh_css_isp_awb_params *awb,
-    unsigned int level);
+void ia_css_awb_dump(const struct sh_css_isp_awb_params *awb,
+		     unsigned int level);
 
-void
-ia_css_af_dump(
-    const struct sh_css_isp_af_params *af,
-    unsigned int level);
+void ia_css_af_dump(const struct sh_css_isp_af_params *af, unsigned int level);
 
-void
-ia_css_s3a_dump(
-    const struct sh_css_isp_s3a_params *s3a,
-    unsigned int level);
+void ia_css_s3a_dump(const struct sh_css_isp_s3a_params *s3a,
+		     unsigned int level);
 
-void
-ia_css_s3a_debug_dtrace(
-    const struct ia_css_3a_config *config,
-    unsigned int level);
+void ia_css_s3a_debug_dtrace(const struct ia_css_3a_config *config,
+			     unsigned int level);
 #endif
 
-void
-ia_css_s3a_hmem_decode(
-    struct ia_css_3a_statistics *host_stats,
-    const struct ia_css_bh_table *hmem_buf);
+void ia_css_s3a_hmem_decode(struct ia_css_3a_statistics *host_stats,
+			    const struct ia_css_bh_table *hmem_buf);
 
-void
-ia_css_s3a_dmem_decode(
-    struct ia_css_3a_statistics *host_stats,
-    const struct ia_css_3a_output *isp_stats);
+void ia_css_s3a_dmem_decode(struct ia_css_3a_statistics *host_stats,
+			    const struct ia_css_3a_output *isp_stats);
 
-void
-ia_css_s3a_vmem_decode(
-    struct ia_css_3a_statistics *host_stats,
-    const u16 *isp_stats_hi,
-    const uint16_t *isp_stats_lo);
+void ia_css_s3a_vmem_decode(struct ia_css_3a_statistics *host_stats,
+			    const u16 *isp_stats_hi,
+			    const uint16_t *isp_stats_lo);
 
 #endif /* __IA_CSS_S3A_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
index b8206d2f3d31066acb5518cd750b6fbbdc433b52..083676f72def1e91c818799a1ea3e9f50412c88a 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
@@ -30,26 +30,27 @@
  */
 struct ia_css_3a_grid_info {
 #if defined(SYSTEM_css_skycam_c0_system)
-	u32 ae_enable;					/** ae enabled in binary,
+	u32 ae_enable; /** ae enabled in binary,
 								   0:disabled, 1:enabled */
 	struct ae_public_config_grid_config
-		ae_grd_info;	/** see description in ae_public.h*/
+		ae_grd_info; /** see description in ae_public.h*/
 
-	u32 awb_enable;					/** awb enabled in binary,
+	u32 awb_enable; /** awb enabled in binary,
 								   0:disabled, 1:enabled */
 	struct awb_public_config_grid_config
-		awb_grd_info;	/** see description in awb_public.h*/
+		awb_grd_info; /** see description in awb_public.h*/
 
-	u32 af_enable;					/** af enabled in binary,
+	u32 af_enable; /** af enabled in binary,
 								   0:disabled, 1:enabled */
-	struct af_public_grid_config		af_grd_info;	/** see description in af_public.h*/
+	struct af_public_grid_config
+		af_grd_info; /** see description in af_public.h*/
 
-	u32 awb_fr_enable;					/** awb_fr enabled in binary,
+	u32 awb_fr_enable; /** awb_fr enabled in binary,
 								   0:disabled, 1:enabled */
 	struct awb_fr_public_grid_config
-		awb_fr_grd_info;/** see description in awb_fr_public.h*/
+		awb_fr_grd_info; /** see description in awb_fr_public.h*/
 
-	u32 elem_bit_depth;    /** TODO:Taken from BYT  - need input from AIQ
+	u32 elem_bit_depth; /** TODO:Taken from BYT  - need input from AIQ
 					if needed for SKC
 					Bit depth of element used
 					to calculate 3A statistics.
@@ -57,34 +58,34 @@ struct ia_css_3a_grid_info {
 					bayer bit depth in DSP. */
 
 #else
-	u32 enable;            /** 3A statistics enabled.
+	u32 enable; /** 3A statistics enabled.
 					0:disabled, 1:enabled */
-	u32 use_dmem;          /** DMEM or VMEM determines layout.
+	u32 use_dmem; /** DMEM or VMEM determines layout.
 					0:3A statistics are stored to VMEM,
 					1:3A statistics are stored to DMEM */
-	u32 has_histogram;     /** Statistics include histogram.
+	u32 has_histogram; /** Statistics include histogram.
 					0:no histogram, 1:has histogram */
-	u32 width;		    /** Width of 3A grid table.
+	u32 width; /** Width of 3A grid table.
 					(= Horizontal number of grid cells
 					in table, which cells have effective
 					statistics.) */
-	u32 height;	    /** Height of 3A grid table.
+	u32 height; /** Height of 3A grid table.
 					(= Vertical number of grid cells
 					in table, which cells have effective
 					statistics.) */
-	u32 aligned_width;     /** Horizontal stride (for alloc).
+	u32 aligned_width; /** Horizontal stride (for alloc).
 					(= Horizontal number of grid cells
 					in table, which means
 					the allocated width.) */
-	u32 aligned_height;    /** Vertical stride (for alloc).
+	u32 aligned_height; /** Vertical stride (for alloc).
 					(= Vertical number of grid cells
 					in table, which means
 					the allocated height.) */
 	u32 bqs_per_grid_cell; /** Grid cell size in BQ(Bayer Quad) unit.
 					(1BQ means {Gr,R,B,Gb}(2x2 pixels).)
 					Valid values are 8,16,32,64. */
-	u32 deci_factor_log2;  /** log2 of bqs_per_grid_cell. */
-	u32 elem_bit_depth;    /** Bit depth of element used
+	u32 deci_factor_log2; /** log2 of bqs_per_grid_cell. */
+	u32 elem_bit_depth; /** Bit depth of element used
 					to calculate 3A statistics.
 					This is 13, which is the normalized
 					bayer bit depth in DSP. */
@@ -114,32 +115,32 @@ struct ia_css_3a_grid_info {
  *  ISP2: S3A2 and SDVS2 are used.
  */
 struct ia_css_3a_config {
-	ia_css_u0_16 ae_y_coef_r;	/** Weight of R for Y.
+	ia_css_u0_16 ae_y_coef_r; /** Weight of R for Y.
 						u0.16, [0,65535],
 						default/ineffective 25559 */
-	ia_css_u0_16 ae_y_coef_g;	/** Weight of G for Y.
+	ia_css_u0_16 ae_y_coef_g; /** Weight of G for Y.
 						u0.16, [0,65535],
 						default/ineffective 32768 */
-	ia_css_u0_16 ae_y_coef_b;	/** Weight of B for Y.
+	ia_css_u0_16 ae_y_coef_b; /** Weight of B for Y.
 						u0.16, [0,65535],
 						default/ineffective 7209 */
-	ia_css_u0_16 awb_lg_high_raw;	/** AWB level gate high for raw.
+	ia_css_u0_16 awb_lg_high_raw; /** AWB level gate high for raw.
 						u0.16, [0,65535],
 						default 65472(=1023*64),
 						ineffective 65535 */
-	ia_css_u0_16 awb_lg_low;	/** AWB level gate low.
+	ia_css_u0_16 awb_lg_low; /** AWB level gate low.
 						u0.16, [0,65535],
 						default 64(=1*64),
 						ineffective 0 */
-	ia_css_u0_16 awb_lg_high;	/** AWB level gate high.
+	ia_css_u0_16 awb_lg_high; /** AWB level gate high.
 						u0.16, [0,65535],
 						default 65535,
 						ineffective 65535 */
-	ia_css_s0_15 af_fir1_coef[7];	/** AF FIR coefficients of fir1.
+	ia_css_s0_15 af_fir1_coef[7]; /** AF FIR coefficients of fir1.
 						s0.15, [-32768,32767],
 				default/ineffective
 				-6689,-12207,-32768,32767,12207,6689,0 */
-	ia_css_s0_15 af_fir2_coef[7];	/** AF FIR coefficients of fir2.
+	ia_css_s0_15 af_fir2_coef[7]; /** AF FIR coefficients of fir2.
 						s0.15, [-32768,32767],
 				default/ineffective
 				2053,0,-18437,32767,-18437,2053,0 */
@@ -156,22 +157,22 @@ struct ia_css_3a_config {
  *  ISP2: S3A2 is used.
  */
 struct ia_css_3a_output {
-	s32 ae_y;    /** Sum of Y in a statistics window, for AE.
+	s32 ae_y; /** Sum of Y in a statistics window, for AE.
 				(u19.13) */
 	s32 awb_cnt; /** Number of effective pixels
 				in a statistics window.
 				Pixels passed by the AWB level gate check are
 				judged as "effective". (u32) */
-	s32 awb_gr;  /** Sum of Gr in a statistics window, for AWB.
+	s32 awb_gr; /** Sum of Gr in a statistics window, for AWB.
 				All Gr pixels (not only for effective pixels)
 				are summed. (u19.13) */
-	s32 awb_r;   /** Sum of R in a statistics window, for AWB.
+	s32 awb_r; /** Sum of R in a statistics window, for AWB.
 				All R pixels (not only for effective pixels)
 				are summed. (u19.13) */
-	s32 awb_b;   /** Sum of B in a statistics window, for AWB.
+	s32 awb_b; /** Sum of B in a statistics window, for AWB.
 				All B pixels (not only for effective pixels)
 				are summed. (u19.13) */
-	s32 awb_gb;  /** Sum of Gb in a statistics window, for AWB.
+	s32 awb_gb; /** Sum of Gb in a statistics window, for AWB.
 				All Gb pixels (not only for effective pixels)
 				are summed. (u19.13) */
 	s32 af_hpf1; /** Sum of |Y| following high pass filter af_fir1
@@ -185,11 +186,12 @@ struct ia_css_3a_output {
  */
 struct ia_css_3a_statistics {
 	struct ia_css_3a_grid_info
-		grid;	/** grid info contains the dimensions of the 3A grid */
+		grid; /** grid info contains the dimensions of the 3A grid */
 	struct ia_css_3a_output
-		*data;	/** the pointer to 3a_output[grid.width * grid.height]
+		*data; /** the pointer to 3a_output[grid.width * grid.height]
 						     containing the 3A statistics */
-	struct ia_css_3a_rgby_output *rgby_data;/** the pointer to 3a_rgby_output[256]
+	struct ia_css_3a_rgby_output
+		*rgby_data; /** the pointer to 3a_rgby_output[256]
 						     containing the histogram */
 };
 
@@ -204,10 +206,10 @@ struct ia_css_3a_statistics {
  *  ISP2: HIST2 is used.
  */
 struct ia_css_3a_rgby_output {
-	u32 r;	/** Number of R of one bin of the histogram R. (u24) */
-	u32 g;	/** Number of G of one bin of the histogram G. (u24) */
-	u32 b;	/** Number of B of one bin of the histogram B. (u24) */
-	u32 y;	/** Number of Y of one bin of the histogram Y. (u24) */
+	u32 r; /** Number of R of one bin of the histogram R. (u24) */
+	u32 g; /** Number of G of one bin of the histogram G. (u24) */
+	u32 b; /** Number of B of one bin of the histogram B. (u24) */
+	u32 y; /** Number of Y of one bin of the histogram Y. (u24) */
 };
 
 #endif /* __IA_CSS_S3A_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.c
index 16b7d36e1cc265b3896eeb3401ccfe06fc17b2ea..5aadb3eb36147a06d5cc5756bd5dc40c68ed5ac2 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.c
@@ -14,25 +14,20 @@
 
 #include "ia_css_sc.host.h"
 
-void
-ia_css_sc_encode(
-    struct sh_css_isp_sc_params *to,
-    struct ia_css_shading_table **from,
-    unsigned int size)
+void ia_css_sc_encode(struct sh_css_isp_sc_params *to,
+		      struct ia_css_shading_table **from, unsigned int size)
 {
 	(void)size;
 	to->gain_shift = (*from)->fraction_bits;
 }
 
-void
-ia_css_sc_dump(
-    const struct sh_css_isp_sc_params *sc,
-    unsigned int level)
+void ia_css_sc_dump(const struct sh_css_isp_sc_params *sc, unsigned int level)
 {
-	if (!sc) return;
+	if (!sc)
+		return;
 	ia_css_debug_dtrace(level, "Shading Correction:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "sc_gain_shift", sc->gain_shift);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "sc_gain_shift",
+			    sc->gain_shift);
 }
 
 /* ------ deprecated(bz675) : from ------ */
@@ -42,41 +37,43 @@ ia_css_sc_dump(
    and does not have a parameter which is used in the isp kernels.
    Then, I did not use @parameter{} to generate the get/set function
    for the ia_css_shading_settings structure. (michie) */
-void
-sh_css_get_shading_settings(const struct ia_css_isp_parameters *params,
-			    struct ia_css_shading_settings *settings)
+void sh_css_get_shading_settings(const struct ia_css_isp_parameters *params,
+				 struct ia_css_shading_settings *settings)
 {
 	if (!settings)
 		return;
 	assert(params);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_get_shading_settings() enter: settings=%p\n", settings);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_get_shading_settings() enter: settings=%p\n", settings);
 
 	*settings = params->shading_settings;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_get_shading_settings() leave: settings.enable_shading_table_conversion=%d\n",
-			    settings->enable_shading_table_conversion);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_get_shading_settings() leave: settings.enable_shading_table_conversion=%d\n",
+		settings->enable_shading_table_conversion);
 }
 
-void
-sh_css_set_shading_settings(struct ia_css_isp_parameters *params,
-			    const struct ia_css_shading_settings *settings)
+void sh_css_set_shading_settings(struct ia_css_isp_parameters *params,
+				 const struct ia_css_shading_settings *settings)
 {
 	if (!settings)
 		return;
 	assert(params);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_set_shading_settings() enter: settings.enable_shading_table_conversion=%d\n",
-			    settings->enable_shading_table_conversion);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_set_shading_settings() enter: settings.enable_shading_table_conversion=%d\n",
+		settings->enable_shading_table_conversion);
 
 	params->shading_settings = *settings;
 	params->shading_settings_changed = true;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_set_shading_settings() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_set_shading_settings() leave: return_void\n");
 }
 
 /* ------ deprecated(bz675) : to ------ */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.h
index 1730b368d191f4d00fc6e4deb2d4bdcd5a5bbc66..a3fa06f895a89edd66960207f0b0a3d2819323c0 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.h
@@ -12,25 +12,17 @@
 #include "ia_css_sc_types.h"
 #include "ia_css_sc_param.h"
 
-void
-ia_css_sc_encode(
-    struct sh_css_isp_sc_params *to,
-    struct ia_css_shading_table **from,
-    unsigned int size);
+void ia_css_sc_encode(struct sh_css_isp_sc_params *to,
+		      struct ia_css_shading_table **from, unsigned int size);
 
-void
-ia_css_sc_dump(
-    const struct sh_css_isp_sc_params *sc,
-    unsigned int level);
+void ia_css_sc_dump(const struct sh_css_isp_sc_params *sc, unsigned int level);
 
 /* ------ deprecated(bz675) : from ------ */
-void
-sh_css_get_shading_settings(const struct ia_css_isp_parameters *params,
-			    struct ia_css_shading_settings *settings);
+void sh_css_get_shading_settings(const struct ia_css_isp_parameters *params,
+				 struct ia_css_shading_settings *settings);
 
-void
-sh_css_set_shading_settings(struct ia_css_isp_parameters *params,
-			    const struct ia_css_shading_settings *settings);
+void sh_css_set_shading_settings(struct ia_css_isp_parameters *params,
+				 const struct ia_css_shading_settings *settings);
 /* ------ deprecated(bz675) : to ------ */
 
 #endif /* __IA_CSS_SC_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_param.h
index 61e9c04d25157550fcb48efc71a0f8244ccbee35..0d38dbbef4a77925153994d01e350450a4fa9b0b 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_param.h
@@ -24,7 +24,7 @@ struct sh_css_isp_sc_params {
  *     Max grid cell bqs to support the shading table centerting: N = 32
  *     CEIL_DIV(N-1, ISP_SLICE_NELEMS) = CEIL_DIV(31, 4) = 8
  */
-#define SH_CSS_SC_INTERPED_GAIN_HOR_SLICE_TIMES   8
+#define SH_CSS_SC_INTERPED_GAIN_HOR_SLICE_TIMES 8
 
 struct sh_css_isp_sc_isp_config {
 	u32 interped_gain_hor_slice_bqs[SH_CSS_SC_INTERPED_GAIN_HOR_SLICE_TIMES];
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_types.h
index 2f91934f2c06a81ba5296704b21e0597b477dead..59430c291ac75f16928f935df85e747300c583a2 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_types.h
@@ -12,16 +12,16 @@
 */
 
 /* Number of color planes in the shading table. */
-#define IA_CSS_SC_NUM_COLORS           4
+#define IA_CSS_SC_NUM_COLORS 4
 
 /* The 4 colors that a shading table consists of.
  *  For each color we store a grid of values.
  */
 enum ia_css_sc_color {
 	IA_CSS_SC_COLOR_GR, /** Green on a green-red line */
-	IA_CSS_SC_COLOR_R,  /** Red */
-	IA_CSS_SC_COLOR_B,  /** Blue */
-	IA_CSS_SC_COLOR_GB  /** Green on a green-blue line */
+	IA_CSS_SC_COLOR_R, /** Red */
+	IA_CSS_SC_COLOR_B, /** Blue */
+	IA_CSS_SC_COLOR_GB /** Green on a green-blue line */
 };
 
 /* Lens Shading Correction table.
@@ -58,7 +58,7 @@ struct ia_css_shading_table {
 	u32 enable; /** Set to false for no shading correction.
 			  The data field can be NULL when enable == true */
 	/* ------ deprecated(bz675) : from ------ */
-	u32 sensor_width;  /** Native sensor width in pixels. */
+	u32 sensor_width; /** Native sensor width in pixels. */
 	u32 sensor_height; /** Native sensor height in lines.
 		When shading_settings.enable_shading_table_conversion is set
 		as 0, sensor_width and sensor_height are NOT used.
@@ -66,7 +66,7 @@ struct ia_css_shading_table {
 		in the css, when shading_settings.
 		enable_shading_table_conversion is set as 1. */
 	/* ------ deprecated(bz675) : to ------ */
-	u32 width;  /** Number of data points per line per color.
+	u32 width; /** Number of data points per line per color.
 				u8.0, [0,81] */
 	u32 height; /** Number of lines of data points per color.
 				u8.0, [0,61] */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/common/ia_css_sdis_common.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/common/ia_css_sdis_common.host.h
index bad400b2fd377ec2c80fe75d2d53ac1293cf5cc1..d11b7d2d78fd9ae6a57a1aa5b550399fd3c085d1 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/common/ia_css_sdis_common.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/common/ia_css_sdis_common.host.h
@@ -7,12 +7,14 @@
 #ifndef _IA_CSS_SDIS_COMMON_HOST_H
 #define _IA_CSS_SDIS_COMMON_HOST_H
 
-#define ISP_MAX_SDIS_HOR_PROJ_NUM_ISP \
-	__ISP_SDIS_HOR_PROJ_NUM_ISP(ISP_MAX_INTERNAL_WIDTH, ISP_MAX_INTERNAL_HEIGHT, \
-		SH_CSS_DIS_DECI_FACTOR_LOG2, ISP_PIPE_VERSION)
-#define ISP_MAX_SDIS_VER_PROJ_NUM_ISP \
+#define ISP_MAX_SDIS_HOR_PROJ_NUM_ISP                            \
+	__ISP_SDIS_HOR_PROJ_NUM_ISP(ISP_MAX_INTERNAL_WIDTH,      \
+				    ISP_MAX_INTERNAL_HEIGHT,     \
+				    SH_CSS_DIS_DECI_FACTOR_LOG2, \
+				    ISP_PIPE_VERSION)
+#define ISP_MAX_SDIS_VER_PROJ_NUM_ISP                       \
 	__ISP_SDIS_VER_PROJ_NUM_ISP(ISP_MAX_INTERNAL_WIDTH, \
-		SH_CSS_DIS_DECI_FACTOR_LOG2)
+				    SH_CSS_DIS_DECI_FACTOR_LOG2)
 
 #define _ISP_SDIS_HOR_COEF_NUM_VECS \
 	__ISP_SDIS_HOR_COEF_NUM_VECS(ISP_INTERNAL_WIDTH)
@@ -24,7 +26,7 @@
 /* SDIS Coefficients: */
 /* The ISP uses vectors to store the coefficients, so we round
    the number of coefficients up to vectors. */
-#define __ISP_SDIS_HOR_COEF_NUM_VECS(in_width)  _ISP_VECS(_ISP_BQS(in_width))
+#define __ISP_SDIS_HOR_COEF_NUM_VECS(in_width) _ISP_VECS(_ISP_BQS(in_width))
 #define __ISP_SDIS_VER_COEF_NUM_VECS(in_height) _ISP_VECS(_ISP_BQS(in_height))
 
 /* SDIS Projections:
@@ -35,18 +37,18 @@
  * valid. The host needs to use the bigger one for the stride but
  * should only return the valid ones to the 3A. */
 #define __ISP_SDIS_HOR_PROJ_NUM_ISP(in_width, in_height, deci_factor_log2, \
-	isp_pipe_version) \
-	((isp_pipe_version == 1) ? \
-		CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2) : \
-		CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2))
+				    isp_pipe_version)                      \
+	((isp_pipe_version == 1) ?                                         \
+		 CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2) :       \
+		 CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2))
 
 #define __ISP_SDIS_VER_PROJ_NUM_ISP(in_width, deci_factor_log2) \
 	CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2)
 
-#define SH_CSS_DIS_VER_NUM_COEF_TYPES(b) \
-  (((b)->info->sp.pipeline.isp_pipe_version == 2) ? \
-	IA_CSS_DVS2_NUM_COEF_TYPES : \
-	IA_CSS_DVS_NUM_COEF_TYPES)
+#define SH_CSS_DIS_VER_NUM_COEF_TYPES(b)                  \
+	(((b)->info->sp.pipeline.isp_pipe_version == 2) ? \
+		 IA_CSS_DVS2_NUM_COEF_TYPES :             \
+		 IA_CSS_DVS_NUM_COEF_TYPES)
 
 #ifndef PIPE_GENERATION
 #if defined(__ISP) || defined(MK_FIRMWARE)
@@ -68,12 +70,12 @@ struct sh_css_isp_sdis_vert_proj_tbl {
 
 struct sh_css_isp_sdis_hori_coef_tbl {
 	VMEM_ARRAY(tbl[ISP_DVS_NUM_COEF_TYPES],
-		   ISP_MAX_SDIS_HOR_COEF_NUM_VECS * ISP_NWAY);
+		   ISP_MAX_SDIS_HOR_COEF_NUM_VECS *ISP_NWAY);
 };
 
 struct sh_css_isp_sdis_vert_coef_tbl {
 	VMEM_ARRAY(tbl[ISP_DVS_NUM_COEF_TYPES],
-		   ISP_MAX_SDIS_VER_COEF_NUM_VECS * ISP_NWAY);
+		   ISP_MAX_SDIS_VER_COEF_NUM_VECS *ISP_NWAY);
 };
 
 #endif /* defined(__ISP) || defined (MK_FIRMWARE) */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/common/ia_css_sdis_common_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/common/ia_css_sdis_common_types.h
index 1a3790c1c353bd655118bc74445c4a34ed13c38b..eb4f6bc3ba7b9e743b83975ab2e26e4f0bdbe734 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/common/ia_css_sdis_common_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/common/ia_css_sdis_common_types.h
@@ -17,8 +17,8 @@
  */
 
 struct ia_css_dvs_grid_dim {
-	u32 width;		/** Width of DVS grid table in cells */
-	u32 height;	/** Height of DVS grid table in cells */
+	u32 width; /** Width of DVS grid table in cells */
+	u32 height; /** Height of DVS grid table in cells */
 };
 
 /* DVS statistics dimensions in number of cells for
@@ -41,7 +41,7 @@ struct ia_css_sdis_info {
  *  ISP2: SDVS2 is used.
  */
 struct ia_css_dvs_grid_res {
-	u32 width;		/** Width of DVS grid table.
+	u32 width; /** Width of DVS grid table.
 					(= Horizontal number of grid cells
 					in table, which cells have effective
 					statistics.)
@@ -51,13 +51,13 @@ struct ia_css_dvs_grid_res {
 					(= Horizontal number of grid cells
 					in table, which means
 					the allocated width.) */
-	u32 height;	/** Height of DVS grid table.
+	u32 height; /** Height of DVS grid table.
 					(= Vertical number of grid cells
 					in table, which cells have effective
 					statistics.)
 					For DVS1, This is equal to
 					the number of horizontal statistics. */
-	u32 aligned_height;/** Stride of each grid column.
+	u32 aligned_height; /** Stride of each grid column.
 					(= Vertical number of grid cells
 					in table, which means
 					the allocated height.) */
@@ -67,9 +67,9 @@ struct ia_css_dvs_grid_res {
  * However, that implies driver I/F changes
  */
 struct ia_css_dvs_grid_info {
-	u32 enable;        /** DVS statistics enabled.
+	u32 enable; /** DVS statistics enabled.
 					0:disabled, 1:enabled */
-	u32 width;		/** Width of DVS grid table.
+	u32 width; /** Width of DVS grid table.
 					(= Horizontal number of grid cells
 					in table, which cells have effective
 					statistics.)
@@ -79,13 +79,13 @@ struct ia_css_dvs_grid_info {
 					(= Horizontal number of grid cells
 					in table, which means
 					the allocated width.) */
-	u32 height;	/** Height of DVS grid table.
+	u32 height; /** Height of DVS grid table.
 					(= Vertical number of grid cells
 					in table, which cells have effective
 					statistics.)
 					For DVS1, This is equal to
 					the number of horizontal statistics. */
-	u32 aligned_height;/** Stride of each grid column.
+	u32 aligned_height; /** Stride of each grid column.
 					(= Vertical number of grid cells
 					in table, which means
 					the allocated height.) */
@@ -94,13 +94,13 @@ struct ia_css_dvs_grid_info {
 					For DVS1, valid value is 64.
 					For DVS2, valid value is only 64,
 					currently. */
-	u32 num_hor_coefs;	/** Number of horizontal coefficients. */
-	u32 num_ver_coefs;	/** Number of vertical coefficients. */
+	u32 num_hor_coefs; /** Number of horizontal coefficients. */
+	u32 num_ver_coefs; /** Number of vertical coefficients. */
 };
 
 /* Number of DVS statistics levels
  */
-#define IA_CSS_DVS_STAT_NUM_OF_LEVELS	3
+#define IA_CSS_DVS_STAT_NUM_OF_LEVELS 3
 
 /* DVS statistics generated by accelerator global configuration
  */
@@ -166,20 +166,21 @@ struct dvs_stat_public_dvs_level_fe_roi_cfg {
 /* DVS statistics generated by accelerator public configuration
  */
 struct dvs_stat_public_dvs_grd_cfg {
-	struct dvs_stat_public_dvs_level_grid_cfg    grd_cfg;
+	struct dvs_stat_public_dvs_level_grid_cfg grd_cfg;
 	/** DVS statistics level grid configuration */
-	struct dvs_stat_public_dvs_level_grid_start  grd_start;
+	struct dvs_stat_public_dvs_level_grid_start grd_start;
 	/** DVS statistics level grid start configuration */
-	struct dvs_stat_public_dvs_level_grid_end    grd_end;
+	struct dvs_stat_public_dvs_level_grid_end grd_end;
 	/** DVS statistics level grid end configuration */
 };
 
 /* DVS statistics grid generated by accelerator
  */
 struct ia_css_dvs_stat_grid_info {
-	struct dvs_stat_public_dvs_global_cfg       dvs_gbl_cfg;
+	struct dvs_stat_public_dvs_global_cfg dvs_gbl_cfg;
 	/** DVS statistics global configuration (kappa, match, binning) */
-	struct dvs_stat_public_dvs_grd_cfg       grd_cfg[IA_CSS_DVS_STAT_NUM_OF_LEVELS];
+	struct dvs_stat_public_dvs_grd_cfg
+		grd_cfg[IA_CSS_DVS_STAT_NUM_OF_LEVELS];
 	/** DVS statistics grid configuration (blocks and grids) */
 	struct dvs_stat_public_dvs_level_fe_roi_cfg
 		fe_roi_cfg[IA_CSS_DVS_STAT_NUM_OF_LEVELS];
@@ -188,15 +189,12 @@ struct ia_css_dvs_stat_grid_info {
 
 /* DVS statistics generated by accelerator default grid info
  */
-#define DEFAULT_DVS_GRID_INFO { \
-	.dvs_stat_grid_info = { \
-		.fe_roi_cfg = { \
-			[1] = { \
-			    .x_start = 4 \
-			} \
-		} \
-	} \
-}
+#define DEFAULT_DVS_GRID_INFO                                    \
+	{                                                        \
+		.dvs_stat_grid_info = {                          \
+			.fe_roi_cfg = { [1] = { .x_start = 4 } } \
+		}                                                \
+	}
 
 /* Union that holds all types of DVS statistics grid info in
  *  CSS format
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c
index a1bea8bd1a397d6fce03b09edba17b8e3b1f71fb..f2977ea1e96de8663157319730c2ae9bf9f8a9fd 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c
@@ -18,9 +18,8 @@ const struct ia_css_dvs_coefficients default_sdis_config = {
 	.ver_coefs = NULL
 };
 
-static void
-fill_row(short *private, const short *public, unsigned int width,
-	 unsigned int padding)
+static void fill_row(short *private, const short *public, unsigned int width,
+		     unsigned int padding)
 {
 	assert((int)width >= 0);
 	assert((int)padding >= 0);
@@ -28,88 +27,87 @@ fill_row(short *private, const short *public, unsigned int width,
 	memset(&private[width], 0, padding * sizeof(short));
 }
 
-void ia_css_sdis_horicoef_vmem_encode(
-    struct sh_css_isp_sdis_hori_coef_tbl *to,
-    const struct ia_css_dvs_coefficients *from,
-    unsigned int size)
+void ia_css_sdis_horicoef_vmem_encode(struct sh_css_isp_sdis_hori_coef_tbl *to,
+				      const struct ia_css_dvs_coefficients *from,
+				      unsigned int size)
 {
-	unsigned int aligned_width = from->grid.aligned_width *
-				     from->grid.bqs_per_grid_cell;
-	unsigned int width         = from->grid.num_hor_coefs;
-	int      padding       = aligned_width - width;
-	unsigned int stride        = size / IA_CSS_DVS_NUM_COEF_TYPES / sizeof(short);
-	unsigned int total_bytes   = aligned_width * IA_CSS_DVS_NUM_COEF_TYPES * sizeof(
-					 short);
-	short   *public        = from->hor_coefs;
-	short   *private       = (short *)to;
+	unsigned int aligned_width =
+		from->grid.aligned_width * from->grid.bqs_per_grid_cell;
+	unsigned int width = from->grid.num_hor_coefs;
+	int padding = aligned_width - width;
+	unsigned int stride = size / IA_CSS_DVS_NUM_COEF_TYPES / sizeof(short);
+	unsigned int total_bytes =
+		aligned_width * IA_CSS_DVS_NUM_COEF_TYPES * sizeof(short);
+	short *public = from->hor_coefs;
+	short *private = (short *)to;
 	unsigned int type;
 
 	/* Copy the table, add padding */
 	assert(padding >= 0);
 	assert(total_bytes <= size);
-	assert(size % (IA_CSS_DVS_NUM_COEF_TYPES * ISP_VEC_NELEMS * sizeof(
-			   short)) == 0);
+	assert(size % (IA_CSS_DVS_NUM_COEF_TYPES * ISP_VEC_NELEMS *
+		       sizeof(short)) ==
+	       0);
 
 	for (type = 0; type < IA_CSS_DVS_NUM_COEF_TYPES; type++) {
-		fill_row(&private[type * stride], &public[type * width], width, padding);
+		fill_row(&private[type * stride], &public[type * width], width,
+			 padding);
 	}
 }
 
-void ia_css_sdis_vertcoef_vmem_encode(
-    struct sh_css_isp_sdis_vert_coef_tbl *to,
-    const struct ia_css_dvs_coefficients *from,
-    unsigned int size)
+void ia_css_sdis_vertcoef_vmem_encode(struct sh_css_isp_sdis_vert_coef_tbl *to,
+				      const struct ia_css_dvs_coefficients *from,
+				      unsigned int size)
 {
-	unsigned int aligned_height = from->grid.aligned_height *
-				      from->grid.bqs_per_grid_cell;
-	unsigned int height         = from->grid.num_ver_coefs;
-	int      padding        = aligned_height - height;
-	unsigned int stride         = size / IA_CSS_DVS_NUM_COEF_TYPES / sizeof(short);
-	unsigned int total_bytes    = aligned_height * IA_CSS_DVS_NUM_COEF_TYPES *
-				      sizeof(short);
-	short   *public         = from->ver_coefs;
-	short   *private        = (short *)to;
+	unsigned int aligned_height =
+		from->grid.aligned_height * from->grid.bqs_per_grid_cell;
+	unsigned int height = from->grid.num_ver_coefs;
+	int padding = aligned_height - height;
+	unsigned int stride = size / IA_CSS_DVS_NUM_COEF_TYPES / sizeof(short);
+	unsigned int total_bytes =
+		aligned_height * IA_CSS_DVS_NUM_COEF_TYPES * sizeof(short);
+	short *public = from->ver_coefs;
+	short *private = (short *)to;
 	unsigned int type;
 
 	/* Copy the table, add padding */
 	assert(padding >= 0);
 	assert(total_bytes <= size);
-	assert(size % (IA_CSS_DVS_NUM_COEF_TYPES * ISP_VEC_NELEMS * sizeof(
-			   short)) == 0);
+	assert(size % (IA_CSS_DVS_NUM_COEF_TYPES * ISP_VEC_NELEMS *
+		       sizeof(short)) ==
+	       0);
 
 	for (type = 0; type < IA_CSS_DVS_NUM_COEF_TYPES; type++) {
-		fill_row(&private[type * stride], &public[type * height], height, padding);
+		fill_row(&private[type * stride], &public[type * height],
+			 height, padding);
 	}
 }
 
-void ia_css_sdis_horiproj_encode(
-    struct sh_css_isp_sdis_hori_proj_tbl *to,
-    const struct ia_css_dvs_coefficients *from,
-    unsigned int size)
+void ia_css_sdis_horiproj_encode(struct sh_css_isp_sdis_hori_proj_tbl *to,
+				 const struct ia_css_dvs_coefficients *from,
+				 unsigned int size)
 {
 	(void)to;
 	(void)from;
 	(void)size;
 }
 
-void ia_css_sdis_vertproj_encode(
-    struct sh_css_isp_sdis_vert_proj_tbl *to,
-    const struct ia_css_dvs_coefficients *from,
-    unsigned int size)
+void ia_css_sdis_vertproj_encode(struct sh_css_isp_sdis_vert_proj_tbl *to,
+				 const struct ia_css_dvs_coefficients *from,
+				 unsigned int size)
 {
 	(void)to;
 	(void)from;
 	(void)size;
 }
 
-void ia_css_get_isp_dis_coefficients(
-    struct ia_css_stream *stream,
-    short *horizontal_coefficients,
-    short *vertical_coefficients)
+void ia_css_get_isp_dis_coefficients(struct ia_css_stream *stream,
+				     short *horizontal_coefficients,
+				     short *vertical_coefficients)
 {
 	struct ia_css_isp_parameters *params;
 	unsigned int hor_num_isp, ver_num_isp;
-	unsigned int hor_num_3a,  ver_num_3a;
+	unsigned int hor_num_3a, ver_num_3a;
 	int i;
 	struct ia_css_binary *dvs_binary;
 
@@ -127,110 +125,102 @@ void ia_css_get_isp_dis_coefficients(
 
 	hor_num_isp = dvs_binary->dis.coef.pad.width;
 	ver_num_isp = dvs_binary->dis.coef.pad.height;
-	hor_num_3a  = dvs_binary->dis.coef.dim.width;
-	ver_num_3a  = dvs_binary->dis.coef.dim.height;
+	hor_num_3a = dvs_binary->dis.coef.dim.width;
+	ver_num_3a = dvs_binary->dis.coef.dim.height;
 
 	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
 		fill_row(&horizontal_coefficients[i * hor_num_isp],
-			 &params->dvs_coefs.hor_coefs[i * hor_num_3a], hor_num_3a,
-			 hor_num_isp - hor_num_3a);
+			 &params->dvs_coefs.hor_coefs[i * hor_num_3a],
+			 hor_num_3a, hor_num_isp - hor_num_3a);
 	}
 	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(dvs_binary); i++) {
 		fill_row(&vertical_coefficients[i * ver_num_isp],
-			 &params->dvs_coefs.ver_coefs[i * ver_num_3a], ver_num_3a,
-			 ver_num_isp - ver_num_3a);
+			 &params->dvs_coefs.ver_coefs[i * ver_num_3a],
+			 ver_num_3a, ver_num_isp - ver_num_3a);
 	}
 
 	IA_CSS_LEAVE("void");
 }
 
-size_t
-ia_css_sdis_hor_coef_tbl_bytes(
-    const struct ia_css_binary *binary)
+size_t ia_css_sdis_hor_coef_tbl_bytes(const struct ia_css_binary *binary)
 {
 	if (binary->info->sp.pipeline.isp_pipe_version == 1)
-		return sizeof(short) * IA_CSS_DVS_NUM_COEF_TYPES  * binary->dis.coef.pad.width;
+		return sizeof(short) * IA_CSS_DVS_NUM_COEF_TYPES *
+		       binary->dis.coef.pad.width;
 	else
-		return sizeof(short) * IA_CSS_DVS2_NUM_COEF_TYPES * binary->dis.coef.pad.width;
+		return sizeof(short) * IA_CSS_DVS2_NUM_COEF_TYPES *
+		       binary->dis.coef.pad.width;
 }
 
-size_t
-ia_css_sdis_ver_coef_tbl_bytes(
-    const struct ia_css_binary *binary)
+size_t ia_css_sdis_ver_coef_tbl_bytes(const struct ia_css_binary *binary)
 {
 	return sizeof(short) * SH_CSS_DIS_VER_NUM_COEF_TYPES(binary) *
 	       binary->dis.coef.pad.height;
 }
 
-void
-ia_css_sdis_init_info(
-    struct ia_css_sdis_info *dis,
-    unsigned int sc_3a_dis_width,
-    unsigned int sc_3a_dis_padded_width,
-    unsigned int sc_3a_dis_height,
-    unsigned int isp_pipe_version,
-    unsigned int enabled)
+void ia_css_sdis_init_info(struct ia_css_sdis_info *dis,
+			   unsigned int sc_3a_dis_width,
+			   unsigned int sc_3a_dis_padded_width,
+			   unsigned int sc_3a_dis_height,
+			   unsigned int isp_pipe_version, unsigned int enabled)
 {
 	if (!enabled) {
-		*dis = (struct ia_css_sdis_info) { };
+		*dis = (struct ia_css_sdis_info){};
 		return;
 	}
 
 	dis->deci_factor_log2 = SH_CSS_DIS_DECI_FACTOR_LOG2;
 
-	dis->grid.dim.width  =
-	    _ISP_BQS(sc_3a_dis_width) >> SH_CSS_DIS_DECI_FACTOR_LOG2;
-	dis->grid.dim.height =
-	    _ISP_BQS(sc_3a_dis_height) >> SH_CSS_DIS_DECI_FACTOR_LOG2;
-	dis->grid.pad.width  =
-	    CEIL_SHIFT(_ISP_BQS(sc_3a_dis_padded_width), SH_CSS_DIS_DECI_FACTOR_LOG2);
-	dis->grid.pad.height =
-	    CEIL_SHIFT(_ISP_BQS(sc_3a_dis_height), SH_CSS_DIS_DECI_FACTOR_LOG2);
-
-	dis->coef.dim.width  =
-	    (_ISP_BQS(sc_3a_dis_width)  >> SH_CSS_DIS_DECI_FACTOR_LOG2) <<
-	    SH_CSS_DIS_DECI_FACTOR_LOG2;
+	dis->grid.dim.width = _ISP_BQS(sc_3a_dis_width) >>
+			      SH_CSS_DIS_DECI_FACTOR_LOG2;
+	dis->grid.dim.height = _ISP_BQS(sc_3a_dis_height) >>
+			       SH_CSS_DIS_DECI_FACTOR_LOG2;
+	dis->grid.pad.width = CEIL_SHIFT(_ISP_BQS(sc_3a_dis_padded_width),
+					 SH_CSS_DIS_DECI_FACTOR_LOG2);
+	dis->grid.pad.height = CEIL_SHIFT(_ISP_BQS(sc_3a_dis_height),
+					  SH_CSS_DIS_DECI_FACTOR_LOG2);
+
+	dis->coef.dim.width =
+		(_ISP_BQS(sc_3a_dis_width) >> SH_CSS_DIS_DECI_FACTOR_LOG2)
+		<< SH_CSS_DIS_DECI_FACTOR_LOG2;
 	dis->coef.dim.height =
-	    (_ISP_BQS(sc_3a_dis_height) >> SH_CSS_DIS_DECI_FACTOR_LOG2) <<
-	    SH_CSS_DIS_DECI_FACTOR_LOG2;
-	dis->coef.pad.width  =
-	    __ISP_SDIS_HOR_COEF_NUM_VECS(sc_3a_dis_padded_width) * ISP_VEC_NELEMS;
+		(_ISP_BQS(sc_3a_dis_height) >> SH_CSS_DIS_DECI_FACTOR_LOG2)
+		<< SH_CSS_DIS_DECI_FACTOR_LOG2;
+	dis->coef.pad.width =
+		__ISP_SDIS_HOR_COEF_NUM_VECS(sc_3a_dis_padded_width) *
+		ISP_VEC_NELEMS;
 	dis->coef.pad.height =
-	    __ISP_SDIS_VER_COEF_NUM_VECS(sc_3a_dis_height) * ISP_VEC_NELEMS;
+		__ISP_SDIS_VER_COEF_NUM_VECS(sc_3a_dis_height) * ISP_VEC_NELEMS;
 	if (isp_pipe_version == 1) {
-		dis->proj.dim.width  =
-		    _ISP_BQS(sc_3a_dis_height) >> SH_CSS_DIS_DECI_FACTOR_LOG2;
-		dis->proj.dim.height =
-		    _ISP_BQS(sc_3a_dis_width)  >> SH_CSS_DIS_DECI_FACTOR_LOG2;
+		dis->proj.dim.width = _ISP_BQS(sc_3a_dis_height) >>
+				      SH_CSS_DIS_DECI_FACTOR_LOG2;
+		dis->proj.dim.height = _ISP_BQS(sc_3a_dis_width) >>
+				       SH_CSS_DIS_DECI_FACTOR_LOG2;
 	} else {
-		dis->proj.dim.width  =
-		    (_ISP_BQS(sc_3a_dis_width)  >> SH_CSS_DIS_DECI_FACTOR_LOG2) *
-		    (_ISP_BQS(sc_3a_dis_height) >> SH_CSS_DIS_DECI_FACTOR_LOG2);
-		dis->proj.dim.height =
-		    (_ISP_BQS(sc_3a_dis_width)  >> SH_CSS_DIS_DECI_FACTOR_LOG2) *
-		    (_ISP_BQS(sc_3a_dis_height) >> SH_CSS_DIS_DECI_FACTOR_LOG2);
-	}
-	dis->proj.pad.width  =
-	    __ISP_SDIS_HOR_PROJ_NUM_ISP(sc_3a_dis_padded_width,
-					sc_3a_dis_height,
-					SH_CSS_DIS_DECI_FACTOR_LOG2,
-					isp_pipe_version);
-	dis->proj.pad.height =
-	    __ISP_SDIS_VER_PROJ_NUM_ISP(sc_3a_dis_padded_width,
+		dis->proj.dim.width = (_ISP_BQS(sc_3a_dis_width) >>
+				       SH_CSS_DIS_DECI_FACTOR_LOG2) *
+				      (_ISP_BQS(sc_3a_dis_height) >>
+				       SH_CSS_DIS_DECI_FACTOR_LOG2);
+		dis->proj.dim.height = (_ISP_BQS(sc_3a_dis_width) >>
+					SH_CSS_DIS_DECI_FACTOR_LOG2) *
+				       (_ISP_BQS(sc_3a_dis_height) >>
 					SH_CSS_DIS_DECI_FACTOR_LOG2);
+	}
+	dis->proj.pad.width = __ISP_SDIS_HOR_PROJ_NUM_ISP(
+		sc_3a_dis_padded_width, sc_3a_dis_height,
+		SH_CSS_DIS_DECI_FACTOR_LOG2, isp_pipe_version);
+	dis->proj.pad.height = __ISP_SDIS_VER_PROJ_NUM_ISP(
+		sc_3a_dis_padded_width, SH_CSS_DIS_DECI_FACTOR_LOG2);
 }
 
-void ia_css_sdis_clear_coefficients(
-    struct ia_css_dvs_coefficients *dvs_coefs)
+void ia_css_sdis_clear_coefficients(struct ia_css_dvs_coefficients *dvs_coefs)
 {
 	dvs_coefs->hor_coefs = NULL;
 	dvs_coefs->ver_coefs = NULL;
 }
 
-int
-ia_css_get_dvs_statistics(
-    struct ia_css_dvs_statistics	       *host_stats,
-    const struct ia_css_isp_dvs_statistics *isp_stats)
+int ia_css_get_dvs_statistics(struct ia_css_dvs_statistics *host_stats,
+			      const struct ia_css_isp_dvs_statistics *isp_stats)
 {
 	struct ia_css_isp_dvs_statistics_map *map;
 	int ret = 0;
@@ -254,10 +244,9 @@ ia_css_get_dvs_statistics(
 	return ret;
 }
 
-void
-ia_css_translate_dvs_statistics(
-    struct ia_css_dvs_statistics               *host_stats,
-    const struct ia_css_isp_dvs_statistics_map *isp_stats)
+void ia_css_translate_dvs_statistics(
+	struct ia_css_dvs_statistics *host_stats,
+	const struct ia_css_isp_dvs_statistics_map *isp_stats)
 {
 	unsigned int hor_num_isp, ver_num_isp, hor_num_dvs, ver_num_dvs, i;
 	s32 *hor_ptr_dvs, *ver_ptr_dvs, *hor_ptr_isp, *ver_ptr_isp;
@@ -296,8 +285,7 @@ ia_css_translate_dvs_statistics(
 }
 
 struct ia_css_isp_dvs_statistics *
-ia_css_isp_dvs_statistics_allocate(
-    const struct ia_css_dvs_grid_info *grid)
+ia_css_isp_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
 {
 	struct ia_css_isp_dvs_statistics *me;
 	int hor_size, ver_size;
@@ -314,10 +302,10 @@ ia_css_isp_dvs_statistics_allocate(
 		goto err;
 
 	hor_size = CEIL_MUL(sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES *
-			    grid->aligned_height,
+				    grid->aligned_height,
 			    HIVE_ISP_DDR_WORD_BYTES);
 	ver_size = CEIL_MUL(sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES *
-			    grid->aligned_width,
+				    grid->aligned_width,
 			    HIVE_ISP_DDR_WORD_BYTES);
 
 	me->size = hor_size + ver_size;
@@ -340,10 +328,8 @@ ia_css_isp_dvs_statistics_allocate(
 	return NULL;
 }
 
-struct ia_css_isp_dvs_statistics_map *
-ia_css_isp_dvs_statistics_map_allocate(
-    const struct ia_css_isp_dvs_statistics *isp_stats,
-    void *data_ptr)
+struct ia_css_isp_dvs_statistics_map *ia_css_isp_dvs_statistics_map_allocate(
+	const struct ia_css_isp_dvs_statistics *isp_stats, void *data_ptr)
 {
 	struct ia_css_isp_dvs_statistics_map *me;
 	/* Windows compiler does not like adding sizes to a void *
@@ -380,8 +366,7 @@ ia_css_isp_dvs_statistics_map_allocate(
 	return NULL;
 }
 
-void
-ia_css_isp_dvs_statistics_map_free(struct ia_css_isp_dvs_statistics_map *me)
+void ia_css_isp_dvs_statistics_map_free(struct ia_css_isp_dvs_statistics_map *me)
 {
 	if (me) {
 		if (me->data_allocated)
@@ -390,8 +375,7 @@ ia_css_isp_dvs_statistics_map_free(struct ia_css_isp_dvs_statistics_map *me)
 	}
 }
 
-void
-ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me)
+void ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me)
 {
 	if (me) {
 		hmm_free(me->data_ptr);
@@ -400,28 +384,28 @@ ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me)
 }
 
 void ia_css_sdis_horicoef_debug_dtrace(
-    const struct ia_css_dvs_coefficients *config, unsigned int level)
+	const struct ia_css_dvs_coefficients *config, unsigned int level)
 {
 	(void)config;
 	(void)level;
 }
 
 void ia_css_sdis_vertcoef_debug_dtrace(
-    const struct ia_css_dvs_coefficients *config, unsigned int level)
+	const struct ia_css_dvs_coefficients *config, unsigned int level)
 {
 	(void)config;
 	(void)level;
 }
 
 void ia_css_sdis_horiproj_debug_dtrace(
-    const struct ia_css_dvs_coefficients *config, unsigned int level)
+	const struct ia_css_dvs_coefficients *config, unsigned int level)
 {
 	(void)config;
 	(void)level;
 }
 
 void ia_css_sdis_vertproj_debug_dtrace(
-    const struct ia_css_dvs_coefficients *config, unsigned int level)
+	const struct ia_css_dvs_coefficients *config, unsigned int level)
 {
 	(void)config;
 	(void)level;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.h
index c8566dafcbe584d8f6dec8a017344cb009f27b01..d0c7305125de92773e7cc6ac4edd83039b21b211 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.h
@@ -20,74 +20,59 @@ struct sh_css_isp_sdis_vert_coef_tbl;
 struct sh_css_isp_sdis_hori_proj_tbl;
 struct sh_css_isp_sdis_vert_proj_tbl;
 
-void ia_css_sdis_horicoef_vmem_encode(
-    struct sh_css_isp_sdis_hori_coef_tbl *to,
-    const struct ia_css_dvs_coefficients *from,
-    unsigned int size);
-
-void ia_css_sdis_vertcoef_vmem_encode(
-    struct sh_css_isp_sdis_vert_coef_tbl *to,
-    const struct ia_css_dvs_coefficients *from,
-    unsigned int size);
-
-void ia_css_sdis_horiproj_encode(
-    struct sh_css_isp_sdis_hori_proj_tbl *to,
-    const struct ia_css_dvs_coefficients *from,
-    unsigned int size);
-
-void ia_css_sdis_vertproj_encode(
-    struct sh_css_isp_sdis_vert_proj_tbl *to,
-    const struct ia_css_dvs_coefficients *from,
-    unsigned int size);
-
-void ia_css_get_isp_dis_coefficients(
-    struct ia_css_stream *stream,
-    short *horizontal_coefficients,
-    short *vertical_coefficients);
-
-int
-ia_css_get_dvs_statistics(
-    struct ia_css_dvs_statistics	       *host_stats,
-    const struct ia_css_isp_dvs_statistics *isp_stats);
-
-void
-ia_css_translate_dvs_statistics(
-    struct ia_css_dvs_statistics               *host_stats,
-    const struct ia_css_isp_dvs_statistics_map *isp_stats);
+void ia_css_sdis_horicoef_vmem_encode(struct sh_css_isp_sdis_hori_coef_tbl *to,
+				      const struct ia_css_dvs_coefficients *from,
+				      unsigned int size);
+
+void ia_css_sdis_vertcoef_vmem_encode(struct sh_css_isp_sdis_vert_coef_tbl *to,
+				      const struct ia_css_dvs_coefficients *from,
+				      unsigned int size);
+
+void ia_css_sdis_horiproj_encode(struct sh_css_isp_sdis_hori_proj_tbl *to,
+				 const struct ia_css_dvs_coefficients *from,
+				 unsigned int size);
+
+void ia_css_sdis_vertproj_encode(struct sh_css_isp_sdis_vert_proj_tbl *to,
+				 const struct ia_css_dvs_coefficients *from,
+				 unsigned int size);
+
+void ia_css_get_isp_dis_coefficients(struct ia_css_stream *stream,
+				     short *horizontal_coefficients,
+				     short *vertical_coefficients);
+
+int ia_css_get_dvs_statistics(struct ia_css_dvs_statistics *host_stats,
+			      const struct ia_css_isp_dvs_statistics *isp_stats);
+
+void ia_css_translate_dvs_statistics(
+	struct ia_css_dvs_statistics *host_stats,
+	const struct ia_css_isp_dvs_statistics_map *isp_stats);
 
 struct ia_css_isp_dvs_statistics *
-ia_css_isp_dvs_statistics_allocate(
-    const struct ia_css_dvs_grid_info *grid);
+ia_css_isp_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
 
-void
-ia_css_isp_dvs_statistics_free(
-    struct ia_css_isp_dvs_statistics *me);
+void ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me);
 
 size_t ia_css_sdis_hor_coef_tbl_bytes(const struct ia_css_binary *binary);
 size_t ia_css_sdis_ver_coef_tbl_bytes(const struct ia_css_binary *binary);
 
-void
-ia_css_sdis_init_info(
-    struct ia_css_sdis_info *dis,
-    unsigned int sc_3a_dis_width,
-    unsigned int sc_3a_dis_padded_width,
-    unsigned int sc_3a_dis_height,
-    unsigned int isp_pipe_version,
-    unsigned int enabled);
+void ia_css_sdis_init_info(struct ia_css_sdis_info *dis,
+			   unsigned int sc_3a_dis_width,
+			   unsigned int sc_3a_dis_padded_width,
+			   unsigned int sc_3a_dis_height,
+			   unsigned int isp_pipe_version, unsigned int enabled);
 
-void ia_css_sdis_clear_coefficients(
-    struct ia_css_dvs_coefficients *dvs_coefs);
+void ia_css_sdis_clear_coefficients(struct ia_css_dvs_coefficients *dvs_coefs);
 
 void ia_css_sdis_horicoef_debug_dtrace(
-    const struct ia_css_dvs_coefficients *config, unsigned int level);
+	const struct ia_css_dvs_coefficients *config, unsigned int level);
 
 void ia_css_sdis_vertcoef_debug_dtrace(
-    const struct ia_css_dvs_coefficients *config, unsigned int level);
+	const struct ia_css_dvs_coefficients *config, unsigned int level);
 
 void ia_css_sdis_horiproj_debug_dtrace(
-    const struct ia_css_dvs_coefficients *config, unsigned int level);
+	const struct ia_css_dvs_coefficients *config, unsigned int level);
 
 void ia_css_sdis_vertproj_debug_dtrace(
-    const struct ia_css_dvs_coefficients *config, unsigned int level);
+	const struct ia_css_dvs_coefficients *config, unsigned int level);
 
 #endif /* __IA_CSS_SDIS_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis_types.h
index 02a91968c37aed57acc5bd5a767dd5ef4a242a5a..133f101635631049f7606b84b57b3b5debfbb940 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_1.0/ia_css_sdis_types.h
@@ -12,7 +12,7 @@
 */
 
 /* Number of DVS coefficient types */
-#define IA_CSS_DVS_NUM_COEF_TYPES      6
+#define IA_CSS_DVS_NUM_COEF_TYPES 6
 
 #ifndef PIPE_GENERATION
 #include "isp/kernels/sdis/common/ia_css_sdis_common_types.h"
@@ -24,10 +24,10 @@
 
 struct ia_css_dvs_coefficients {
 	struct ia_css_dvs_grid_info
-		grid;/** grid info contains the dimensions of the dvs grid */
-	s16 *hor_coefs;	/** the pointer to int16_t[grid.num_hor_coefs * IA_CSS_DVS_NUM_COEF_TYPES]
+		grid; /** grid info contains the dimensions of the dvs grid */
+	s16 *hor_coefs; /** the pointer to int16_t[grid.num_hor_coefs * IA_CSS_DVS_NUM_COEF_TYPES]
 				     containing the horizontal coefficients */
-	s16 *ver_coefs;	/** the pointer to int16_t[grid.num_ver_coefs * IA_CSS_DVS_NUM_COEF_TYPES]
+	s16 *ver_coefs; /** the pointer to int16_t[grid.num_ver_coefs * IA_CSS_DVS_NUM_COEF_TYPES]
 				     containing the vertical coefficients */
 };
 
@@ -37,10 +37,10 @@ struct ia_css_dvs_coefficients {
 
 struct ia_css_dvs_statistics {
 	struct ia_css_dvs_grid_info
-		grid;/** grid info contains the dimensions of the dvs grid */
-	s32 *hor_proj;	/** the pointer to int16_t[grid.height * IA_CSS_DVS_NUM_COEF_TYPES]
+		grid; /** grid info contains the dimensions of the dvs grid */
+	s32 *hor_proj; /** the pointer to int16_t[grid.height * IA_CSS_DVS_NUM_COEF_TYPES]
 				     containing the horizontal projections */
-	s32 *ver_proj;	/** the pointer to int16_t[grid.width * IA_CSS_DVS_NUM_COEF_TYPES]
+	s32 *ver_proj; /** the pointer to int16_t[grid.width * IA_CSS_DVS_NUM_COEF_TYPES]
 				     containing the vertical projections */
 };
 
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c
index 027eae0ca69e27760756494c44af793c7705f6a2..2ce9e1a1285456fef11550e80a743be87a10b9e2 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c
@@ -16,78 +16,83 @@ const struct ia_css_dvs2_coefficients default_sdis2_config = {
 	.ver_coefs = { NULL, NULL, NULL, NULL },
 };
 
-static void
-fill_row(short *private, const short *public, unsigned int width,
-	 unsigned int padding)
+static void fill_row(short *private, const short *public, unsigned int width,
+		     unsigned int padding)
 {
 	memcpy(private, public, width * sizeof(short));
 	memset(&private[width], 0, padding * sizeof(short));
 }
 
 void ia_css_sdis2_horicoef_vmem_encode(
-    struct sh_css_isp_sdis_hori_coef_tbl *to,
-    const struct ia_css_dvs2_coefficients *from,
-    unsigned int size)
+	struct sh_css_isp_sdis_hori_coef_tbl *to,
+	const struct ia_css_dvs2_coefficients *from, unsigned int size)
 {
-	unsigned int aligned_width = from->grid.aligned_width *
-				     from->grid.bqs_per_grid_cell;
-	unsigned int width         = from->grid.num_hor_coefs;
-	int      padding       = aligned_width - width;
-	unsigned int stride        = size / IA_CSS_DVS2_NUM_COEF_TYPES / sizeof(short);
-	unsigned int total_bytes   = aligned_width * IA_CSS_DVS2_NUM_COEF_TYPES *
-				     sizeof(short);
-	short   *private       = (short *)to;
+	unsigned int aligned_width =
+		from->grid.aligned_width * from->grid.bqs_per_grid_cell;
+	unsigned int width = from->grid.num_hor_coefs;
+	int padding = aligned_width - width;
+	unsigned int stride = size / IA_CSS_DVS2_NUM_COEF_TYPES / sizeof(short);
+	unsigned int total_bytes =
+		aligned_width * IA_CSS_DVS2_NUM_COEF_TYPES * sizeof(short);
+	short *private = (short *)to;
 
 	/* Copy the table, add padding */
 	assert(padding >= 0);
 	assert(total_bytes <= size);
-	assert(size % (IA_CSS_DVS2_NUM_COEF_TYPES * ISP_VEC_NELEMS * sizeof(
-			   short)) == 0);
-	fill_row(&private[0 * stride], from->hor_coefs.odd_real,  width, padding);
-	fill_row(&private[1 * stride], from->hor_coefs.odd_imag,  width, padding);
-	fill_row(&private[2 * stride], from->hor_coefs.even_real, width, padding);
-	fill_row(&private[3 * stride], from->hor_coefs.even_imag, width, padding);
+	assert(size % (IA_CSS_DVS2_NUM_COEF_TYPES * ISP_VEC_NELEMS *
+		       sizeof(short)) ==
+	       0);
+	fill_row(&private[0 * stride], from->hor_coefs.odd_real, width,
+		 padding);
+	fill_row(&private[1 * stride], from->hor_coefs.odd_imag, width,
+		 padding);
+	fill_row(&private[2 * stride], from->hor_coefs.even_real, width,
+		 padding);
+	fill_row(&private[3 * stride], from->hor_coefs.even_imag, width,
+		 padding);
 }
 
 void ia_css_sdis2_vertcoef_vmem_encode(
-    struct sh_css_isp_sdis_vert_coef_tbl *to,
-    const struct ia_css_dvs2_coefficients *from,
-    unsigned int size)
+	struct sh_css_isp_sdis_vert_coef_tbl *to,
+	const struct ia_css_dvs2_coefficients *from, unsigned int size)
 {
-	unsigned int aligned_height = from->grid.aligned_height *
-				      from->grid.bqs_per_grid_cell;
-	unsigned int height         = from->grid.num_ver_coefs;
-	int      padding        = aligned_height - height;
-	unsigned int stride         = size / IA_CSS_DVS2_NUM_COEF_TYPES / sizeof(short);
-	unsigned int total_bytes    = aligned_height * IA_CSS_DVS2_NUM_COEF_TYPES *
-				      sizeof(short);
-	short   *private        = (short *)to;
+	unsigned int aligned_height =
+		from->grid.aligned_height * from->grid.bqs_per_grid_cell;
+	unsigned int height = from->grid.num_ver_coefs;
+	int padding = aligned_height - height;
+	unsigned int stride = size / IA_CSS_DVS2_NUM_COEF_TYPES / sizeof(short);
+	unsigned int total_bytes =
+		aligned_height * IA_CSS_DVS2_NUM_COEF_TYPES * sizeof(short);
+	short *private = (short *)to;
 
 	/* Copy the table, add padding */
 	assert(padding >= 0);
 	assert(total_bytes <= size);
-	assert(size % (IA_CSS_DVS2_NUM_COEF_TYPES * ISP_VEC_NELEMS * sizeof(
-			   short)) == 0);
-	fill_row(&private[0 * stride], from->ver_coefs.odd_real,  height, padding);
-	fill_row(&private[1 * stride], from->ver_coefs.odd_imag,  height, padding);
-	fill_row(&private[2 * stride], from->ver_coefs.even_real, height, padding);
-	fill_row(&private[3 * stride], from->ver_coefs.even_imag, height, padding);
+	assert(size % (IA_CSS_DVS2_NUM_COEF_TYPES * ISP_VEC_NELEMS *
+		       sizeof(short)) ==
+	       0);
+	fill_row(&private[0 * stride], from->ver_coefs.odd_real, height,
+		 padding);
+	fill_row(&private[1 * stride], from->ver_coefs.odd_imag, height,
+		 padding);
+	fill_row(&private[2 * stride], from->ver_coefs.even_real, height,
+		 padding);
+	fill_row(&private[3 * stride], from->ver_coefs.even_imag, height,
+		 padding);
 }
 
-void ia_css_sdis2_horiproj_encode(
-    struct sh_css_isp_sdis_hori_proj_tbl *to,
-    const struct ia_css_dvs2_coefficients *from,
-    unsigned int size)
+void ia_css_sdis2_horiproj_encode(struct sh_css_isp_sdis_hori_proj_tbl *to,
+				  const struct ia_css_dvs2_coefficients *from,
+				  unsigned int size)
 {
 	(void)to;
 	(void)from;
 	(void)size;
 }
 
-void ia_css_sdis2_vertproj_encode(
-    struct sh_css_isp_sdis_vert_proj_tbl *to,
-    const struct ia_css_dvs2_coefficients *from,
-    unsigned int size)
+void ia_css_sdis2_vertproj_encode(struct sh_css_isp_sdis_vert_proj_tbl *to,
+				  const struct ia_css_dvs2_coefficients *from,
+				  unsigned int size)
 {
 	(void)to;
 	(void)from;
@@ -95,15 +100,11 @@ void ia_css_sdis2_vertproj_encode(
 }
 
 void ia_css_get_isp_dvs2_coefficients(
-    struct ia_css_stream *stream,
-    short *hor_coefs_odd_real,
-    short *hor_coefs_odd_imag,
-    short *hor_coefs_even_real,
-    short *hor_coefs_even_imag,
-    short *ver_coefs_odd_real,
-    short *ver_coefs_odd_imag,
-    short *ver_coefs_even_real,
-    short *ver_coefs_even_imag)
+	struct ia_css_stream *stream, short *hor_coefs_odd_real,
+	short *hor_coefs_odd_imag, short *hor_coefs_even_real,
+	short *hor_coefs_even_imag, short *ver_coefs_odd_real,
+	short *ver_coefs_odd_imag, short *ver_coefs_even_real,
+	short *ver_coefs_even_imag)
 {
 	struct ia_css_isp_parameters *params;
 	unsigned int hor_num_3a, ver_num_3a;
@@ -128,20 +129,20 @@ void ia_css_get_isp_dvs2_coefficients(
 	if (!dvs_binary)
 		return;
 
-	hor_num_3a  = dvs_binary->dis.coef.dim.width;
-	ver_num_3a  = dvs_binary->dis.coef.dim.height;
+	hor_num_3a = dvs_binary->dis.coef.dim.width;
+	ver_num_3a = dvs_binary->dis.coef.dim.height;
 
-	memcpy(hor_coefs_odd_real,  params->dvs2_coefs.hor_coefs.odd_real,
+	memcpy(hor_coefs_odd_real, params->dvs2_coefs.hor_coefs.odd_real,
 	       hor_num_3a * sizeof(short));
-	memcpy(hor_coefs_odd_imag,  params->dvs2_coefs.hor_coefs.odd_imag,
+	memcpy(hor_coefs_odd_imag, params->dvs2_coefs.hor_coefs.odd_imag,
 	       hor_num_3a * sizeof(short));
 	memcpy(hor_coefs_even_real, params->dvs2_coefs.hor_coefs.even_real,
 	       hor_num_3a * sizeof(short));
 	memcpy(hor_coefs_even_imag, params->dvs2_coefs.hor_coefs.even_imag,
 	       hor_num_3a * sizeof(short));
-	memcpy(ver_coefs_odd_real,  params->dvs2_coefs.ver_coefs.odd_real,
+	memcpy(ver_coefs_odd_real, params->dvs2_coefs.ver_coefs.odd_real,
 	       ver_num_3a * sizeof(short));
-	memcpy(ver_coefs_odd_imag,  params->dvs2_coefs.ver_coefs.odd_imag,
+	memcpy(ver_coefs_odd_imag, params->dvs2_coefs.ver_coefs.odd_imag,
 	       ver_num_3a * sizeof(short));
 	memcpy(ver_coefs_even_real, params->dvs2_coefs.ver_coefs.even_real,
 	       ver_num_3a * sizeof(short));
@@ -151,23 +152,21 @@ void ia_css_get_isp_dvs2_coefficients(
 	IA_CSS_LEAVE("void");
 }
 
-void ia_css_sdis2_clear_coefficients(
-    struct ia_css_dvs2_coefficients *dvs2_coefs)
+void ia_css_sdis2_clear_coefficients(struct ia_css_dvs2_coefficients *dvs2_coefs)
 {
-	dvs2_coefs->hor_coefs.odd_real  = NULL;
-	dvs2_coefs->hor_coefs.odd_imag  = NULL;
+	dvs2_coefs->hor_coefs.odd_real = NULL;
+	dvs2_coefs->hor_coefs.odd_imag = NULL;
 	dvs2_coefs->hor_coefs.even_real = NULL;
 	dvs2_coefs->hor_coefs.even_imag = NULL;
-	dvs2_coefs->ver_coefs.odd_real  = NULL;
-	dvs2_coefs->ver_coefs.odd_imag  = NULL;
+	dvs2_coefs->ver_coefs.odd_real = NULL;
+	dvs2_coefs->ver_coefs.odd_imag = NULL;
 	dvs2_coefs->ver_coefs.even_real = NULL;
 	dvs2_coefs->ver_coefs.even_imag = NULL;
 }
 
-int
-ia_css_get_dvs2_statistics(
-    struct ia_css_dvs2_statistics          *host_stats,
-    const struct ia_css_isp_dvs_statistics *isp_stats) {
+int ia_css_get_dvs2_statistics(struct ia_css_dvs2_statistics *host_stats,
+			       const struct ia_css_isp_dvs_statistics *isp_stats)
+{
 	struct ia_css_isp_dvs_statistics_map *map;
 	int ret = 0;
 
@@ -177,13 +176,11 @@ ia_css_get_dvs2_statistics(
 	assert(isp_stats);
 
 	map = ia_css_isp_dvs_statistics_map_allocate(isp_stats, NULL);
-	if (map)
-	{
+	if (map) {
 		hmm_load(isp_stats->data_ptr, map->data_ptr, isp_stats->size);
 		ia_css_translate_dvs2_statistics(host_stats, map);
 		ia_css_isp_dvs_statistics_map_free(map);
-	} else
-	{
+	} else {
 		IA_CSS_ERROR("out of memory");
 		ret = -ENOMEM;
 	}
@@ -192,10 +189,9 @@ ia_css_get_dvs2_statistics(
 	return ret;
 }
 
-void
-ia_css_translate_dvs2_statistics(
-    struct ia_css_dvs2_statistics		   *host_stats,
-    const struct ia_css_isp_dvs_statistics_map *isp_stats)
+void ia_css_translate_dvs2_statistics(
+	struct ia_css_dvs2_statistics *host_stats,
+	const struct ia_css_isp_dvs_statistics_map *isp_stats)
 {
 	unsigned int size_bytes, table_width, table_size, height;
 	unsigned int src_offset = 0, dst_offset = 0;
@@ -214,20 +210,21 @@ ia_css_translate_dvs2_statistics(
 	assert(isp_stats->hor_proj);
 	assert(isp_stats->ver_proj);
 
-	IA_CSS_ENTER("hor_coefs.odd_real=%p, hor_coefs.odd_imag=%p, hor_coefs.even_real=%p, hor_coefs.even_imag=%p, ver_coefs.odd_real=%p, ver_coefs.odd_imag=%p, ver_coefs.even_real=%p, ver_coefs.even_imag=%p, haddr=%p, vaddr=%p",
-		     host_stats->hor_prod.odd_real, host_stats->hor_prod.odd_imag,
-		     host_stats->hor_prod.even_real, host_stats->hor_prod.even_imag,
-		     host_stats->ver_prod.odd_real, host_stats->ver_prod.odd_imag,
-		     host_stats->ver_prod.even_real, host_stats->ver_prod.even_imag,
-		     isp_stats->hor_proj, isp_stats->ver_proj);
+	IA_CSS_ENTER(
+		"hor_coefs.odd_real=%p, hor_coefs.odd_imag=%p, hor_coefs.even_real=%p, hor_coefs.even_imag=%p, ver_coefs.odd_real=%p, ver_coefs.odd_imag=%p, ver_coefs.even_real=%p, ver_coefs.even_imag=%p, haddr=%p, vaddr=%p",
+		host_stats->hor_prod.odd_real, host_stats->hor_prod.odd_imag,
+		host_stats->hor_prod.even_real, host_stats->hor_prod.even_imag,
+		host_stats->ver_prod.odd_real, host_stats->ver_prod.odd_imag,
+		host_stats->ver_prod.even_real, host_stats->ver_prod.even_imag,
+		isp_stats->hor_proj, isp_stats->ver_proj);
 
 	/* Host side: reflecting the true width in bytes */
 	size_bytes = host_stats->grid.aligned_width * sizeof(*htemp_ptr);
 
 	/* DDR side: need to be aligned to the system bus width */
 	/* statistics table width in terms of 32-bit words*/
-	table_width = CEIL_MUL(size_bytes,
-			       HIVE_ISP_DDR_WORD_BYTES) / sizeof(*htemp_ptr);
+	table_width = CEIL_MUL(size_bytes, HIVE_ISP_DDR_WORD_BYTES) /
+		      sizeof(*htemp_ptr);
 	table_size = table_width * host_stats->grid.aligned_height;
 
 	htemp_ptr = isp_stats->hor_proj; /* horizontal stats */
@@ -261,8 +258,7 @@ ia_css_translate_dvs2_statistics(
 }
 
 struct ia_css_isp_dvs_statistics *
-ia_css_isp_dvs2_statistics_allocate(
-    const struct ia_css_dvs_grid_info *grid)
+ia_css_isp_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
 {
 	struct ia_css_isp_dvs_statistics *me;
 	int size;
@@ -281,8 +277,9 @@ ia_css_isp_dvs2_statistics_allocate(
 	/* on ISP 2 SDIS DMA model, every row of projection table width must be
 	   aligned to HIVE_ISP_DDR_WORD_BYTES
 	*/
-	size = CEIL_MUL(sizeof(int) * grid->aligned_width, HIVE_ISP_DDR_WORD_BYTES)
-	       * grid->aligned_height * IA_CSS_DVS2_NUM_COEF_TYPES;
+	size = CEIL_MUL(sizeof(int) * grid->aligned_width,
+			HIVE_ISP_DDR_WORD_BYTES) *
+	       grid->aligned_height * IA_CSS_DVS2_NUM_COEF_TYPES;
 
 	me->size = 2 * size;
 	me->data_ptr = hmm_alloc(me->size);
@@ -302,8 +299,7 @@ ia_css_isp_dvs2_statistics_allocate(
 	return NULL;
 }
 
-void
-ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me)
+void ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me)
 {
 	if (me) {
 		hmm_free(me->data_ptr);
@@ -312,28 +308,28 @@ ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me)
 }
 
 void ia_css_sdis2_horicoef_debug_dtrace(
-    const struct ia_css_dvs2_coefficients *config, unsigned int level)
+	const struct ia_css_dvs2_coefficients *config, unsigned int level)
 {
 	(void)config;
 	(void)level;
 }
 
 void ia_css_sdis2_vertcoef_debug_dtrace(
-    const struct ia_css_dvs2_coefficients *config, unsigned int level)
+	const struct ia_css_dvs2_coefficients *config, unsigned int level)
 {
 	(void)config;
 	(void)level;
 }
 
 void ia_css_sdis2_horiproj_debug_dtrace(
-    const struct ia_css_dvs2_coefficients *config, unsigned int level)
+	const struct ia_css_dvs2_coefficients *config, unsigned int level)
 {
 	(void)config;
 	(void)level;
 }
 
 void ia_css_sdis2_vertproj_debug_dtrace(
-    const struct ia_css_dvs2_coefficients *config, unsigned int level)
+	const struct ia_css_dvs2_coefficients *config, unsigned int level)
 {
 	(void)config;
 	(void)level;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.h
index e8ec4066c1cbdf47bd922a887412056a4ac230a6..849628a48d4bb5d28e92eb959274e72c1fa632bd 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.h
@@ -21,67 +21,54 @@ struct sh_css_isp_sdis_hori_proj_tbl;
 struct sh_css_isp_sdis_vert_proj_tbl;
 
 void ia_css_sdis2_horicoef_vmem_encode(
-    struct sh_css_isp_sdis_hori_coef_tbl *to,
-    const struct ia_css_dvs2_coefficients *from,
-    unsigned int size);
+	struct sh_css_isp_sdis_hori_coef_tbl *to,
+	const struct ia_css_dvs2_coefficients *from, unsigned int size);
 
 void ia_css_sdis2_vertcoef_vmem_encode(
-    struct sh_css_isp_sdis_vert_coef_tbl *to,
-    const struct ia_css_dvs2_coefficients *from,
-    unsigned int size);
+	struct sh_css_isp_sdis_vert_coef_tbl *to,
+	const struct ia_css_dvs2_coefficients *from, unsigned int size);
 
-void ia_css_sdis2_horiproj_encode(
-    struct sh_css_isp_sdis_hori_proj_tbl *to,
-    const struct ia_css_dvs2_coefficients *from,
-    unsigned int size);
+void ia_css_sdis2_horiproj_encode(struct sh_css_isp_sdis_hori_proj_tbl *to,
+				  const struct ia_css_dvs2_coefficients *from,
+				  unsigned int size);
 
-void ia_css_sdis2_vertproj_encode(
-    struct sh_css_isp_sdis_vert_proj_tbl *to,
-    const struct ia_css_dvs2_coefficients *from,
-    unsigned int size);
+void ia_css_sdis2_vertproj_encode(struct sh_css_isp_sdis_vert_proj_tbl *to,
+				  const struct ia_css_dvs2_coefficients *from,
+				  unsigned int size);
 
 void ia_css_get_isp_dvs2_coefficients(
-    struct ia_css_stream *stream,
-    short *hor_coefs_odd_real,
-    short *hor_coefs_odd_imag,
-    short *hor_coefs_even_real,
-    short *hor_coefs_even_imag,
-    short *ver_coefs_odd_real,
-    short *ver_coefs_odd_imag,
-    short *ver_coefs_even_real,
-    short *ver_coefs_even_imag);
+	struct ia_css_stream *stream, short *hor_coefs_odd_real,
+	short *hor_coefs_odd_imag, short *hor_coefs_even_real,
+	short *hor_coefs_even_imag, short *ver_coefs_odd_real,
+	short *ver_coefs_odd_imag, short *ver_coefs_even_real,
+	short *ver_coefs_even_imag);
 
 void ia_css_sdis2_clear_coefficients(
-    struct ia_css_dvs2_coefficients *dvs2_coefs);
+	struct ia_css_dvs2_coefficients *dvs2_coefs);
 
-int
-ia_css_get_dvs2_statistics(
-    struct ia_css_dvs2_statistics	       *host_stats,
-    const struct ia_css_isp_dvs_statistics *isp_stats);
+int ia_css_get_dvs2_statistics(
+	struct ia_css_dvs2_statistics *host_stats,
+	const struct ia_css_isp_dvs_statistics *isp_stats);
 
-void
-ia_css_translate_dvs2_statistics(
-    struct ia_css_dvs2_statistics              *host_stats,
-    const struct ia_css_isp_dvs_statistics_map *isp_stats);
+void ia_css_translate_dvs2_statistics(
+	struct ia_css_dvs2_statistics *host_stats,
+	const struct ia_css_isp_dvs_statistics_map *isp_stats);
 
 struct ia_css_isp_dvs_statistics *
-ia_css_isp_dvs2_statistics_allocate(
-    const struct ia_css_dvs_grid_info *grid);
+ia_css_isp_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
 
-void
-ia_css_isp_dvs2_statistics_free(
-    struct ia_css_isp_dvs_statistics *me);
+void ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me);
 
 void ia_css_sdis2_horicoef_debug_dtrace(
-    const struct ia_css_dvs2_coefficients *config, unsigned int level);
+	const struct ia_css_dvs2_coefficients *config, unsigned int level);
 
 void ia_css_sdis2_vertcoef_debug_dtrace(
-    const struct ia_css_dvs2_coefficients *config, unsigned int level);
+	const struct ia_css_dvs2_coefficients *config, unsigned int level);
 
 void ia_css_sdis2_horiproj_debug_dtrace(
-    const struct ia_css_dvs2_coefficients *config, unsigned int level);
+	const struct ia_css_dvs2_coefficients *config, unsigned int level);
 
 void ia_css_sdis2_vertproj_debug_dtrace(
-    const struct ia_css_dvs2_coefficients *config, unsigned int level);
+	const struct ia_css_dvs2_coefficients *config, unsigned int level);
 
 #endif /* __IA_CSS_SDIS2_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2_types.h
index 2bed08435755a4d02aaf5fe8bea697172d55211d..866b467a0e1a082036cc5d57a875502ec639686e 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/sdis/sdis_2/ia_css_sdis2_types.h
@@ -12,7 +12,7 @@
 */
 
 /* Number of DVS coefficient types */
-#define IA_CSS_DVS2_NUM_COEF_TYPES     4
+#define IA_CSS_DVS2_NUM_COEF_TYPES 4
 
 #ifndef PIPE_GENERATION
 #include "isp/kernels/sdis/common/ia_css_sdis_common_types.h"
@@ -24,8 +24,8 @@
 struct ia_css_dvs2_coef_types {
 	s16 *odd_real; /** real part of the odd coefficients*/
 	s16 *odd_imag; /** imaginary part of the odd coefficients*/
-	s16 *even_real;/** real part of the even coefficients*/
-	s16 *even_imag;/** imaginary part of the even coefficients*/
+	s16 *even_real; /** real part of the even coefficients*/
+	s16 *even_imag; /** imaginary part of the even coefficients*/
 };
 
 /* DVS 2.0 Coefficients. This structure describes the coefficients that are needed for the dvs statistics.
@@ -34,7 +34,7 @@ struct ia_css_dvs2_coef_types {
  */
 struct ia_css_dvs2_coefficients {
 	struct ia_css_dvs_grid_info
-		grid;        /** grid info contains the dimensions of the dvs grid */
+		grid; /** grid info contains the dimensions of the dvs grid */
 	struct ia_css_dvs2_coef_types
 		hor_coefs; /** struct with pointers that contain the horizontal coefficients */
 	struct ia_css_dvs2_coef_types
@@ -47,8 +47,8 @@ struct ia_css_dvs2_coefficients {
 struct ia_css_dvs2_stat_types {
 	s32 *odd_real; /** real part of the odd statistics*/
 	s32 *odd_imag; /** imaginary part of the odd statistics*/
-	s32 *even_real;/** real part of the even statistics*/
-	s32 *even_imag;/** imaginary part of the even statistics*/
+	s32 *even_real; /** real part of the even statistics*/
+	s32 *even_imag; /** imaginary part of the even statistics*/
 };
 
 /* DVS 2.0 Statistics. This structure describes the statistics that are generated using the provided coefficients.
@@ -57,7 +57,7 @@ struct ia_css_dvs2_stat_types {
  */
 struct ia_css_dvs2_statistics {
 	struct ia_css_dvs_grid_info
-		grid;       /** grid info contains the dimensions of the dvs grid */
+		grid; /** grid info contains the dimensions of the dvs grid */
 	struct ia_css_dvs2_stat_types
 		hor_prod; /** struct with pointers that contain the horizontal statistics */
 	struct ia_css_dvs2_stat_types
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c
index ce93a07a7961cf9ee6590d059cc9bc59ee2bbc97..9f3fe899d1b9d3fc733679ab63a70b31f1ad4110 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c
@@ -8,58 +8,50 @@
 #include "ia_css_tdf.host.h"
 
 static const s16 g_pyramid[8][8] = {
-	{128, 384, 640, 896, 896, 640, 384, 128},
-	{384, 1152, 1920, 2688, 2688, 1920, 1152, 384},
-	{640, 1920, 3200, 4480, 4480, 3200, 1920, 640},
-	{896, 2688, 4480, 6272, 6272, 4480, 2688, 896},
-	{896, 2688, 4480, 6272, 6272, 4480, 2688, 896},
-	{640, 1920, 3200, 4480, 4480, 3200, 1920, 640},
-	{384, 1152, 1920, 2688, 2688, 1920, 1152, 384},
-	{128, 384, 640, 896, 896, 640, 384, 128}
+	{ 128, 384, 640, 896, 896, 640, 384, 128 },
+	{ 384, 1152, 1920, 2688, 2688, 1920, 1152, 384 },
+	{ 640, 1920, 3200, 4480, 4480, 3200, 1920, 640 },
+	{ 896, 2688, 4480, 6272, 6272, 4480, 2688, 896 },
+	{ 896, 2688, 4480, 6272, 6272, 4480, 2688, 896 },
+	{ 640, 1920, 3200, 4480, 4480, 3200, 1920, 640 },
+	{ 384, 1152, 1920, 2688, 2688, 1920, 1152, 384 },
+	{ 128, 384, 640, 896, 896, 640, 384, 128 }
 };
 
-void
-ia_css_tdf_vmem_encode(
-    struct ia_css_isp_tdf_vmem_params *to,
-    const struct ia_css_tdf_config *from,
-    size_t size)
+void ia_css_tdf_vmem_encode(struct ia_css_isp_tdf_vmem_params *to,
+			    const struct ia_css_tdf_config *from, size_t size)
 {
 	unsigned int i;
 	(void)size;
 
 	for (i = 0; i < ISP_VEC_NELEMS; i++) {
-		to->pyramid[0][i]          = g_pyramid[i / 8][i % 8];
-		to->threshold_flat[0][i]   = from->thres_flat_table[i];
+		to->pyramid[0][i] = g_pyramid[i / 8][i % 8];
+		to->threshold_flat[0][i] = from->thres_flat_table[i];
 		to->threshold_detail[0][i] = from->thres_detail_table[i];
 	}
 }
 
-void
-ia_css_tdf_encode(
-    struct ia_css_isp_tdf_dmem_params *to,
-    const struct ia_css_tdf_config *from,
-    size_t size)
+void ia_css_tdf_encode(struct ia_css_isp_tdf_dmem_params *to,
+		       const struct ia_css_tdf_config *from, size_t size)
 {
 	(void)size;
-	to->Epsilon_0        = from->epsilon_0;
-	to->Epsilon_1        = from->epsilon_1;
-	to->EpsScaleText     = from->eps_scale_text;
-	to->EpsScaleEdge     = from->eps_scale_edge;
-	to->Sepa_flat	     = from->sepa_flat;
-	to->Sepa_Edge	     = from->sepa_edge;
-	to->Blend_Flat	     = from->blend_flat;
-	to->Blend_Text	     = from->blend_text;
-	to->Blend_Edge	     = from->blend_edge;
-	to->Shading_Gain     = from->shading_gain;
+	to->Epsilon_0 = from->epsilon_0;
+	to->Epsilon_1 = from->epsilon_1;
+	to->EpsScaleText = from->eps_scale_text;
+	to->EpsScaleEdge = from->eps_scale_edge;
+	to->Sepa_flat = from->sepa_flat;
+	to->Sepa_Edge = from->sepa_edge;
+	to->Blend_Flat = from->blend_flat;
+	to->Blend_Text = from->blend_text;
+	to->Blend_Edge = from->blend_edge;
+	to->Shading_Gain = from->shading_gain;
 	to->Shading_baseGain = from->shading_base_gain;
-	to->LocalY_Gain      = from->local_y_gain;
-	to->LocalY_baseGain  = from->local_y_base_gain;
+	to->LocalY_Gain = from->local_y_gain;
+	to->LocalY_baseGain = from->local_y_base_gain;
 }
 
-void
-ia_css_tdf_debug_dtrace(
-    const struct ia_css_tdf_config *config,
-    unsigned int level)
+void ia_css_tdf_debug_dtrace(const struct ia_css_tdf_config *config,
+			     unsigned int level)
 {
 	(void)config;
 	(void)level;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.h
index 22ec8745a08394b0ee67c48225c697b066b9a050..1afce891969fc8156eaf4a63bdfaa9cb5e807f12 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.h
@@ -10,21 +10,13 @@
 #include "ia_css_tdf_types.h"
 #include "ia_css_tdf_param.h"
 
-void
-ia_css_tdf_vmem_encode(
-    struct ia_css_isp_tdf_vmem_params *to,
-    const struct ia_css_tdf_config *from,
-    size_t size);
+void ia_css_tdf_vmem_encode(struct ia_css_isp_tdf_vmem_params *to,
+			    const struct ia_css_tdf_config *from, size_t size);
 
-void
-ia_css_tdf_encode(
-    struct ia_css_isp_tdf_dmem_params *to,
-    const struct ia_css_tdf_config *from,
-    size_t size);
+void ia_css_tdf_encode(struct ia_css_isp_tdf_dmem_params *to,
+		       const struct ia_css_tdf_config *from, size_t size);
 
-void
-ia_css_tdf_debug_dtrace(
-    const struct ia_css_tdf_config *config, unsigned int level)
-;
+void ia_css_tdf_debug_dtrace(const struct ia_css_tdf_config *config,
+			     unsigned int level);
 
 #endif /* __IA_CSS_TDF_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h
index a462365783afa06ccfd8f42960b0968c6d1b5c5d..9f28dbb57e1a2ad45d2955479b4f47bcfbce711d 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h
@@ -22,23 +22,25 @@
  * ISP2.6.1: TDF is used.
  */
 struct ia_css_tdf_config {
-	s32 thres_flat_table[64];	/** Final optimized strength table of NR for flat region. */
-	s32 thres_detail_table[64];	/** Final optimized strength table of NR for detail region. */
-	s32 epsilon_0;		/** Coefficient to control variance for dark area (for flat region). */
-	s32 epsilon_1;		/** Coefficient to control variance for bright area (for flat region). */
-	s32 eps_scale_text;		/** Epsilon scaling coefficient for texture region. */
-	s32 eps_scale_edge;		/** Epsilon scaling coefficient for edge region. */
-	s32 sepa_flat;		/** Threshold to judge flat (edge < m_Flat_thre). */
-	s32 sepa_edge;		/** Threshold to judge edge (edge > m_Edge_thre). */
-	s32 blend_flat;		/** Blending ratio at flat region. */
-	s32 blend_text;		/** Blending ratio at texture region. */
-	s32 blend_edge;		/** Blending ratio at edge region. */
-	s32 shading_gain;		/** Gain of Shading control. */
-	s32 shading_base_gain;	/** Base Gain of Shading control. */
-	s32 local_y_gain;		/** Gain of local luminance control. */
-	s32 local_y_base_gain;	/** Base gain of local luminance control. */
-	s32 rad_x_origin;		/** Initial x coord. for radius computation. */
-	s32 rad_y_origin;		/** Initial y coord. for radius computation. */
+	s32 thres_flat_table
+		[64]; /** Final optimized strength table of NR for flat region. */
+	s32 thres_detail_table
+		[64]; /** Final optimized strength table of NR for detail region. */
+	s32 epsilon_0; /** Coefficient to control variance for dark area (for flat region). */
+	s32 epsilon_1; /** Coefficient to control variance for bright area (for flat region). */
+	s32 eps_scale_text; /** Epsilon scaling coefficient for texture region. */
+	s32 eps_scale_edge; /** Epsilon scaling coefficient for edge region. */
+	s32 sepa_flat; /** Threshold to judge flat (edge < m_Flat_thre). */
+	s32 sepa_edge; /** Threshold to judge edge (edge > m_Edge_thre). */
+	s32 blend_flat; /** Blending ratio at flat region. */
+	s32 blend_text; /** Blending ratio at texture region. */
+	s32 blend_edge; /** Blending ratio at edge region. */
+	s32 shading_gain; /** Gain of Shading control. */
+	s32 shading_base_gain; /** Base Gain of Shading control. */
+	s32 local_y_gain; /** Gain of local luminance control. */
+	s32 local_y_base_gain; /** Base gain of local luminance control. */
+	s32 rad_x_origin; /** Initial x coord. for radius computation. */
+	s32 rad_y_origin; /** Initial y coord. for radius computation. */
 };
 
 #endif /* __IA_CSS_TDF_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr3/ia_css_tnr3_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr3/ia_css_tnr3_types.h
index 42b760ffac67d4a787b93801c8a5666b4c2a64f5..25d71762dd5dd8f3f53509433d543a7d97c61a3b 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr3/ia_css_tnr3_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr3/ia_css_tnr3_types.h
@@ -17,7 +17,7 @@ Copyright (c) 2010 - 2015, Intel Corporation.
  * \details The parameters to TNR3 are specified as a piecewise linear segment.
  * The number of such segments is fixed at 3.
  */
-#define TNR3_NUM_SEGMENTS    3
+#define TNR3_NUM_SEGMENTS 3
 
 /* Temporal Noise Reduction v3 (TNR3) configuration.
  * The parameter to this kernel is fourfold
@@ -36,21 +36,23 @@ Copyright (c) 2010 - 2015, Intel Corporation.
  * 4. Selection of the reference frame buffer to be used for noise reduction.
  */
 struct ia_css_tnr3_kernel_config {
-	unsigned int maxfb_y;                        /** Maximum Feedback Gain for Y */
-	unsigned int maxfb_u;                        /** Maximum Feedback Gain for U */
-	unsigned int maxfb_v;                        /** Maximum Feedback Gain for V */
-	unsigned int round_adj_y;                    /** Rounding Adjust for Y */
-	unsigned int round_adj_u;                    /** Rounding Adjust for U */
-	unsigned int round_adj_v;                    /** Rounding Adjust for V */
-	unsigned int knee_y[TNR3_NUM_SEGMENTS - 1];  /** Knee points */
-	unsigned int sigma_y[TNR3_NUM_SEGMENTS +
-					       1]; /** Standard deviation for Y at points Y0, Y1, Y2, Y3 */
-	unsigned int sigma_u[TNR3_NUM_SEGMENTS +
-					       1]; /** Standard deviation for U at points U0, U1, U2, U3 */
-	unsigned int sigma_v[TNR3_NUM_SEGMENTS +
-					       1]; /** Standard deviation for V at points V0, V1, V2, V3 */
-	unsigned int
-	ref_buf_select;                 /** Selection of the reference buffer */
+	unsigned int maxfb_y; /** Maximum Feedback Gain for Y */
+	unsigned int maxfb_u; /** Maximum Feedback Gain for U */
+	unsigned int maxfb_v; /** Maximum Feedback Gain for V */
+	unsigned int round_adj_y; /** Rounding Adjust for Y */
+	unsigned int round_adj_u; /** Rounding Adjust for U */
+	unsigned int round_adj_v; /** Rounding Adjust for V */
+	unsigned int knee_y[TNR3_NUM_SEGMENTS - 1]; /** Knee points */
+	unsigned int sigma_y
+		[TNR3_NUM_SEGMENTS +
+		 1]; /** Standard deviation for Y at points Y0, Y1, Y2, Y3 */
+	unsigned int sigma_u
+		[TNR3_NUM_SEGMENTS +
+		 1]; /** Standard deviation for U at points U0, U1, U2, U3 */
+	unsigned int sigma_v
+		[TNR3_NUM_SEGMENTS +
+		 1]; /** Standard deviation for V at points V0, V1, V2, V3 */
+	unsigned int ref_buf_select; /** Selection of the reference buffer */
 };
 
 #endif
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.c
index 31b96d93c3cc12421864042570be06ce183e1c17..a14e8794c7c21bcaf5fe3248268d7ad06900c519 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.c
@@ -21,45 +21,37 @@ const struct ia_css_tnr_config default_tnr_config = {
 	32,
 };
 
-void
-ia_css_tnr_encode(
-    struct sh_css_isp_tnr_params *to,
-    const struct ia_css_tnr_config *from,
-    unsigned int size)
+void ia_css_tnr_encode(struct sh_css_isp_tnr_params *to,
+		       const struct ia_css_tnr_config *from, unsigned int size)
 {
 	(void)size;
-	to->coef =
-	    uDIGIT_FITTING(from->gain, 16, SH_CSS_TNR_COEF_SHIFT);
+	to->coef = uDIGIT_FITTING(from->gain, 16, SH_CSS_TNR_COEF_SHIFT);
 	to->threshold_Y =
-	    uDIGIT_FITTING(from->threshold_y, 16, SH_CSS_ISP_YUV_BITS);
+		uDIGIT_FITTING(from->threshold_y, 16, SH_CSS_ISP_YUV_BITS);
 	to->threshold_C =
-	    uDIGIT_FITTING(from->threshold_uv, 16, SH_CSS_ISP_YUV_BITS);
+		uDIGIT_FITTING(from->threshold_uv, 16, SH_CSS_ISP_YUV_BITS);
 }
 
-void
-ia_css_tnr_dump(
-    const struct sh_css_isp_tnr_params *tnr,
-    unsigned int level)
+void ia_css_tnr_dump(const struct sh_css_isp_tnr_params *tnr,
+		     unsigned int level)
 {
-	if (!tnr) return;
+	if (!tnr)
+		return;
 	ia_css_debug_dtrace(level, "Temporal Noise Reduction:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "tnr_coef", tnr->coef);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "tnr_threshold_Y", tnr->threshold_Y);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "tnr_threshold_C", tnr->threshold_C);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "tnr_coef", tnr->coef);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "tnr_threshold_Y",
+			    tnr->threshold_Y);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "tnr_threshold_C",
+			    tnr->threshold_C);
 }
 
-void
-ia_css_tnr_debug_dtrace(
-    const struct ia_css_tnr_config *config,
-    unsigned int level)
+void ia_css_tnr_debug_dtrace(const struct ia_css_tnr_config *config,
+			     unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.gain=%d, config.threshold_y=%d, config.threshold_uv=%d\n",
-			    config->gain,
-			    config->threshold_y, config->threshold_uv);
+	ia_css_debug_dtrace(
+		level,
+		"config.gain=%d, config.threshold_y=%d, config.threshold_uv=%d\n",
+		config->gain, config->threshold_y, config->threshold_uv);
 }
 
 int ia_css_tnr_config(struct sh_css_isp_tnr_isp_config *to,
@@ -70,7 +62,8 @@ int ia_css_tnr_config(struct sh_css_isp_tnr_isp_config *to,
 	unsigned int i;
 	int ret;
 
-	ret = ia_css_dma_configure_from_info(&to->port_b, &from->tnr_frames[0]->frame_info);
+	ret = ia_css_dma_configure_from_info(&to->port_b,
+					     &from->tnr_frames[0]->frame_info);
 	if (ret)
 		return ret;
 	to->width_a_over_b = elems_a / to->port_b.elems;
@@ -87,8 +80,8 @@ int ia_css_tnr_config(struct sh_css_isp_tnr_isp_config *to,
 	return 0;
 }
 
-int ia_css_tnr_configure(const struct ia_css_binary     *binary,
-			 const struct ia_css_frame * const *frames)
+int ia_css_tnr_configure(const struct ia_css_binary *binary,
+			 const struct ia_css_frame *const *frames)
 {
 	struct ia_css_tnr_configuration config;
 	unsigned int i;
@@ -99,10 +92,7 @@ int ia_css_tnr_configure(const struct ia_css_binary     *binary,
 	return ia_css_configure_tnr(binary, &config);
 }
 
-void
-ia_css_init_tnr_state(
-    struct sh_css_isp_tnr_dmem_state *state,
-    size_t size)
+void ia_css_init_tnr_state(struct sh_css_isp_tnr_dmem_state *state, size_t size)
 {
 	(void)size;
 
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h
index 3ab82458b945503f00e23349905ecce7e6a83acf..8f13a8aec99f4a96deb99c9a11045b26b8102121 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h
@@ -14,31 +14,22 @@
 
 extern const struct ia_css_tnr_config default_tnr_config;
 
-void
-ia_css_tnr_encode(
-    struct sh_css_isp_tnr_params *to,
-    const struct ia_css_tnr_config *from,
-    unsigned int size);
-
-void
-ia_css_tnr_dump(
-    const struct sh_css_isp_tnr_params *tnr,
-    unsigned int level);
-
-void
-ia_css_tnr_debug_dtrace(
-    const struct ia_css_tnr_config *config,
-    unsigned int level);
-
-int ia_css_tnr_config(struct sh_css_isp_tnr_isp_config      *to,
+void ia_css_tnr_encode(struct sh_css_isp_tnr_params *to,
+		       const struct ia_css_tnr_config *from, unsigned int size);
+
+void ia_css_tnr_dump(const struct sh_css_isp_tnr_params *tnr,
+		     unsigned int level);
+
+void ia_css_tnr_debug_dtrace(const struct ia_css_tnr_config *config,
+			     unsigned int level);
+
+int ia_css_tnr_config(struct sh_css_isp_tnr_isp_config *to,
 		      const struct ia_css_tnr_configuration *from,
 		      unsigned int size);
 
-int ia_css_tnr_configure(const struct ia_css_binary        *binary,
-			 const struct ia_css_frame * const *frames);
+int ia_css_tnr_configure(const struct ia_css_binary *binary,
+			 const struct ia_css_frame *const *frames);
 
-void
-ia_css_init_tnr_state(
-    struct sh_css_isp_tnr_dmem_state *state,
-    size_t size);
+void ia_css_init_tnr_state(struct sh_css_isp_tnr_dmem_state *state,
+			   size_t size);
 #endif /* __IA_CSS_TNR_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf.host.c
index 127f12ba221440ce070378d19e6a6a7436b41053..38c7f511cb821c9207540d7e63579017b6fb37a6 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf.host.c
@@ -17,9 +17,9 @@
 
 #include "isp.h"
 
-int ia_css_vf_config(struct sh_css_isp_vf_isp_config      *to,
-		    const struct ia_css_vf_configuration *from,
-		    unsigned int size)
+int ia_css_vf_config(struct sh_css_isp_vf_isp_config *to,
+		     const struct ia_css_vf_configuration *from,
+		     unsigned int size)
 {
 	unsigned int elems_a = ISP_VEC_NELEMS;
 	int ret;
@@ -29,7 +29,8 @@ int ia_css_vf_config(struct sh_css_isp_vf_isp_config      *to,
 
 	if (from->info) {
 		ia_css_frame_info_to_frame_sp_info(&to->info, from->info);
-		ret = ia_css_dma_configure_from_info(&to->dma.port_b, from->info);
+		ret = ia_css_dma_configure_from_info(&to->dma.port_b,
+						     from->info);
 		if (ret)
 			return ret;
 		to->dma.width_a_over_b = elems_a / to->dma.port_b.elems;
@@ -45,11 +46,10 @@ int ia_css_vf_config(struct sh_css_isp_vf_isp_config      *to,
  * to the requested viewfinder resolution on the upper side. The output cannot
  * be smaller than the requested viewfinder resolution.
  */
-int
-sh_css_vf_downscale_log2(
-    const struct ia_css_frame_info *out_info,
-    const struct ia_css_frame_info *vf_info,
-    unsigned int *downscale_log2) {
+int sh_css_vf_downscale_log2(const struct ia_css_frame_info *out_info,
+			     const struct ia_css_frame_info *vf_info,
+			     unsigned int *downscale_log2)
+{
 	unsigned int ds_log2 = 0;
 	unsigned int out_width;
 
@@ -65,8 +65,7 @@ sh_css_vf_downscale_log2(
 	* test for the height since the vmem buffers only put restrictions on
 	* the width of a line, not on the number of lines in a frame.
 	*/
-	while (out_width >= vf_info->res.width)
-	{
+	while (out_width >= vf_info->res.width) {
 		ds_log2++;
 		out_width /= 2;
 	}
@@ -74,25 +73,24 @@ sh_css_vf_downscale_log2(
 	if ((ds_log2 > 0) && (out_width < ia_css_binary_max_vf_width()))
 		ds_log2--;
 	/* TODO: use actual max input resolution of vf_pp binary */
-	if ((out_info->res.width >> ds_log2) >= 2 * ia_css_binary_max_vf_width())
+	if ((out_info->res.width >> ds_log2) >=
+	    2 * ia_css_binary_max_vf_width())
 		return -EINVAL;
 	*downscale_log2 = ds_log2;
 	return 0;
 }
 
-static int
-configure_kernel(
-    const struct ia_css_binary_info *info,
-    const struct ia_css_frame_info *out_info,
-    const struct ia_css_frame_info *vf_info,
-    unsigned int *downscale_log2,
-    struct ia_css_vf_configuration *config) {
+static int configure_kernel(const struct ia_css_binary_info *info,
+			    const struct ia_css_frame_info *out_info,
+			    const struct ia_css_frame_info *vf_info,
+			    unsigned int *downscale_log2,
+			    struct ia_css_vf_configuration *config)
+{
 	int err;
 	unsigned int vf_log_ds = 0;
 
 	/* First compute value */
-	if (vf_info)
-	{
+	if (vf_info) {
 		err = sh_css_vf_downscale_log2(out_info, vf_info, &vf_log_ds);
 		if (err)
 			return err;
@@ -105,10 +103,8 @@ configure_kernel(
 	return 0;
 }
 
-static void
-configure_dma(
-    struct ia_css_vf_configuration *config,
-    const struct ia_css_frame_info *vf_info)
+static void configure_dma(struct ia_css_vf_configuration *config,
+			  const struct ia_css_frame_info *vf_info)
 {
 	config->info = vf_info;
 }
@@ -122,7 +118,8 @@ int ia_css_vf_configure(const struct ia_css_binary *binary,
 	struct ia_css_vf_configuration config;
 	const struct ia_css_binary_info *info = &binary->info->sp;
 
-	err = configure_kernel(info, out_info, vf_info, downscale_log2, &config);
+	err = configure_kernel(info, out_info, vf_info, downscale_log2,
+			       &config);
 	if (err)
 		dev_warn(atomisp_dev, "Couldn't setup downscale\n");
 
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf.host.h
index d2085b7f45014e3cb2090d0cec90cddfd704fcff..26914fdc654863e6965867e381def2ac30ca5a0e 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf.host.h
@@ -17,21 +17,17 @@
  * to the requested viewfinder resolution on the upper side. The output cannot
  * be smaller than the requested viewfinder resolution.
  */
-int
-sh_css_vf_downscale_log2(
-    const struct ia_css_frame_info *out_info,
-    const struct ia_css_frame_info *vf_info,
-    unsigned int *downscale_log2);
+int sh_css_vf_downscale_log2(const struct ia_css_frame_info *out_info,
+			     const struct ia_css_frame_info *vf_info,
+			     unsigned int *downscale_log2);
 
 int ia_css_vf_config(struct sh_css_isp_vf_isp_config *to,
 		     const struct ia_css_vf_configuration *from,
 		     unsigned int size);
 
-int
-ia_css_vf_configure(
-    const struct ia_css_binary *binary,
-    const struct ia_css_frame_info *out_info,
-    struct ia_css_frame_info *vf_info,
-    unsigned int *downscale_log2);
+int ia_css_vf_configure(const struct ia_css_binary *binary,
+			const struct ia_css_frame_info *out_info,
+			struct ia_css_frame_info *vf_info,
+			unsigned int *downscale_log2);
 
 #endif /* __IA_CSS_VF_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf_param.h
index cf1e4f401cd19003ed18d912e8474c1fee56f8e5..ebfe83b4e45592037c41e7e272a12286fb248a8c 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/vf/vf_1.0/ia_css_vf_param.h
@@ -13,7 +13,7 @@
 #include "ia_css_frame_comm.h" /* ia_css_frame_sp_info */
 #include "ia_css_vf_types.h"
 
-#define VFDEC_BITS_PER_PIXEL	GAMMA_OUTPUT_BITS
+#define VFDEC_BITS_PER_PIXEL GAMMA_OUTPUT_BITS
 
 /* Viewfinder decimation */
 struct sh_css_isp_vf_isp_config {
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb.host.c
index bc18bdaaaf0da29a9cdf161135b94a45338e0197..873a30d18b37131518c85fb48cc44393892b098c 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb.host.c
@@ -13,66 +13,45 @@
 
 #include "ia_css_wb.host.h"
 
-const struct ia_css_wb_config default_wb_config = {
-	1,
-	32768,
-	32768,
-	32768,
-	32768
-};
+const struct ia_css_wb_config default_wb_config = { 1, 32768, 32768, 32768,
+						    32768 };
 
-void
-ia_css_wb_encode(
-    struct sh_css_isp_wb_params *to,
-    const struct ia_css_wb_config *from,
-    unsigned int size)
+void ia_css_wb_encode(struct sh_css_isp_wb_params *to,
+		      const struct ia_css_wb_config *from, unsigned int size)
 {
 	(void)size;
-	to->gain_shift =
-	    uISP_REG_BIT - from->integer_bits;
-	to->gain_gr =
-	    uDIGIT_FITTING(from->gr, 16 - from->integer_bits,
-			   to->gain_shift);
-	to->gain_r =
-	    uDIGIT_FITTING(from->r, 16 - from->integer_bits,
-			   to->gain_shift);
-	to->gain_b =
-	    uDIGIT_FITTING(from->b, 16 - from->integer_bits,
-			   to->gain_shift);
-	to->gain_gb =
-	    uDIGIT_FITTING(from->gb, 16 - from->integer_bits,
-			   to->gain_shift);
+	to->gain_shift = uISP_REG_BIT - from->integer_bits;
+	to->gain_gr = uDIGIT_FITTING(from->gr, 16 - from->integer_bits,
+				     to->gain_shift);
+	to->gain_r = uDIGIT_FITTING(from->r, 16 - from->integer_bits,
+				    to->gain_shift);
+	to->gain_b = uDIGIT_FITTING(from->b, 16 - from->integer_bits,
+				    to->gain_shift);
+	to->gain_gb = uDIGIT_FITTING(from->gb, 16 - from->integer_bits,
+				     to->gain_shift);
 }
 
 #ifndef IA_CSS_NO_DEBUG
-void
-ia_css_wb_dump(
-    const struct sh_css_isp_wb_params *wb,
-    unsigned int level)
+void ia_css_wb_dump(const struct sh_css_isp_wb_params *wb, unsigned int level)
 {
-	if (!wb) return;
+	if (!wb)
+		return;
 	ia_css_debug_dtrace(level, "White Balance:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "wb_gain_shift", wb->gain_shift);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "wb_gain_gr", wb->gain_gr);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "wb_gain_r", wb->gain_r);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "wb_gain_b", wb->gain_b);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "wb_gain_gb", wb->gain_gb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "wb_gain_shift",
+			    wb->gain_shift);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "wb_gain_gr", wb->gain_gr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "wb_gain_r", wb->gain_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "wb_gain_b", wb->gain_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "wb_gain_gb", wb->gain_gb);
 }
 
-void
-ia_css_wb_debug_dtrace(
-    const struct ia_css_wb_config *config,
-    unsigned int level)
+void ia_css_wb_debug_dtrace(const struct ia_css_wb_config *config,
+			    unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.integer_bits=%d, config.gr=%d, config.r=%d, config.b=%d, config.gb=%d\n",
-			    config->integer_bits,
-			    config->gr, config->r,
-			    config->b, config->gb);
+	ia_css_debug_dtrace(
+		level,
+		"config.integer_bits=%d, config.gr=%d, config.r=%d, config.b=%d, config.gb=%d\n",
+		config->integer_bits, config->gr, config->r, config->b,
+		config->gb);
 }
 #endif
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb.host.h
index 841b6c6f7e7c6ed4a19ca77f1520c2f06726ce29..9bd0d558810725353f20ce18821ff4b3ab6e9a7c 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb.host.h
@@ -12,20 +12,12 @@
 
 extern const struct ia_css_wb_config default_wb_config;
 
-void
-ia_css_wb_encode(
-    struct sh_css_isp_wb_params *to,
-    const struct ia_css_wb_config *from,
-    unsigned int size);
+void ia_css_wb_encode(struct sh_css_isp_wb_params *to,
+		      const struct ia_css_wb_config *from, unsigned int size);
 
-void
-ia_css_wb_dump(
-    const struct sh_css_isp_wb_params *wb,
-    unsigned int level);
+void ia_css_wb_dump(const struct sh_css_isp_wb_params *wb, unsigned int level);
 
-void
-ia_css_wb_debug_dtrace(
-    const struct ia_css_wb_config *wb,
-    unsigned int level);
+void ia_css_wb_debug_dtrace(const struct ia_css_wb_config *wb,
+			    unsigned int level);
 
 #endif /* __IA_CSS_WB_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb_types.h
index 3a59c7de7387c3bd520254688175d982629ace96..5d678e6b25dd6ce3f83b845d24b188aba5af31f4 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/wb/wb_1.0/ia_css_wb_types.h
@@ -21,16 +21,16 @@ struct ia_css_wb_config {
 	u32 integer_bits; /** Common exponent of gains.
 				u8.0, [0,3],
 				default 1, ineffective 1 */
-	u32 gr;	/** Significand of Gr gain.
+	u32 gr; /** Significand of Gr gain.
 				u[integer_bits].[16-integer_bits], [0,65535],
 				default/ineffective 32768(u1.15, 1.0) */
-	u32 r;	/** Significand of R gain.
+	u32 r; /** Significand of R gain.
 				u[integer_bits].[16-integer_bits], [0,65535],
 				default/ineffective 32768(u1.15, 1.0) */
-	u32 b;	/** Significand of B gain.
+	u32 b; /** Significand of B gain.
 				u[integer_bits].[16-integer_bits], [0,65535],
 				default/ineffective 32768(u1.15, 1.0) */
-	u32 gb;	/** Significand of Gb gain.
+	u32 gb; /** Significand of Gb gain.
 				u[integer_bits].[16-integer_bits], [0,65535],
 				default/ineffective 32768(u1.15, 1.0) */
 };
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
index 9f9f3af9fb41bc6be815f13fb0049c7e4a4a582e..a39ca681a2ababd43fad7dbea514711a25da24c5 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
@@ -16,42 +16,32 @@ const struct ia_css_xnr_config default_xnr_config = {
 	6400
 };
 
-void
-ia_css_xnr_table_vamem_encode(
-    struct sh_css_isp_xnr_vamem_params *to,
-    const struct ia_css_xnr_table *from,
-    unsigned int size)
+void ia_css_xnr_table_vamem_encode(struct sh_css_isp_xnr_vamem_params *to,
+				   const struct ia_css_xnr_table *from,
+				   unsigned int size)
 {
 	(void)size;
-	memcpy(&to->xnr,  &from->data, sizeof(to->xnr));
+	memcpy(&to->xnr, &from->data, sizeof(to->xnr));
 }
 
-void
-ia_css_xnr_encode(
-    struct sh_css_isp_xnr_params *to,
-    const struct ia_css_xnr_config *from,
-    unsigned int size)
+void ia_css_xnr_encode(struct sh_css_isp_xnr_params *to,
+		       const struct ia_css_xnr_config *from, unsigned int size)
 {
 	(void)size;
 
-	to->threshold =
-	    (uint16_t)uDIGIT_FITTING(from->threshold, 16, SH_CSS_ISP_YUV_BITS);
+	to->threshold = (uint16_t)uDIGIT_FITTING(from->threshold, 16,
+						 SH_CSS_ISP_YUV_BITS);
 }
 
-void
-ia_css_xnr_table_debug_dtrace(
-    const struct ia_css_xnr_table *config,
-    unsigned int level)
+void ia_css_xnr_table_debug_dtrace(const struct ia_css_xnr_table *config,
+				   unsigned int level)
 {
 	(void)config;
 	(void)level;
 }
 
-void
-ia_css_xnr_debug_dtrace(
-    const struct ia_css_xnr_config *config,
-    unsigned int level)
+void ia_css_xnr_debug_dtrace(const struct ia_css_xnr_config *config,
+			     unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.threshold=%d\n", config->threshold);
+	ia_css_debug_dtrace(level, "config.threshold=%d\n", config->threshold);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.h
index b8e63486a8a5bc818e46e1e18e90f218da9573cf..9d24038fc32cac47002e9fa14656b15a6c0245bd 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.h
@@ -14,26 +14,17 @@
 
 extern const struct ia_css_xnr_config default_xnr_config;
 
-void
-ia_css_xnr_table_vamem_encode(
-    struct sh_css_isp_xnr_vamem_params *to,
-    const struct ia_css_xnr_table *from,
-    unsigned int size);
-
-void
-ia_css_xnr_encode(
-    struct sh_css_isp_xnr_params *to,
-    const struct ia_css_xnr_config *from,
-    unsigned int size);
-
-void
-ia_css_xnr_table_debug_dtrace(
-    const struct ia_css_xnr_table *s3a,
-    unsigned int level);
-
-void
-ia_css_xnr_debug_dtrace(
-    const struct ia_css_xnr_config *config,
-    unsigned int level);
+void ia_css_xnr_table_vamem_encode(struct sh_css_isp_xnr_vamem_params *to,
+				   const struct ia_css_xnr_table *from,
+				   unsigned int size);
+
+void ia_css_xnr_encode(struct sh_css_isp_xnr_params *to,
+		       const struct ia_css_xnr_config *from, unsigned int size);
+
+void ia_css_xnr_table_debug_dtrace(const struct ia_css_xnr_table *s3a,
+				   unsigned int level);
+
+void ia_css_xnr_debug_dtrace(const struct ia_css_xnr_config *config,
+			     unsigned int level);
 
 #endif /* __IA_CSS_XNR_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_param.h
index 0e92c32242f30309f98f9ce9ad64a4697a4bc4bd..f102fa80c5c74421e45260b009ace1f7d0adbf68 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_param.h
@@ -11,8 +11,8 @@
 #include <system_global.h>
 
 #ifndef PIPE_GENERATION
-#define SH_CSS_ISP_XNR_TABLE_SIZE_LOG2       IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2
-#define SH_CSS_ISP_XNR_TABLE_SIZE            IA_CSS_VAMEM_2_XNR_TABLE_SIZE
+#define SH_CSS_ISP_XNR_TABLE_SIZE_LOG2 IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_XNR_TABLE_SIZE IA_CSS_VAMEM_2_XNR_TABLE_SIZE
 
 #else
 /* For pipe generation, the size is not relevant */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_table.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_table.host.c
index ce8eef985e5dfc3ae44a742289253d24855fb746..4341003d73f137e38f8d92d7d0122ef719ea97ad 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_table.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_table.host.c
@@ -14,30 +14,31 @@
 
 struct ia_css_xnr_table default_xnr_table;
 
-
-static const uint16_t
-default_xnr_table_data[IA_CSS_VAMEM_2_XNR_TABLE_SIZE] = {
+static const uint16_t default_xnr_table_data[IA_CSS_VAMEM_2_XNR_TABLE_SIZE] = {
 	/* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 */
-	8191 >> 1, 4096 >> 1, 2730 >> 1, 2048 >> 1, 1638 >> 1, 1365 >> 1, 1170 >> 1, 1024 >> 1, 910 >> 1, 819 >> 1, 744 >> 1, 682 >> 1, 630 >> 1, 585 >> 1,
-	     546 >> 1, 512 >> 1,
-
-	     /* 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 */
-	     481 >> 1, 455 >> 1, 431 >> 1, 409 >> 1, 390 >> 1, 372 >> 1, 356 >> 1, 341 >> 1, 327 >> 1, 315 >> 1, 303 >> 1, 292 >> 1, 282 >> 1, 273 >> 1, 264 >> 1,
-	     256 >> 1,
-
-	     /* 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 */
-	     248 >> 1, 240 >> 1, 234 >> 1, 227 >> 1, 221 >> 1, 215 >> 1, 210 >> 1, 204 >> 1, 199 >> 1, 195 >> 1, 190 >> 1, 186 >> 1, 182 >> 1, 178 >> 1, 174 >> 1,
-	     170 >> 1,
-
-	     /* 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 */
-	     167 >> 1, 163 >> 1, 160 >> 1, 157 >> 1, 154 >> 1, 151 >> 1, 148 >> 1, 146 >> 1, 143 >> 1, 141 >> 1, 138 >> 1, 136 >> 1, 134 >> 1, 132 >> 1, 130 >> 1, 128 >> 1
+	8191 >> 1, 4096 >> 1, 2730 >> 1, 2048 >> 1, 1638 >> 1, 1365 >> 1,
+	1170 >> 1, 1024 >> 1, 910 >> 1, 819 >> 1, 744 >> 1, 682 >> 1, 630 >> 1,
+	585 >> 1, 546 >> 1, 512 >> 1,
+
+	/* 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 */
+	481 >> 1, 455 >> 1, 431 >> 1, 409 >> 1, 390 >> 1, 372 >> 1, 356 >> 1,
+	341 >> 1, 327 >> 1, 315 >> 1, 303 >> 1, 292 >> 1, 282 >> 1, 273 >> 1,
+	264 >> 1, 256 >> 1,
+
+	/* 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 */
+	248 >> 1, 240 >> 1, 234 >> 1, 227 >> 1, 221 >> 1, 215 >> 1, 210 >> 1,
+	204 >> 1, 199 >> 1, 195 >> 1, 190 >> 1, 186 >> 1, 182 >> 1, 178 >> 1,
+	174 >> 1, 170 >> 1,
+
+	/* 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 */
+	167 >> 1, 163 >> 1, 160 >> 1, 157 >> 1, 154 >> 1, 151 >> 1, 148 >> 1,
+	146 >> 1, 143 >> 1, 141 >> 1, 138 >> 1, 136 >> 1, 134 >> 1, 132 >> 1,
+	130 >> 1, 128 >> 1
 };
 
-
-void
-ia_css_config_xnr_table(void)
+void ia_css_config_xnr_table(void)
 {
 	memcpy(default_xnr_table.data.vamem_2, default_xnr_table_data,
 	       sizeof(default_xnr_table_data));
-	default_xnr_table.vamem_type     = IA_CSS_VAMEM_TYPE_2;
+	default_xnr_table.vamem_type = IA_CSS_VAMEM_TYPE_2;
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_types.h
index 42ad8b9b51d38891c1874a3f031f2daee1b893f5..35dc0eedd66970a4cafd6e5d6578482d949c82fa 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_1.0/ia_css_xnr_types.h
@@ -29,14 +29,14 @@
  */
 
 /* Number of elements in the xnr table. */
-#define IA_CSS_VAMEM_1_XNR_TABLE_SIZE_LOG2      6
+#define IA_CSS_VAMEM_1_XNR_TABLE_SIZE_LOG2 6
 /* Number of elements in the xnr table. */
-#define IA_CSS_VAMEM_1_XNR_TABLE_SIZE           BIT(IA_CSS_VAMEM_1_XNR_TABLE_SIZE_LOG2)
+#define IA_CSS_VAMEM_1_XNR_TABLE_SIZE BIT(IA_CSS_VAMEM_1_XNR_TABLE_SIZE_LOG2)
 
 /* Number of elements in the xnr table. */
-#define IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2      6
+#define IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2 6
 /* Number of elements in the xnr table. */
-#define IA_CSS_VAMEM_2_XNR_TABLE_SIZE		BIT(IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2)
+#define IA_CSS_VAMEM_2_XNR_TABLE_SIZE BIT(IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2)
 
 /** IA_CSS_VAMEM_TYPE_1(ISP2300) or
      IA_CSS_VAMEM_TYPE_2(ISP2400) */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
index e90dea58215b9303d08a81b226885c92834a2ddf..f5d37819658dfdbbbe963ce81fe8f8299a6d3d14 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
@@ -14,12 +14,12 @@
 #include "ia_css_xnr3.host.h"
 
 /* Maximum value for alpha on ISP interface */
-#define XNR_MAX_ALPHA  ((1 << (ISP_VEC_ELEMBITS - 1)) - 1)
+#define XNR_MAX_ALPHA ((1 << (ISP_VEC_ELEMBITS - 1)) - 1)
 
 /* Minimum value for sigma on host interface. Lower values translate to
  * max_alpha.
  */
-#define XNR_MIN_SIGMA  (IA_CSS_XNR3_SIGMA_SCALE / 100)
+#define XNR_MIN_SIGMA (IA_CSS_XNR3_SIGMA_SCALE / 100)
 
 /*
  * division look-up table
@@ -27,24 +27,23 @@
  */
 #define XNR3_LOOK_UP_TABLE_POINTS 16
 
-static const s16 x[XNR3_LOOK_UP_TABLE_POINTS] = {
-	1024, 1164, 1320, 1492, 1680, 1884, 2108, 2352,
-	2616, 2900, 3208, 3540, 3896, 4276, 4684, 5120
-};
+static const s16 x[XNR3_LOOK_UP_TABLE_POINTS] = { 1024, 1164, 1320, 1492,
+						  1680, 1884, 2108, 2352,
+						  2616, 2900, 3208, 3540,
+						  3896, 4276, 4684, 5120 };
 
-static const s16 a[XNR3_LOOK_UP_TABLE_POINTS] = {
-	-7213, -5580, -4371, -3421, -2722, -2159, -6950, -5585,
-	    -4529, -3697, -3010, -2485, -2070, -1727, -1428, 0
-    };
+static const s16 a[XNR3_LOOK_UP_TABLE_POINTS] = { -7213, -5580, -4371, -3421,
+						  -2722, -2159, -6950, -5585,
+						  -4529, -3697, -3010, -2485,
+						  -2070, -1727, -1428, 0 };
 
-static const s16 b[XNR3_LOOK_UP_TABLE_POINTS] = {
-	4096, 3603, 3178, 2811, 2497, 2226, 1990, 1783,
-	1603, 1446, 1307, 1185, 1077, 981, 895, 819
-};
+static const s16 b[XNR3_LOOK_UP_TABLE_POINTS] = { 4096, 3603, 3178, 2811,
+						  2497, 2226, 1990, 1783,
+						  1603, 1446, 1307, 1185,
+						  1077, 981,  895,  819 };
 
-static const s16 c[XNR3_LOOK_UP_TABLE_POINTS] = {
-	1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-};
+static const s16 c[XNR3_LOOK_UP_TABLE_POINTS] = { 1, 1, 1, 1, 1, 1, 0, 0,
+						  0, 0, 0, 0, 0, 0, 0, 0 };
 
 /*
  * Default kernel parameters. In general, default is bypass mode or as close
@@ -65,8 +64,7 @@ const struct ia_css_xnr3_config default_xnr3_config = {
  * Compute an alpha value for the ISP kernel from sigma value on the host
  * parameter interface as: alpha_scale * 1/(sigma/sigma_scale)
  */
-static int32_t
-compute_alpha(int sigma)
+static int32_t compute_alpha(int sigma)
 {
 	s32 alpha;
 	int offset = sigma / 2;
@@ -74,7 +72,9 @@ compute_alpha(int sigma)
 	if (sigma < XNR_MIN_SIGMA) {
 		alpha = XNR_MAX_ALPHA;
 	} else {
-		alpha = ((IA_CSS_XNR3_SIGMA_SCALE * XNR_ALPHA_SCALE_FACTOR) + offset) / sigma;
+		alpha = ((IA_CSS_XNR3_SIGMA_SCALE * XNR_ALPHA_SCALE_FACTOR) +
+			 offset) /
+			sigma;
 
 		if (alpha > XNR_MAX_ALPHA)
 			alpha = XNR_MAX_ALPHA;
@@ -87,8 +87,7 @@ compute_alpha(int sigma)
  * Compute the scaled coring value for the ISP kernel from the value on the
  * host parameter interface.
  */
-static int32_t
-compute_coring(int coring)
+static int32_t compute_coring(int coring)
 {
 	s32 isp_coring;
 	s32 isp_scale = XNR_CORING_SCALE_FACTOR;
@@ -106,8 +105,7 @@ compute_coring(int coring)
  * Compute the scaled blending strength for the ISP kernel from the value on
  * the host parameter interface.
  */
-static int32_t
-compute_blending(int strength)
+static int32_t compute_blending(int strength)
 {
 	s32 isp_strength;
 	s32 isp_scale = XNR_BLENDING_SCALE_FACTOR;
@@ -123,11 +121,9 @@ compute_blending(int strength)
 	return MAX(MIN(isp_strength, 0), -isp_scale);
 }
 
-void
-ia_css_xnr3_encode(
-    struct sh_css_isp_xnr3_params *to,
-    const struct ia_css_xnr3_config *from,
-    unsigned int size)
+void ia_css_xnr3_encode(struct sh_css_isp_xnr3_params *to,
+			const struct ia_css_xnr3_config *from,
+			unsigned int size)
 {
 	int kernel_size = XNR_FILTER_SIZE;
 	int adjust_factor = roundup_pow_of_two(kernel_size);
@@ -148,8 +144,10 @@ ia_css_xnr3_encode(
 	s32 coring_u1 = compute_coring(from->coring.u1);
 	s32 coring_v0 = compute_coring(from->coring.v0);
 	s32 coring_v1 = compute_coring(from->coring.v1);
-	s32 coring_udiff = (coring_u1 - coring_u0) * adjust_factor / kernel_size;
-	s32 coring_vdiff = (coring_v1 - coring_v0) * adjust_factor / kernel_size;
+	s32 coring_udiff =
+		(coring_u1 - coring_u0) * adjust_factor / kernel_size;
+	s32 coring_vdiff =
+		(coring_v1 - coring_v0) * adjust_factor / kernel_size;
 
 	s32 blending = compute_blending(from->blending.strength);
 
@@ -178,11 +176,9 @@ ia_css_xnr3_encode(
  * -----------------------------------------------
  * VMEM Encode Function to translate UV parameters from userspace into ISP space
 */
-void
-ia_css_xnr3_vmem_encode(
-    struct sh_css_isp_xnr3_vmem_params *to,
-    const struct ia_css_xnr3_config *from,
-    unsigned int size)
+void ia_css_xnr3_vmem_encode(struct sh_css_isp_xnr3_vmem_params *to,
+			     const struct ia_css_xnr3_config *from,
+			     unsigned int size)
 {
 	unsigned int i, j, base;
 	const unsigned int total_blocks = 4;
@@ -230,10 +226,8 @@ ia_css_xnr3_vmem_encode(
 }
 
 /* Dummy Function added as the tool expects it*/
-void
-ia_css_xnr3_debug_dtrace(
-    const struct ia_css_xnr3_config *config,
-    unsigned int level)
+void ia_css_xnr3_debug_dtrace(const struct ia_css_xnr3_config *config,
+			      unsigned int level)
 {
 	(void)config;
 	(void)level;
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.h
index a5e1294527fca259b7b4bbfc0d37546b11265db8..3b5aaca16a4b25b85a27138fc2241d3e8c671da6 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.h
@@ -12,22 +12,16 @@
 
 extern const struct ia_css_xnr3_config default_xnr3_config;
 
-void
-ia_css_xnr3_encode(
-    struct sh_css_isp_xnr3_params *to,
-    const struct ia_css_xnr3_config *from,
-    unsigned int size);
+void ia_css_xnr3_encode(struct sh_css_isp_xnr3_params *to,
+			const struct ia_css_xnr3_config *from,
+			unsigned int size);
 
 /* ISP2401 */
-void
-ia_css_xnr3_vmem_encode(
-    struct sh_css_isp_xnr3_vmem_params *to,
-    const struct ia_css_xnr3_config *from,
-    unsigned int size);
+void ia_css_xnr3_vmem_encode(struct sh_css_isp_xnr3_vmem_params *to,
+			     const struct ia_css_xnr3_config *from,
+			     unsigned int size);
 
-void
-ia_css_xnr3_debug_dtrace(
-    const struct ia_css_xnr3_config *config,
-    unsigned int level);
+void ia_css_xnr3_debug_dtrace(const struct ia_css_xnr3_config *config,
+			      unsigned int level);
 
 #endif /* __IA_CSS_XNR3_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_param.h b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_param.h
index 8997099dff5a512b0e9ec20a4ad37eb01e34cd2b..ea41c8f8f0d5846df8da6f60663deb40c898e8e7 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_param.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_param.h
@@ -13,19 +13,19 @@
 /* Scaling factor of the alpha values: which fixed-point value represents 1.0?
  * It must be chosen such that 1/min_sigma still fits in an ISP vector
  * element. */
-#define XNR_ALPHA_SCALE_LOG2        5
-#define XNR_ALPHA_SCALE_FACTOR      BIT(XNR_ALPHA_SCALE_LOG2)
+#define XNR_ALPHA_SCALE_LOG2 5
+#define XNR_ALPHA_SCALE_FACTOR BIT(XNR_ALPHA_SCALE_LOG2)
 
 /* Scaling factor of the coring values on the ISP. */
-#define XNR_CORING_SCALE_LOG2       (ISP_VEC_ELEMBITS - 1)
-#define XNR_CORING_SCALE_FACTOR     BIT(XNR_CORING_SCALE_LOG2)
+#define XNR_CORING_SCALE_LOG2 (ISP_VEC_ELEMBITS - 1)
+#define XNR_CORING_SCALE_FACTOR BIT(XNR_CORING_SCALE_LOG2)
 
 /* Scaling factor of the blending strength on the ISP. */
-#define XNR_BLENDING_SCALE_LOG2     (ISP_VEC_ELEMBITS - 1)
-#define XNR_BLENDING_SCALE_FACTOR   BIT(XNR_BLENDING_SCALE_LOG2)
+#define XNR_BLENDING_SCALE_LOG2 (ISP_VEC_ELEMBITS - 1)
+#define XNR_BLENDING_SCALE_FACTOR BIT(XNR_BLENDING_SCALE_LOG2)
 
 /* XNR3 filter size. Must be 11x11, 9x9 or 5x5. */
-#define XNR_FILTER_SIZE             5
+#define XNR_FILTER_SIZE 5
 
 /* XNR3 alpha (1/sigma) parameters on the ISP, expressed as a base (0) value
  * for dark areas, and a scaled diff towards the value for bright areas. */
@@ -54,8 +54,8 @@ struct sh_css_xnr3_blending_params {
 
 /* XNR3 ISP parameters */
 struct sh_css_isp_xnr3_params {
-	struct sh_css_xnr3_alpha_params    alpha;
-	struct sh_css_xnr3_coring_params   coring;
+	struct sh_css_xnr3_alpha_params alpha;
+	struct sh_css_xnr3_coring_params coring;
 	struct sh_css_xnr3_blending_params blending;
 };
 
@@ -72,4 +72,4 @@ struct sh_css_isp_xnr3_vmem_params {
 	VMEM_ARRAY(c, ISP_VEC_NELEMS);
 };
 
-#endif  /*__IA_CSS_XNR3_PARAM_H */
+#endif /*__IA_CSS_XNR3_PARAM_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h
index c012c1865d1ec4afb75068ab19aa7e539131decd..f728e155f601088ffe2dcf37e9c9e265b59942b9 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h
@@ -15,7 +15,7 @@
  * \brief Scale of the XNR sigma parameters.
  * \details The define specifies which fixed-point value represents 1.0.
  */
-#define IA_CSS_XNR3_SIGMA_SCALE  BIT(10)
+#define IA_CSS_XNR3_SIGMA_SCALE BIT(10)
 
 /**
  * \brief Scale of the XNR coring parameters.
@@ -38,12 +38,12 @@
  * IA_CSS_XNR3_SIGMA_SCALE.
  */
 struct ia_css_xnr3_sigma_params {
-	int y0;     /** Sigma for Y range similarity in dark area */
-	int y1;     /** Sigma for Y range similarity in bright area */
-	int u0;     /** Sigma for U range similarity in dark area */
-	int u1;     /** Sigma for U range similarity in bright area */
-	int v0;     /** Sigma for V range similarity in dark area */
-	int v1;     /** Sigma for V range similarity in bright area */
+	int y0; /** Sigma for Y range similarity in dark area */
+	int y1; /** Sigma for Y range similarity in bright area */
+	int u0; /** Sigma for U range similarity in dark area */
+	int u1; /** Sigma for U range similarity in bright area */
+	int v0; /** Sigma for V range similarity in dark area */
+	int v1; /** Sigma for V range similarity in bright area */
 };
 
 /**
@@ -55,10 +55,10 @@ struct ia_css_xnr3_sigma_params {
  * with IA_CSS_XNR3_CORING_SCALE. The ineffective value is 0.
  */
 struct ia_css_xnr3_coring_params {
-	int u0;     /** Coring threshold of U channel in dark area */
-	int u1;     /** Coring threshold of U channel in bright area */
-	int v0;     /** Coring threshold of V channel in dark area */
-	int v1;     /** Coring threshold of V channel in bright area */
+	int u0; /** Coring threshold of U channel in dark area */
+	int u1; /** Coring threshold of U channel in bright area */
+	int v0; /** Coring threshold of V channel in dark area */
+	int v1; /** Coring threshold of V channel in bright area */
 };
 
 /**
@@ -72,7 +72,7 @@ struct ia_css_xnr3_coring_params {
  * value of 0.0 bypasses the entire xnr3 filter.
  */
 struct ia_css_xnr3_blending_params {
-	int strength;   /** Blending strength */
+	int strength; /** Blending strength */
 };
 
 /**
@@ -81,9 +81,10 @@ struct ia_css_xnr3_blending_params {
  * from the CSS API.
  */
 struct ia_css_xnr3_config {
-	struct ia_css_xnr3_sigma_params    sigma;    /** XNR3 sigma parameters */
-	struct ia_css_xnr3_coring_params   coring;   /** XNR3 coring parameters */
-	struct ia_css_xnr3_blending_params blending; /** XNR3 blending parameters */
+	struct ia_css_xnr3_sigma_params sigma; /** XNR3 sigma parameters */
+	struct ia_css_xnr3_coring_params coring; /** XNR3 coring parameters */
+	struct ia_css_xnr3_blending_params
+		blending; /** XNR3 blending parameters */
 };
 
 #endif /* __IA_CSS_XNR3_TYPES_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.c
index d43a3539c6d4cd875354b187e98288b040d01c88..efdc0adfd8e24d098bd86cae08c31d2d6f4ae845 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.c
@@ -12,45 +12,28 @@
 #include "bnr/bnr_1.0/ia_css_bnr.host.h"
 #include "ia_css_ynr.host.h"
 
-const struct ia_css_nr_config default_nr_config = {
-	16384,
-	8192,
-	1280,
-	0,
-	0
-};
+const struct ia_css_nr_config default_nr_config = { 16384, 8192, 1280, 0, 0 };
 
-const struct ia_css_ee_config default_ee_config = {
-	8192,
-	128,
-	2048
-};
+const struct ia_css_ee_config default_ee_config = { 8192, 128, 2048 };
 
-void
-ia_css_nr_encode(
-    struct sh_css_isp_ynr_params *to,
-    const struct ia_css_nr_config *from,
-    unsigned int size)
+void ia_css_nr_encode(struct sh_css_isp_ynr_params *to,
+		      const struct ia_css_nr_config *from, unsigned int size)
 {
 	(void)size;
 	/* YNR (Y Noise Reduction) */
-	to->threshold =
-	    uDIGIT_FITTING(8192U, 16, SH_CSS_BAYER_BITS);
+	to->threshold = uDIGIT_FITTING(8192U, 16, SH_CSS_BAYER_BITS);
 	to->gain_all =
-	    uDIGIT_FITTING(from->ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
+		uDIGIT_FITTING(from->ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
 	to->gain_dir =
-	    uDIGIT_FITTING(from->ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
+		uDIGIT_FITTING(from->ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
 	to->threshold_cb =
-	    uDIGIT_FITTING(from->threshold_cb, 16, SH_CSS_BAYER_BITS);
+		uDIGIT_FITTING(from->threshold_cb, 16, SH_CSS_BAYER_BITS);
 	to->threshold_cr =
-	    uDIGIT_FITTING(from->threshold_cr, 16, SH_CSS_BAYER_BITS);
+		uDIGIT_FITTING(from->threshold_cr, 16, SH_CSS_BAYER_BITS);
 }
 
-void
-ia_css_yee_encode(
-    struct sh_css_isp_yee_params *to,
-    const struct ia_css_yee_config *from,
-    unsigned int size)
+void ia_css_yee_encode(struct sh_css_isp_yee_params *to,
+		       const struct ia_css_yee_config *from, unsigned int size)
 {
 	int asiWk1 = (int)from->ee.gain;
 	int asiWk2 = asiWk1 / 8;
@@ -59,80 +42,62 @@ ia_css_yee_encode(
 	(void)size;
 	/* YEE (Y Edge Enhancement) */
 	to->dirthreshold_s =
-	    min((uDIGIT_FITTING(from->nr.direction, 16, SH_CSS_BAYER_BITS)
-		 << 1),
-		SH_CSS_BAYER_MAXVAL);
+		min((uDIGIT_FITTING(from->nr.direction, 16, SH_CSS_BAYER_BITS)
+		     << 1),
+		    SH_CSS_BAYER_MAXVAL);
 	to->dirthreshold_g =
-	    min((uDIGIT_FITTING(from->nr.direction, 16, SH_CSS_BAYER_BITS)
-		 << 4),
-		SH_CSS_BAYER_MAXVAL);
-	to->dirthreshold_width_log2 =
-	    uFRACTION_BITS_FITTING(8);
-	to->dirthreshold_width =
-	    1 << to->dirthreshold_width_log2;
-	to->detailgain =
-	    uDIGIT_FITTING(from->ee.detail_gain, 11,
-			   SH_CSS_YEE_DETAIL_GAIN_SHIFT);
-	to->coring_s =
-	    (uDIGIT_FITTING(56U, 16, SH_CSS_BAYER_BITS) *
-	     from->ee.threshold) >> 8;
-	to->coring_g =
-	    (uDIGIT_FITTING(224U, 16, SH_CSS_BAYER_BITS) *
-	     from->ee.threshold) >> 8;
+		min((uDIGIT_FITTING(from->nr.direction, 16, SH_CSS_BAYER_BITS)
+		     << 4),
+		    SH_CSS_BAYER_MAXVAL);
+	to->dirthreshold_width_log2 = uFRACTION_BITS_FITTING(8);
+	to->dirthreshold_width = 1 << to->dirthreshold_width_log2;
+	to->detailgain = uDIGIT_FITTING(from->ee.detail_gain, 11,
+					SH_CSS_YEE_DETAIL_GAIN_SHIFT);
+	to->coring_s = (uDIGIT_FITTING(56U, 16, SH_CSS_BAYER_BITS) *
+			from->ee.threshold) >>
+		       8;
+	to->coring_g = (uDIGIT_FITTING(224U, 16, SH_CSS_BAYER_BITS) *
+			from->ee.threshold) >>
+		       8;
 	/* 8; // *1.125 ->[s4.8] */
-	to->scale_plus_s =
-	    (asiWk1 + asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	to->scale_plus_s = (asiWk1 + asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
 	/* 8; // ( * -.25)->[s4.8] */
-	to->scale_plus_g =
-	    (0 - asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	to->scale_plus_g = (0 - asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
 	/* 8; // *0.875 ->[s4.8] */
-	to->scale_minus_s =
-	    (asiWk1 - asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	to->scale_minus_s = (asiWk1 - asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
 	/* 8; // ( *.25 ) ->[s4.8] */
-	to->scale_minus_g =
-	    (asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
-	to->clip_plus_s =
-	    uDIGIT_FITTING(32760U, 16, SH_CSS_BAYER_BITS);
+	to->scale_minus_g = (asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	to->clip_plus_s = uDIGIT_FITTING(32760U, 16, SH_CSS_BAYER_BITS);
 	to->clip_plus_g = 0;
-	to->clip_minus_s =
-	    uDIGIT_FITTING(504U, 16, SH_CSS_BAYER_BITS);
-	to->clip_minus_g =
-	    uDIGIT_FITTING(32256U, 16, SH_CSS_BAYER_BITS);
+	to->clip_minus_s = uDIGIT_FITTING(504U, 16, SH_CSS_BAYER_BITS);
+	to->clip_minus_g = uDIGIT_FITTING(32256U, 16, SH_CSS_BAYER_BITS);
 	to->Yclip = SH_CSS_BAYER_MAXVAL;
 }
 
-void
-ia_css_nr_dump(
-    const struct sh_css_isp_ynr_params *ynr,
-    unsigned int level)
+void ia_css_nr_dump(const struct sh_css_isp_ynr_params *ynr, unsigned int level)
 {
-	if (!ynr) return;
-	ia_css_debug_dtrace(level,
-			    "Y Noise Reduction:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ynr_threshold", ynr->threshold);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ynr_gain_all", ynr->gain_all);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ynr_gain_dir", ynr->gain_dir);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ynr_threshold_cb", ynr->threshold_cb);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ynr_threshold_cr", ynr->threshold_cr);
+	if (!ynr)
+		return;
+	ia_css_debug_dtrace(level, "Y Noise Reduction:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ynr_threshold",
+			    ynr->threshold);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ynr_gain_all",
+			    ynr->gain_all);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ynr_gain_dir",
+			    ynr->gain_dir);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ynr_threshold_cb",
+			    ynr->threshold_cb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ynr_threshold_cr",
+			    ynr->threshold_cr);
 }
 
-void
-ia_css_yee_dump(
-    const struct sh_css_isp_yee_params *yee,
-    unsigned int level)
+void ia_css_yee_dump(const struct sh_css_isp_yee_params *yee,
+		     unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "Y Edge Enhancement:\n");
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ynryee_dirthreshold_s",
+	ia_css_debug_dtrace(level, "Y Edge Enhancement:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ynryee_dirthreshold_s",
 			    yee->dirthreshold_s);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ynryee_dirthreshold_g",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ynryee_dirthreshold_g",
 			    yee->dirthreshold_g);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
 			    "ynryee_dirthreshold_width_log2",
@@ -140,70 +105,53 @@ ia_css_yee_dump(
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
 			    "ynryee_dirthreshold_width",
 			    yee->dirthreshold_width);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_detailgain",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_detailgain",
 			    yee->detailgain);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_coring_s",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_coring_s",
 			    yee->coring_s);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_coring_g",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_coring_g",
 			    yee->coring_g);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_scale_plus_s",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_scale_plus_s",
 			    yee->scale_plus_s);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_scale_plus_g",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_scale_plus_g",
 			    yee->scale_plus_g);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_scale_minus_s",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_scale_minus_s",
 			    yee->scale_minus_s);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_scale_minus_g",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_scale_minus_g",
 			    yee->scale_minus_g);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_clip_plus_s",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_clip_plus_s",
 			    yee->clip_plus_s);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_clip_plus_g",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_clip_plus_g",
 			    yee->clip_plus_g);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_clip_minus_s",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_clip_minus_s",
 			    yee->clip_minus_s);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "yee_clip_minus_g",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "yee_clip_minus_g",
 			    yee->clip_minus_g);
-	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
-			    "ynryee_Yclip",
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "ynryee_Yclip",
 			    yee->Yclip);
 }
 
-void
-ia_css_nr_debug_dtrace(
-    const struct ia_css_nr_config *config,
-    unsigned int level)
+void ia_css_nr_debug_dtrace(const struct ia_css_nr_config *config,
+			    unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.direction=%d, config.bnr_gain=%d, config.ynr_gain=%d, config.threshold_cb=%d, config.threshold_cr=%d\n",
-			    config->direction,
-			    config->bnr_gain, config->ynr_gain,
-			    config->threshold_cb, config->threshold_cr);
+	ia_css_debug_dtrace(
+		level,
+		"config.direction=%d, config.bnr_gain=%d, config.ynr_gain=%d, config.threshold_cb=%d, config.threshold_cr=%d\n",
+		config->direction, config->bnr_gain, config->ynr_gain,
+		config->threshold_cb, config->threshold_cr);
 }
 
-void
-ia_css_ee_debug_dtrace(
-    const struct ia_css_ee_config *config,
-    unsigned int level)
+void ia_css_ee_debug_dtrace(const struct ia_css_ee_config *config,
+			    unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.threshold=%d, config.gain=%d, config.detail_gain=%d\n",
-			    config->threshold, config->gain, config->detail_gain);
+	ia_css_debug_dtrace(
+		level,
+		"config.threshold=%d, config.gain=%d, config.detail_gain=%d\n",
+		config->threshold, config->gain, config->detail_gain);
 }
 
-void
-ia_css_init_ynr_state(
-    void/*struct sh_css_isp_ynr_vmem_state*/ * state,
-    size_t size)
+void ia_css_init_ynr_state(void /*struct sh_css_isp_ynr_vmem_state*/ *state,
+			   size_t size)
 {
 	memset(state, 0, size);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h
index ed5c17cc081fd47eb94ea29339a61d487382fddc..3a5defb57c876fd355f17936ae2ae9f087f49a4b 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h
@@ -13,40 +13,24 @@
 extern const struct ia_css_nr_config default_nr_config;
 extern const struct ia_css_ee_config default_ee_config;
 
-void
-ia_css_nr_encode(
-    struct sh_css_isp_ynr_params *to,
-    const struct ia_css_nr_config *from,
-    unsigned int size);
-
-void
-ia_css_yee_encode(
-    struct sh_css_isp_yee_params *to,
-    const struct ia_css_yee_config *from,
-    unsigned int size);
-
-void
-ia_css_nr_dump(
-    const struct sh_css_isp_ynr_params *ynr,
-    unsigned int level);
-
-void
-ia_css_yee_dump(
-    const struct sh_css_isp_yee_params *yee,
-    unsigned int level);
-
-void
-ia_css_nr_debug_dtrace(
-    const struct ia_css_nr_config *config,
-    unsigned int level);
-
-void
-ia_css_ee_debug_dtrace(
-    const struct ia_css_ee_config *config,
-    unsigned int level);
-
-void
-ia_css_init_ynr_state(
-    void/*struct sh_css_isp_ynr_vmem_state*/ * state,
-    size_t size);
+void ia_css_nr_encode(struct sh_css_isp_ynr_params *to,
+		      const struct ia_css_nr_config *from, unsigned int size);
+
+void ia_css_yee_encode(struct sh_css_isp_yee_params *to,
+		       const struct ia_css_yee_config *from, unsigned int size);
+
+void ia_css_nr_dump(const struct sh_css_isp_ynr_params *ynr,
+		    unsigned int level);
+
+void ia_css_yee_dump(const struct sh_css_isp_yee_params *yee,
+		     unsigned int level);
+
+void ia_css_nr_debug_dtrace(const struct ia_css_nr_config *config,
+			    unsigned int level);
+
+void ia_css_ee_debug_dtrace(const struct ia_css_ee_config *config,
+			    unsigned int level);
+
+void ia_css_init_ynr_state(void /*struct sh_css_isp_ynr_vmem_state*/ *state,
+			   size_t size);
 #endif /* __IA_CSS_YNR_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr_types.h
index bf5c388938ef7198bdc0c8977060fc95ceea0756..8ab8b45e40061ef402117115d279ba9e677a2627 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr_types.h
@@ -20,13 +20,13 @@
  *        BNR1,YNR2,CNR2 are used for Still.
  */
 struct ia_css_nr_config {
-	ia_css_u0_16 bnr_gain;	   /** Strength of noise reduction (BNR).
+	ia_css_u0_16 bnr_gain; /** Strength of noise reduction (BNR).
 				u0.16, [0,65535],
 				default 14336(0.21875), ineffective 0 */
-	ia_css_u0_16 ynr_gain;	   /** Strength of noise reduction (YNR).
+	ia_css_u0_16 ynr_gain; /** Strength of noise reduction (YNR).
 				u0.16, [0,65535],
 				default 14336(0.21875), ineffective 0 */
-	ia_css_u0_16 direction;    /** Sensitivity of edge (BNR).
+	ia_css_u0_16 direction; /** Sensitivity of edge (BNR).
 				u0.16, [0,65535],
 				default 512(0.0078125), ineffective 0 */
 	ia_css_u0_16 threshold_cb; /** Coring threshold for Cb (CNR).
@@ -49,10 +49,10 @@ struct ia_css_nr_config {
  *       (YEE2 is used for Still.)
  */
 struct ia_css_ee_config {
-	ia_css_u5_11 gain;	  /** The strength of sharpness.
+	ia_css_u5_11 gain; /** The strength of sharpness.
 					u5.11, [0,65535],
 					default 8192(4.0), ineffective 0 */
-	ia_css_u8_8 threshold;    /** The threshold that divides noises from
+	ia_css_u8_8 threshold; /** The threshold that divides noises from
 					edge.
 					u8.8, [0,65535],
 					default 256(1.0), ineffective 65535 */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.c b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.c
index 9e75cb6415776908ab1422abe92f04a74290408c..8d397f442cef8ec25d37ffad7f8258d5eaac449f 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.c
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.c
@@ -20,41 +20,35 @@ const struct ia_css_ynr_config default_ynr_config = {
 
 const struct ia_css_fc_config default_fc_config = {
 	1,
-	0,		/* 0 -> ineffective */
-	0,		/* 0 -> ineffective */
-	0,		/* 0 -> ineffective */
-	0,		/* 0 -> ineffective */
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
-	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
-	(int16_t)-(1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
-	(int16_t)-(1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
+	0, /* 0 -> ineffective */
+	0, /* 0 -> ineffective */
+	0, /* 0 -> ineffective */
+	0, /* 0 -> ineffective */
+	(1 << (ISP_VEC_ELEMBITS - 2)), /* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 2)), /* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 2)), /* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 2)), /* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 1)) - 1, /* 1 */
+	(1 << (ISP_VEC_ELEMBITS - 1)) - 1, /* 1 */
+	(int16_t) -(1 << (ISP_VEC_ELEMBITS - 1)), /* -1 */
+	(int16_t) -(1 << (ISP_VEC_ELEMBITS - 1)), /* -1 */
 };
 
-void
-ia_css_ynr_encode(
-    struct sh_css_isp_yee2_params *to,
-    const struct ia_css_ynr_config *from,
-    unsigned int size)
+void ia_css_ynr_encode(struct sh_css_isp_yee2_params *to,
+		       const struct ia_css_ynr_config *from, unsigned int size)
 {
 	(void)size;
-	to->edge_sense_gain_0   = from->edge_sense_gain_0;
-	to->edge_sense_gain_1   = from->edge_sense_gain_1;
+	to->edge_sense_gain_0 = from->edge_sense_gain_0;
+	to->edge_sense_gain_1 = from->edge_sense_gain_1;
 	to->corner_sense_gain_0 = from->corner_sense_gain_0;
 	to->corner_sense_gain_1 = from->corner_sense_gain_1;
 }
 
-void
-ia_css_fc_encode(
-    struct sh_css_isp_fc_params *to,
-    const struct ia_css_fc_config *from,
-    unsigned int size)
+void ia_css_fc_encode(struct sh_css_isp_fc_params *to,
+		      const struct ia_css_fc_config *from, unsigned int size)
 {
 	(void)size;
-	to->gain_exp   = from->gain_exp;
+	to->gain_exp = from->gain_exp;
 
 	to->coring_pos_0 = from->coring_pos_0;
 	to->coring_pos_1 = from->coring_pos_1;
@@ -72,39 +66,30 @@ ia_css_fc_encode(
 	to->crop_neg_1 = from->crop_neg_1;
 }
 
-void
-ia_css_ynr_dump(
-    const struct sh_css_isp_yee2_params *yee2,
-    unsigned int level);
+void ia_css_ynr_dump(const struct sh_css_isp_yee2_params *yee2,
+		     unsigned int level);
 
-void
-ia_css_fc_dump(
-    const struct sh_css_isp_fc_params *fc,
-    unsigned int level);
+void ia_css_fc_dump(const struct sh_css_isp_fc_params *fc, unsigned int level);
 
-void
-ia_css_fc_debug_dtrace(
-    const struct ia_css_fc_config *config,
-    unsigned int level)
+void ia_css_fc_debug_dtrace(const struct ia_css_fc_config *config,
+			    unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.gain_exp=%d, config.coring_pos_0=%d, config.coring_pos_1=%d, config.coring_neg_0=%d, config.coring_neg_1=%d, config.gain_pos_0=%d, config.gain_pos_1=%d, config.gain_neg_0=%d, config.gain_neg_1=%d, config.crop_pos_0=%d, config.crop_pos_1=%d, config.crop_neg_0=%d, config.crop_neg_1=%d\n",
-			    config->gain_exp,
-			    config->coring_pos_0, config->coring_pos_1,
-			    config->coring_neg_0, config->coring_neg_1,
-			    config->gain_pos_0, config->gain_pos_1,
-			    config->gain_neg_0, config->gain_neg_1,
-			    config->crop_pos_0, config->crop_pos_1,
-			    config->crop_neg_0, config->crop_neg_1);
+	ia_css_debug_dtrace(
+		level,
+		"config.gain_exp=%d, config.coring_pos_0=%d, config.coring_pos_1=%d, config.coring_neg_0=%d, config.coring_neg_1=%d, config.gain_pos_0=%d, config.gain_pos_1=%d, config.gain_neg_0=%d, config.gain_neg_1=%d, config.crop_pos_0=%d, config.crop_pos_1=%d, config.crop_neg_0=%d, config.crop_neg_1=%d\n",
+		config->gain_exp, config->coring_pos_0, config->coring_pos_1,
+		config->coring_neg_0, config->coring_neg_1, config->gain_pos_0,
+		config->gain_pos_1, config->gain_neg_0, config->gain_neg_1,
+		config->crop_pos_0, config->crop_pos_1, config->crop_neg_0,
+		config->crop_neg_1);
 }
 
-void
-ia_css_ynr_debug_dtrace(
-    const struct ia_css_ynr_config *config,
-    unsigned int level)
+void ia_css_ynr_debug_dtrace(const struct ia_css_ynr_config *config,
+			     unsigned int level)
 {
-	ia_css_debug_dtrace(level,
-			    "config.edge_sense_gain_0=%d, config.edge_sense_gain_1=%d, config.corner_sense_gain_0=%d, config.corner_sense_gain_1=%d\n",
-			    config->edge_sense_gain_0, config->edge_sense_gain_1,
-			    config->corner_sense_gain_0, config->corner_sense_gain_1);
+	ia_css_debug_dtrace(
+		level,
+		"config.edge_sense_gain_0=%d, config.edge_sense_gain_1=%d, config.corner_sense_gain_0=%d, config.corner_sense_gain_1=%d\n",
+		config->edge_sense_gain_0, config->edge_sense_gain_1,
+		config->corner_sense_gain_0, config->corner_sense_gain_1);
 }
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.h b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.h
index cad590e76fcfd3e550787417fcfe2ca650835f83..511f947988c05df57ce9e9dadb76c5058ace1e41 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.h
@@ -11,38 +11,23 @@
 #include "ia_css_ynr2_param.h"
 
 extern const struct ia_css_ynr_config default_ynr_config;
-extern const struct ia_css_fc_config  default_fc_config;
-
-void
-ia_css_ynr_encode(
-    struct sh_css_isp_yee2_params *to,
-    const struct ia_css_ynr_config *from,
-    unsigned int size);
-
-void
-ia_css_fc_encode(
-    struct sh_css_isp_fc_params *to,
-    const struct ia_css_fc_config *from,
-    unsigned int size);
-
-void
-ia_css_ynr_dump(
-    const struct sh_css_isp_yee2_params *yee2,
-    unsigned int level);
-
-void
-ia_css_fc_dump(
-    const struct sh_css_isp_fc_params *fc,
-    unsigned int level);
-
-void
-ia_css_fc_debug_dtrace(
-    const struct ia_css_fc_config *config,
-    unsigned int level);
-
-void
-ia_css_ynr_debug_dtrace(
-    const struct ia_css_ynr_config *config,
-    unsigned int level);
+extern const struct ia_css_fc_config default_fc_config;
+
+void ia_css_ynr_encode(struct sh_css_isp_yee2_params *to,
+		       const struct ia_css_ynr_config *from, unsigned int size);
+
+void ia_css_fc_encode(struct sh_css_isp_fc_params *to,
+		      const struct ia_css_fc_config *from, unsigned int size);
+
+void ia_css_ynr_dump(const struct sh_css_isp_yee2_params *yee2,
+		     unsigned int level);
+
+void ia_css_fc_dump(const struct sh_css_isp_fc_params *fc, unsigned int level);
+
+void ia_css_fc_debug_dtrace(const struct ia_css_fc_config *config,
+			    unsigned int level);
+
+void ia_css_ynr_debug_dtrace(const struct ia_css_ynr_config *config,
+			     unsigned int level);
 
 #endif /* __IA_CSS_YNR2_HOST_H */
diff --git a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h
index 502e104d7226ba88a3e09c84f54e455ab4eac762..151b6cdab63f6d25db8aade4a989f12f886f7e7f 100644
--- a/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h
@@ -19,10 +19,10 @@
  *  ISP2: YNR2 and YEE2 are used for Still.
  */
 struct ia_css_ynr_config {
-	u16 edge_sense_gain_0;   /** Sensitivity of edge in dark area.
+	u16 edge_sense_gain_0; /** Sensitivity of edge in dark area.
 					u13.0, [0,8191],
 					default 1000, ineffective 0 */
-	u16 edge_sense_gain_1;   /** Sensitivity of edge in bright area.
+	u16 edge_sense_gain_1; /** Sensitivity of edge in bright area.
 					u13.0, [0,8191],
 					default 1000, ineffective 0 */
 	u16 corner_sense_gain_0; /** Sensitivity of corner in dark area.
@@ -41,7 +41,7 @@ struct ia_css_ynr_config {
  *  ISP2: FC2 is used for Still.
  */
 struct ia_css_fc_config {
-	u8  gain_exp;   /** Common exponent of gains.
+	u8 gain_exp; /** Common exponent of gains.
 				u8.0, [0,13],
 				default 1, ineffective 0 */
 	u16 coring_pos_0; /** Coring threshold for positive edge in dark area.
@@ -74,10 +74,10 @@ struct ia_css_fc_config {
 	u16 crop_pos_1; /** Limit for positive edge in bright area.
 				u0.13, [0,8191],
 				default/ineffective 8191(almost 1.0) */
-	s16  crop_neg_0; /** Limit for negative edge in dark area.
+	s16 crop_neg_0; /** Limit for negative edge in dark area.
 				s0.13, [-8192,0],
 				default/ineffective -8192(-1.0) */
-	s16  crop_neg_1; /** Limit for negative edge in bright area.
+	s16 crop_neg_1; /** Limit for negative edge in bright area.
 				s0.13, [-8192,0],
 				default/ineffective -8192(-1.0) */
 };
diff --git a/drivers/staging/media/atomisp/pci/isp/modes/interface/input_buf.isp.h b/drivers/staging/media/atomisp/pci/isp/modes/interface/input_buf.isp.h
index c7ade6ce6c68a9a8b784b94ada1f4685c8922ade..d3a1cfcae335ef2bc34e2ef5670507e37ed31945 100644
--- a/drivers/staging/media/atomisp/pci/isp/modes/interface/input_buf.isp.h
+++ b/drivers/staging/media/atomisp/pci/isp/modes/interface/input_buf.isp.h
@@ -12,8 +12,8 @@ Copyright (c) 2010 - 2015, Intel Corporation.
 #include "sh_css_defs.h"
 #include "isp_const.h" /* MAX_VECTORS_PER_INPUT_LINE */
 
-#define INPUT_BUF_HEIGHT	2 /* double buffer */
-#define INPUT_BUF_LINES		2
+#define INPUT_BUF_HEIGHT 2 /* double buffer */
+#define INPUT_BUF_LINES 2
 
 #ifndef ENABLE_CONTINUOUS
 #define ENABLE_CONTINUOUS 0
@@ -21,8 +21,9 @@ Copyright (c) 2010 - 2015, Intel Corporation.
 
 /* In continuous mode, the input buffer must be a fixed size for all binaries
  * and at a fixed address since it will be used by the SP. */
-#define EXTRA_INPUT_VECTORS	2 /* For left padding */
-#define MAX_VECTORS_PER_INPUT_LINE_CONT (CEIL_DIV(SH_CSS_MAX_SENSOR_WIDTH, ISP_NWAY) + EXTRA_INPUT_VECTORS)
+#define EXTRA_INPUT_VECTORS 2 /* For left padding */
+#define MAX_VECTORS_PER_INPUT_LINE_CONT \
+	(CEIL_DIV(SH_CSS_MAX_SENSOR_WIDTH, ISP_NWAY) + EXTRA_INPUT_VECTORS)
 
 /* The input buffer should be on a fixed address in vmem, for continuous capture */
 #define INPUT_BUF_ADDR 0x0
diff --git a/drivers/staging/media/atomisp/pci/isp/modes/interface/isp_const.h b/drivers/staging/media/atomisp/pci/isp/modes/interface/isp_const.h
index b767b0d35bb495f4433057c862461496bec9c108..56eb17c2a4a1dc4421dbf230ade765b2c4f763b0 100644
--- a/drivers/staging/media/atomisp/pci/isp/modes/interface/isp_const.h
+++ b/drivers/staging/media/atomisp/pci/isp/modes/interface/isp_const.h
@@ -8,70 +8,72 @@ Copyright (c) 2010 - 2015, Intel Corporation.
 #ifndef _COMMON_ISP_CONST_H_
 #define _COMMON_ISP_CONST_H_
 
-/*#include "isp.h"*/	/* ISP_VEC_NELEMS */
+/*#include "isp.h"*/ /* ISP_VEC_NELEMS */
 
 /* Binary independent constants */
 
 #ifndef NO_HOIST
-#  define		NO_HOIST	HIVE_ATTRIBUTE((no_hoist))
+#define NO_HOIST HIVE_ATTRIBUTE((no_hoist))
 #endif
 
 #define NO_HOIST_CSE HIVE_ATTRIBUTE((no_hoist, no_cse))
 
 #define UNION struct /* Union constructors not allowed in C++ */
 
-#define XMEM_WIDTH_BITS              HIVE_ISP_DDR_WORD_BITS
-#define XMEM_SHORTS_PER_WORD         (HIVE_ISP_DDR_WORD_BITS / 16)
-#define XMEM_INTS_PER_WORD           (HIVE_ISP_DDR_WORD_BITS / 32)
-#define XMEM_POW2_BYTES_PER_WORD      HIVE_ISP_DDR_WORD_BYTES
+#define XMEM_WIDTH_BITS HIVE_ISP_DDR_WORD_BITS
+#define XMEM_SHORTS_PER_WORD (HIVE_ISP_DDR_WORD_BITS / 16)
+#define XMEM_INTS_PER_WORD (HIVE_ISP_DDR_WORD_BITS / 32)
+#define XMEM_POW2_BYTES_PER_WORD HIVE_ISP_DDR_WORD_BYTES
 
-#define BITS8_ELEMENTS_PER_XMEM_ADDR    CEIL_DIV(XMEM_WIDTH_BITS, 8)
-#define BITS16_ELEMENTS_PER_XMEM_ADDR    CEIL_DIV(XMEM_WIDTH_BITS, 16)
+#define BITS8_ELEMENTS_PER_XMEM_ADDR CEIL_DIV(XMEM_WIDTH_BITS, 8)
+#define BITS16_ELEMENTS_PER_XMEM_ADDR CEIL_DIV(XMEM_WIDTH_BITS, 16)
 
-#define ISP_NWAY_LOG2  6
+#define ISP_NWAY_LOG2 6
 
 /* *****************************
  * ISP input/output buffer sizes
  * ****************************/
 /* input image */
-#define INPUT_BUF_DMA_HEIGHT          2
-#define INPUT_BUF_HEIGHT              2 /* double buffer */
-#define OUTPUT_BUF_DMA_HEIGHT         2
-#define OUTPUT_BUF_HEIGHT             2 /* double buffer */
-#define OUTPUT_NUM_TRANSFERS	      4
+#define INPUT_BUF_DMA_HEIGHT 2
+#define INPUT_BUF_HEIGHT 2 /* double buffer */
+#define OUTPUT_BUF_DMA_HEIGHT 2
+#define OUTPUT_BUF_HEIGHT 2 /* double buffer */
+#define OUTPUT_NUM_TRANSFERS 4
 
 /* GDC accelerator: Up/Down Scaling */
 /* These should be moved to the gdc_defs.h in the device */
-#define UDS_SCALING_N                 HRT_GDC_N
+#define UDS_SCALING_N HRT_GDC_N
 /* AB: This should cover the zooming up to 16MP */
-#define UDS_MAX_OXDIM                 5000
+#define UDS_MAX_OXDIM 5000
 /* We support maximally 2 planes with different parameters
        - luma and chroma (YUV420) */
-#define UDS_MAX_PLANES                2
-#define UDS_BLI_BLOCK_HEIGHT          2
-#define UDS_BCI_BLOCK_HEIGHT          4
-#define UDS_BLI_INTERP_ENVELOPE       1
-#define UDS_BCI_INTERP_ENVELOPE       3
-#define UDS_MAX_ZOOM_FAC              64
+#define UDS_MAX_PLANES 2
+#define UDS_BLI_BLOCK_HEIGHT 2
+#define UDS_BCI_BLOCK_HEIGHT 4
+#define UDS_BLI_INTERP_ENVELOPE 1
+#define UDS_BCI_INTERP_ENVELOPE 3
+#define UDS_MAX_ZOOM_FAC 64
 /* Make it always one FPGA vector.
    Four FPGA vectors are required and
    four of them fit in one ASIC vector.*/
-#define UDS_MAX_CHUNKS                16
+#define UDS_MAX_CHUNKS 16
 
-#define ISP_LEFT_PADDING	_ISP_LEFT_CROP_EXTRA(ISP_LEFT_CROPPING)
-#define ISP_LEFT_PADDING_VECS	CEIL_DIV(ISP_LEFT_PADDING, ISP_VEC_NELEMS)
+#define ISP_LEFT_PADDING _ISP_LEFT_CROP_EXTRA(ISP_LEFT_CROPPING)
+#define ISP_LEFT_PADDING_VECS CEIL_DIV(ISP_LEFT_PADDING, ISP_VEC_NELEMS)
 /* in case of continuous the croppong of the current binary doesn't matter for the buffer calculation, but the cropping of the sp copy should be used */
-#define ISP_LEFT_PADDING_CONT	_ISP_LEFT_CROP_EXTRA(SH_CSS_MAX_LEFT_CROPPING)
-#define ISP_LEFT_PADDING_VECS_CONT	CEIL_DIV(ISP_LEFT_PADDING_CONT, ISP_VEC_NELEMS)
+#define ISP_LEFT_PADDING_CONT _ISP_LEFT_CROP_EXTRA(SH_CSS_MAX_LEFT_CROPPING)
+#define ISP_LEFT_PADDING_VECS_CONT \
+	CEIL_DIV(ISP_LEFT_PADDING_CONT, ISP_VEC_NELEMS)
 
-#define CEIL_ROUND_DIV_STRIPE(width, stripe, padding) \
-	CEIL_MUL(padding + CEIL_DIV(width - padding, stripe), ((ENABLE_RAW_BINNING || ENABLE_FIXED_BAYER_DS) ? 4 : 2))
+#define CEIL_ROUND_DIV_STRIPE(width, stripe, padding)         \
+	CEIL_MUL(padding + CEIL_DIV(width - padding, stripe), \
+		 ((ENABLE_RAW_BINNING || ENABLE_FIXED_BAYER_DS) ? 4 : 2))
 
 /* output (Y,U,V) image, 4:2:0 */
-#define MAX_VECTORS_PER_LINE \
-	CEIL_ROUND_DIV_STRIPE(CEIL_DIV(ISP_MAX_INTERNAL_WIDTH, ISP_VEC_NELEMS), \
-			      ISP_NUM_STRIPES, \
-			      ISP_LEFT_PADDING_VECS)
+#define MAX_VECTORS_PER_LINE                                   \
+	CEIL_ROUND_DIV_STRIPE(CEIL_DIV(ISP_MAX_INTERNAL_WIDTH, \
+				       ISP_VEC_NELEMS),        \
+			      ISP_NUM_STRIPES, ISP_LEFT_PADDING_VECS)
 
 /*
  * ITERATOR_VECTOR_INCREMENT' explanation:
@@ -80,58 +82,58 @@ Copyright (c) 2010 - 2015, Intel Corporation.
  * so the calc for the output buffer vmem size is:
  * ((width[vectors]/num_of_stripes) + 2[vectors])
  */
-#define MAX_VECTORS_PER_OUTPUT_LINE \
-	CEIL_DIV(CEIL_DIV(ISP_MAX_OUTPUT_WIDTH, ISP_NUM_STRIPES) + ISP_LEFT_PADDING, ISP_VEC_NELEMS)
+#define MAX_VECTORS_PER_OUTPUT_LINE                                \
+	CEIL_DIV(CEIL_DIV(ISP_MAX_OUTPUT_WIDTH, ISP_NUM_STRIPES) + \
+			 ISP_LEFT_PADDING,                         \
+		 ISP_VEC_NELEMS)
 
 /* Must be even due to interlaced bayer input */
-#define MAX_VECTORS_PER_INPUT_LINE	CEIL_MUL((CEIL_DIV(ISP_MAX_INPUT_WIDTH, ISP_VEC_NELEMS) + ISP_LEFT_PADDING_VECS), 2)
-#define MAX_VECTORS_PER_INPUT_STRIPE	CEIL_ROUND_DIV_STRIPE(MAX_VECTORS_PER_INPUT_LINE, \
-							      ISP_NUM_STRIPES, \
-							      ISP_LEFT_PADDING_VECS)
+#define MAX_VECTORS_PER_INPUT_LINE                                \
+	CEIL_MUL((CEIL_DIV(ISP_MAX_INPUT_WIDTH, ISP_VEC_NELEMS) + \
+		  ISP_LEFT_PADDING_VECS),                         \
+		 2)
+#define MAX_VECTORS_PER_INPUT_STRIPE                                       \
+	CEIL_ROUND_DIV_STRIPE(MAX_VECTORS_PER_INPUT_LINE, ISP_NUM_STRIPES, \
+			      ISP_LEFT_PADDING_VECS)
 
 /* Add 2 for left croppping */
-#define MAX_SP_RAW_COPY_VECTORS_PER_INPUT_LINE	(CEIL_DIV(ISP_MAX_INPUT_WIDTH, ISP_VEC_NELEMS) + 2)
+#define MAX_SP_RAW_COPY_VECTORS_PER_INPUT_LINE \
+	(CEIL_DIV(ISP_MAX_INPUT_WIDTH, ISP_VEC_NELEMS) + 2)
 
-#define MAX_VECTORS_PER_BUF_LINE \
-	(MAX_VECTORS_PER_LINE + DUMMY_BUF_VECTORS)
+#define MAX_VECTORS_PER_BUF_LINE (MAX_VECTORS_PER_LINE + DUMMY_BUF_VECTORS)
 #define MAX_VECTORS_PER_BUF_INPUT_LINE \
 	(MAX_VECTORS_PER_INPUT_STRIPE + DUMMY_BUF_VECTORS)
-#define MAX_OUTPUT_Y_FRAME_WIDTH \
-	(MAX_VECTORS_PER_LINE * ISP_VEC_NELEMS)
-#define MAX_OUTPUT_Y_FRAME_SIMDWIDTH \
-	MAX_VECTORS_PER_LINE
-#define MAX_OUTPUT_C_FRAME_WIDTH \
-	(MAX_OUTPUT_Y_FRAME_WIDTH / 2)
+#define MAX_OUTPUT_Y_FRAME_WIDTH (MAX_VECTORS_PER_LINE * ISP_VEC_NELEMS)
+#define MAX_OUTPUT_Y_FRAME_SIMDWIDTH MAX_VECTORS_PER_LINE
+#define MAX_OUTPUT_C_FRAME_WIDTH (MAX_OUTPUT_Y_FRAME_WIDTH / 2)
 #define MAX_OUTPUT_C_FRAME_SIMDWIDTH \
 	CEIL_DIV(MAX_OUTPUT_C_FRAME_WIDTH, ISP_VEC_NELEMS)
 
 /* should be even */
 #define NO_CHUNKING (OUTPUT_NUM_CHUNKS == 1)
 
-#define MAX_VECTORS_PER_CHUNK \
-	(NO_CHUNKING ? MAX_VECTORS_PER_LINE \
-				: 2 * CEIL_DIV(MAX_VECTORS_PER_LINE, \
-					     2 * OUTPUT_NUM_CHUNKS))
+#define MAX_VECTORS_PER_CHUNK           \
+	(NO_CHUNKING ?                  \
+		 MAX_VECTORS_PER_LINE : \
+		 2 * CEIL_DIV(MAX_VECTORS_PER_LINE, 2 * OUTPUT_NUM_CHUNKS))
 
-#define MAX_C_VECTORS_PER_CHUNK \
-	(MAX_VECTORS_PER_CHUNK / 2)
+#define MAX_C_VECTORS_PER_CHUNK (MAX_VECTORS_PER_CHUNK / 2)
 
 /* should be even */
-#define MAX_VECTORS_PER_OUTPUT_CHUNK \
-	(NO_CHUNKING ? MAX_VECTORS_PER_OUTPUT_LINE \
-				: 2 * CEIL_DIV(MAX_VECTORS_PER_OUTPUT_LINE, \
-					     2 * OUTPUT_NUM_CHUNKS))
+#define MAX_VECTORS_PER_OUTPUT_CHUNK                             \
+	(NO_CHUNKING ? MAX_VECTORS_PER_OUTPUT_LINE :             \
+		       2 * CEIL_DIV(MAX_VECTORS_PER_OUTPUT_LINE, \
+				    2 * OUTPUT_NUM_CHUNKS))
 
-#define MAX_C_VECTORS_PER_OUTPUT_CHUNK \
-	(MAX_VECTORS_PER_OUTPUT_CHUNK / 2)
+#define MAX_C_VECTORS_PER_OUTPUT_CHUNK (MAX_VECTORS_PER_OUTPUT_CHUNK / 2)
 
 /* should be even */
-#define MAX_VECTORS_PER_INPUT_CHUNK \
-	(INPUT_NUM_CHUNKS == 1 ? MAX_VECTORS_PER_INPUT_STRIPE \
-			       : 2 * CEIL_DIV(MAX_VECTORS_PER_INPUT_STRIPE, \
-					    2 * OUTPUT_NUM_CHUNKS))
+#define MAX_VECTORS_PER_INPUT_CHUNK                                         \
+	(INPUT_NUM_CHUNKS == 1 ? MAX_VECTORS_PER_INPUT_STRIPE :             \
+				 2 * CEIL_DIV(MAX_VECTORS_PER_INPUT_STRIPE, \
+					      2 * OUTPUT_NUM_CHUNKS))
 
-#define DEFAULT_C_SUBSAMPLING      2
+#define DEFAULT_C_SUBSAMPLING 2
 
 /****** DMA buffer properties */
 
diff --git a/drivers/staging/media/atomisp/pci/isp/modes/interface/isp_types.h b/drivers/staging/media/atomisp/pci/isp/modes/interface/isp_types.h
index e5c77a95d7026d373ab35309e625da863e18f649..aa5ff34ae3b4fa23e05f96bb9e55337eced5a5d9 100644
--- a/drivers/staging/media/atomisp/pci/isp/modes/interface/isp_types.h
+++ b/drivers/staging/media/atomisp/pci/isp/modes/interface/isp_types.h
@@ -27,7 +27,7 @@ enum sh_stream_format {
 	sh_stream_format_yuv422,
 	sh_stream_format_rgb,
 	sh_stream_format_raw,
-	sh_stream_format_binary,	/* bytestream such as jpeg */
+	sh_stream_format_binary, /* bytestream such as jpeg */
 };
 
 struct s_isp_frames {
diff --git a/drivers/staging/media/atomisp/pci/isp2400_input_system_global.h b/drivers/staging/media/atomisp/pci/isp2400_input_system_global.h
index df4378fd3540b72ee8f00dc53e752ecc2e09a36b..aed207e1fc92aa058131fd01d9895eaa13abaa49 100644
--- a/drivers/staging/media/atomisp/pci/isp2400_input_system_global.h
+++ b/drivers/staging/media/atomisp/pci/isp2400_input_system_global.h
@@ -7,13 +7,13 @@
 #include <type_support.h>
 
 //CSI reveiver has 3 ports.
-#define		N_CSI_PORTS (3)
+#define N_CSI_PORTS (3)
 //AM: Use previous define for this.
 
 //MIPI allows up to 4 channels.
-#define		N_CHANNELS  (4)
+#define N_CHANNELS (4)
 // 12KB = 256bit x 384 words
-#define		IB_CAPACITY_IN_WORDS (384)
+#define IB_CAPACITY_IN_WORDS (384)
 
 typedef enum {
 	MIPI_0LANE_CFG = 0,
@@ -65,75 +65,76 @@ typedef enum {
 	N_INPUT_SYSTEM_BUFFERING_MODE
 } buffering_mode_t;
 
-typedef struct isp2400_input_system_cfg_s	input_system_cfg_t;
-typedef struct sync_generator_cfg_s	sync_generator_cfg_t;
-typedef struct tpg_cfg_s			tpg_cfg_t;
-typedef struct prbs_cfg_s			prbs_cfg_t;
+typedef struct isp2400_input_system_cfg_s input_system_cfg_t;
+typedef struct sync_generator_cfg_s sync_generator_cfg_t;
+typedef struct tpg_cfg_s tpg_cfg_t;
+typedef struct prbs_cfg_s prbs_cfg_t;
 
 /* MW: uint16_t should be sufficient */
 struct isp2400_input_system_cfg_s {
-	u32	no_side_band;
-	u32	fmt_type;
-	u32	ch_id;
-	u32	input_mode;
+	u32 no_side_band;
+	u32 fmt_type;
+	u32 ch_id;
+	u32 input_mode;
 };
 
 struct sync_generator_cfg_s {
-	u32	width;
-	u32	height;
-	u32	hblank_cycles;
-	u32	vblank_cycles;
+	u32 width;
+	u32 height;
+	u32 hblank_cycles;
+	u32 vblank_cycles;
 };
 
 /* MW: tpg & prbs are exclusive */
 struct tpg_cfg_s {
-	u32	x_mask;
-	u32	y_mask;
-	u32	x_delta;
-	u32	y_delta;
-	u32	xy_mask;
+	u32 x_mask;
+	u32 y_mask;
+	u32 x_delta;
+	u32 y_delta;
+	u32 xy_mask;
 	sync_generator_cfg_t sync_gen_cfg;
 };
 
 struct prbs_cfg_s {
-	u32	seed;
+	u32 seed;
 	sync_generator_cfg_t sync_gen_cfg;
 };
 
 struct gpfifo_cfg_s {
-// TBD.
+	// TBD.
 	sync_generator_cfg_t sync_gen_cfg;
 };
 
-typedef struct gpfifo_cfg_s		gpfifo_cfg_t;
+typedef struct gpfifo_cfg_s gpfifo_cfg_t;
 
 //ALX:Commented out to pass the compilation.
 //typedef struct isp2400_input_system_cfg_s input_system_cfg_t;
 
 struct ib_buffer_s {
-	u32	mem_reg_size;
-	u32	nof_mem_regs;
-	u32	mem_reg_addr;
+	u32 mem_reg_size;
+	u32 nof_mem_regs;
+	u32 mem_reg_addr;
 };
 
-typedef struct ib_buffer_s	isp2400_ib_buffer_t;
+typedef struct ib_buffer_s isp2400_ib_buffer_t;
 
 struct csi_cfg_s {
-	u32			csi_port;
-	buffering_mode_t	buffering_mode;
-	isp2400_ib_buffer_t	csi_buffer;
-	isp2400_ib_buffer_t	acquisition_buffer;
-	u32			nof_xmem_buffers;
+	u32 csi_port;
+	buffering_mode_t buffering_mode;
+	isp2400_ib_buffer_t csi_buffer;
+	isp2400_ib_buffer_t acquisition_buffer;
+	u32 nof_xmem_buffers;
 };
 
-typedef struct csi_cfg_s	 csi_cfg_t;
+typedef struct csi_cfg_s csi_cfg_t;
 
 typedef enum {
-	INPUT_SYSTEM_CFG_FLAG_RESET	= 0,
-	INPUT_SYSTEM_CFG_FLAG_SET		= 1U << 0,
-	INPUT_SYSTEM_CFG_FLAG_BLOCKED	= 1U << 1,
-	INPUT_SYSTEM_CFG_FLAG_REQUIRED	= 1U << 2,
-	INPUT_SYSTEM_CFG_FLAG_CONFLICT	= 1U << 3	// To mark a conflicting configuration.
+	INPUT_SYSTEM_CFG_FLAG_RESET = 0,
+	INPUT_SYSTEM_CFG_FLAG_SET = 1U << 0,
+	INPUT_SYSTEM_CFG_FLAG_BLOCKED = 1U << 1,
+	INPUT_SYSTEM_CFG_FLAG_REQUIRED = 1U << 2,
+	INPUT_SYSTEM_CFG_FLAG_CONFLICT =
+		1U << 3 // To mark a conflicting configuration.
 } isp2400_input_system_cfg_flag_t;
 
 typedef u32 input_system_config_flags_t;
diff --git a/drivers/staging/media/atomisp/pci/isp2400_input_system_local.h b/drivers/staging/media/atomisp/pci/isp2400_input_system_local.h
index 56a4db03304486496f4c7f8597044247984e65ae..7a9d27e711a3196a478998700de2ae92fbeba45b 100644
--- a/drivers/staging/media/atomisp/pci/isp2400_input_system_local.h
+++ b/drivers/staging/media/atomisp/pci/isp2400_input_system_local.h
@@ -7,7 +7,7 @@
 #ifndef __INPUT_SYSTEM_2400_LOCAL_H_INCLUDED__
 #define __INPUT_SYSTEM_2400_LOCAL_H_INCLUDED__
 
-#include "input_system_defs.h"		/* HIVE_ISYS_GPREG_MULTICAST_A_IDX,... */
+#include "input_system_defs.h" /* HIVE_ISYS_GPREG_MULTICAST_A_IDX,... */
 
 /*
  * _HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX,
@@ -21,138 +21,192 @@
 #include "input_system_ctrl_defs.h"
 
 struct target_cfg2400_s {
-	input_switch_cfg_channel_t		input_switch_channel_cfg;
-	target_isp_cfg_t	target_isp_cfg;
-	target_sp_cfg_t		target_sp_cfg;
-	target_strm2mem_cfg_t	target_strm2mem_cfg;
+	input_switch_cfg_channel_t input_switch_channel_cfg;
+	target_isp_cfg_t target_isp_cfg;
+	target_sp_cfg_t target_sp_cfg;
+	target_strm2mem_cfg_t target_strm2mem_cfg;
 };
 
 // Configuration of a channel.
 struct channel_cfg_s {
-	u32		ch_id;
-	backend_channel_cfg_t	backend_ch;
-	input_system_source_t	source_type;
-	source_cfg_t		source_cfg;
-	target_cfg2400_t	target_cfg;
+	u32 ch_id;
+	backend_channel_cfg_t backend_ch;
+	input_system_source_t source_type;
+	source_cfg_t source_cfg;
+	target_cfg2400_t target_cfg;
 };
 
 // Complete configuration for input system.
 struct input_system_cfg2400_s {
 	input_system_source_t source_type;
-	input_system_config_flags_t	source_type_flags;
+	input_system_config_flags_t source_type_flags;
 	//channel_cfg_t		channel[N_CHANNELS];
-	input_system_config_flags_t	ch_flags[N_CHANNELS];
+	input_system_config_flags_t ch_flags[N_CHANNELS];
 	//  This is the place where the buffers' settings are collected, as given.
-	csi_cfg_t			csi_value[N_CSI_PORTS];
-	input_system_config_flags_t	csi_flags[N_CSI_PORTS];
+	csi_cfg_t csi_value[N_CSI_PORTS];
+	input_system_config_flags_t csi_flags[N_CSI_PORTS];
 
 	// Possible another struct for ib.
 	// This buffers set at the end, based on the all configurations.
-	isp2400_ib_buffer_t			csi_buffer[N_CSI_PORTS];
-	input_system_config_flags_t	csi_buffer_flags[N_CSI_PORTS];
-	isp2400_ib_buffer_t			acquisition_buffer_unique;
-	input_system_config_flags_t	acquisition_buffer_unique_flags;
-	u32			unallocated_ib_mem_words; // Used for check.DEFAULT = IB_CAPACITY_IN_WORDS.
+	isp2400_ib_buffer_t csi_buffer[N_CSI_PORTS];
+	input_system_config_flags_t csi_buffer_flags[N_CSI_PORTS];
+	isp2400_ib_buffer_t acquisition_buffer_unique;
+	input_system_config_flags_t acquisition_buffer_unique_flags;
+	u32 unallocated_ib_mem_words; // Used for check.DEFAULT = IB_CAPACITY_IN_WORDS.
 	//uint32_t			acq_allocated_ib_mem_words;
 
-	input_system_connection_t		multicast[N_CSI_PORTS];
-	input_system_multiplex_t		multiplexer;
-	input_system_config_flags_t		multiplexer_flags;
-
-	tpg_cfg_t			tpg_value;
-	input_system_config_flags_t	tpg_flags;
-	prbs_cfg_t			prbs_value;
-	input_system_config_flags_t	prbs_flags;
-	gpfifo_cfg_t		gpfifo_value;
-	input_system_config_flags_t	gpfifo_flags;
+	input_system_connection_t multicast[N_CSI_PORTS];
+	input_system_multiplex_t multiplexer;
+	input_system_config_flags_t multiplexer_flags;
 
-	input_switch_cfg_t		input_switch_cfg;
+	tpg_cfg_t tpg_value;
+	input_system_config_flags_t tpg_flags;
+	prbs_cfg_t prbs_value;
+	input_system_config_flags_t prbs_flags;
+	gpfifo_cfg_t gpfifo_value;
+	input_system_config_flags_t gpfifo_flags;
 
-	target_isp_cfg_t		target_isp[N_CHANNELS];
-	input_system_config_flags_t	target_isp_flags[N_CHANNELS];
-	target_sp_cfg_t			target_sp[N_CHANNELS];
-	input_system_config_flags_t	target_sp_flags[N_CHANNELS];
-	target_strm2mem_cfg_t	target_strm2mem[N_CHANNELS];
-	input_system_config_flags_t	target_strm2mem_flags[N_CHANNELS];
+	input_switch_cfg_t input_switch_cfg;
 
-	input_system_config_flags_t		session_flags;
+	target_isp_cfg_t target_isp[N_CHANNELS];
+	input_system_config_flags_t target_isp_flags[N_CHANNELS];
+	target_sp_cfg_t target_sp[N_CHANNELS];
+	input_system_config_flags_t target_sp_flags[N_CHANNELS];
+	target_strm2mem_cfg_t target_strm2mem[N_CHANNELS];
+	input_system_config_flags_t target_strm2mem_flags[N_CHANNELS];
 
+	input_system_config_flags_t session_flags;
 };
 
 /*
  * For each MIPI port
  */
-#define _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX			_HRT_CSS_RECEIVER_2400_DEVICE_READY_REG_IDX
-#define _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX			_HRT_CSS_RECEIVER_2400_IRQ_STATUS_REG_IDX
-#define _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX			_HRT_CSS_RECEIVER_2400_IRQ_ENABLE_REG_IDX
-#define _HRT_CSS_RECEIVER_TIMEOUT_COUNT_REG_IDX		    _HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX
-#define _HRT_CSS_RECEIVER_INIT_COUNT_REG_IDX			_HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX
+#define _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_DEVICE_READY_REG_IDX
+#define _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_IRQ_STATUS_REG_IDX
+#define _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_IRQ_ENABLE_REG_IDX
+#define _HRT_CSS_RECEIVER_TIMEOUT_COUNT_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX
+#define _HRT_CSS_RECEIVER_INIT_COUNT_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX
 /* new regs for each MIPI port w.r.t. 2300 */
-#define _HRT_CSS_RECEIVER_RAW16_18_DATAID_REG_IDX       _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_REG_IDX
-#define _HRT_CSS_RECEIVER_SYNC_COUNT_REG_IDX            _HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX
-#define _HRT_CSS_RECEIVER_RX_COUNT_REG_IDX              _HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX
+#define _HRT_CSS_RECEIVER_RAW16_18_DATAID_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_REG_IDX
+#define _HRT_CSS_RECEIVER_SYNC_COUNT_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX
+#define _HRT_CSS_RECEIVER_RX_COUNT_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX
 
 /* _HRT_CSS_RECEIVER_2400_COMP_FORMAT_REG_IDX is not defined per MIPI port but per channel */
 /* _HRT_CSS_RECEIVER_2400_COMP_PREDICT_REG_IDX is not defined per MIPI port but per channel */
-#define _HRT_CSS_RECEIVER_FS_TO_LS_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_FS_TO_LS_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_LS_TO_DATA_DELAY_REG_IDX      _HRT_CSS_RECEIVER_2400_LS_TO_DATA_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_DATA_TO_LE_DELAY_REG_IDX      _HRT_CSS_RECEIVER_2400_DATA_TO_LE_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_LE_TO_FE_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_LE_TO_FE_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_FE_TO_FS_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_FE_TO_FS_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_LE_TO_LS_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_LE_TO_LS_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX			_HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX
-#define _HRT_CSS_RECEIVER_BACKEND_RST_REG_IDX           _HRT_CSS_RECEIVER_2400_BACKEND_RST_REG_IDX
-#define _HRT_CSS_RECEIVER_RAW18_REG_IDX                 _HRT_CSS_RECEIVER_2400_RAW18_REG_IDX
-#define _HRT_CSS_RECEIVER_FORCE_RAW8_REG_IDX            _HRT_CSS_RECEIVER_2400_FORCE_RAW8_REG_IDX
-#define _HRT_CSS_RECEIVER_RAW16_REG_IDX                 _HRT_CSS_RECEIVER_2400_RAW16_REG_IDX
+#define _HRT_CSS_RECEIVER_FS_TO_LS_DELAY_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_FS_TO_LS_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_LS_TO_DATA_DELAY_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_LS_TO_DATA_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_DATA_TO_LE_DELAY_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_DATA_TO_LE_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_LE_TO_FE_DELAY_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_LE_TO_FE_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_FE_TO_FS_DELAY_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_FE_TO_FS_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_LE_TO_LS_DELAY_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_LE_TO_LS_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX
+#define _HRT_CSS_RECEIVER_BACKEND_RST_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_BACKEND_RST_REG_IDX
+#define _HRT_CSS_RECEIVER_RAW18_REG_IDX _HRT_CSS_RECEIVER_2400_RAW18_REG_IDX
+#define _HRT_CSS_RECEIVER_FORCE_RAW8_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_FORCE_RAW8_REG_IDX
+#define _HRT_CSS_RECEIVER_RAW16_REG_IDX _HRT_CSS_RECEIVER_2400_RAW16_REG_IDX
 
 /* Previously MIPI port regs, now 2x2 logical channel regs */
-#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC0_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX
-#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC0_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX
-#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC1_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX
-#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC1_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX
-#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC2_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX
-#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC2_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX
-#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC3_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX
-#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC3_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC0_REG0_IDX \
+	_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC0_REG1_IDX \
+	_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC1_REG0_IDX \
+	_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC1_REG1_IDX \
+	_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC2_REG0_IDX \
+	_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC2_REG1_IDX \
+	_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC3_REG0_IDX \
+	_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC3_REG1_IDX \
+	_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX
 
 /* Second backend is at offset 0x0700 w.r.t. the first port at offset 0x0100 */
-#define _HRT_CSS_BE_OFFSET                              448
-#define _HRT_CSS_RECEIVER_BE_GSP_ACC_OVL_REG_IDX        (_HRT_CSS_RECEIVER_2400_BE_GSP_ACC_OVL_REG_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_SRST_REG_IDX               (_HRT_CSS_RECEIVER_2400_BE_SRST_REG_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX            (_HRT_CSS_RECEIVER_2400_BE_TWO_PPC_REG_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG0_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG0_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG1_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG1_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG2_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG2_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG3_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG3_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_SEL_REG_IDX                (_HRT_CSS_RECEIVER_2400_BE_SEL_REG_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_RAW16_CONFIG_REG_IDX       (_HRT_CSS_RECEIVER_2400_BE_RAW16_CONFIG_REG_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_RAW18_CONFIG_REG_IDX       (_HRT_CSS_RECEIVER_2400_BE_RAW18_CONFIG_REG_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_FORCE_RAW8_REG_IDX         (_HRT_CSS_RECEIVER_2400_BE_FORCE_RAW8_REG_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_IRQ_STATUS_REG_IDX         (_HRT_CSS_RECEIVER_2400_BE_IRQ_STATUS_REG_IDX + _HRT_CSS_BE_OFFSET)
-#define _HRT_CSS_RECEIVER_BE_IRQ_CLEAR_REG_IDX          (_HRT_CSS_RECEIVER_2400_BE_IRQ_CLEAR_REG_IDX + _HRT_CSS_BE_OFFSET)
-
-#define _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT		_HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_BIT
-#define _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT		_HRT_CSS_RECEIVER_2400_IRQ_RESERVED_BIT
-#define _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT	_HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_BIT
-#define _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT	_HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_BIT
-#define _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT		_HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_BIT
-
-#define _HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX		_HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX
-#define	_HRT_CSS_RECEIVER_DATA_TIMEOUT_IDX		_HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_IDX
-#define	_HRT_CSS_RECEIVER_DATA_TIMEOUT_BITS		_HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_BITS
+#define _HRT_CSS_BE_OFFSET 448
+#define _HRT_CSS_RECEIVER_BE_GSP_ACC_OVL_REG_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_GSP_ACC_OVL_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_SRST_REG_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_SRST_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_TWO_PPC_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG0_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG0_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG1_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG1_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG2_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG2_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG3_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG3_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_SEL_REG_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_SEL_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_RAW16_CONFIG_REG_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_RAW16_CONFIG_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_RAW18_CONFIG_REG_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_RAW18_CONFIG_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_FORCE_RAW8_REG_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_FORCE_RAW8_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_IRQ_STATUS_REG_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_IRQ_STATUS_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_IRQ_CLEAR_REG_IDX \
+	(_HRT_CSS_RECEIVER_2400_BE_IRQ_CLEAR_REG_IDX + _HRT_CSS_BE_OFFSET)
+
+#define _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT _HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_BIT
+#define _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_RESERVED_BIT
+#define _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_BIT
+#define _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT _HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT _HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_BIT
+#define _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT \
+	_HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_BIT
+
+#define _HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX \
+	_HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX
+#define _HRT_CSS_RECEIVER_DATA_TIMEOUT_IDX \
+	_HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_IDX
+#define _HRT_CSS_RECEIVER_DATA_TIMEOUT_BITS \
+	_HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_BITS
 
 typedef enum {
 	MIPI_FORMAT_2400_RGB888 = 0,
@@ -160,75 +214,77 @@ typedef enum {
 	MIPI_FORMAT_2400_RGB444,
 	MIPI_FORMAT_2400_RGB565,
 	MIPI_FORMAT_2400_RGB666,
-	MIPI_FORMAT_2400_RAW8,		/* 5 */
+	MIPI_FORMAT_2400_RAW8, /* 5 */
 	MIPI_FORMAT_2400_RAW10,
 	MIPI_FORMAT_2400_RAW6,
 	MIPI_FORMAT_2400_RAW7,
 	MIPI_FORMAT_2400_RAW12,
-	MIPI_FORMAT_2400_RAW14,		/* 10 */
+	MIPI_FORMAT_2400_RAW14, /* 10 */
 	MIPI_FORMAT_2400_YUV420_8,
 	MIPI_FORMAT_2400_YUV420_10,
 	MIPI_FORMAT_2400_YUV422_8,
 	MIPI_FORMAT_2400_YUV422_10,
-	MIPI_FORMAT_2400_CUSTOM0,	/* 15 */
+	MIPI_FORMAT_2400_CUSTOM0, /* 15 */
 	MIPI_FORMAT_2400_YUV420_8_LEGACY,
 	MIPI_FORMAT_2400_EMBEDDED,
 	MIPI_FORMAT_2400_CUSTOM1,
 	MIPI_FORMAT_2400_CUSTOM2,
-	MIPI_FORMAT_2400_CUSTOM3,	/* 20 */
+	MIPI_FORMAT_2400_CUSTOM3, /* 20 */
 	MIPI_FORMAT_2400_CUSTOM4,
 	MIPI_FORMAT_2400_CUSTOM5,
 	MIPI_FORMAT_2400_CUSTOM6,
 	MIPI_FORMAT_2400_CUSTOM7,
-	MIPI_FORMAT_2400_YUV420_8_SHIFT,	/* 25 */
+	MIPI_FORMAT_2400_YUV420_8_SHIFT, /* 25 */
 	MIPI_FORMAT_2400_YUV420_10_SHIFT,
 	MIPI_FORMAT_2400_RAW16,
 	MIPI_FORMAT_2400_RAW18,
 	N_MIPI_FORMAT_2400,
 } mipi_format_2400_t;
 
-#define N_MIPI_FORMAT_CUSTOM	8
+#define N_MIPI_FORMAT_CUSTOM 8
 
 /* The number of stores for compressed format types */
-#define	N_MIPI_COMPRESSOR_CONTEXT	(N_RX_CHANNEL_ID * N_MIPI_FORMAT_CUSTOM)
+#define N_MIPI_COMPRESSOR_CONTEXT (N_RX_CHANNEL_ID * N_MIPI_FORMAT_CUSTOM)
 
 typedef enum {
-	RX_IRQ_INFO_BUFFER_OVERRUN   = 1UL << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT,
-	RX_IRQ_INFO_INIT_TIMEOUT     = 1UL << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT,
-	RX_IRQ_INFO_ENTER_SLEEP_MODE = 1UL << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT,
-	RX_IRQ_INFO_EXIT_SLEEP_MODE  = 1UL << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT,
-	RX_IRQ_INFO_ECC_CORRECTED    = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT,
-	RX_IRQ_INFO_ERR_SOT          = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT,
-	RX_IRQ_INFO_ERR_SOT_SYNC     = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT,
-	RX_IRQ_INFO_ERR_CONTROL      = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT,
-	RX_IRQ_INFO_ERR_ECC_DOUBLE   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT,
+	RX_IRQ_INFO_BUFFER_OVERRUN = 1UL << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT,
+	RX_IRQ_INFO_INIT_TIMEOUT = 1UL
+				   << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT,
+	RX_IRQ_INFO_ENTER_SLEEP_MODE =
+		1UL << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT,
+	RX_IRQ_INFO_EXIT_SLEEP_MODE =
+		1UL << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT,
+	RX_IRQ_INFO_ECC_CORRECTED =
+		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT,
+	RX_IRQ_INFO_ERR_SOT = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT,
+	RX_IRQ_INFO_ERR_SOT_SYNC = 1UL
+				   << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT,
+	RX_IRQ_INFO_ERR_CONTROL = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT,
+	RX_IRQ_INFO_ERR_ECC_DOUBLE =
+		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT,
 	/*	RX_IRQ_INFO_NO_ERR           = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT, */
-	RX_IRQ_INFO_ERR_CRC          = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT,
-	RX_IRQ_INFO_ERR_UNKNOWN_ID   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT,
-	RX_IRQ_INFO_ERR_FRAME_SYNC   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT,
-	RX_IRQ_INFO_ERR_FRAME_DATA   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT,
-	RX_IRQ_INFO_ERR_DATA_TIMEOUT = 1UL << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT,
-	RX_IRQ_INFO_ERR_UNKNOWN_ESC  = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT,
-	RX_IRQ_INFO_ERR_LINE_SYNC    = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT,
-}  rx_irq_info_t;
+	RX_IRQ_INFO_ERR_CRC = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT,
+	RX_IRQ_INFO_ERR_UNKNOWN_ID = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT,
+	RX_IRQ_INFO_ERR_FRAME_SYNC =
+		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT,
+	RX_IRQ_INFO_ERR_FRAME_DATA =
+		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT,
+	RX_IRQ_INFO_ERR_DATA_TIMEOUT =
+		1UL << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT,
+	RX_IRQ_INFO_ERR_UNKNOWN_ESC = 1UL
+				      << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT,
+	RX_IRQ_INFO_ERR_LINE_SYNC = 1UL
+				    << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT,
+} rx_irq_info_t;
 
 /* NOTE: The base has already an offset of 0x0100 */
 static const hrt_address __maybe_unused MIPI_PORT_OFFSET[N_MIPI_PORT_ID] = {
-	0x00000000UL,
-	0x00000100UL,
-	0x00000200UL
+	0x00000000UL, 0x00000100UL, 0x00000200UL
 };
 
 static const hrt_address __maybe_unused SUB_SYSTEM_OFFSET[N_SUB_SYSTEM_ID] = {
-	0x00001000UL,
-	0x00002000UL,
-	0x00003000UL,
-	0x00004000UL,
-	0x00005000UL,
-	0x00009000UL,
-	0x0000A000UL,
-	0x0000B000UL,
-	0x0000C000UL
+	0x00001000UL, 0x00002000UL, 0x00003000UL, 0x00004000UL, 0x00005000UL,
+	0x00009000UL, 0x0000A000UL, 0x0000B000UL, 0x0000C000UL
 };
 
 #endif /* __INPUT_SYSTEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/isp2400_input_system_private.h b/drivers/staging/media/atomisp/pci/isp2400_input_system_private.h
index a6762683a0ac5f94a1715ad7d054b4698d231998..d7923f451e5364e0adab8ed1a0133608f02bcff9 100644
--- a/drivers/staging/media/atomisp/pci/isp2400_input_system_private.h
+++ b/drivers/staging/media/atomisp/pci/isp2400_input_system_private.h
@@ -13,32 +13,29 @@
 
 #include "assert_support.h"
 
-STORAGE_CLASS_INPUT_SYSTEM_C void input_system_reg_store(
-    const input_system_ID_t			ID,
-    const hrt_address			reg,
-    const hrt_data				value)
+STORAGE_CLASS_INPUT_SYSTEM_C void
+input_system_reg_store(const input_system_ID_t ID, const hrt_address reg,
+		       const hrt_data value)
 {
 	assert(ID < N_INPUT_SYSTEM_ID);
 	assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
-	ia_css_device_store_uint32(INPUT_SYSTEM_BASE[ID] + reg * sizeof(hrt_data),
-				   value);
+	ia_css_device_store_uint32(
+		INPUT_SYSTEM_BASE[ID] + reg * sizeof(hrt_data), value);
 	return;
 }
 
-STORAGE_CLASS_INPUT_SYSTEM_C hrt_data input_system_reg_load(
-    const input_system_ID_t			ID,
-    const hrt_address			reg)
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data
+input_system_reg_load(const input_system_ID_t ID, const hrt_address reg)
 {
 	assert(ID < N_INPUT_SYSTEM_ID);
 	assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
-	return ia_css_device_load_uint32(INPUT_SYSTEM_BASE[ID] + reg * sizeof(
-					     hrt_data));
+	return ia_css_device_load_uint32(INPUT_SYSTEM_BASE[ID] +
+					 reg * sizeof(hrt_data));
 }
 
-STORAGE_CLASS_INPUT_SYSTEM_C void receiver_reg_store(
-    const rx_ID_t				ID,
-    const hrt_address			reg,
-    const hrt_data				value)
+STORAGE_CLASS_INPUT_SYSTEM_C void receiver_reg_store(const rx_ID_t ID,
+						     const hrt_address reg,
+						     const hrt_data value)
 {
 	assert(ID < N_RX_ID);
 	assert(RX_BASE[ID] != (hrt_address)-1);
@@ -46,69 +43,68 @@ STORAGE_CLASS_INPUT_SYSTEM_C void receiver_reg_store(
 	return;
 }
 
-STORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_reg_load(
-    const rx_ID_t				ID,
-    const hrt_address			reg)
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_reg_load(const rx_ID_t ID,
+							const hrt_address reg)
 {
 	assert(ID < N_RX_ID);
 	assert(RX_BASE[ID] != (hrt_address)-1);
 	return ia_css_device_load_uint32(RX_BASE[ID] + reg * sizeof(hrt_data));
 }
 
-STORAGE_CLASS_INPUT_SYSTEM_C void receiver_port_reg_store(
-    const rx_ID_t				ID,
-    const enum mipi_port_id			port_ID,
-    const hrt_address			reg,
-    const hrt_data				value)
+STORAGE_CLASS_INPUT_SYSTEM_C void
+receiver_port_reg_store(const rx_ID_t ID, const enum mipi_port_id port_ID,
+			const hrt_address reg, const hrt_data value)
 {
 	assert(ID < N_RX_ID);
 	assert(port_ID < N_MIPI_PORT_ID);
 	assert(RX_BASE[ID] != (hrt_address)-1);
 	assert(MIPI_PORT_OFFSET[port_ID] != (hrt_address)-1);
-	ia_css_device_store_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] + reg *
-				   sizeof(hrt_data), value);
+	ia_css_device_store_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] +
+					   reg * sizeof(hrt_data),
+				   value);
 	return;
 }
 
-STORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_port_reg_load(
-    const rx_ID_t				ID,
-    const enum mipi_port_id			port_ID,
-    const hrt_address			reg)
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data
+receiver_port_reg_load(const rx_ID_t ID, const enum mipi_port_id port_ID,
+		       const hrt_address reg)
 {
 	assert(ID < N_RX_ID);
 	assert(port_ID < N_MIPI_PORT_ID);
 	assert(RX_BASE[ID] != (hrt_address)-1);
 	assert(MIPI_PORT_OFFSET[port_ID] != (hrt_address)-1);
-	return ia_css_device_load_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] + reg *
-					 sizeof(hrt_data));
+	return ia_css_device_load_uint32(RX_BASE[ID] +
+					 MIPI_PORT_OFFSET[port_ID] +
+					 reg * sizeof(hrt_data));
 }
 
-STORAGE_CLASS_INPUT_SYSTEM_C void input_system_sub_system_reg_store(
-    const input_system_ID_t			ID,
-    const sub_system_ID_t			sub_ID,
-    const hrt_address			reg,
-    const hrt_data				value)
+STORAGE_CLASS_INPUT_SYSTEM_C void
+input_system_sub_system_reg_store(const input_system_ID_t ID,
+				  const sub_system_ID_t sub_ID,
+				  const hrt_address reg, const hrt_data value)
 {
 	assert(ID < N_INPUT_SYSTEM_ID);
 	assert(sub_ID < N_SUB_SYSTEM_ID);
 	assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
 	assert(SUB_SYSTEM_OFFSET[sub_ID] != (hrt_address)-1);
-	ia_css_device_store_uint32(INPUT_SYSTEM_BASE[ID] + SUB_SYSTEM_OFFSET[sub_ID] +
-				   reg * sizeof(hrt_data), value);
+	ia_css_device_store_uint32(INPUT_SYSTEM_BASE[ID] +
+					   SUB_SYSTEM_OFFSET[sub_ID] +
+					   reg * sizeof(hrt_data),
+				   value);
 	return;
 }
 
 STORAGE_CLASS_INPUT_SYSTEM_C hrt_data input_system_sub_system_reg_load(
-    const input_system_ID_t			ID,
-    const sub_system_ID_t			sub_ID,
-    const hrt_address			reg)
+	const input_system_ID_t ID, const sub_system_ID_t sub_ID,
+	const hrt_address reg)
 {
 	assert(ID < N_INPUT_SYSTEM_ID);
 	assert(sub_ID < N_SUB_SYSTEM_ID);
 	assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
 	assert(SUB_SYSTEM_OFFSET[sub_ID] != (hrt_address)-1);
 	return ia_css_device_load_uint32(INPUT_SYSTEM_BASE[ID] +
-					 SUB_SYSTEM_OFFSET[sub_ID] + reg * sizeof(hrt_data));
+					 SUB_SYSTEM_OFFSET[sub_ID] +
+					 reg * sizeof(hrt_data));
 }
 
 #endif /* __INPUT_SYSTEM_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/isp2400_input_system_public.h b/drivers/staging/media/atomisp/pci/isp2400_input_system_public.h
index 2147929392e16ef0ddf4687c39fb24c2cd9c461a..d81ae5e98299143c99a4c2df955353f727557859 100644
--- a/drivers/staging/media/atomisp/pci/isp2400_input_system_public.h
+++ b/drivers/staging/media/atomisp/pci/isp2400_input_system_public.h
@@ -22,11 +22,9 @@
 
  \return none, RECEIVER[ID].cfg[cfg_ID] = {comp, pred}
  */
-void receiver_set_compression(
-    const rx_ID_t				ID,
-    const unsigned int			cfg_ID,
-    const mipi_compressor_t		comp,
-    const mipi_predictor_t		pred);
+void receiver_set_compression(const rx_ID_t ID, const unsigned int cfg_ID,
+			      const mipi_compressor_t comp,
+			      const mipi_predictor_t pred);
 
 /*! Enable PORT[port_ID] of RECEIVER[ID]
 
@@ -36,10 +34,8 @@ void receiver_set_compression(
 
  \return None, enable(RECEIVER[ID].PORT[port_ID])
  */
-void receiver_port_enable(
-    const rx_ID_t				ID,
-    const enum mipi_port_id		port_ID,
-    const bool					cnd);
+void receiver_port_enable(const rx_ID_t ID, const enum mipi_port_id port_ID,
+			  const bool cnd);
 
 /*! Flag if PORT[port_ID] of RECEIVER[ID] is enabled
 
@@ -48,9 +44,8 @@ void receiver_port_enable(
 
  \return enable(RECEIVER[ID].PORT[port_ID]) == true
  */
-bool is_receiver_port_enabled(
-    const rx_ID_t				ID,
-    const enum mipi_port_id		port_ID);
+bool is_receiver_port_enabled(const rx_ID_t ID,
+			      const enum mipi_port_id port_ID);
 
 /*! Enable the IRQ channels of PORT[port_ID] of RECEIVER[ID]
 
@@ -60,10 +55,8 @@ bool is_receiver_port_enabled(
 
  \return None, enable(RECEIVER[ID].PORT[port_ID].irq_info)
  */
-void receiver_irq_enable(
-    const rx_ID_t				ID,
-    const enum mipi_port_id		port_ID,
-    const rx_irq_info_t			irq_info);
+void receiver_irq_enable(const rx_ID_t ID, const enum mipi_port_id port_ID,
+			 const rx_irq_info_t irq_info);
 
 /*! Return the IRQ status of PORT[port_ID] of RECEIVER[ID]
 
@@ -72,9 +65,8 @@ void receiver_irq_enable(
 
  \return RECEIVER[ID].PORT[port_ID].irq_info
  */
-rx_irq_info_t receiver_get_irq_info(
-    const rx_ID_t				ID,
-    const enum mipi_port_id		port_ID);
+rx_irq_info_t receiver_get_irq_info(const rx_ID_t ID,
+				    const enum mipi_port_id port_ID);
 
 /*! Clear the IRQ status of PORT[port_ID] of RECEIVER[ID]
 
@@ -84,10 +76,8 @@ rx_irq_info_t receiver_get_irq_info(
 
  \return None, clear(RECEIVER[ID].PORT[port_ID].irq_info)
  */
-void receiver_irq_clear(
-    const rx_ID_t				ID,
-    const enum mipi_port_id			port_ID,
-    const rx_irq_info_t			irq_info);
+void receiver_irq_clear(const rx_ID_t ID, const enum mipi_port_id port_ID,
+			const rx_irq_info_t irq_info);
 
 /*! Write to a control register of INPUT_SYSTEM[ID]
 
@@ -97,10 +87,9 @@ void receiver_irq_clear(
 
  \return none, INPUT_SYSTEM[ID].ctrl[reg] = value
  */
-STORAGE_CLASS_INPUT_SYSTEM_H void input_system_reg_store(
-    const input_system_ID_t			ID,
-    const hrt_address			reg,
-    const hrt_data				value);
+STORAGE_CLASS_INPUT_SYSTEM_H void
+input_system_reg_store(const input_system_ID_t ID, const hrt_address reg,
+		       const hrt_data value);
 
 /*! Read from a control register of INPUT_SYSTEM[ID]
 
@@ -110,9 +99,8 @@ STORAGE_CLASS_INPUT_SYSTEM_H void input_system_reg_store(
 
  \return INPUT_SYSTEM[ID].ctrl[reg]
  */
-STORAGE_CLASS_INPUT_SYSTEM_H hrt_data input_system_reg_load(
-    const input_system_ID_t			ID,
-    const hrt_address			reg);
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data
+input_system_reg_load(const input_system_ID_t ID, const hrt_address reg);
 
 /*! Write to a control register of RECEIVER[ID]
 
@@ -122,10 +110,9 @@ STORAGE_CLASS_INPUT_SYSTEM_H hrt_data input_system_reg_load(
 
  \return none, RECEIVER[ID].ctrl[reg] = value
  */
-STORAGE_CLASS_INPUT_SYSTEM_H void receiver_reg_store(
-    const rx_ID_t				ID,
-    const hrt_address			reg,
-    const hrt_data				value);
+STORAGE_CLASS_INPUT_SYSTEM_H void receiver_reg_store(const rx_ID_t ID,
+						     const hrt_address reg,
+						     const hrt_data value);
 
 /*! Read from a control register of RECEIVER[ID]
 
@@ -135,9 +122,8 @@ STORAGE_CLASS_INPUT_SYSTEM_H void receiver_reg_store(
 
  \return RECEIVER[ID].ctrl[reg]
  */
-STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_reg_load(
-    const rx_ID_t				ID,
-    const hrt_address			reg);
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_reg_load(const rx_ID_t ID,
+							const hrt_address reg);
 
 /*! Write to a control register of PORT[port_ID] of RECEIVER[ID]
 
@@ -148,11 +134,9 @@ STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_reg_load(
 
  \return none, RECEIVER[ID].PORT[port_ID].ctrl[reg] = value
  */
-STORAGE_CLASS_INPUT_SYSTEM_H void receiver_port_reg_store(
-    const rx_ID_t				ID,
-    const enum mipi_port_id			port_ID,
-    const hrt_address			reg,
-    const hrt_data				value);
+STORAGE_CLASS_INPUT_SYSTEM_H void
+receiver_port_reg_store(const rx_ID_t ID, const enum mipi_port_id port_ID,
+			const hrt_address reg, const hrt_data value);
 
 /*! Read from a control register PORT[port_ID] of RECEIVER[ID]
 
@@ -163,10 +147,9 @@ STORAGE_CLASS_INPUT_SYSTEM_H void receiver_port_reg_store(
 
  \return RECEIVER[ID].PORT[port_ID].ctrl[reg]
  */
-STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_port_reg_load(
-    const rx_ID_t				ID,
-    const enum mipi_port_id		port_ID,
-    const hrt_address			reg);
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data
+receiver_port_reg_load(const rx_ID_t ID, const enum mipi_port_id port_ID,
+		       const hrt_address reg);
 
 /*! Write to a control register of SUB_SYSTEM[sub_ID] of INPUT_SYSTEM[ID]
 
@@ -177,11 +160,10 @@ STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_port_reg_load(
 
  \return none, INPUT_SYSTEM[ID].SUB_SYSTEM[sub_ID].ctrl[reg] = value
  */
-STORAGE_CLASS_INPUT_SYSTEM_H void input_system_sub_system_reg_store(
-    const input_system_ID_t			ID,
-    const sub_system_ID_t			sub_ID,
-    const hrt_address			reg,
-    const hrt_data				value);
+STORAGE_CLASS_INPUT_SYSTEM_H void
+input_system_sub_system_reg_store(const input_system_ID_t ID,
+				  const sub_system_ID_t sub_ID,
+				  const hrt_address reg, const hrt_data value);
 
 /*! Read from a control register SUB_SYSTEM[sub_ID] of INPUT_SYSTEM[ID]
 
@@ -193,9 +175,8 @@ STORAGE_CLASS_INPUT_SYSTEM_H void input_system_sub_system_reg_store(
  \return INPUT_SYSTEM[ID].SUB_SYSTEM[sub_ID].ctrl[reg]
  */
 STORAGE_CLASS_INPUT_SYSTEM_H hrt_data input_system_sub_system_reg_load(
-    const input_system_ID_t		ID,
-    const sub_system_ID_t		sub_ID,
-    const hrt_address			reg);
+	const input_system_ID_t ID, const sub_system_ID_t sub_ID,
+	const hrt_address reg);
 
 ///////////////////////////////////////////////////////////////////////////
 //
@@ -223,86 +204,52 @@ input_system_err_t input_system_configuration_commit(void);
 
 // FIFO channel config function user
 
-input_system_err_t	input_system_csi_fifo_channel_cfg(
-    u32				ch_id,
-    input_system_csi_port_t	port,
-    backend_channel_cfg_t	backend_ch,
-    target_cfg2400_t			target
-);
-
-input_system_err_t	input_system_csi_fifo_channel_with_counting_cfg(
-    u32				ch_id,
-    u32				nof_frame,
-    input_system_csi_port_t	port,
-    backend_channel_cfg_t	backend_ch,
-    u32				mem_region_size,
-    u32				nof_mem_regions,
-    target_cfg2400_t			target
-);
+input_system_err_t
+input_system_csi_fifo_channel_cfg(u32 ch_id, input_system_csi_port_t port,
+				  backend_channel_cfg_t backend_ch,
+				  target_cfg2400_t target);
+
+input_system_err_t input_system_csi_fifo_channel_with_counting_cfg(
+	u32 ch_id, u32 nof_frame, input_system_csi_port_t port,
+	backend_channel_cfg_t backend_ch, u32 mem_region_size,
+	u32 nof_mem_regions, target_cfg2400_t target);
 
 // SRAM channel config function user
 
-input_system_err_t	input_system_csi_sram_channel_cfg(
-    u32				ch_id,
-    input_system_csi_port_t	port,
-    backend_channel_cfg_t	backend_ch,
-    u32				csi_mem_region_size,
-    u32				csi_nof_mem_regions,
-    target_cfg2400_t			target
-);
+input_system_err_t input_system_csi_sram_channel_cfg(
+	u32 ch_id, input_system_csi_port_t port,
+	backend_channel_cfg_t backend_ch, u32 csi_mem_region_size,
+	u32 csi_nof_mem_regions, target_cfg2400_t target);
 
 //XMEM channel config function user
 
-input_system_err_t	input_system_csi_xmem_channel_cfg(
-    u32				ch_id,
-    input_system_csi_port_t port,
-    backend_channel_cfg_t	backend_ch,
-    u32				mem_region_size,
-    u32				nof_mem_regions,
-    u32				acq_mem_region_size,
-    u32				acq_nof_mem_regions,
-    target_cfg2400_t			target,
-    uint32_t				nof_xmem_buffers
-);
-
-input_system_err_t	input_system_csi_xmem_capture_only_channel_cfg(
-    u32				ch_id,
-    u32				nof_frames,
-    input_system_csi_port_t port,
-    u32				csi_mem_region_size,
-    u32				csi_nof_mem_regions,
-    u32				acq_mem_region_size,
-    u32				acq_nof_mem_regions,
-    target_cfg2400_t			target
-);
-
-input_system_err_t	input_system_csi_xmem_acquire_only_channel_cfg(
-    u32				ch_id,
-    u32				nof_frames,
-    input_system_csi_port_t port,
-    backend_channel_cfg_t	backend_ch,
-    u32				acq_mem_region_size,
-    u32				acq_nof_mem_regions,
-    target_cfg2400_t			target
-);
+input_system_err_t input_system_csi_xmem_channel_cfg(
+	u32 ch_id, input_system_csi_port_t port,
+	backend_channel_cfg_t backend_ch, u32 mem_region_size,
+	u32 nof_mem_regions, u32 acq_mem_region_size, u32 acq_nof_mem_regions,
+	target_cfg2400_t target, uint32_t nof_xmem_buffers);
+
+input_system_err_t input_system_csi_xmem_capture_only_channel_cfg(
+	u32 ch_id, u32 nof_frames, input_system_csi_port_t port,
+	u32 csi_mem_region_size, u32 csi_nof_mem_regions,
+	u32 acq_mem_region_size, u32 acq_nof_mem_regions,
+	target_cfg2400_t target);
+
+input_system_err_t input_system_csi_xmem_acquire_only_channel_cfg(
+	u32 ch_id, u32 nof_frames, input_system_csi_port_t port,
+	backend_channel_cfg_t backend_ch, u32 acq_mem_region_size,
+	u32 acq_nof_mem_regions, target_cfg2400_t target);
 
 // Non - CSI channel config function user
 
-input_system_err_t	input_system_prbs_channel_cfg(
-    u32		ch_id,
-    u32		nof_frames,
-    u32		seed,
-    u32		sync_gen_width,
-    u32		sync_gen_height,
-    u32		sync_gen_hblank_cycles,
-    u32		sync_gen_vblank_cycles,
-    target_cfg2400_t	target
-);
-
-input_system_err_t	input_system_gpfifo_channel_cfg(
-    u32		ch_id,
-    u32		nof_frames,
-    target_cfg2400_t	target
-);
+input_system_err_t input_system_prbs_channel_cfg(u32 ch_id, u32 nof_frames,
+						 u32 seed, u32 sync_gen_width,
+						 u32 sync_gen_height,
+						 u32 sync_gen_hblank_cycles,
+						 u32 sync_gen_vblank_cycles,
+						 target_cfg2400_t target);
+
+input_system_err_t input_system_gpfifo_channel_cfg(u32 ch_id, u32 nof_frames,
+						   target_cfg2400_t target);
 
 #endif /* __INPUT_SYSTEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/isp2400_support.h b/drivers/staging/media/atomisp/pci/isp2400_support.h
index 6e0b563c6c485d42b1b58286911792a6c052970d..68bce33a40526a40e0f9a2a1ffb69cdcc4da5a52 100644
--- a/drivers/staging/media/atomisp/pci/isp2400_support.h
+++ b/drivers/staging/media/atomisp/pci/isp2400_support.h
@@ -13,18 +13,25 @@
 typedef char *tmemvectors, *tmemvectoru, *tvector;
 #endif
 
-#define hrt_isp_vamem1_store_16(cell, addr, val) hrt_mem_store_16(cell, HRT_PROC_TYPE_PROP(cell, _simd_vamem1), addr, val)
-#define hrt_isp_vamem2_store_16(cell, addr, val) hrt_mem_store_16(cell, HRT_PROC_TYPE_PROP(cell, _simd_vamem2), addr, val)
+#define hrt_isp_vamem1_store_16(cell, addr, val)                             \
+	hrt_mem_store_16(cell, HRT_PROC_TYPE_PROP(cell, _simd_vamem1), addr, \
+			 val)
+#define hrt_isp_vamem2_store_16(cell, addr, val)                             \
+	hrt_mem_store_16(cell, HRT_PROC_TYPE_PROP(cell, _simd_vamem2), addr, \
+			 val)
 
 #define hrt_isp_dmem(cell) HRT_PROC_TYPE_PROP(cell, _base_dmem)
 #define hrt_isp_vmem(cell) HRT_PROC_TYPE_PROP(cell, _simd_vmem)
 
-#define hrt_isp_dmem_master_port_address(cell) hrt_mem_master_port_address(cell, hrt_isp_dmem(cell))
-#define hrt_isp_vmem_master_port_address(cell) hrt_mem_master_port_address(cell, hrt_isp_vmem(cell))
+#define hrt_isp_dmem_master_port_address(cell) \
+	hrt_mem_master_port_address(cell, hrt_isp_dmem(cell))
+#define hrt_isp_vmem_master_port_address(cell) \
+	hrt_mem_master_port_address(cell, hrt_isp_vmem(cell))
 
 #if ISP_HAS_HIST
 #define hrt_isp_hist(cell) HRT_PROC_TYPE_PROP(cell, _simd_histogram)
-#define hrt_isp_hist_master_port_address(cell) hrt_mem_master_port_address(cell, hrt_isp_hist(cell))
+#define hrt_isp_hist_master_port_address(cell) \
+	hrt_mem_master_port_address(cell, hrt_isp_hist(cell))
 #endif
 
 #endif /* _isp2400_support_h */
diff --git a/drivers/staging/media/atomisp/pci/isp2401_input_system_global.h b/drivers/staging/media/atomisp/pci/isp2401_input_system_global.h
index 4aadeb1336ba78b9d03978724569e5f313817cf9..d548487aa810737ccb3db0e1c46bb4494eaadde4 100644
--- a/drivers/staging/media/atomisp/pci/isp2401_input_system_global.h
+++ b/drivers/staging/media/atomisp/pci/isp2401_input_system_global.h
@@ -5,26 +5,27 @@
  */
 
 /* CSI reveiver has 3 ports. */
-#define		N_CSI_PORTS (3)
+#define N_CSI_PORTS (3)
 
 #include "system_local.h"
-#include "isys_dma_global.h"	/*	isys2401_dma_channel,
+#include "isys_dma_global.h" /*	isys2401_dma_channel,
 				 *	isys2401_dma_cfg_t
 				 */
 
-#include "ibuf_ctrl_local.h"	/*	ibuf_cfg_t,
+#include "ibuf_ctrl_local.h" /*	ibuf_cfg_t,
 				 *	ibuf_ctrl_cfg_t
 				 */
 
-#include "isys_stream2mmio.h"	/*	stream2mmio_cfg_t */
+#include "isys_stream2mmio.h" /*	stream2mmio_cfg_t */
 
-#include "csi_rx.h"		/*	csi_rx_frontend_cfg_t,
+#include "csi_rx.h" /*	csi_rx_frontend_cfg_t,
 				 *	csi_rx_backend_cfg_t,
 				 *	csi_rx_backend_lut_entry_t
 				 */
 #include "pixelgen.h"
 
-#define INPUT_SYSTEM_N_STREAM_ID  6	/* maximum number of simultaneous
+#define INPUT_SYSTEM_N_STREAM_ID \
+	6 /* maximum number of simultaneous
 					virtual channels supported*/
 
 typedef enum {
@@ -36,80 +37,80 @@ typedef enum {
 
 typedef struct input_system_channel_s input_system_channel_t;
 struct input_system_channel_s {
-	stream2mmio_ID_t	stream2mmio_id;
-	stream2mmio_sid_ID_t	stream2mmio_sid_id;
+	stream2mmio_ID_t stream2mmio_id;
+	stream2mmio_sid_ID_t stream2mmio_sid_id;
 
-	ibuf_ctrl_ID_t		ibuf_ctrl_id;
-	isp2401_ib_buffer_t	ib_buffer;
+	ibuf_ctrl_ID_t ibuf_ctrl_id;
+	isp2401_ib_buffer_t ib_buffer;
 
-	isys2401_dma_ID_t	dma_id;
-	isys2401_dma_channel	dma_channel;
+	isys2401_dma_ID_t dma_id;
+	isys2401_dma_channel dma_channel;
 };
 
 typedef struct input_system_channel_cfg_s input_system_channel_cfg_t;
 struct input_system_channel_cfg_s {
-	stream2mmio_cfg_t	stream2mmio_cfg;
-	ibuf_ctrl_cfg_t		ibuf_ctrl_cfg;
-	isys2401_dma_cfg_t	dma_cfg;
-	isys2401_dma_port_cfg_t	dma_src_port_cfg;
-	isys2401_dma_port_cfg_t	dma_dest_port_cfg;
+	stream2mmio_cfg_t stream2mmio_cfg;
+	ibuf_ctrl_cfg_t ibuf_ctrl_cfg;
+	isys2401_dma_cfg_t dma_cfg;
+	isys2401_dma_port_cfg_t dma_src_port_cfg;
+	isys2401_dma_port_cfg_t dma_dest_port_cfg;
 };
 
 typedef struct input_system_input_port_s input_system_input_port_t;
 struct input_system_input_port_s {
-	input_system_source_type_t	source_type;
+	input_system_source_type_t source_type;
 
 	struct {
-		csi_rx_frontend_ID_t		frontend_id;
-		csi_rx_backend_ID_t		backend_id;
-		csi_mipi_packet_type_t		packet_type;
-		csi_rx_backend_lut_entry_t	backend_lut_entry;
+		csi_rx_frontend_ID_t frontend_id;
+		csi_rx_backend_ID_t backend_id;
+		csi_mipi_packet_type_t packet_type;
+		csi_rx_backend_lut_entry_t backend_lut_entry;
 	} csi_rx;
 
 	struct {
-		csi_mipi_packet_type_t		packet_type;
-		csi_rx_backend_lut_entry_t	backend_lut_entry;
+		csi_mipi_packet_type_t packet_type;
+		csi_rx_backend_lut_entry_t backend_lut_entry;
 	} metadata;
 
 	struct {
-		pixelgen_ID_t			pixelgen_id;
+		pixelgen_ID_t pixelgen_id;
 	} pixelgen;
 };
 
 typedef struct input_system_input_port_cfg_s input_system_input_port_cfg_t;
 struct input_system_input_port_cfg_s {
 	struct {
-		csi_rx_frontend_cfg_t	frontend_cfg;
-		csi_rx_backend_cfg_t	backend_cfg;
-		csi_rx_backend_cfg_t	md_backend_cfg;
+		csi_rx_frontend_cfg_t frontend_cfg;
+		csi_rx_backend_cfg_t backend_cfg;
+		csi_rx_backend_cfg_t md_backend_cfg;
 	} csi_rx_cfg;
 
 	struct {
-		pixelgen_tpg_cfg_t	tpg_cfg;
-		pixelgen_prbs_cfg_t	prbs_cfg;
+		pixelgen_tpg_cfg_t tpg_cfg;
+		pixelgen_prbs_cfg_t prbs_cfg;
 	} pixelgen_cfg;
 };
 
 typedef struct isp2401_input_system_cfg_s isp2401_input_system_cfg_t;
 struct isp2401_input_system_cfg_s {
-	input_system_input_port_ID_t	input_port_id;
+	input_system_input_port_ID_t input_port_id;
 
-	input_system_source_type_t	mode;
+	input_system_source_type_t mode;
 
 	bool online;
 	bool raw_packed;
 	s8 linked_isys_stream_id;
 
 	struct {
-		bool	comp_enable;
-		s32	active_lanes;
-		s32	fmt_type;
-		s32	ch_id;
+		bool comp_enable;
+		s32 active_lanes;
+		s32 fmt_type;
+		s32 ch_id;
 		s32 comp_predictor;
 		s32 comp_scheme;
 	} csi_port_attr;
 
-	pixelgen_tpg_cfg_t	tpg_port_attr;
+	pixelgen_tpg_cfg_t tpg_port_attr;
 
 	pixelgen_prbs_cfg_t prbs_port_attr;
 
@@ -126,7 +127,7 @@ struct isp2401_input_system_cfg_s {
 	} output_port_attr;
 
 	struct {
-		bool    enable;
+		bool enable;
 		s32 fmt_type;
 		s32 align_req_in_bytes;
 		s32 bits_per_pixel;
@@ -137,13 +138,13 @@ struct isp2401_input_system_cfg_s {
 
 typedef struct virtual_input_system_stream_s virtual_input_system_stream_t;
 struct virtual_input_system_stream_s {
-	u32 id;				/*Used when multiple MIPI data types and/or virtual channels are used.
+	u32 id; /*Used when multiple MIPI data types and/or virtual channels are used.
 								Must be unique within one CSI RX
 								and lower than SH_CSS_MAX_ISYS_CHANNEL_NODES */
 	u8 enable_metadata;
-	input_system_input_port_t	input_port;
-	input_system_channel_t		channel;
-	input_system_channel_t		md_channel; /* metadata channel */
+	input_system_input_port_t input_port;
+	input_system_channel_t channel;
+	input_system_channel_t md_channel; /* metadata channel */
 	u8 online;
 	s8 linked_isys_stream_id;
 	u8 valid;
@@ -153,14 +154,14 @@ typedef struct virtual_input_system_stream_cfg_s
 	virtual_input_system_stream_cfg_t;
 struct virtual_input_system_stream_cfg_s {
 	u8 enable_metadata;
-	input_system_input_port_cfg_t	input_port_cfg;
-	input_system_channel_cfg_t	channel_cfg;
-	input_system_channel_cfg_t	md_channel_cfg;
+	input_system_input_port_cfg_t input_port_cfg;
+	input_system_channel_cfg_t channel_cfg;
+	input_system_channel_cfg_t md_channel_cfg;
 	u8 valid;
 };
 
-#define ISP_INPUT_BUF_START_ADDR	0
-#define NUM_OF_INPUT_BUF		2
-#define NUM_OF_LINES_PER_BUF		2
-#define LINES_OF_ISP_INPUT_BUF		(NUM_OF_INPUT_BUF * NUM_OF_LINES_PER_BUF)
-#define ISP_INPUT_BUF_STRIDE		SH_CSS_MAX_SENSOR_WIDTH
+#define ISP_INPUT_BUF_START_ADDR 0
+#define NUM_OF_INPUT_BUF 2
+#define NUM_OF_LINES_PER_BUF 2
+#define LINES_OF_ISP_INPUT_BUF (NUM_OF_INPUT_BUF * NUM_OF_LINES_PER_BUF)
+#define ISP_INPUT_BUF_STRIDE SH_CSS_MAX_SENSOR_WIDTH
diff --git a/drivers/staging/media/atomisp/pci/isp2401_input_system_local.h b/drivers/staging/media/atomisp/pci/isp2401_input_system_local.h
index 50e58553075040cdfcc227285fa2f37102c29e7d..6b545f6a12136112540ab84bc3176ac1e06304bd 100644
--- a/drivers/staging/media/atomisp/pci/isp2401_input_system_local.h
+++ b/drivers/staging/media/atomisp/pci/isp2401_input_system_local.h
@@ -53,9 +53,9 @@ typedef enum {
 	N_MIPI_FORMAT_2401
 } mipi_format_2401_t;
 
-#define N_MIPI_FORMAT_CUSTOM	8
+#define N_MIPI_FORMAT_CUSTOM 8
 
 /* The number of stores for compressed format types */
-#define	N_MIPI_COMPRESSOR_CONTEXT	(N_RX_CHANNEL_ID * N_MIPI_FORMAT_CUSTOM)
+#define N_MIPI_COMPRESSOR_CONTEXT (N_RX_CHANNEL_ID * N_MIPI_FORMAT_CUSTOM)
 
 #endif /* __INPUT_SYSTEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/isp2401_input_system_private.h b/drivers/staging/media/atomisp/pci/isp2401_input_system_private.h
index 36ae5445fdb41858e19e9f83d4002bd22749bf86..a00d06db87cfa41029d1dd87d75d75238c121446 100644
--- a/drivers/staging/media/atomisp/pci/isp2401_input_system_private.h
+++ b/drivers/staging/media/atomisp/pci/isp2401_input_system_private.h
@@ -9,7 +9,7 @@
 
 #include "input_system_public.h"
 
-#include "device_access.h"	/* ia_css_device_load_uint32 */
+#include "device_access.h" /* ia_css_device_load_uint32 */
 
 #include "assert_support.h" /* assert */
 #include "print_support.h" /* print */
@@ -20,7 +20,8 @@ static inline hrt_data ibuf_ctrl_reg_load(const ibuf_ctrl_ID_t ID,
 {
 	assert(ID < N_IBUF_CTRL_ID);
 	assert(IBUF_CTRL_BASE[ID] != (hrt_address)-1);
-	return ia_css_device_load_uint32(IBUF_CTRL_BASE[ID] + reg * sizeof(hrt_data));
+	return ia_css_device_load_uint32(IBUF_CTRL_BASE[ID] +
+					 reg * sizeof(hrt_data));
 }
 
 /* Store a value to the register */
@@ -31,7 +32,8 @@ static inline void ibuf_ctrl_reg_store(const ibuf_ctrl_ID_t ID,
 	assert(ID < N_IBUF_CTRL_ID);
 	assert(IBUF_CTRL_BASE[ID] != (hrt_address)-1);
 
-	ia_css_device_store_uint32(IBUF_CTRL_BASE[ID] + reg * sizeof(hrt_data), value);
+	ia_css_device_store_uint32(IBUF_CTRL_BASE[ID] + reg * sizeof(hrt_data),
+				   value);
 }
 
 /* Get the state of the ibuf-controller process */
@@ -41,86 +43,85 @@ static inline void ibuf_ctrl_get_proc_state(const ibuf_ctrl_ID_t ID,
 {
 	hrt_address reg_bank_offset;
 
-	reg_bank_offset =
-	    _IBUF_CNTRL_PROC_REG_ALIGN * (1 + proc_id);
+	reg_bank_offset = _IBUF_CNTRL_PROC_REG_ALIGN * (1 + proc_id);
 
-	state->num_items =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_NUM_ITEMS_PER_STORE);
+	state->num_items = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_NUM_ITEMS_PER_STORE);
 
-	state->num_stores =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_NUM_STORES_PER_FRAME);
+	state->num_stores = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_NUM_STORES_PER_FRAME);
 
-	state->dma_channel =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_DMA_CHANNEL);
+	state->dma_channel = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_DMA_CHANNEL);
 
 	state->dma_command =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_DMA_CMD);
+		ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_DMA_CMD);
 
-	state->ibuf_st_addr =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_BUFFER_START_ADDRESS);
+	state->ibuf_st_addr = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_BUFFER_START_ADDRESS);
 
-	state->ibuf_stride =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_BUFFER_STRIDE);
+	state->ibuf_stride = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_BUFFER_STRIDE);
 
-	state->ibuf_end_addr =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_BUFFER_END_ADDRESS);
+	state->ibuf_end_addr = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_BUFFER_END_ADDRESS);
 
-	state->dest_st_addr =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_DEST_START_ADDRESS);
+	state->dest_st_addr = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_DEST_START_ADDRESS);
 
-	state->dest_stride =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_DEST_STRIDE);
+	state->dest_stride = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_DEST_STRIDE);
 
-	state->dest_end_addr =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_DEST_END_ADDRESS);
+	state->dest_end_addr = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_DEST_END_ADDRESS);
 
-	state->sync_frame =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_SYNC_FRAME);
+	state->sync_frame = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_SYNC_FRAME);
 
-	state->sync_command =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_STR2MMIO_SYNC_CMD);
+	state->sync_command = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_STR2MMIO_SYNC_CMD);
 
-	state->store_command =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_STR2MMIO_STORE_CMD);
+	state->store_command = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_STR2MMIO_STORE_CMD);
 
-	state->shift_returned_items =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_SHIFT_ITEMS);
+	state->shift_returned_items = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_SHIFT_ITEMS);
 
-	state->elems_ibuf =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_ELEMS_P_WORD_IBUF);
+	state->elems_ibuf = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_ELEMS_P_WORD_IBUF);
 
-	state->elems_dest =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_ELEMS_P_WORD_DEST);
+	state->elems_dest = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_ELEMS_P_WORD_DEST);
 
-	state->cur_stores =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_CUR_STORES);
+	state->cur_stores = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_CUR_STORES);
 
 	state->cur_acks =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_CUR_ACKS);
+		ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_CUR_ACKS);
 
-	state->cur_s2m_ibuf_addr =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_CUR_S2M_IBUF_ADDR);
+	state->cur_s2m_ibuf_addr = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_CUR_S2M_IBUF_ADDR);
 
-	state->cur_dma_ibuf_addr =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_CUR_DMA_IBUF_ADDR);
+	state->cur_dma_ibuf_addr = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_CUR_DMA_IBUF_ADDR);
 
-	state->cur_dma_dest_addr =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_CUR_DMA_DEST_ADDR);
+	state->cur_dma_dest_addr = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_CUR_DMA_DEST_ADDR);
 
-	state->cur_isp_dest_addr =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_CUR_ISP_DEST_ADDR);
+	state->cur_isp_dest_addr = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_CUR_ISP_DEST_ADDR);
 
-	state->dma_cmds_send =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_CUR_NR_DMA_CMDS_SEND);
+	state->dma_cmds_send = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_CUR_NR_DMA_CMDS_SEND);
 
-	state->main_cntrl_state =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_MAIN_CNTRL_STATE);
+	state->main_cntrl_state = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_MAIN_CNTRL_STATE);
 
-	state->dma_sync_state =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_DMA_SYNC_STATE);
+	state->dma_sync_state = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_DMA_SYNC_STATE);
 
-	state->isp_sync_state =
-	    ibuf_ctrl_reg_load(ID, reg_bank_offset + _IBUF_CNTRL_ISP_SYNC_STATE);
+	state->isp_sync_state = ibuf_ctrl_reg_load(
+		ID, reg_bank_offset + _IBUF_CNTRL_ISP_SYNC_STATE);
 }
 
 /* Get the ibuf-controller state. */
@@ -130,19 +131,15 @@ static inline void ibuf_ctrl_get_state(const ibuf_ctrl_ID_t ID,
 	u32 i;
 
 	state->recalc_words =
-	    ibuf_ctrl_reg_load(ID, _IBUF_CNTRL_RECALC_WORDS_STATUS);
-	state->arbiters =
-	    ibuf_ctrl_reg_load(ID, _IBUF_CNTRL_ARBITERS_STATUS);
+		ibuf_ctrl_reg_load(ID, _IBUF_CNTRL_RECALC_WORDS_STATUS);
+	state->arbiters = ibuf_ctrl_reg_load(ID, _IBUF_CNTRL_ARBITERS_STATUS);
 
 	/*
 	 * Get the values of the register-set per
 	 * ibuf-controller process.
 	 */
 	for (i = 0; i < N_IBUF_CTRL_PROCS[ID]; i++) {
-		ibuf_ctrl_get_proc_state(
-		    ID,
-		    i,
-		    &state->proc_state[i]);
+		ibuf_ctrl_get_proc_state(ID, i, &state->proc_state[i]);
 	}
 }
 
@@ -154,71 +151,92 @@ static inline void ibuf_ctrl_dump_state(const ibuf_ctrl_ID_t ID,
 
 	ia_css_print("IBUF controller ID %d recalculate words 0x%x\n", ID,
 		     state->recalc_words);
-	ia_css_print("IBUF controller ID %d arbiters 0x%x\n", ID, state->arbiters);
+	ia_css_print("IBUF controller ID %d arbiters 0x%x\n", ID,
+		     state->arbiters);
 
 	/*
 	 * Dump the values of the register-set per
 	 * ibuf-controller process.
 	 */
 	for (i = 0; i < N_IBUF_CTRL_PROCS[ID]; i++) {
-		ia_css_print("IBUF controller ID %d Process ID %d num_items 0x%x\n", ID, i,
-			     state->proc_state[i].num_items);
-		ia_css_print("IBUF controller ID %d Process ID %d num_stores 0x%x\n", ID, i,
-			     state->proc_state[i].num_stores);
-		ia_css_print("IBUF controller ID %d Process ID %d dma_channel 0x%x\n", ID, i,
-			     state->proc_state[i].dma_channel);
-		ia_css_print("IBUF controller ID %d Process ID %d dma_command 0x%x\n", ID, i,
-			     state->proc_state[i].dma_command);
-		ia_css_print("IBUF controller ID %d Process ID %d ibuf_st_addr 0x%x\n", ID, i,
-			     state->proc_state[i].ibuf_st_addr);
-		ia_css_print("IBUF controller ID %d Process ID %d ibuf_stride 0x%x\n", ID, i,
-			     state->proc_state[i].ibuf_stride);
-		ia_css_print("IBUF controller ID %d Process ID %d ibuf_end_addr 0x%x\n", ID, i,
-			     state->proc_state[i].ibuf_end_addr);
-		ia_css_print("IBUF controller ID %d Process ID %d dest_st_addr 0x%x\n", ID, i,
-			     state->proc_state[i].dest_st_addr);
-		ia_css_print("IBUF controller ID %d Process ID %d dest_stride 0x%x\n", ID, i,
-			     state->proc_state[i].dest_stride);
-		ia_css_print("IBUF controller ID %d Process ID %d dest_end_addr 0x%x\n", ID, i,
-			     state->proc_state[i].dest_end_addr);
-		ia_css_print("IBUF controller ID %d Process ID %d sync_frame 0x%x\n", ID, i,
-			     state->proc_state[i].sync_frame);
-		ia_css_print("IBUF controller ID %d Process ID %d sync_command 0x%x\n", ID, i,
-			     state->proc_state[i].sync_command);
-		ia_css_print("IBUF controller ID %d Process ID %d store_command 0x%x\n", ID, i,
-			     state->proc_state[i].store_command);
-		ia_css_print("IBUF controller ID %d Process ID %d shift_returned_items 0x%x\n",
-			     ID, i,
-			     state->proc_state[i].shift_returned_items);
-		ia_css_print("IBUF controller ID %d Process ID %d elems_ibuf 0x%x\n", ID, i,
-			     state->proc_state[i].elems_ibuf);
-		ia_css_print("IBUF controller ID %d Process ID %d elems_dest 0x%x\n", ID, i,
-			     state->proc_state[i].elems_dest);
-		ia_css_print("IBUF controller ID %d Process ID %d cur_stores 0x%x\n", ID, i,
-			     state->proc_state[i].cur_stores);
-		ia_css_print("IBUF controller ID %d Process ID %d cur_acks 0x%x\n", ID, i,
-			     state->proc_state[i].cur_acks);
-		ia_css_print("IBUF controller ID %d Process ID %d cur_s2m_ibuf_addr 0x%x\n", ID,
-			     i,
-			     state->proc_state[i].cur_s2m_ibuf_addr);
-		ia_css_print("IBUF controller ID %d Process ID %d cur_dma_ibuf_addr 0x%x\n", ID,
-			     i,
-			     state->proc_state[i].cur_dma_ibuf_addr);
-		ia_css_print("IBUF controller ID %d Process ID %d cur_dma_dest_addr 0x%x\n", ID,
-			     i,
-			     state->proc_state[i].cur_dma_dest_addr);
-		ia_css_print("IBUF controller ID %d Process ID %d cur_isp_dest_addr 0x%x\n", ID,
-			     i,
-			     state->proc_state[i].cur_isp_dest_addr);
-		ia_css_print("IBUF controller ID %d Process ID %d dma_cmds_send 0x%x\n", ID, i,
-			     state->proc_state[i].dma_cmds_send);
-		ia_css_print("IBUF controller ID %d Process ID %d main_cntrl_state 0x%x\n", ID,
-			     i,
-			     state->proc_state[i].main_cntrl_state);
-		ia_css_print("IBUF controller ID %d Process ID %d dma_sync_state 0x%x\n", ID, i,
-			     state->proc_state[i].dma_sync_state);
-		ia_css_print("IBUF controller ID %d Process ID %d isp_sync_state 0x%x\n", ID, i,
-			     state->proc_state[i].isp_sync_state);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d num_items 0x%x\n",
+			ID, i, state->proc_state[i].num_items);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d num_stores 0x%x\n",
+			ID, i, state->proc_state[i].num_stores);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d dma_channel 0x%x\n",
+			ID, i, state->proc_state[i].dma_channel);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d dma_command 0x%x\n",
+			ID, i, state->proc_state[i].dma_command);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d ibuf_st_addr 0x%x\n",
+			ID, i, state->proc_state[i].ibuf_st_addr);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d ibuf_stride 0x%x\n",
+			ID, i, state->proc_state[i].ibuf_stride);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d ibuf_end_addr 0x%x\n",
+			ID, i, state->proc_state[i].ibuf_end_addr);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d dest_st_addr 0x%x\n",
+			ID, i, state->proc_state[i].dest_st_addr);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d dest_stride 0x%x\n",
+			ID, i, state->proc_state[i].dest_stride);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d dest_end_addr 0x%x\n",
+			ID, i, state->proc_state[i].dest_end_addr);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d sync_frame 0x%x\n",
+			ID, i, state->proc_state[i].sync_frame);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d sync_command 0x%x\n",
+			ID, i, state->proc_state[i].sync_command);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d store_command 0x%x\n",
+			ID, i, state->proc_state[i].store_command);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d shift_returned_items 0x%x\n",
+			ID, i, state->proc_state[i].shift_returned_items);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d elems_ibuf 0x%x\n",
+			ID, i, state->proc_state[i].elems_ibuf);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d elems_dest 0x%x\n",
+			ID, i, state->proc_state[i].elems_dest);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d cur_stores 0x%x\n",
+			ID, i, state->proc_state[i].cur_stores);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d cur_acks 0x%x\n",
+			ID, i, state->proc_state[i].cur_acks);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d cur_s2m_ibuf_addr 0x%x\n",
+			ID, i, state->proc_state[i].cur_s2m_ibuf_addr);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d cur_dma_ibuf_addr 0x%x\n",
+			ID, i, state->proc_state[i].cur_dma_ibuf_addr);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d cur_dma_dest_addr 0x%x\n",
+			ID, i, state->proc_state[i].cur_dma_dest_addr);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d cur_isp_dest_addr 0x%x\n",
+			ID, i, state->proc_state[i].cur_isp_dest_addr);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d dma_cmds_send 0x%x\n",
+			ID, i, state->proc_state[i].dma_cmds_send);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d main_cntrl_state 0x%x\n",
+			ID, i, state->proc_state[i].main_cntrl_state);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d dma_sync_state 0x%x\n",
+			ID, i, state->proc_state[i].dma_sync_state);
+		ia_css_print(
+			"IBUF controller ID %d Process ID %d isp_sync_state 0x%x\n",
+			ID, i, state->proc_state[i].isp_sync_state);
 	}
 }
 
diff --git a/drivers/staging/media/atomisp/pci/isp_acquisition_defs.h b/drivers/staging/media/atomisp/pci/isp_acquisition_defs.h
index b04404ad59d94812e1994768ea8d4ce19e70d7d7..7b2c86a5e271d99803c985c3f98b78bf2befb848 100644
--- a/drivers/staging/media/atomisp/pci/isp_acquisition_defs.h
+++ b/drivers/staging/media/atomisp/pci/isp_acquisition_defs.h
@@ -7,214 +7,257 @@
 #ifndef _isp_acquisition_defs_h
 #define _isp_acquisition_defs_h
 
-#define _ISP_ACQUISITION_REG_ALIGN                4  /* assuming 32 bit control bus width */
-#define _ISP_ACQUISITION_BYTES_PER_ELEM           4
+#define _ISP_ACQUISITION_REG_ALIGN 4 /* assuming 32 bit control bus width */
+#define _ISP_ACQUISITION_BYTES_PER_ELEM 4
 
 /* --------------------------------------------------*/
 
-#define NOF_ACQ_IRQS                              1
+#define NOF_ACQ_IRQS 1
 
 /* --------------------------------------------------*/
 /* FSM */
 /* --------------------------------------------------*/
-#define MEM2STREAM_FSM_STATE_BITS                 2
-#define ACQ_SYNCHRONIZER_FSM_STATE_BITS           2
+#define MEM2STREAM_FSM_STATE_BITS 2
+#define ACQ_SYNCHRONIZER_FSM_STATE_BITS 2
 
 /* --------------------------------------------------*/
 /* REGISTER INFO */
 /* --------------------------------------------------*/
 
-#define NOF_ACQ_REGS                              12
+#define NOF_ACQ_REGS 12
 
 // Register id's of MMIO slave accessible registers
-#define ACQ_START_ADDR_REG_ID                     0
-#define ACQ_MEM_REGION_SIZE_REG_ID                1
-#define ACQ_NUM_MEM_REGIONS_REG_ID                2
-#define ACQ_INIT_REG_ID                           3
-#define ACQ_RECEIVED_SHORT_PACKETS_REG_ID         4
-#define ACQ_RECEIVED_LONG_PACKETS_REG_ID          5
-#define ACQ_LAST_COMMAND_REG_ID                   6
-#define ACQ_NEXT_COMMAND_REG_ID                   7
-#define ACQ_LAST_ACKNOWLEDGE_REG_ID               8
-#define ACQ_NEXT_ACKNOWLEDGE_REG_ID               9
-#define ACQ_FSM_STATE_INFO_REG_ID                 10
-#define ACQ_INT_CNTR_INFO_REG_ID                  11
+#define ACQ_START_ADDR_REG_ID 0
+#define ACQ_MEM_REGION_SIZE_REG_ID 1
+#define ACQ_NUM_MEM_REGIONS_REG_ID 2
+#define ACQ_INIT_REG_ID 3
+#define ACQ_RECEIVED_SHORT_PACKETS_REG_ID 4
+#define ACQ_RECEIVED_LONG_PACKETS_REG_ID 5
+#define ACQ_LAST_COMMAND_REG_ID 6
+#define ACQ_NEXT_COMMAND_REG_ID 7
+#define ACQ_LAST_ACKNOWLEDGE_REG_ID 8
+#define ACQ_NEXT_ACKNOWLEDGE_REG_ID 9
+#define ACQ_FSM_STATE_INFO_REG_ID 10
+#define ACQ_INT_CNTR_INFO_REG_ID 11
 
 // Register width
-#define ACQ_START_ADDR_REG_WIDTH                  9
-#define ACQ_MEM_REGION_SIZE_REG_WIDTH             9
-#define ACQ_NUM_MEM_REGIONS_REG_WIDTH             9
-#define ACQ_INIT_REG_WIDTH                        3
-#define ACQ_RECEIVED_SHORT_PACKETS_REG_WIDTH      32
-#define ACQ_RECEIVED_LONG_PACKETS_REG_WIDTH       32
-#define ACQ_LAST_COMMAND_REG_WIDTH                32
-#define ACQ_NEXT_COMMAND_REG_WIDTH                32
-#define ACQ_LAST_ACKNOWLEDGE_REG_WIDTH            32
-#define ACQ_NEXT_ACKNOWLEDGE_REG_WIDTH            32
-#define ACQ_FSM_STATE_INFO_REG_WIDTH              ((MEM2STREAM_FSM_STATE_BITS * 3) + (ACQ_SYNCHRONIZER_FSM_STATE_BITS * 3))
-#define ACQ_INT_CNTR_INFO_REG_WIDTH               32
+#define ACQ_START_ADDR_REG_WIDTH 9
+#define ACQ_MEM_REGION_SIZE_REG_WIDTH 9
+#define ACQ_NUM_MEM_REGIONS_REG_WIDTH 9
+#define ACQ_INIT_REG_WIDTH 3
+#define ACQ_RECEIVED_SHORT_PACKETS_REG_WIDTH 32
+#define ACQ_RECEIVED_LONG_PACKETS_REG_WIDTH 32
+#define ACQ_LAST_COMMAND_REG_WIDTH 32
+#define ACQ_NEXT_COMMAND_REG_WIDTH 32
+#define ACQ_LAST_ACKNOWLEDGE_REG_WIDTH 32
+#define ACQ_NEXT_ACKNOWLEDGE_REG_WIDTH 32
+#define ACQ_FSM_STATE_INFO_REG_WIDTH       \
+	((MEM2STREAM_FSM_STATE_BITS * 3) + \
+	 (ACQ_SYNCHRONIZER_FSM_STATE_BITS * 3))
+#define ACQ_INT_CNTR_INFO_REG_WIDTH 32
 
 /* register reset value */
-#define ACQ_START_ADDR_REG_RSTVAL                 0
-#define ACQ_MEM_REGION_SIZE_REG_RSTVAL            128
-#define ACQ_NUM_MEM_REGIONS_REG_RSTVAL            3
-#define ACQ_INIT_REG_RSTVAL                       0
-#define ACQ_RECEIVED_SHORT_PACKETS_REG_RSTVAL     0
-#define ACQ_RECEIVED_LONG_PACKETS_REG_RSTVAL      0
-#define ACQ_LAST_COMMAND_REG_RSTVAL               0
-#define ACQ_NEXT_COMMAND_REG_RSTVAL               0
-#define ACQ_LAST_ACKNOWLEDGE_REG_RSTVAL           0
-#define ACQ_NEXT_ACKNOWLEDGE_REG_RSTVAL           0
-#define ACQ_FSM_STATE_INFO_REG_RSTVAL             0
-#define ACQ_INT_CNTR_INFO_REG_RSTVAL              0
+#define ACQ_START_ADDR_REG_RSTVAL 0
+#define ACQ_MEM_REGION_SIZE_REG_RSTVAL 128
+#define ACQ_NUM_MEM_REGIONS_REG_RSTVAL 3
+#define ACQ_INIT_REG_RSTVAL 0
+#define ACQ_RECEIVED_SHORT_PACKETS_REG_RSTVAL 0
+#define ACQ_RECEIVED_LONG_PACKETS_REG_RSTVAL 0
+#define ACQ_LAST_COMMAND_REG_RSTVAL 0
+#define ACQ_NEXT_COMMAND_REG_RSTVAL 0
+#define ACQ_LAST_ACKNOWLEDGE_REG_RSTVAL 0
+#define ACQ_NEXT_ACKNOWLEDGE_REG_RSTVAL 0
+#define ACQ_FSM_STATE_INFO_REG_RSTVAL 0
+#define ACQ_INT_CNTR_INFO_REG_RSTVAL 0
 
 /* bit definitions */
-#define ACQ_INIT_RST_REG_BIT                      0
-#define ACQ_INIT_RESYNC_BIT                       2
-#define ACQ_INIT_RST_IDX                          ACQ_INIT_RST_REG_BIT
-#define ACQ_INIT_RST_BITS                         1
-#define ACQ_INIT_RESYNC_IDX                       ACQ_INIT_RESYNC_BIT
-#define ACQ_INIT_RESYNC_BITS                      1
+#define ACQ_INIT_RST_REG_BIT 0
+#define ACQ_INIT_RESYNC_BIT 2
+#define ACQ_INIT_RST_IDX ACQ_INIT_RST_REG_BIT
+#define ACQ_INIT_RST_BITS 1
+#define ACQ_INIT_RESYNC_IDX ACQ_INIT_RESYNC_BIT
+#define ACQ_INIT_RESYNC_BITS 1
 
 /* --------------------------------------------------*/
 /* TOKEN INFO */
 /* --------------------------------------------------*/
-#define ACQ_TOKEN_ID_LSB                          0
-#define ACQ_TOKEN_ID_MSB                          3
-#define ACQ_TOKEN_WIDTH                           (ACQ_TOKEN_ID_MSB - ACQ_TOKEN_ID_LSB  + 1) // 4
-#define ACQ_TOKEN_ID_IDX                          0
-#define ACQ_TOKEN_ID_BITS                         ACQ_TOKEN_WIDTH
-#define ACQ_INIT_CMD_INIT_IDX                     4
-#define ACQ_INIT_CMD_INIT_BITS                    3
-#define ACQ_CMD_START_ADDR_IDX                    4
-#define ACQ_CMD_START_ADDR_BITS                   9
-#define ACQ_CMD_NOFWORDS_IDX                      13
-#define ACQ_CMD_NOFWORDS_BITS                     9
-#define ACQ_MEM_REGION_ID_IDX                     22
-#define ACQ_MEM_REGION_ID_BITS                    9
-#define ACQ_PACKET_LENGTH_TOKEN_MSB               21
-#define ACQ_PACKET_LENGTH_TOKEN_LSB               13
-#define ACQ_PACKET_DATA_FORMAT_ID_TOKEN_MSB       9
-#define ACQ_PACKET_DATA_FORMAT_ID_TOKEN_LSB       4
-#define ACQ_PACKET_CH_ID_TOKEN_MSB                11
-#define ACQ_PACKET_CH_ID_TOKEN_LSB                10
-#define ACQ_PACKET_MEM_REGION_ID_TOKEN_MSB        12		/* only for capt_end_of_packet_written */
-#define ACQ_PACKET_MEM_REGION_ID_TOKEN_LSB        4		/* only for capt_end_of_packet_written */
+#define ACQ_TOKEN_ID_LSB 0
+#define ACQ_TOKEN_ID_MSB 3
+#define ACQ_TOKEN_WIDTH (ACQ_TOKEN_ID_MSB - ACQ_TOKEN_ID_LSB + 1) // 4
+#define ACQ_TOKEN_ID_IDX 0
+#define ACQ_TOKEN_ID_BITS ACQ_TOKEN_WIDTH
+#define ACQ_INIT_CMD_INIT_IDX 4
+#define ACQ_INIT_CMD_INIT_BITS 3
+#define ACQ_CMD_START_ADDR_IDX 4
+#define ACQ_CMD_START_ADDR_BITS 9
+#define ACQ_CMD_NOFWORDS_IDX 13
+#define ACQ_CMD_NOFWORDS_BITS 9
+#define ACQ_MEM_REGION_ID_IDX 22
+#define ACQ_MEM_REGION_ID_BITS 9
+#define ACQ_PACKET_LENGTH_TOKEN_MSB 21
+#define ACQ_PACKET_LENGTH_TOKEN_LSB 13
+#define ACQ_PACKET_DATA_FORMAT_ID_TOKEN_MSB 9
+#define ACQ_PACKET_DATA_FORMAT_ID_TOKEN_LSB 4
+#define ACQ_PACKET_CH_ID_TOKEN_MSB 11
+#define ACQ_PACKET_CH_ID_TOKEN_LSB 10
+#define ACQ_PACKET_MEM_REGION_ID_TOKEN_MSB \
+	12 /* only for capt_end_of_packet_written */
+#define ACQ_PACKET_MEM_REGION_ID_TOKEN_LSB \
+	4 /* only for capt_end_of_packet_written */
 
 /* Command tokens IDs */
-#define ACQ_READ_REGION_AUTO_INCR_TOKEN_ID        0 //0000b
-#define ACQ_READ_REGION_TOKEN_ID                  1 //0001b
-#define ACQ_READ_REGION_SOP_TOKEN_ID              2 //0010b
-#define ACQ_INIT_TOKEN_ID                         8 //1000b
+#define ACQ_READ_REGION_AUTO_INCR_TOKEN_ID 0 //0000b
+#define ACQ_READ_REGION_TOKEN_ID 1 //0001b
+#define ACQ_READ_REGION_SOP_TOKEN_ID 2 //0010b
+#define ACQ_INIT_TOKEN_ID 8 //1000b
 
 /* Acknowledge token IDs */
-#define ACQ_READ_REGION_ACK_TOKEN_ID              0 //0000b
-#define ACQ_END_OF_PACKET_TOKEN_ID                4 //0100b
-#define ACQ_END_OF_REGION_TOKEN_ID                5 //0101b
-#define ACQ_SOP_MISMATCH_TOKEN_ID                 6 //0110b
-#define ACQ_UNDEF_PH_TOKEN_ID                     7 //0111b
-
-#define ACQ_TOKEN_MEMREGIONID_MSB                 30
-#define ACQ_TOKEN_MEMREGIONID_LSB                 22
-#define ACQ_TOKEN_NOFWORDS_MSB                    21
-#define ACQ_TOKEN_NOFWORDS_LSB                    13
-#define ACQ_TOKEN_STARTADDR_MSB                   12
-#define ACQ_TOKEN_STARTADDR_LSB                   4
+#define ACQ_READ_REGION_ACK_TOKEN_ID 0 //0000b
+#define ACQ_END_OF_PACKET_TOKEN_ID 4 //0100b
+#define ACQ_END_OF_REGION_TOKEN_ID 5 //0101b
+#define ACQ_SOP_MISMATCH_TOKEN_ID 6 //0110b
+#define ACQ_UNDEF_PH_TOKEN_ID 7 //0111b
+
+#define ACQ_TOKEN_MEMREGIONID_MSB 30
+#define ACQ_TOKEN_MEMREGIONID_LSB 22
+#define ACQ_TOKEN_NOFWORDS_MSB 21
+#define ACQ_TOKEN_NOFWORDS_LSB 13
+#define ACQ_TOKEN_STARTADDR_MSB 12
+#define ACQ_TOKEN_STARTADDR_LSB 4
 
 /* --------------------------------------------------*/
 /* MIPI */
 /* --------------------------------------------------*/
 
-#define WORD_COUNT_WIDTH                          16
-#define PKT_CODE_WIDTH                            6
-#define CHN_NO_WIDTH                              2
-#define ERROR_INFO_WIDTH                          8
+#define WORD_COUNT_WIDTH 16
+#define PKT_CODE_WIDTH 6
+#define CHN_NO_WIDTH 2
+#define ERROR_INFO_WIDTH 8
 
-#define LONG_PKTCODE_MAX                          63
-#define LONG_PKTCODE_MIN                          16
-#define SHORT_PKTCODE_MAX                         15
+#define LONG_PKTCODE_MAX 63
+#define LONG_PKTCODE_MIN 16
+#define SHORT_PKTCODE_MAX 15
 
-#define EOF_CODE                                  1
+#define EOF_CODE 1
 
 /* --------------------------------------------------*/
 /* Packet Info */
 /* --------------------------------------------------*/
-#define ACQ_START_OF_FRAME                        0
-#define ACQ_END_OF_FRAME                          1
-#define ACQ_START_OF_LINE                         2
-#define ACQ_END_OF_LINE                           3
-#define ACQ_LINE_PAYLOAD                          4
-#define ACQ_GEN_SH_PKT                            5
+#define ACQ_START_OF_FRAME 0
+#define ACQ_END_OF_FRAME 1
+#define ACQ_START_OF_LINE 2
+#define ACQ_END_OF_LINE 3
+#define ACQ_LINE_PAYLOAD 4
+#define ACQ_GEN_SH_PKT 5
 
 /* bit definition */
-#define ACQ_PKT_TYPE_IDX                          16
-#define ACQ_PKT_TYPE_BITS                         6
-#define ACQ_PKT_SOP_IDX                           32
-#define ACQ_WORD_CNT_IDX                          0
-#define ACQ_WORD_CNT_BITS                         16
-#define ACQ_PKT_INFO_IDX                          16
-#define ACQ_PKT_INFO_BITS                         8
-#define ACQ_HEADER_DATA_IDX                       0
-#define ACQ_HEADER_DATA_BITS                      16
-#define ACQ_ACK_TOKEN_ID_IDX                      ACQ_TOKEN_ID_IDX
-#define ACQ_ACK_TOKEN_ID_BITS                     ACQ_TOKEN_ID_BITS
-#define ACQ_ACK_NOFWORDS_IDX                      13
-#define ACQ_ACK_NOFWORDS_BITS                     9
-#define ACQ_ACK_PKT_LEN_IDX                       4
-#define ACQ_ACK_PKT_LEN_BITS                      16
+#define ACQ_PKT_TYPE_IDX 16
+#define ACQ_PKT_TYPE_BITS 6
+#define ACQ_PKT_SOP_IDX 32
+#define ACQ_WORD_CNT_IDX 0
+#define ACQ_WORD_CNT_BITS 16
+#define ACQ_PKT_INFO_IDX 16
+#define ACQ_PKT_INFO_BITS 8
+#define ACQ_HEADER_DATA_IDX 0
+#define ACQ_HEADER_DATA_BITS 16
+#define ACQ_ACK_TOKEN_ID_IDX ACQ_TOKEN_ID_IDX
+#define ACQ_ACK_TOKEN_ID_BITS ACQ_TOKEN_ID_BITS
+#define ACQ_ACK_NOFWORDS_IDX 13
+#define ACQ_ACK_NOFWORDS_BITS 9
+#define ACQ_ACK_PKT_LEN_IDX 4
+#define ACQ_ACK_PKT_LEN_BITS 16
 
 /* --------------------------------------------------*/
 /* Packet Data Type */
 /* --------------------------------------------------*/
 
-#define ACQ_YUV420_8_DATA                       24   /* 01 1000 YUV420 8-bit                                        */
-#define ACQ_YUV420_10_DATA                      25   /* 01 1001  YUV420 10-bit                                      */
-#define ACQ_YUV420_8L_DATA                      26   /* 01 1010   YUV420 8-bit legacy                               */
-#define ACQ_YUV422_8_DATA                       30   /* 01 1110   YUV422 8-bit                                      */
-#define ACQ_YUV422_10_DATA                      31   /* 01 1111   YUV422 10-bit                                     */
-#define ACQ_RGB444_DATA                         32   /* 10 0000   RGB444                                            */
-#define ACQ_RGB555_DATA						 33   /* 10 0001   RGB555                                            */
-#define ACQ_RGB565_DATA						 34   /* 10 0010   RGB565                                            */
-#define ACQ_RGB666_DATA						 35   /* 10 0011   RGB666                                            */
-#define ACQ_RGB888_DATA						 36   /* 10 0100   RGB888                                            */
-#define ACQ_RAW6_DATA							 40   /* 10 1000   RAW6                                              */
-#define ACQ_RAW7_DATA							 41   /* 10 1001   RAW7                                              */
-#define ACQ_RAW8_DATA							 42   /* 10 1010   RAW8                                              */
-#define ACQ_RAW10_DATA						 43   /* 10 1011   RAW10                                             */
-#define ACQ_RAW12_DATA						 44   /* 10 1100   RAW12                                             */
-#define ACQ_RAW14_DATA						 45   /* 10 1101   RAW14                                             */
-#define ACQ_USR_DEF_1_DATA						 48   /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
-#define ACQ_USR_DEF_2_DATA						 49   /* 11 0001    User Defined 8-bit Data Type 2                   */
-#define ACQ_USR_DEF_3_DATA						 50   /* 11 0010    User Defined 8-bit Data Type 3                   */
-#define ACQ_USR_DEF_4_DATA						 51   /* 11 0011    User Defined 8-bit Data Type 4                   */
-#define ACQ_USR_DEF_5_DATA						 52   /* 11 0100    User Defined 8-bit Data Type 5                   */
-#define ACQ_USR_DEF_6_DATA						 53   /* 11 0101    User Defined 8-bit Data Type 6                   */
-#define ACQ_USR_DEF_7_DATA						 54   /* 11 0110    User Defined 8-bit Data Type 7                   */
-#define ACQ_USR_DEF_8_DATA						 55   /* 11 0111    User Defined 8-bit Data Type 8                   */
-#define ACQ_Emb_DATA							 18   /* 01 0010    embedded eight bit non image data                */
-#define ACQ_SOF_DATA							 0   /* 00 0000    frame start                                      */
-#define ACQ_EOF_DATA							 1   /* 00 0001    frame end                                        */
-#define ACQ_SOL_DATA							 2   /* 00 0010    line start                                       */
-#define ACQ_EOL_DATA							 3   /* 00 0011    line end                                         */
-#define ACQ_GEN_SH1_DATA						 8   /* 00 1000  Generic Short Packet Code 1                        */
-#define ACQ_GEN_SH2_DATA						 9   /* 00 1001    Generic Short Packet Code 2                      */
-#define ACQ_GEN_SH3_DATA						 10   /* 00 1010    Generic Short Packet Code 3                      */
-#define ACQ_GEN_SH4_DATA						 11   /* 00 1011    Generic Short Packet Code 4                      */
-#define ACQ_GEN_SH5_DATA						 12   /* 00 1100    Generic Short Packet Code 5                      */
-#define ACQ_GEN_SH6_DATA						 13   /* 00 1101    Generic Short Packet Code 6                      */
-#define ACQ_GEN_SH7_DATA						 14   /* 00 1110    Generic Short Packet Code 7                      */
-#define ACQ_GEN_SH8_DATA						 15   /* 00 1111    Generic Short Packet Code 8                      */
-#define ACQ_YUV420_8_CSPS_DATA					 28   /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
-#define ACQ_YUV420_10_CSPS_DATA					 29   /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
-#define ACQ_RESERVED_DATA_TYPE_MIN              56
-#define ACQ_RESERVED_DATA_TYPE_MAX              63
-#define ACQ_GEN_LONG_RESERVED_DATA_TYPE_MIN     19
-#define ACQ_GEN_LONG_RESERVED_DATA_TYPE_MAX     23
-#define ACQ_YUV_RESERVED_DATA_TYPE              27
-#define ACQ_RGB_RESERVED_DATA_TYPE_MIN          37
-#define ACQ_RGB_RESERVED_DATA_TYPE_MAX          39
-#define ACQ_RAW_RESERVED_DATA_TYPE_MIN          46
-#define ACQ_RAW_RESERVED_DATA_TYPE_MAX          47
+#define ACQ_YUV420_8_DATA \
+	24 /* 01 1000 YUV420 8-bit                                        */
+#define ACQ_YUV420_10_DATA \
+	25 /* 01 1001  YUV420 10-bit                                      */
+#define ACQ_YUV420_8L_DATA \
+	26 /* 01 1010   YUV420 8-bit legacy                               */
+#define ACQ_YUV422_8_DATA \
+	30 /* 01 1110   YUV422 8-bit                                      */
+#define ACQ_YUV422_10_DATA \
+	31 /* 01 1111   YUV422 10-bit                                     */
+#define ACQ_RGB444_DATA \
+	32 /* 10 0000   RGB444                                            */
+#define ACQ_RGB555_DATA \
+	33 /* 10 0001   RGB555                                            */
+#define ACQ_RGB565_DATA \
+	34 /* 10 0010   RGB565                                            */
+#define ACQ_RGB666_DATA \
+	35 /* 10 0011   RGB666                                            */
+#define ACQ_RGB888_DATA \
+	36 /* 10 0100   RGB888                                            */
+#define ACQ_RAW6_DATA \
+	40 /* 10 1000   RAW6                                              */
+#define ACQ_RAW7_DATA \
+	41 /* 10 1001   RAW7                                              */
+#define ACQ_RAW8_DATA \
+	42 /* 10 1010   RAW8                                              */
+#define ACQ_RAW10_DATA \
+	43 /* 10 1011   RAW10                                             */
+#define ACQ_RAW12_DATA \
+	44 /* 10 1100   RAW12                                             */
+#define ACQ_RAW14_DATA \
+	45 /* 10 1101   RAW14                                             */
+#define ACQ_USR_DEF_1_DATA \
+	48 /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
+#define ACQ_USR_DEF_2_DATA \
+	49 /* 11 0001    User Defined 8-bit Data Type 2                   */
+#define ACQ_USR_DEF_3_DATA \
+	50 /* 11 0010    User Defined 8-bit Data Type 3                   */
+#define ACQ_USR_DEF_4_DATA \
+	51 /* 11 0011    User Defined 8-bit Data Type 4                   */
+#define ACQ_USR_DEF_5_DATA \
+	52 /* 11 0100    User Defined 8-bit Data Type 5                   */
+#define ACQ_USR_DEF_6_DATA \
+	53 /* 11 0101    User Defined 8-bit Data Type 6                   */
+#define ACQ_USR_DEF_7_DATA \
+	54 /* 11 0110    User Defined 8-bit Data Type 7                   */
+#define ACQ_USR_DEF_8_DATA \
+	55 /* 11 0111    User Defined 8-bit Data Type 8                   */
+#define ACQ_Emb_DATA \
+	18 /* 01 0010    embedded eight bit non image data                */
+#define ACQ_SOF_DATA \
+	0 /* 00 0000    frame start                                      */
+#define ACQ_EOF_DATA \
+	1 /* 00 0001    frame end                                        */
+#define ACQ_SOL_DATA \
+	2 /* 00 0010    line start                                       */
+#define ACQ_EOL_DATA \
+	3 /* 00 0011    line end                                         */
+#define ACQ_GEN_SH1_DATA \
+	8 /* 00 1000  Generic Short Packet Code 1                        */
+#define ACQ_GEN_SH2_DATA \
+	9 /* 00 1001    Generic Short Packet Code 2                      */
+#define ACQ_GEN_SH3_DATA \
+	10 /* 00 1010    Generic Short Packet Code 3                      */
+#define ACQ_GEN_SH4_DATA \
+	11 /* 00 1011    Generic Short Packet Code 4                      */
+#define ACQ_GEN_SH5_DATA \
+	12 /* 00 1100    Generic Short Packet Code 5                      */
+#define ACQ_GEN_SH6_DATA \
+	13 /* 00 1101    Generic Short Packet Code 6                      */
+#define ACQ_GEN_SH7_DATA \
+	14 /* 00 1110    Generic Short Packet Code 7                      */
+#define ACQ_GEN_SH8_DATA \
+	15 /* 00 1111    Generic Short Packet Code 8                      */
+#define ACQ_YUV420_8_CSPS_DATA \
+	28 /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
+#define ACQ_YUV420_10_CSPS_DATA \
+	29 /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
+#define ACQ_RESERVED_DATA_TYPE_MIN 56
+#define ACQ_RESERVED_DATA_TYPE_MAX 63
+#define ACQ_GEN_LONG_RESERVED_DATA_TYPE_MIN 19
+#define ACQ_GEN_LONG_RESERVED_DATA_TYPE_MAX 23
+#define ACQ_YUV_RESERVED_DATA_TYPE 27
+#define ACQ_RGB_RESERVED_DATA_TYPE_MIN 37
+#define ACQ_RGB_RESERVED_DATA_TYPE_MAX 39
+#define ACQ_RAW_RESERVED_DATA_TYPE_MIN 46
+#define ACQ_RAW_RESERVED_DATA_TYPE_MAX 47
 
 /* --------------------------------------------------*/
 
diff --git a/drivers/staging/media/atomisp/pci/isp_capture_defs.h b/drivers/staging/media/atomisp/pci/isp_capture_defs.h
index b1fbf492a8095242e1691dbc8a0a0fe45435b935..5e64598e1df8d75adc7b22bdf98ebcb737bf5df9 100644
--- a/drivers/staging/media/atomisp/pci/isp_capture_defs.h
+++ b/drivers/staging/media/atomisp/pci/isp_capture_defs.h
@@ -7,263 +7,313 @@
 #ifndef _isp_capture_defs_h
 #define _isp_capture_defs_h
 
-#define _ISP_CAPTURE_REG_ALIGN                    4  /* assuming 32 bit control bus width */
-#define _ISP_CAPTURE_BITS_PER_ELEM                32  /* only for data, not SOP */
-#define _ISP_CAPTURE_BYTES_PER_ELEM               (_ISP_CAPTURE_BITS_PER_ELEM / 8)
-#define _ISP_CAPTURE_BYTES_PER_WORD               32		/* 256/8 */
-#define _ISP_CAPTURE_ELEM_PER_WORD                _ISP_CAPTURE_BYTES_PER_WORD / _ISP_CAPTURE_BYTES_PER_ELEM
+#define _ISP_CAPTURE_REG_ALIGN 4 /* assuming 32 bit control bus width */
+#define _ISP_CAPTURE_BITS_PER_ELEM 32 /* only for data, not SOP */
+#define _ISP_CAPTURE_BYTES_PER_ELEM (_ISP_CAPTURE_BITS_PER_ELEM / 8)
+#define _ISP_CAPTURE_BYTES_PER_WORD 32 /* 256/8 */
+#define _ISP_CAPTURE_ELEM_PER_WORD ( \
+	_ISP_CAPTURE_BYTES_PER_WORD / _ISP_CAPTURE_BYTES_PER_ELEM)
 
 /* --------------------------------------------------*/
 
-#define NOF_IRQS                                  2
+#define NOF_IRQS 2
 
 /* --------------------------------------------------*/
 /* REGISTER INFO */
 /* --------------------------------------------------*/
 
 // Number of registers
-#define CAPT_NOF_REGS                             16
+#define CAPT_NOF_REGS 16
 
 // Register id's of MMIO slave accessible registers
-#define CAPT_START_MODE_REG_ID                    0
-#define CAPT_START_ADDR_REG_ID                    1
-#define CAPT_MEM_REGION_SIZE_REG_ID               2
-#define CAPT_NUM_MEM_REGIONS_REG_ID               3
-#define CAPT_INIT_REG_ID                          4
-#define CAPT_START_REG_ID                         5
-#define CAPT_STOP_REG_ID                          6
-
-#define CAPT_PACKET_LENGTH_REG_ID                 7
-#define CAPT_RECEIVED_LENGTH_REG_ID               8
-#define CAPT_RECEIVED_SHORT_PACKETS_REG_ID        9
-#define CAPT_RECEIVED_LONG_PACKETS_REG_ID         10
-#define CAPT_LAST_COMMAND_REG_ID                  11
-#define CAPT_NEXT_COMMAND_REG_ID                  12
-#define CAPT_LAST_ACKNOWLEDGE_REG_ID              13
-#define CAPT_NEXT_ACKNOWLEDGE_REG_ID              14
-#define CAPT_FSM_STATE_INFO_REG_ID                15
+#define CAPT_START_MODE_REG_ID 0
+#define CAPT_START_ADDR_REG_ID 1
+#define CAPT_MEM_REGION_SIZE_REG_ID 2
+#define CAPT_NUM_MEM_REGIONS_REG_ID 3
+#define CAPT_INIT_REG_ID 4
+#define CAPT_START_REG_ID 5
+#define CAPT_STOP_REG_ID 6
+
+#define CAPT_PACKET_LENGTH_REG_ID 7
+#define CAPT_RECEIVED_LENGTH_REG_ID 8
+#define CAPT_RECEIVED_SHORT_PACKETS_REG_ID 9
+#define CAPT_RECEIVED_LONG_PACKETS_REG_ID 10
+#define CAPT_LAST_COMMAND_REG_ID 11
+#define CAPT_NEXT_COMMAND_REG_ID 12
+#define CAPT_LAST_ACKNOWLEDGE_REG_ID 13
+#define CAPT_NEXT_ACKNOWLEDGE_REG_ID 14
+#define CAPT_FSM_STATE_INFO_REG_ID 15
 
 // Register width
-#define CAPT_START_MODE_REG_WIDTH                 1
+#define CAPT_START_MODE_REG_WIDTH 1
 
-#define CAPT_START_REG_WIDTH                      1
-#define CAPT_STOP_REG_WIDTH                       1
+#define CAPT_START_REG_WIDTH 1
+#define CAPT_STOP_REG_WIDTH 1
 
 /* --------------------------------------------------*/
 /* FSM */
 /* --------------------------------------------------*/
-#define CAPT_WRITE2MEM_FSM_STATE_BITS             2
-#define CAPT_SYNCHRONIZER_FSM_STATE_BITS          3
-
-#define CAPT_PACKET_LENGTH_REG_WIDTH              17
-#define CAPT_RECEIVED_LENGTH_REG_WIDTH            17
-#define CAPT_RECEIVED_SHORT_PACKETS_REG_WIDTH     32
-#define CAPT_RECEIVED_LONG_PACKETS_REG_WIDTH      32
-#define CAPT_LAST_COMMAND_REG_WIDTH               32
-#define CAPT_LAST_ACKNOWLEDGE_REG_WIDTH           32
-#define CAPT_NEXT_ACKNOWLEDGE_REG_WIDTH           32
-#define CAPT_FSM_STATE_INFO_REG_WIDTH             ((CAPT_WRITE2MEM_FSM_STATE_BITS * 3) + (CAPT_SYNCHRONIZER_FSM_STATE_BITS * 3))
+#define CAPT_WRITE2MEM_FSM_STATE_BITS 2
+#define CAPT_SYNCHRONIZER_FSM_STATE_BITS 3
+
+#define CAPT_PACKET_LENGTH_REG_WIDTH 17
+#define CAPT_RECEIVED_LENGTH_REG_WIDTH 17
+#define CAPT_RECEIVED_SHORT_PACKETS_REG_WIDTH 32
+#define CAPT_RECEIVED_LONG_PACKETS_REG_WIDTH 32
+#define CAPT_LAST_COMMAND_REG_WIDTH 32
+#define CAPT_LAST_ACKNOWLEDGE_REG_WIDTH 32
+#define CAPT_NEXT_ACKNOWLEDGE_REG_WIDTH 32
+#define CAPT_FSM_STATE_INFO_REG_WIDTH          \
+	((CAPT_WRITE2MEM_FSM_STATE_BITS * 3) + \
+	 (CAPT_SYNCHRONIZER_FSM_STATE_BITS * 3))
 
 /* register reset value */
-#define CAPT_START_MODE_REG_RSTVAL                0
-#define CAPT_START_ADDR_REG_RSTVAL                0
-#define CAPT_MEM_REGION_SIZE_REG_RSTVAL           128
-#define CAPT_NUM_MEM_REGIONS_REG_RSTVAL           3
-#define CAPT_INIT_REG_RSTVAL                      0
-
-#define CAPT_START_REG_RSTVAL                     0
-#define CAPT_STOP_REG_RSTVAL                      0
-
-#define CAPT_PACKET_LENGTH_REG_RSTVAL             0
-#define CAPT_RECEIVED_LENGTH_REG_RSTVAL           0
-#define CAPT_RECEIVED_SHORT_PACKETS_REG_RSTVAL    0
-#define CAPT_RECEIVED_LONG_PACKETS_REG_RSTVAL     0
-#define CAPT_LAST_COMMAND_REG_RSTVAL              0
-#define CAPT_NEXT_COMMAND_REG_RSTVAL              0
-#define CAPT_LAST_ACKNOWLEDGE_REG_RSTVAL          0
-#define CAPT_NEXT_ACKNOWLEDGE_REG_RSTVAL          0
-#define CAPT_FSM_STATE_INFO_REG_RSTVAL            0
+#define CAPT_START_MODE_REG_RSTVAL 0
+#define CAPT_START_ADDR_REG_RSTVAL 0
+#define CAPT_MEM_REGION_SIZE_REG_RSTVAL 128
+#define CAPT_NUM_MEM_REGIONS_REG_RSTVAL 3
+#define CAPT_INIT_REG_RSTVAL 0
+
+#define CAPT_START_REG_RSTVAL 0
+#define CAPT_STOP_REG_RSTVAL 0
+
+#define CAPT_PACKET_LENGTH_REG_RSTVAL 0
+#define CAPT_RECEIVED_LENGTH_REG_RSTVAL 0
+#define CAPT_RECEIVED_SHORT_PACKETS_REG_RSTVAL 0
+#define CAPT_RECEIVED_LONG_PACKETS_REG_RSTVAL 0
+#define CAPT_LAST_COMMAND_REG_RSTVAL 0
+#define CAPT_NEXT_COMMAND_REG_RSTVAL 0
+#define CAPT_LAST_ACKNOWLEDGE_REG_RSTVAL 0
+#define CAPT_NEXT_ACKNOWLEDGE_REG_RSTVAL 0
+#define CAPT_FSM_STATE_INFO_REG_RSTVAL 0
 
 /* bit definitions */
-#define CAPT_INIT_RST_REG_BIT                     0
-#define CAPT_INIT_FLUSH_BIT                       1
-#define CAPT_INIT_RESYNC_BIT                      2
-#define CAPT_INIT_RESTART_BIT                     3
-#define CAPT_INIT_RESTART_MEM_ADDR_LSB            4
-
-#define CAPT_INIT_RST_REG_IDX                     CAPT_INIT_RST_REG_BIT
-#define CAPT_INIT_RST_REG_BITS                    1
-#define CAPT_INIT_FLUSH_IDX                       CAPT_INIT_FLUSH_BIT
-#define CAPT_INIT_FLUSH_BITS                      1
-#define CAPT_INIT_RESYNC_IDX                      CAPT_INIT_RESYNC_BIT
-#define CAPT_INIT_RESYNC_BITS                     1
-#define CAPT_INIT_RESTART_IDX                     CAPT_INIT_RESTART_BIT
-#define CAPT_INIT_RESTART_BITS									1
-#define CAPT_INIT_RESTART_MEM_ADDR_IDX            CAPT_INIT_RESTART_MEM_ADDR_LSB
+#define CAPT_INIT_RST_REG_BIT 0
+#define CAPT_INIT_FLUSH_BIT 1
+#define CAPT_INIT_RESYNC_BIT 2
+#define CAPT_INIT_RESTART_BIT 3
+#define CAPT_INIT_RESTART_MEM_ADDR_LSB 4
+
+#define CAPT_INIT_RST_REG_IDX CAPT_INIT_RST_REG_BIT
+#define CAPT_INIT_RST_REG_BITS 1
+#define CAPT_INIT_FLUSH_IDX CAPT_INIT_FLUSH_BIT
+#define CAPT_INIT_FLUSH_BITS 1
+#define CAPT_INIT_RESYNC_IDX CAPT_INIT_RESYNC_BIT
+#define CAPT_INIT_RESYNC_BITS 1
+#define CAPT_INIT_RESTART_IDX CAPT_INIT_RESTART_BIT
+#define CAPT_INIT_RESTART_BITS 1
+#define CAPT_INIT_RESTART_MEM_ADDR_IDX CAPT_INIT_RESTART_MEM_ADDR_LSB
 
 /* --------------------------------------------------*/
 /* TOKEN INFO */
 /* --------------------------------------------------*/
-#define CAPT_TOKEN_ID_LSB                         0
-#define CAPT_TOKEN_ID_MSB                         3
-#define CAPT_TOKEN_WIDTH                         (CAPT_TOKEN_ID_MSB - CAPT_TOKEN_ID_LSB  + 1) /* 4 */
+#define CAPT_TOKEN_ID_LSB 0
+#define CAPT_TOKEN_ID_MSB 3
+#define CAPT_TOKEN_WIDTH (CAPT_TOKEN_ID_MSB - CAPT_TOKEN_ID_LSB + 1) /* 4 */
 
 /* Command tokens IDs */
-#define CAPT_START_TOKEN_ID                       0 /* 0000b */
-#define CAPT_STOP_TOKEN_ID                        1 /* 0001b */
-#define CAPT_FREEZE_TOKEN_ID                      2 /* 0010b */
-#define CAPT_RESUME_TOKEN_ID                      3 /* 0011b */
-#define CAPT_INIT_TOKEN_ID                        8 /* 1000b */
-
-#define CAPT_START_TOKEN_BIT                      0
-#define CAPT_STOP_TOKEN_BIT                       0
-#define CAPT_FREEZE_TOKEN_BIT                     0
-#define CAPT_RESUME_TOKEN_BIT                     0
-#define CAPT_INIT_TOKEN_BIT                       0
+#define CAPT_START_TOKEN_ID 0 /* 0000b */
+#define CAPT_STOP_TOKEN_ID 1 /* 0001b */
+#define CAPT_FREEZE_TOKEN_ID 2 /* 0010b */
+#define CAPT_RESUME_TOKEN_ID 3 /* 0011b */
+#define CAPT_INIT_TOKEN_ID 8 /* 1000b */
+
+#define CAPT_START_TOKEN_BIT 0
+#define CAPT_STOP_TOKEN_BIT 0
+#define CAPT_FREEZE_TOKEN_BIT 0
+#define CAPT_RESUME_TOKEN_BIT 0
+#define CAPT_INIT_TOKEN_BIT 0
 
 /* Acknowledge token IDs */
-#define CAPT_END_OF_PACKET_RECEIVED_TOKEN_ID      0 /* 0000b */
-#define CAPT_END_OF_PACKET_WRITTEN_TOKEN_ID       1 /* 0001b */
-#define CAPT_END_OF_REGION_WRITTEN_TOKEN_ID       2 /* 0010b */
-#define CAPT_FLUSH_DONE_TOKEN_ID                  3 /* 0011b */
-#define CAPT_PREMATURE_SOP_TOKEN_ID               4 /* 0100b */
-#define CAPT_MISSING_SOP_TOKEN_ID                 5 /* 0101b */
-#define CAPT_UNDEF_PH_TOKEN_ID                    6 /* 0110b */
-#define CAPT_STOP_ACK_TOKEN_ID                    7 /* 0111b */
-
-#define CAPT_PACKET_LENGTH_TOKEN_MSB             19
-#define CAPT_PACKET_LENGTH_TOKEN_LSB              4
-#define CAPT_SUPER_PACKET_LENGTH_TOKEN_MSB       20
-#define CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB        4
-#define CAPT_PACKET_DATA_FORMAT_ID_TOKEN_MSB     25
-#define CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB     20
-#define CAPT_PACKET_CH_ID_TOKEN_MSB              27
-#define CAPT_PACKET_CH_ID_TOKEN_LSB              26
-#define CAPT_PACKET_MEM_REGION_ID_TOKEN_MSB      29
-#define CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB      21
+#define CAPT_END_OF_PACKET_RECEIVED_TOKEN_ID 0 /* 0000b */
+#define CAPT_END_OF_PACKET_WRITTEN_TOKEN_ID 1 /* 0001b */
+#define CAPT_END_OF_REGION_WRITTEN_TOKEN_ID 2 /* 0010b */
+#define CAPT_FLUSH_DONE_TOKEN_ID 3 /* 0011b */
+#define CAPT_PREMATURE_SOP_TOKEN_ID 4 /* 0100b */
+#define CAPT_MISSING_SOP_TOKEN_ID 5 /* 0101b */
+#define CAPT_UNDEF_PH_TOKEN_ID 6 /* 0110b */
+#define CAPT_STOP_ACK_TOKEN_ID 7 /* 0111b */
+
+#define CAPT_PACKET_LENGTH_TOKEN_MSB 19
+#define CAPT_PACKET_LENGTH_TOKEN_LSB 4
+#define CAPT_SUPER_PACKET_LENGTH_TOKEN_MSB 20
+#define CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB 4
+#define CAPT_PACKET_DATA_FORMAT_ID_TOKEN_MSB 25
+#define CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB 20
+#define CAPT_PACKET_CH_ID_TOKEN_MSB 27
+#define CAPT_PACKET_CH_ID_TOKEN_LSB 26
+#define CAPT_PACKET_MEM_REGION_ID_TOKEN_MSB 29
+#define CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB 21
 
 /*  bit definition */
-#define CAPT_CMD_IDX                              CAPT_TOKEN_ID_LSB
-#define	CAPT_CMD_BITS                             (CAPT_TOKEN_ID_MSB - CAPT_TOKEN_ID_LSB + 1)
-#define CAPT_SOP_IDX                              32
-#define CAPT_SOP_BITS                             1
-#define CAPT_PKT_INFO_IDX                         16
-#define CAPT_PKT_INFO_BITS                        8
-#define CAPT_PKT_TYPE_IDX                         0
-#define CAPT_PKT_TYPE_BITS                        6
-#define CAPT_HEADER_DATA_IDX                      0
-#define CAPT_HEADER_DATA_BITS                     16
-#define CAPT_PKT_DATA_IDX                         0
-#define CAPT_PKT_DATA_BITS                        32
-#define CAPT_WORD_CNT_IDX                         0
-#define CAPT_WORD_CNT_BITS                        16
-#define CAPT_ACK_TOKEN_ID_IDX                     0
-#define CAPT_ACK_TOKEN_ID_BITS                    4
+#define CAPT_CMD_IDX CAPT_TOKEN_ID_LSB
+#define CAPT_CMD_BITS (CAPT_TOKEN_ID_MSB - CAPT_TOKEN_ID_LSB + 1)
+#define CAPT_SOP_IDX 32
+#define CAPT_SOP_BITS 1
+#define CAPT_PKT_INFO_IDX 16
+#define CAPT_PKT_INFO_BITS 8
+#define CAPT_PKT_TYPE_IDX 0
+#define CAPT_PKT_TYPE_BITS 6
+#define CAPT_HEADER_DATA_IDX 0
+#define CAPT_HEADER_DATA_BITS 16
+#define CAPT_PKT_DATA_IDX 0
+#define CAPT_PKT_DATA_BITS 32
+#define CAPT_WORD_CNT_IDX 0
+#define CAPT_WORD_CNT_BITS 16
+#define CAPT_ACK_TOKEN_ID_IDX 0
+#define CAPT_ACK_TOKEN_ID_BITS 4
 //#define CAPT_ACK_PKT_LEN_IDX                      CAPT_PACKET_LENGTH_TOKEN_LSB
 //#define CAPT_ACK_PKT_LEN_BITS                     (CAPT_PACKET_LENGTH_TOKEN_MSB - CAPT_PACKET_LENGTH_TOKEN_LSB + 1)
 //#define CAPT_ACK_PKT_INFO_IDX                     20
 //#define CAPT_ACK_PKT_INFO_BITS                    8
 //#define CAPT_ACK_MEM_REG_ID1_IDX                  20			/* for capt_end_of_packet_written */
 //#define CAPT_ACK_MEM_REG_ID2_IDX                  4       /* for capt_end_of_region_written */
-#define CAPT_ACK_PKT_LEN_IDX                      CAPT_PACKET_LENGTH_TOKEN_LSB
-#define CAPT_ACK_PKT_LEN_BITS                     (CAPT_PACKET_LENGTH_TOKEN_MSB - CAPT_PACKET_LENGTH_TOKEN_LSB + 1)
-#define CAPT_ACK_SUPER_PKT_LEN_IDX                CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB
-#define CAPT_ACK_SUPER_PKT_LEN_BITS               (CAPT_SUPER_PACKET_LENGTH_TOKEN_MSB - CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB + 1)
-#define CAPT_ACK_PKT_INFO_IDX                     CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB
-#define CAPT_ACK_PKT_INFO_BITS                    (CAPT_PACKET_CH_ID_TOKEN_MSB - CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB + 1)
-#define CAPT_ACK_MEM_REGION_ID_IDX                CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB
-#define CAPT_ACK_MEM_REGION_ID_BITS               (CAPT_PACKET_MEM_REGION_ID_TOKEN_MSB - CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB + 1)
-#define CAPT_ACK_PKT_TYPE_IDX                     CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB
-#define CAPT_ACK_PKT_TYPE_BITS                    (CAPT_PACKET_DATA_FORMAT_ID_TOKEN_MSB - CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB + 1)
-#define CAPT_INIT_TOKEN_INIT_IDX                  4
-#define CAPT_INIT_TOKEN_INIT_BITS                 22
+#define CAPT_ACK_PKT_LEN_IDX CAPT_PACKET_LENGTH_TOKEN_LSB
+#define CAPT_ACK_PKT_LEN_BITS \
+	(CAPT_PACKET_LENGTH_TOKEN_MSB - CAPT_PACKET_LENGTH_TOKEN_LSB + 1)
+#define CAPT_ACK_SUPER_PKT_LEN_IDX CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB
+#define CAPT_ACK_SUPER_PKT_LEN_BITS           \
+	(CAPT_SUPER_PACKET_LENGTH_TOKEN_MSB - \
+	 CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB + 1)
+#define CAPT_ACK_PKT_INFO_IDX CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB
+#define CAPT_ACK_PKT_INFO_BITS \
+	(CAPT_PACKET_CH_ID_TOKEN_MSB - CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB + 1)
+#define CAPT_ACK_MEM_REGION_ID_IDX CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB
+#define CAPT_ACK_MEM_REGION_ID_BITS            \
+	(CAPT_PACKET_MEM_REGION_ID_TOKEN_MSB - \
+	 CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB + 1)
+#define CAPT_ACK_PKT_TYPE_IDX CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB
+#define CAPT_ACK_PKT_TYPE_BITS                  \
+	(CAPT_PACKET_DATA_FORMAT_ID_TOKEN_MSB - \
+	 CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB + 1)
+#define CAPT_INIT_TOKEN_INIT_IDX 4
+#define CAPT_INIT_TOKEN_INIT_BITS 22
 
 /* --------------------------------------------------*/
 /* MIPI */
 /* --------------------------------------------------*/
 
-#define CAPT_WORD_COUNT_WIDTH                     16
-#define CAPT_PKT_CODE_WIDTH                       6
-#define CAPT_CHN_NO_WIDTH                         2
-#define CAPT_ERROR_INFO_WIDTH                     8
+#define CAPT_WORD_COUNT_WIDTH 16
+#define CAPT_PKT_CODE_WIDTH 6
+#define CAPT_CHN_NO_WIDTH 2
+#define CAPT_ERROR_INFO_WIDTH 8
 
-#define LONG_PKTCODE_MAX                          63
-#define LONG_PKTCODE_MIN                          16
-#define SHORT_PKTCODE_MAX                         15
+#define LONG_PKTCODE_MAX 63
+#define LONG_PKTCODE_MIN 16
+#define SHORT_PKTCODE_MAX 15
 
 /* --------------------------------------------------*/
 /* Packet Info */
 /* --------------------------------------------------*/
-#define CAPT_START_OF_FRAME                       0
-#define CAPT_END_OF_FRAME                         1
-#define CAPT_START_OF_LINE                        2
-#define CAPT_END_OF_LINE                          3
-#define CAPT_LINE_PAYLOAD                         4
-#define CAPT_GEN_SH_PKT                           5
+#define CAPT_START_OF_FRAME 0
+#define CAPT_END_OF_FRAME 1
+#define CAPT_START_OF_LINE 2
+#define CAPT_END_OF_LINE 3
+#define CAPT_LINE_PAYLOAD 4
+#define CAPT_GEN_SH_PKT 5
 
 /* --------------------------------------------------*/
 /* Packet Data Type */
 /* --------------------------------------------------*/
 
-#define CAPT_YUV420_8_DATA                       24   /* 01 1000 YUV420 8-bit                                        */
-#define CAPT_YUV420_10_DATA                      25   /* 01 1001  YUV420 10-bit                                      */
-#define CAPT_YUV420_8L_DATA                      26   /* 01 1010   YUV420 8-bit legacy                               */
-#define CAPT_YUV422_8_DATA                       30   /* 01 1110   YUV422 8-bit                                      */
-#define CAPT_YUV422_10_DATA                      31   /* 01 1111   YUV422 10-bit                                     */
-#define CAPT_RGB444_DATA                         32   /* 10 0000   RGB444                                            */
-#define CAPT_RGB555_DATA						 33   /* 10 0001   RGB555                                            */
-#define CAPT_RGB565_DATA						 34   /* 10 0010   RGB565                                            */
-#define CAPT_RGB666_DATA						 35   /* 10 0011   RGB666                                            */
-#define CAPT_RGB888_DATA						 36   /* 10 0100   RGB888                                            */
-#define CAPT_RAW6_DATA							 40   /* 10 1000   RAW6                                              */
-#define CAPT_RAW7_DATA							 41   /* 10 1001   RAW7                                              */
-#define CAPT_RAW8_DATA							 42   /* 10 1010   RAW8                                              */
-#define CAPT_RAW10_DATA						 43   /* 10 1011   RAW10                                             */
-#define CAPT_RAW12_DATA						 44   /* 10 1100   RAW12                                             */
-#define CAPT_RAW14_DATA						 45   /* 10 1101   RAW14                                             */
-#define CAPT_USR_DEF_1_DATA						 48   /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
-#define CAPT_USR_DEF_2_DATA						 49   /* 11 0001    User Defined 8-bit Data Type 2                   */
-#define CAPT_USR_DEF_3_DATA						 50   /* 11 0010    User Defined 8-bit Data Type 3                   */
-#define CAPT_USR_DEF_4_DATA						 51   /* 11 0011    User Defined 8-bit Data Type 4                   */
-#define CAPT_USR_DEF_5_DATA						 52   /* 11 0100    User Defined 8-bit Data Type 5                   */
-#define CAPT_USR_DEF_6_DATA						 53   /* 11 0101    User Defined 8-bit Data Type 6                   */
-#define CAPT_USR_DEF_7_DATA						 54   /* 11 0110    User Defined 8-bit Data Type 7                   */
-#define CAPT_USR_DEF_8_DATA						 55   /* 11 0111    User Defined 8-bit Data Type 8                   */
-#define CAPT_Emb_DATA							 18   /* 01 0010    embedded eight bit non image data                */
-#define CAPT_SOF_DATA							 0   /* 00 0000    frame start                                      */
-#define CAPT_EOF_DATA							 1   /* 00 0001    frame end                                        */
-#define CAPT_SOL_DATA							 2   /* 00 0010    line start                                       */
-#define CAPT_EOL_DATA							 3   /* 00 0011    line end                                         */
-#define CAPT_GEN_SH1_DATA						 8   /* 00 1000  Generic Short Packet Code 1                        */
-#define CAPT_GEN_SH2_DATA						 9   /* 00 1001    Generic Short Packet Code 2                      */
-#define CAPT_GEN_SH3_DATA						 10   /* 00 1010    Generic Short Packet Code 3                      */
-#define CAPT_GEN_SH4_DATA						 11   /* 00 1011    Generic Short Packet Code 4                      */
-#define CAPT_GEN_SH5_DATA						 12   /* 00 1100    Generic Short Packet Code 5                      */
-#define CAPT_GEN_SH6_DATA						 13   /* 00 1101    Generic Short Packet Code 6                      */
-#define CAPT_GEN_SH7_DATA						 14   /* 00 1110    Generic Short Packet Code 7                      */
-#define CAPT_GEN_SH8_DATA						 15   /* 00 1111    Generic Short Packet Code 8                      */
-#define CAPT_YUV420_8_CSPS_DATA					 28   /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
-#define CAPT_YUV420_10_CSPS_DATA					 29   /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
-#define CAPT_RESERVED_DATA_TYPE_MIN              56
-#define CAPT_RESERVED_DATA_TYPE_MAX              63
-#define CAPT_GEN_LONG_RESERVED_DATA_TYPE_MIN     19
-#define CAPT_GEN_LONG_RESERVED_DATA_TYPE_MAX     23
-#define CAPT_YUV_RESERVED_DATA_TYPE              27
-#define CAPT_RGB_RESERVED_DATA_TYPE_MIN          37
-#define CAPT_RGB_RESERVED_DATA_TYPE_MAX          39
-#define CAPT_RAW_RESERVED_DATA_TYPE_MIN          46
-#define CAPT_RAW_RESERVED_DATA_TYPE_MAX          47
+#define CAPT_YUV420_8_DATA \
+	24 /* 01 1000 YUV420 8-bit                                        */
+#define CAPT_YUV420_10_DATA \
+	25 /* 01 1001  YUV420 10-bit                                      */
+#define CAPT_YUV420_8L_DATA \
+	26 /* 01 1010   YUV420 8-bit legacy                               */
+#define CAPT_YUV422_8_DATA \
+	30 /* 01 1110   YUV422 8-bit                                      */
+#define CAPT_YUV422_10_DATA \
+	31 /* 01 1111   YUV422 10-bit                                     */
+#define CAPT_RGB444_DATA \
+	32 /* 10 0000   RGB444                                            */
+#define CAPT_RGB555_DATA \
+	33 /* 10 0001   RGB555                                            */
+#define CAPT_RGB565_DATA \
+	34 /* 10 0010   RGB565                                            */
+#define CAPT_RGB666_DATA \
+	35 /* 10 0011   RGB666                                            */
+#define CAPT_RGB888_DATA \
+	36 /* 10 0100   RGB888                                            */
+#define CAPT_RAW6_DATA \
+	40 /* 10 1000   RAW6                                              */
+#define CAPT_RAW7_DATA \
+	41 /* 10 1001   RAW7                                              */
+#define CAPT_RAW8_DATA \
+	42 /* 10 1010   RAW8                                              */
+#define CAPT_RAW10_DATA \
+	43 /* 10 1011   RAW10                                             */
+#define CAPT_RAW12_DATA \
+	44 /* 10 1100   RAW12                                             */
+#define CAPT_RAW14_DATA \
+	45 /* 10 1101   RAW14                                             */
+#define CAPT_USR_DEF_1_DATA \
+	48 /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
+#define CAPT_USR_DEF_2_DATA \
+	49 /* 11 0001    User Defined 8-bit Data Type 2                   */
+#define CAPT_USR_DEF_3_DATA \
+	50 /* 11 0010    User Defined 8-bit Data Type 3                   */
+#define CAPT_USR_DEF_4_DATA \
+	51 /* 11 0011    User Defined 8-bit Data Type 4                   */
+#define CAPT_USR_DEF_5_DATA \
+	52 /* 11 0100    User Defined 8-bit Data Type 5                   */
+#define CAPT_USR_DEF_6_DATA \
+	53 /* 11 0101    User Defined 8-bit Data Type 6                   */
+#define CAPT_USR_DEF_7_DATA \
+	54 /* 11 0110    User Defined 8-bit Data Type 7                   */
+#define CAPT_USR_DEF_8_DATA \
+	55 /* 11 0111    User Defined 8-bit Data Type 8                   */
+#define CAPT_Emb_DATA \
+	18 /* 01 0010    embedded eight bit non image data                */
+#define CAPT_SOF_DATA \
+	0 /* 00 0000    frame start                                      */
+#define CAPT_EOF_DATA \
+	1 /* 00 0001    frame end                                        */
+#define CAPT_SOL_DATA \
+	2 /* 00 0010    line start                                       */
+#define CAPT_EOL_DATA \
+	3 /* 00 0011    line end                                         */
+#define CAPT_GEN_SH1_DATA \
+	8 /* 00 1000  Generic Short Packet Code 1                        */
+#define CAPT_GEN_SH2_DATA \
+	9 /* 00 1001    Generic Short Packet Code 2                      */
+#define CAPT_GEN_SH3_DATA \
+	10 /* 00 1010    Generic Short Packet Code 3                      */
+#define CAPT_GEN_SH4_DATA \
+	11 /* 00 1011    Generic Short Packet Code 4                      */
+#define CAPT_GEN_SH5_DATA \
+	12 /* 00 1100    Generic Short Packet Code 5                      */
+#define CAPT_GEN_SH6_DATA \
+	13 /* 00 1101    Generic Short Packet Code 6                      */
+#define CAPT_GEN_SH7_DATA \
+	14 /* 00 1110    Generic Short Packet Code 7                      */
+#define CAPT_GEN_SH8_DATA \
+	15 /* 00 1111    Generic Short Packet Code 8                      */
+#define CAPT_YUV420_8_CSPS_DATA \
+	28 /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
+#define CAPT_YUV420_10_CSPS_DATA \
+	29 /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
+#define CAPT_RESERVED_DATA_TYPE_MIN 56
+#define CAPT_RESERVED_DATA_TYPE_MAX 63
+#define CAPT_GEN_LONG_RESERVED_DATA_TYPE_MIN 19
+#define CAPT_GEN_LONG_RESERVED_DATA_TYPE_MAX 23
+#define CAPT_YUV_RESERVED_DATA_TYPE 27
+#define CAPT_RGB_RESERVED_DATA_TYPE_MIN 37
+#define CAPT_RGB_RESERVED_DATA_TYPE_MAX 39
+#define CAPT_RAW_RESERVED_DATA_TYPE_MIN 46
+#define CAPT_RAW_RESERVED_DATA_TYPE_MAX 47
 
 /* --------------------------------------------------*/
 /* Capture Unit State */
 /* --------------------------------------------------*/
-#define CAPT_FREE_RUN                             0
-#define CAPT_NO_SYNC                              1
-#define CAPT_SYNC_SWP                             2
-#define CAPT_SYNC_MWP                             3
-#define CAPT_SYNC_WAIT                            4
-#define CAPT_FREEZE                               5
-#define CAPT_RUN                                  6
+#define CAPT_FREE_RUN 0
+#define CAPT_NO_SYNC 1
+#define CAPT_SYNC_SWP 2
+#define CAPT_SYNC_MWP 3
+#define CAPT_SYNC_WAIT 4
+#define CAPT_FREEZE 5
+#define CAPT_RUN 6
 
 /* --------------------------------------------------*/
 
diff --git a/drivers/staging/media/atomisp/pci/mamoiada_params.h b/drivers/staging/media/atomisp/pci/mamoiada_params.h
index a4831f1e02dbab04d34672d0b1b84428b59f373e..afb8b70a164eab59f9aeccad80fefe624cefc4c9 100644
--- a/drivers/staging/media/atomisp/pci/mamoiada_params.h
+++ b/drivers/staging/media/atomisp/pci/mamoiada_params.h
@@ -8,195 +8,195 @@
 #define RTL_VERSION
 
 /* instruction pipeline depth */
-#define ISP_BRANCHDELAY                        5
+#define ISP_BRANCHDELAY 5
 
 /* bus */
-#define ISP_BUS_WIDTH                          32
-#define ISP_BUS_ADDR_WIDTH                     32
-#define ISP_BUS_BURST_SIZE                     1
+#define ISP_BUS_WIDTH 32
+#define ISP_BUS_ADDR_WIDTH 32
+#define ISP_BUS_BURST_SIZE 1
 
 /* data-path */
-#define ISP_SCALAR_WIDTH                       32
-#define ISP_SLICE_NELEMS                       4
-#define ISP_VEC_NELEMS                         64
-#define ISP_VEC_ELEMBITS                       14
-#define ISP_VEC_ELEM8BITS                      16
-#define ISP_CLONE_DATAPATH_IS_16               1
+#define ISP_SCALAR_WIDTH 32
+#define ISP_SLICE_NELEMS 4
+#define ISP_VEC_NELEMS 64
+#define ISP_VEC_ELEMBITS 14
+#define ISP_VEC_ELEM8BITS 16
+#define ISP_CLONE_DATAPATH_IS_16 1
 
 /* memories */
-#define ISP_DMEM_DEPTH                         4096
-#define ISP_DMEM_BSEL_DOWNSAMPLE               8
-#define ISP_VMEM_DEPTH                         3072
-#define ISP_VMEM_BSEL_DOWNSAMPLE               8
-#define ISP_VMEM_ELEMBITS                      14
-#define ISP_VMEM_ELEM_PRECISION                14
-#define ISP_PMEM_DEPTH                         2048
-#define ISP_PMEM_WIDTH                         640
-#define ISP_VAMEM_ADDRESS_BITS                 12
-#define ISP_VAMEM_ELEMBITS                     12
-#define ISP_VAMEM_DEPTH                        2048
-#define ISP_VAMEM_ALIGNMENT                    2
-#define ISP_VA_ADDRESS_WIDTH                   896
-#define ISP_VEC_VALSU_LATENCY                  ISP_VEC_NELEMS
-#define ISP_HIST_ADDRESS_BITS                  12
-#define ISP_HIST_ALIGNMENT                     4
-#define ISP_HIST_COMP_IN_PREC                  12
-#define ISP_HIST_DEPTH                         1024
-#define ISP_HIST_WIDTH                         24
-#define ISP_HIST_COMPONENTS                    4
+#define ISP_DMEM_DEPTH 4096
+#define ISP_DMEM_BSEL_DOWNSAMPLE 8
+#define ISP_VMEM_DEPTH 3072
+#define ISP_VMEM_BSEL_DOWNSAMPLE 8
+#define ISP_VMEM_ELEMBITS 14
+#define ISP_VMEM_ELEM_PRECISION 14
+#define ISP_PMEM_DEPTH 2048
+#define ISP_PMEM_WIDTH 640
+#define ISP_VAMEM_ADDRESS_BITS 12
+#define ISP_VAMEM_ELEMBITS 12
+#define ISP_VAMEM_DEPTH 2048
+#define ISP_VAMEM_ALIGNMENT 2
+#define ISP_VA_ADDRESS_WIDTH 896
+#define ISP_VEC_VALSU_LATENCY ISP_VEC_NELEMS
+#define ISP_HIST_ADDRESS_BITS 12
+#define ISP_HIST_ALIGNMENT 4
+#define ISP_HIST_COMP_IN_PREC 12
+#define ISP_HIST_DEPTH 1024
+#define ISP_HIST_WIDTH 24
+#define ISP_HIST_COMPONENTS 4
 
 /* program counter */
-#define ISP_PC_WIDTH                           13
+#define ISP_PC_WIDTH 13
 
 /* Template switches */
-#define ISP_SHIELD_INPUT_DMEM                  0
-#define ISP_SHIELD_OUTPUT_DMEM                 1
-#define ISP_SHIELD_INPUT_VMEM                  0
-#define ISP_SHIELD_OUTPUT_VMEM                 0
-#define ISP_SHIELD_INPUT_PMEM                  1
-#define ISP_SHIELD_OUTPUT_PMEM                 1
-#define ISP_SHIELD_INPUT_HIST                  1
-#define ISP_SHIELD_OUTPUT_HIST                 1
+#define ISP_SHIELD_INPUT_DMEM 0
+#define ISP_SHIELD_OUTPUT_DMEM 1
+#define ISP_SHIELD_INPUT_VMEM 0
+#define ISP_SHIELD_OUTPUT_VMEM 0
+#define ISP_SHIELD_INPUT_PMEM 1
+#define ISP_SHIELD_OUTPUT_PMEM 1
+#define ISP_SHIELD_INPUT_HIST 1
+#define ISP_SHIELD_OUTPUT_HIST 1
 /* When LUT is select the shielding is always on */
-#define ISP_SHIELD_INPUT_VAMEM                 1
-#define ISP_SHIELD_OUTPUT_VAMEM                1
+#define ISP_SHIELD_INPUT_VAMEM 1
+#define ISP_SHIELD_OUTPUT_VAMEM 1
 
-#define ISP_HAS_IRQ                            1
-#define ISP_HAS_SOFT_RESET                     1
-#define ISP_HAS_VEC_DIV                        0
-#define ISP_HAS_VFU_W_2O                       1
-#define ISP_HAS_DEINT3                         1
-#define ISP_HAS_LUT                            1
-#define ISP_HAS_HIST                           1
-#define ISP_HAS_VALSU                          1
-#define ISP_HAS_3rdVALSU                       1
-#define ISP_VRF1_HAS_2P                        1
+#define ISP_HAS_IRQ 1
+#define ISP_HAS_SOFT_RESET 1
+#define ISP_HAS_VEC_DIV 0
+#define ISP_HAS_VFU_W_2O 1
+#define ISP_HAS_DEINT3 1
+#define ISP_HAS_LUT 1
+#define ISP_HAS_HIST 1
+#define ISP_HAS_VALSU 1
+#define ISP_HAS_3rdVALSU 1
+#define ISP_VRF1_HAS_2P 1
 
-#define ISP_SRU_GUARDING                       1
-#define ISP_VLSU_GUARDING                      1
+#define ISP_SRU_GUARDING 1
+#define ISP_VLSU_GUARDING 1
 
-#define ISP_VRF_RAM			     1
-#define ISP_SRF_RAM			     1
+#define ISP_VRF_RAM 1
+#define ISP_SRF_RAM 1
 
-#define ISP_SPLIT_VMUL_VADD_IS                 0
-#define ISP_RFSPLIT_FPGA                       0
+#define ISP_SPLIT_VMUL_VADD_IS 0
+#define ISP_RFSPLIT_FPGA 0
 
 /* RSN or Bus pipelining */
-#define ISP_RSN_PIPE                           1
-#define ISP_VSF_BUS_PIPE                       0
+#define ISP_RSN_PIPE 1
+#define ISP_VSF_BUS_PIPE 0
 
 /* extra slave port to vmem */
-#define ISP_IF_VMEM                            0
-#define ISP_GDC_VMEM                           0
+#define ISP_IF_VMEM 0
+#define ISP_GDC_VMEM 0
 
 /* Streaming ports */
-#define ISP_IF                                 1
-#define ISP_IF_B                               1
-#define ISP_GDC                                1
-#define ISP_SCL                                1
-#define ISP_GPFIFO                             1
-#define ISP_SP                                 1
+#define ISP_IF 1
+#define ISP_IF_B 1
+#define ISP_GDC 1
+#define ISP_SCL 1
+#define ISP_GPFIFO 1
+#define ISP_SP 1
 
 /* Removing Issue Slot(s) */
-#define ISP_HAS_NOT_SIMD_IS2                   0
-#define ISP_HAS_NOT_SIMD_IS3                   0
-#define ISP_HAS_NOT_SIMD_IS4                   0
-#define ISP_HAS_NOT_SIMD_IS4_VADD              0
-#define ISP_HAS_NOT_SIMD_IS5                   0
-#define ISP_HAS_NOT_SIMD_IS6                   0
-#define ISP_HAS_NOT_SIMD_IS7                   0
-#define ISP_HAS_NOT_SIMD_IS8                   0
+#define ISP_HAS_NOT_SIMD_IS2 0
+#define ISP_HAS_NOT_SIMD_IS3 0
+#define ISP_HAS_NOT_SIMD_IS4 0
+#define ISP_HAS_NOT_SIMD_IS4_VADD 0
+#define ISP_HAS_NOT_SIMD_IS5 0
+#define ISP_HAS_NOT_SIMD_IS6 0
+#define ISP_HAS_NOT_SIMD_IS7 0
+#define ISP_HAS_NOT_SIMD_IS8 0
 
 /* ICache  */
-#define ISP_ICACHE                             1
-#define ISP_ICACHE_ONLY                        0
-#define ISP_ICACHE_PREFETCH                    1
-#define ISP_ICACHE_INDEX_BITS                  8
-#define ISP_ICACHE_SET_BITS                    5
-#define ISP_ICACHE_BLOCKS_PER_SET_BITS         1
+#define ISP_ICACHE 1
+#define ISP_ICACHE_ONLY 0
+#define ISP_ICACHE_PREFETCH 1
+#define ISP_ICACHE_INDEX_BITS 8
+#define ISP_ICACHE_SET_BITS 5
+#define ISP_ICACHE_BLOCKS_PER_SET_BITS 1
 
 /* Experimental Flags */
-#define ISP_EXP_1                              0
-#define ISP_EXP_2                              0
-#define ISP_EXP_3                              0
-#define ISP_EXP_4                              0
-#define ISP_EXP_5                              0
-#define ISP_EXP_6                              0
+#define ISP_EXP_1 0
+#define ISP_EXP_2 0
+#define ISP_EXP_3 0
+#define ISP_EXP_4 0
+#define ISP_EXP_5 0
+#define ISP_EXP_6 0
 
 /* Derived values */
-#define ISP_LOG2_PMEM_WIDTH                    10
-#define ISP_VEC_WIDTH                          896
-#define ISP_SLICE_WIDTH                        56
-#define ISP_VMEM_WIDTH                         896
-#define ISP_VMEM_ALIGN                         128
-#define ISP_SIMDLSU                            1
-#define ISP_LSU_IMM_BITS                       12
+#define ISP_LOG2_PMEM_WIDTH 10
+#define ISP_VEC_WIDTH 896
+#define ISP_SLICE_WIDTH 56
+#define ISP_VMEM_WIDTH 896
+#define ISP_VMEM_ALIGN 128
+#define ISP_SIMDLSU 1
+#define ISP_LSU_IMM_BITS 12
 
 /* convenient shortcuts for software*/
-#define ISP_NWAY                               ISP_VEC_NELEMS
-#define NBITS                                  ISP_VEC_ELEMBITS
+#define ISP_NWAY ISP_VEC_NELEMS
+#define NBITS ISP_VEC_ELEMBITS
 
-#define _isp_ceil_div(a, b)                     (((a) + (b) - 1) / (b))
+#define _isp_ceil_div(a, b) (((a) + (b)-1) / (b))
 
-#define ISP_VEC_ALIGN                          ISP_VMEM_ALIGN
+#define ISP_VEC_ALIGN ISP_VMEM_ALIGN
 
 /* register file sizes */
-#define ISP_RF0_SIZE        64
-#define ISP_RF1_SIZE        16
-#define ISP_RF2_SIZE        64
-#define ISP_RF3_SIZE        4
-#define ISP_RF4_SIZE        64
-#define ISP_RF5_SIZE        16
-#define ISP_RF6_SIZE        16
-#define ISP_RF7_SIZE        16
-#define ISP_RF8_SIZE        16
-#define ISP_RF9_SIZE        16
-#define ISP_RF10_SIZE       16
-#define ISP_RF11_SIZE       16
-
-#define ISP_SRF1_SIZE       4
-#define ISP_SRF2_SIZE       64
-#define ISP_SRF3_SIZE       64
-#define ISP_SRF4_SIZE       32
-#define ISP_SRF5_SIZE       64
-#define ISP_FRF0_SIZE       16
-#define ISP_FRF1_SIZE       4
-#define ISP_FRF2_SIZE       16
-#define ISP_FRF3_SIZE       4
-#define ISP_FRF4_SIZE       4
-#define ISP_FRF5_SIZE       8
-#define ISP_FRF6_SIZE       4
+#define ISP_RF0_SIZE 64
+#define ISP_RF1_SIZE 16
+#define ISP_RF2_SIZE 64
+#define ISP_RF3_SIZE 4
+#define ISP_RF4_SIZE 64
+#define ISP_RF5_SIZE 16
+#define ISP_RF6_SIZE 16
+#define ISP_RF7_SIZE 16
+#define ISP_RF8_SIZE 16
+#define ISP_RF9_SIZE 16
+#define ISP_RF10_SIZE 16
+#define ISP_RF11_SIZE 16
+
+#define ISP_SRF1_SIZE 4
+#define ISP_SRF2_SIZE 64
+#define ISP_SRF3_SIZE 64
+#define ISP_SRF4_SIZE 32
+#define ISP_SRF5_SIZE 64
+#define ISP_FRF0_SIZE 16
+#define ISP_FRF1_SIZE 4
+#define ISP_FRF2_SIZE 16
+#define ISP_FRF3_SIZE 4
+#define ISP_FRF4_SIZE 4
+#define ISP_FRF5_SIZE 8
+#define ISP_FRF6_SIZE 4
 /* register file read latency */
-#define ISP_VRF1_READ_LAT       1
-#define ISP_VRF2_READ_LAT       1
-#define ISP_VRF3_READ_LAT       1
-#define ISP_VRF4_READ_LAT       1
-#define ISP_VRF5_READ_LAT       1
-#define ISP_VRF6_READ_LAT       1
-#define ISP_VRF7_READ_LAT       1
-#define ISP_VRF8_READ_LAT       1
-#define ISP_SRF1_READ_LAT       1
-#define ISP_SRF2_READ_LAT       1
-#define ISP_SRF3_READ_LAT       1
-#define ISP_SRF4_READ_LAT       1
-#define ISP_SRF5_READ_LAT       1
-#define ISP_SRF5_READ_LAT       1
+#define ISP_VRF1_READ_LAT 1
+#define ISP_VRF2_READ_LAT 1
+#define ISP_VRF3_READ_LAT 1
+#define ISP_VRF4_READ_LAT 1
+#define ISP_VRF5_READ_LAT 1
+#define ISP_VRF6_READ_LAT 1
+#define ISP_VRF7_READ_LAT 1
+#define ISP_VRF8_READ_LAT 1
+#define ISP_SRF1_READ_LAT 1
+#define ISP_SRF2_READ_LAT 1
+#define ISP_SRF3_READ_LAT 1
+#define ISP_SRF4_READ_LAT 1
+#define ISP_SRF5_READ_LAT 1
+#define ISP_SRF5_READ_LAT 1
 /* immediate sizes */
-#define ISP_IS1_IMM_BITS        14
-#define ISP_IS2_IMM_BITS        13
-#define ISP_IS3_IMM_BITS        14
-#define ISP_IS4_IMM_BITS        14
-#define ISP_IS5_IMM_BITS        9
-#define ISP_IS6_IMM_BITS        16
-#define ISP_IS7_IMM_BITS        9
-#define ISP_IS8_IMM_BITS        16
-#define ISP_IS9_IMM_BITS        11
+#define ISP_IS1_IMM_BITS 14
+#define ISP_IS2_IMM_BITS 13
+#define ISP_IS3_IMM_BITS 14
+#define ISP_IS4_IMM_BITS 14
+#define ISP_IS5_IMM_BITS 9
+#define ISP_IS6_IMM_BITS 16
+#define ISP_IS7_IMM_BITS 9
+#define ISP_IS8_IMM_BITS 16
+#define ISP_IS9_IMM_BITS 11
 /* fifo depths */
-#define ISP_IF_FIFO_DEPTH         0
-#define ISP_IF_B_FIFO_DEPTH       0
-#define ISP_DMA_FIFO_DEPTH        0
-#define ISP_OF_FIFO_DEPTH         0
-#define ISP_GDC_FIFO_DEPTH        0
-#define ISP_SCL_FIFO_DEPTH        0
-#define ISP_GPFIFO_FIFO_DEPTH     0
-#define ISP_SP_FIFO_DEPTH         0
+#define ISP_IF_FIFO_DEPTH 0
+#define ISP_IF_B_FIFO_DEPTH 0
+#define ISP_DMA_FIFO_DEPTH 0
+#define ISP_OF_FIFO_DEPTH 0
+#define ISP_GDC_FIFO_DEPTH 0
+#define ISP_SCL_FIFO_DEPTH 0
+#define ISP_GPFIFO_FIFO_DEPTH 0
+#define ISP_SP_FIFO_DEPTH 0
diff --git a/drivers/staging/media/atomisp/pci/mmu/isp_mmu.c b/drivers/staging/media/atomisp/pci/mmu/isp_mmu.c
index 5193a7eb7d9fcaf3473dcadd115e906f7c9dbd43..c92fd0e49162d189e49d12bbb588892a46d8c315 100644
--- a/drivers/staging/media/atomisp/pci/mmu/isp_mmu.c
+++ b/drivers/staging/media/atomisp/pci/mmu/isp_mmu.c
@@ -12,8 +12,8 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/gfp.h>
-#include <linux/mm.h>		/* for GFP_ATOMIC */
-#include <linux/slab.h>		/* for kmalloc */
+#include <linux/mm.h> /* for GFP_ATOMIC */
+#include <linux/slab.h> /* for kmalloc */
 #include <linux/list.h>
 #include <linux/io.h>
 #include <linux/module.h>
@@ -41,7 +41,7 @@
  *
  * For any confusion, contact bin.gao@intel.com.
  */
-#define NR_PAGES_2GB	(SZ_2G / PAGE_SIZE)
+#define NR_PAGES_2GB (SZ_2G / PAGE_SIZE)
 
 static void free_mmu_map(struct isp_mmu *mmu, unsigned int start_isp_virt,
 			 unsigned int end_isp_virt);
@@ -53,8 +53,7 @@ static unsigned int atomisp_get_pte(phys_addr_t pt, unsigned int idx)
 	return *(pt_virt + idx);
 }
 
-static void atomisp_set_pte(phys_addr_t pt,
-			    unsigned int idx, unsigned int pte)
+static void atomisp_set_pte(phys_addr_t pt, unsigned int idx, unsigned int pte)
 {
 	unsigned int *pt_virt = phys_to_virt(pt);
 	*(pt_virt + idx) = pte;
@@ -65,14 +64,13 @@ static void *isp_pt_phys_to_virt(phys_addr_t phys)
 	return phys_to_virt(phys);
 }
 
-static phys_addr_t isp_pte_to_pgaddr(struct isp_mmu *mmu,
-				     unsigned int pte)
+static phys_addr_t isp_pte_to_pgaddr(struct isp_mmu *mmu, unsigned int pte)
 {
 	return mmu->driver->pte_to_phys(mmu, pte);
 }
 
 static unsigned int isp_pgaddr_to_pte_valid(struct isp_mmu *mmu,
-	phys_addr_t phys)
+					    phys_addr_t phys)
 {
 	unsigned int pte = mmu->driver->phys_to_pte(mmu, phys);
 
@@ -94,10 +92,10 @@ static phys_addr_t alloc_page_table(struct isp_mmu *mmu)
 	if (!virt)
 		return (phys_addr_t)NULL_PAGE;
 
-	/*
+		/*
 	 * we need a uncacheable page table.
 	 */
-#ifdef	CONFIG_X86
+#ifdef CONFIG_X86
 	set_memory_uc((unsigned long)virt, 1);
 #endif
 
@@ -121,64 +119,61 @@ static void free_page_table(struct isp_mmu *mmu, phys_addr_t page)
 	 */
 	virt = phys_to_virt(page);
 
-#ifdef	CONFIG_X86
+#ifdef CONFIG_X86
 	set_memory_wb((unsigned long)virt, 1);
 #endif
 
 	free_page((unsigned long)virt);
 }
 
-static void mmu_remap_error(struct isp_mmu *mmu,
-			    phys_addr_t l1_pt, unsigned int l1_idx,
-			    phys_addr_t l2_pt, unsigned int l2_idx,
-			    unsigned int isp_virt, phys_addr_t old_phys,
-			    phys_addr_t new_phys)
+static void mmu_remap_error(struct isp_mmu *mmu, phys_addr_t l1_pt,
+			    unsigned int l1_idx, phys_addr_t l2_pt,
+			    unsigned int l2_idx, unsigned int isp_virt,
+			    phys_addr_t old_phys, phys_addr_t new_phys)
 {
-	dev_err(atomisp_dev, "address remap:\n\n"
+	dev_err(atomisp_dev,
+		"address remap:\n\n"
 		"\tL1 PT: virt = %p, phys = 0x%llx, idx = %d\n"
 		"\tL2 PT: virt = %p, phys = 0x%llx, idx = %d\n"
 		"\told: isp_virt = 0x%x, phys = 0x%llx\n"
 		"\tnew: isp_virt = 0x%x, phys = 0x%llx\n",
-		isp_pt_phys_to_virt(l1_pt),
-		(u64)l1_pt, l1_idx,
-		isp_pt_phys_to_virt(l2_pt),
-		(u64)l2_pt, l2_idx, isp_virt,
-		(u64)old_phys, isp_virt,
-		(u64)new_phys);
+		isp_pt_phys_to_virt(l1_pt), (u64)l1_pt, l1_idx,
+		isp_pt_phys_to_virt(l2_pt), (u64)l2_pt, l2_idx, isp_virt,
+		(u64)old_phys, isp_virt, (u64)new_phys);
 }
 
-static void mmu_unmap_l2_pte_error(struct isp_mmu *mmu,
-				   phys_addr_t l1_pt, unsigned int l1_idx,
-				   phys_addr_t l2_pt, unsigned int l2_idx,
-				   unsigned int isp_virt, unsigned int pte)
+static void mmu_unmap_l2_pte_error(struct isp_mmu *mmu, phys_addr_t l1_pt,
+				   unsigned int l1_idx, phys_addr_t l2_pt,
+				   unsigned int l2_idx, unsigned int isp_virt,
+				   unsigned int pte)
 {
-	dev_err(atomisp_dev, "unmap invalid L2 pte:\n\n"
+	dev_err(atomisp_dev,
+		"unmap invalid L2 pte:\n\n"
 		"\tL1 PT: virt = %p, phys = 0x%llx, idx = %d\n"
 		"\tL2 PT: virt = %p, phys = 0x%llx, idx = %d\n"
 		"\tisp_virt = 0x%x, pte(page phys) = 0x%x\n",
-		isp_pt_phys_to_virt(l1_pt),
-		(u64)l1_pt, l1_idx,
-		isp_pt_phys_to_virt(l2_pt),
-		(u64)l2_pt, l2_idx, isp_virt,
-		pte);
+		isp_pt_phys_to_virt(l1_pt), (u64)l1_pt, l1_idx,
+		isp_pt_phys_to_virt(l2_pt), (u64)l2_pt, l2_idx, isp_virt, pte);
 }
 
-static void mmu_unmap_l1_pte_error(struct isp_mmu *mmu,
-				   phys_addr_t l1_pt, unsigned int l1_idx,
-				   unsigned int isp_virt, unsigned int pte)
+static void mmu_unmap_l1_pte_error(struct isp_mmu *mmu, phys_addr_t l1_pt,
+				   unsigned int l1_idx, unsigned int isp_virt,
+				   unsigned int pte)
 {
-	dev_err(atomisp_dev, "unmap invalid L1 pte (L2 PT):\n\n"
+	dev_err(atomisp_dev,
+		"unmap invalid L1 pte (L2 PT):\n\n"
 		"\tL1 PT: virt = %p, phys = 0x%llx, idx = %d\n"
 		"\tisp_virt = 0x%x, l1_pte(L2 PT) = 0x%x\n",
-		isp_pt_phys_to_virt(l1_pt),
-		(u64)l1_pt, l1_idx, (unsigned int)isp_virt,
-		pte);
+		isp_pt_phys_to_virt(l1_pt), (u64)l1_pt, l1_idx,
+		(unsigned int)isp_virt, pte);
 }
 
 static void mmu_unmap_l1_pt_error(struct isp_mmu *mmu, unsigned int pte)
 {
-	dev_err(atomisp_dev, "unmap invalid L1PT:\n\n"
-		"L1PT = 0x%x\n", (unsigned int)pte);
+	dev_err(atomisp_dev,
+		"unmap invalid L1PT:\n\n"
+		"L1PT = 0x%x\n",
+		(unsigned int)pte);
 }
 
 /*
@@ -206,8 +201,8 @@ static int mmu_l2_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
 		pte = atomisp_get_pte(l2_pt, idx);
 
 		if (ISP_PTE_VALID(mmu, pte)) {
-			mmu_remap_error(mmu, l1_pt, l1_idx,
-					l2_pt, idx, ptr, pte, phys);
+			mmu_remap_error(mmu, l1_pt, l1_idx, l2_pt, idx, ptr,
+					pte, phys);
 
 			/* free all mapped pages */
 			free_mmu_map(mmu, start, ptr);
@@ -231,8 +226,7 @@ static int mmu_l2_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
  * address
  */
 static int mmu_l1_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
-		      unsigned int start, unsigned int end,
-		      phys_addr_t phys)
+		      unsigned int start, unsigned int end, phys_addr_t phys)
 {
 	phys_addr_t l2_pt;
 	unsigned int ptr, l1_aligned;
@@ -275,13 +269,13 @@ static int mmu_l1_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
 		l1_aligned = (ptr & ISP_PAGE_MASK) + (1U << ISP_L1PT_OFFSET);
 
 		if (l1_aligned < end) {
-			ret = mmu_l2_map(mmu, l1_pt, idx,
-					 l2_pt, ptr, l1_aligned, phys);
+			ret = mmu_l2_map(mmu, l1_pt, idx, l2_pt, ptr,
+					 l1_aligned, phys);
 			phys += (l1_aligned - ptr);
 			ptr = l1_aligned;
 		} else {
-			ret = mmu_l2_map(mmu, l1_pt, idx,
-					 l2_pt, ptr, end, phys);
+			ret = mmu_l2_map(mmu, l1_pt, idx, l2_pt, ptr, end,
+					 phys);
 			phys += (end - ptr);
 			ptr = end;
 		}
@@ -303,8 +297,8 @@ static int mmu_l1_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
  * Update page table according to isp virtual address and page physical
  * address
  */
-static int mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
-		   phys_addr_t phys, unsigned int pgnr)
+static int mmu_map(struct isp_mmu *mmu, unsigned int isp_virt, phys_addr_t phys,
+		   unsigned int pgnr)
 {
 	unsigned int start, end;
 	phys_addr_t l1_pt;
@@ -332,7 +326,7 @@ static int mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
 
 	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
 
-	start = (isp_virt) & ISP_PAGE_MASK;
+	start = (isp_virt)&ISP_PAGE_MASK;
 	end = start + (pgnr << ISP_PAGE_OFFSET);
 	phys &= ISP_PAGE_MASK;
 
@@ -369,8 +363,8 @@ static void mmu_l2_unmap(struct isp_mmu *mmu, phys_addr_t l1_pt,
 		pte = atomisp_get_pte(l2_pt, idx);
 
 		if (!ISP_PTE_VALID(mmu, pte))
-			mmu_unmap_l2_pte_error(mmu, l1_pt, l1_idx,
-					       l2_pt, idx, ptr, pte);
+			mmu_unmap_l2_pte_error(mmu, l1_pt, l1_idx, l2_pt, idx,
+					       ptr, pte);
 
 		atomisp_set_pte(l2_pt, idx, mmu->driver->null_pte);
 		mmu->l2_pgt_refcount[l1_idx]--;
@@ -449,7 +443,7 @@ static void mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
 
 	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
 
-	start = (isp_virt) & ISP_PAGE_MASK;
+	start = (isp_virt)&ISP_PAGE_MASK;
 	end = start + (pgnr << ISP_PAGE_OFFSET);
 
 	mmu_l1_unmap(mmu, l1_pt, start, end);
@@ -466,14 +460,14 @@ static void free_mmu_map(struct isp_mmu *mmu, unsigned int start_isp_virt,
 	unsigned int pgnr;
 	unsigned int start, end;
 
-	start = (start_isp_virt) & ISP_PAGE_MASK;
-	end = (end_isp_virt) & ISP_PAGE_MASK;
+	start = (start_isp_virt)&ISP_PAGE_MASK;
+	end = (end_isp_virt)&ISP_PAGE_MASK;
 	pgnr = (end - start) >> ISP_PAGE_OFFSET;
 	mmu_unmap(mmu, start, pgnr);
 }
 
-int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
-		phys_addr_t phys, unsigned int pgnr)
+int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt, phys_addr_t phys,
+		unsigned int pgnr)
 {
 	return mmu_map(mmu, isp_virt, phys, pgnr);
 }
@@ -485,8 +479,8 @@ void isp_mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
 }
 
 static void isp_mmu_flush_tlb_range_default(struct isp_mmu *mmu,
-	unsigned int start,
-	unsigned int size)
+					    unsigned int start,
+					    unsigned int size)
 {
 	isp_mmu_flush_tlb(mmu);
 }
@@ -494,9 +488,9 @@ static void isp_mmu_flush_tlb_range_default(struct isp_mmu *mmu,
 /*MMU init for internal structure*/
 int isp_mmu_init(struct isp_mmu *mmu, struct isp_mmu_client *driver)
 {
-	if (!mmu)		/* error */
+	if (!mmu) /* error */
 		return -EINVAL;
-	if (!driver)		/* error */
+	if (!driver) /* error */
 		return -EINVAL;
 
 	if (!driver->name)
diff --git a/drivers/staging/media/atomisp/pci/mmu/sh_mmu_mrfld.c b/drivers/staging/media/atomisp/pci/mmu/sh_mmu_mrfld.c
index c9890892c8aadd4f0a78158563ce5d1263966659..da19f29b07a7170b583aab9ac7cebc49eb4ebe4a 100644
--- a/drivers/staging/media/atomisp/pci/mmu/sh_mmu_mrfld.c
+++ b/drivers/staging/media/atomisp/pci/mmu/sh_mmu_mrfld.c
@@ -11,28 +11,25 @@
 #include "mmu/sh_mmu_mrfld.h"
 #include "atomisp_compat.h"
 
-#define MERR_VALID_PTE_MASK	0x80000000
+#define MERR_VALID_PTE_MASK 0x80000000
 
 /*
  * include SH header file here
  */
 
-static unsigned int sh_phys_to_pte(struct isp_mmu *mmu,
-				   phys_addr_t phys)
+static unsigned int sh_phys_to_pte(struct isp_mmu *mmu, phys_addr_t phys)
 {
 	return phys >> ISP_PAGE_OFFSET;
 }
 
-static phys_addr_t sh_pte_to_phys(struct isp_mmu *mmu,
-				  unsigned int pte)
+static phys_addr_t sh_pte_to_phys(struct isp_mmu *mmu, unsigned int pte)
 {
 	unsigned int mask = mmu->driver->pte_valid_mask;
 
 	return (phys_addr_t)((pte & ~mask) << ISP_PAGE_OFFSET);
 }
 
-static unsigned int sh_get_pd_base(struct isp_mmu *mmu,
-				   phys_addr_t phys)
+static unsigned int sh_get_pd_base(struct isp_mmu *mmu, phys_addr_t phys)
 {
 	unsigned int pte = sh_phys_to_pte(mmu, phys);
 
diff --git a/drivers/staging/media/atomisp/pci/mmu_defs.h b/drivers/staging/media/atomisp/pci/mmu_defs.h
index 6a26f2cad52a1b5ccefd50099b19cea74b72aa33..74da73122311a455d3a2a16b9da5dbab4ea4f088 100644
--- a/drivers/staging/media/atomisp/pci/mmu_defs.h
+++ b/drivers/staging/media/atomisp/pci/mmu_defs.h
@@ -7,7 +7,7 @@
 #ifndef _mmu_defs_h
 #define _mmu_defs_h
 
-#define _HRT_MMU_INVALIDATE_TLB_REG_IDX          0
+#define _HRT_MMU_INVALIDATE_TLB_REG_IDX 0
 #define _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX 1
 
 #define _HRT_MMU_REG_ALIGN 4
diff --git a/drivers/staging/media/atomisp/pci/runtime/binary/interface/ia_css_binary.h b/drivers/staging/media/atomisp/pci/runtime/binary/interface/ia_css_binary.h
index 9c682f2ecbb2c6169b978d83087152abf241a3d6..b2f9aaf5c7c71818c46b6a7c3dd34605d485e1dd 100644
--- a/drivers/staging/media/atomisp/pci/runtime/binary/interface/ia_css_binary.h
+++ b/drivers/staging/media/atomisp/pci/runtime/binary/interface/ia_css_binary.h
@@ -19,32 +19,33 @@ Copyright (c) 2010 - 2015, Intel Corporation.
 
 /* The binary mode is used in pre-processor expressions so we cannot
  * use an enum here. */
-#define IA_CSS_BINARY_MODE_COPY       0
-#define IA_CSS_BINARY_MODE_PREVIEW    1
-#define IA_CSS_BINARY_MODE_PRIMARY    2
-#define IA_CSS_BINARY_MODE_VIDEO      3
-#define IA_CSS_BINARY_MODE_PRE_ISP    4
-#define IA_CSS_BINARY_MODE_GDC        5
-#define IA_CSS_BINARY_MODE_POST_ISP   6
-#define IA_CSS_BINARY_MODE_ANR        7
+#define IA_CSS_BINARY_MODE_COPY 0
+#define IA_CSS_BINARY_MODE_PREVIEW 1
+#define IA_CSS_BINARY_MODE_PRIMARY 2
+#define IA_CSS_BINARY_MODE_VIDEO 3
+#define IA_CSS_BINARY_MODE_PRE_ISP 4
+#define IA_CSS_BINARY_MODE_GDC 5
+#define IA_CSS_BINARY_MODE_POST_ISP 6
+#define IA_CSS_BINARY_MODE_ANR 7
 #define IA_CSS_BINARY_MODE_CAPTURE_PP 8
-#define IA_CSS_BINARY_MODE_VF_PP      9
-#define IA_CSS_BINARY_MODE_PRE_DE     10
-#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE0    11
-#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE1    12
-#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE2    13
-#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE3    14
-#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE4    15
-#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE5    16
-#define IA_CSS_BINARY_NUM_MODES       17
+#define IA_CSS_BINARY_MODE_VF_PP 9
+#define IA_CSS_BINARY_MODE_PRE_DE 10
+#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE0 11
+#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE1 12
+#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE2 13
+#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE3 14
+#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE4 15
+#define IA_CSS_BINARY_MODE_PRIMARY_HQ_STAGE5 16
+#define IA_CSS_BINARY_NUM_MODES 17
 
 #define MAX_NUM_PRIMARY_STAGES 6
-#define NUM_PRIMARY_HQ_STAGES  6  /* number of primary stages for ISP2.6.1 high quality pipe */
-#define NUM_PRIMARY_STAGES     1  /* number of primary satges for ISP1/ISP2.2 pipe */
+#define NUM_PRIMARY_HQ_STAGES \
+	6 /* number of primary stages for ISP2.6.1 high quality pipe */
+#define NUM_PRIMARY_STAGES 1 /* number of primary satges for ISP1/ISP2.2 pipe */
 
 /* Indicate where binaries can read input from */
-#define IA_CSS_BINARY_INPUT_SENSOR   0
-#define IA_CSS_BINARY_INPUT_MEMORY   1
+#define IA_CSS_BINARY_INPUT_SENSOR 0
+#define IA_CSS_BINARY_INPUT_MEMORY 1
 #define IA_CSS_BINARY_INPUT_VARIABLE 2
 
 /* Should be included without the path.
@@ -91,7 +92,7 @@ struct ia_css_binary_descr {
 	bool enable_capture_pp_bli;
 	struct ia_css_resolution dvs_env;
 	enum atomisp_input_format stream_format;
-	struct ia_css_frame_info *in_info;		/* the info of the input-frame with the
+	struct ia_css_frame_info *in_info; /* the info of the input-frame with the
 							   ISP required resolution. */
 	struct ia_css_frame_info *bds_out_info;
 	struct ia_css_frame_info *out_info[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -109,61 +110,56 @@ struct ia_css_binary {
 	struct ia_css_frame_info out_frame_info[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
 	struct ia_css_resolution effective_in_frame_res;
 	struct ia_css_frame_info vf_frame_info;
-	int                      input_buf_vectors;
-	int                      deci_factor_log2;
-	int                      vf_downscale_log2;
-	int                      s3atbl_width;
-	int                      s3atbl_height;
-	int                      s3atbl_isp_width;
-	int                      s3atbl_isp_height;
-	unsigned int             morph_tbl_width;
-	unsigned int             morph_tbl_aligned_width;
-	unsigned int             morph_tbl_height;
-	int                      sctbl_width_per_color;
-	int                      sctbl_aligned_width_per_color;
-	int                      sctbl_height;
-	struct ia_css_sdis_info	 dis;
+	int input_buf_vectors;
+	int deci_factor_log2;
+	int vf_downscale_log2;
+	int s3atbl_width;
+	int s3atbl_height;
+	int s3atbl_isp_width;
+	int s3atbl_isp_height;
+	unsigned int morph_tbl_width;
+	unsigned int morph_tbl_aligned_width;
+	unsigned int morph_tbl_height;
+	int sctbl_width_per_color;
+	int sctbl_aligned_width_per_color;
+	int sctbl_height;
+	struct ia_css_sdis_info dis;
 	struct ia_css_resolution dvs_envelope;
-	bool                     online;
-	unsigned int             uds_xc;
-	unsigned int             uds_yc;
-	unsigned int             left_padding;
+	bool online;
+	unsigned int uds_xc;
+	unsigned int uds_yc;
+	unsigned int left_padding;
 	struct sh_css_binary_metrics metrics;
 	struct ia_css_isp_param_host_segments mem_params;
-	struct ia_css_isp_param_css_segments  css_params;
+	struct ia_css_isp_param_css_segments css_params;
 };
 
-#define IA_CSS_BINARY_DEFAULT_SETTINGS { \
-	.input_format		= ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY, \
-	.in_frame_info		= IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
-	.internal_frame_info	= IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
-	.out_frame_info		= {IA_CSS_BINARY_DEFAULT_FRAME_INFO}, \
-	.vf_frame_info		= IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
-}
-
-int
-ia_css_binary_init_infos(void);
-
-int
-ia_css_binary_uninit(void);
-
-int
-ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
-			bool online,
-			bool two_ppc,
-			enum atomisp_input_format stream_format,
-			const struct ia_css_frame_info *in_info,
-			const struct ia_css_frame_info *bds_out_info,
-			const struct ia_css_frame_info *out_info[],
-			const struct ia_css_frame_info *vf_info,
-			struct ia_css_binary *binary,
-			struct ia_css_resolution *dvs_env,
-			int stream_config_left_padding,
-			bool accelerator);
-
-int
-ia_css_binary_find(struct ia_css_binary_descr *descr,
-		   struct ia_css_binary *binary);
+#define IA_CSS_BINARY_DEFAULT_SETTINGS                                   \
+	{                                                                \
+		.input_format = ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY,    \
+		.in_frame_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO,       \
+		.internal_frame_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
+		.out_frame_info = { IA_CSS_BINARY_DEFAULT_FRAME_INFO },  \
+		.vf_frame_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO,       \
+	}
+
+int ia_css_binary_init_infos(void);
+
+int ia_css_binary_uninit(void);
+
+int ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
+			    bool online, bool two_ppc,
+			    enum atomisp_input_format stream_format,
+			    const struct ia_css_frame_info *in_info,
+			    const struct ia_css_frame_info *bds_out_info,
+			    const struct ia_css_frame_info *out_info[],
+			    const struct ia_css_frame_info *vf_info,
+			    struct ia_css_binary *binary,
+			    struct ia_css_resolution *dvs_env,
+			    int stream_config_left_padding, bool accelerator);
+
+int ia_css_binary_find(struct ia_css_binary_descr *descr,
+		       struct ia_css_binary *binary);
 
 /* @brief Get the shading information of the specified shading correction type.
  *
@@ -179,38 +175,31 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
  *		The shading information related to ISP (but, not necessary as API) is stored in the pipe_config.
  * @return	0 or error code upon error.
  */
-int
-ia_css_binary_get_shading_info(const struct ia_css_binary *binary,
-			       enum ia_css_shading_correction_type type,
-			       unsigned int required_bds_factor,
-			       const struct ia_css_stream_config *stream_config,
-			       struct ia_css_shading_info *shading_info,
-			       struct ia_css_pipe_config *pipe_config);
-
-int
-ia_css_binary_3a_grid_info(const struct ia_css_binary *binary,
-			   struct ia_css_grid_info *info,
-			   struct ia_css_pipe *pipe);
-
-void
-ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
-			    struct ia_css_grid_info *info,
-			    struct ia_css_pipe *pipe);
-
-void
-ia_css_binary_dvs_stat_grid_info(
-    const struct ia_css_binary *binary,
-    struct ia_css_grid_info *info,
-    struct ia_css_pipe *pipe);
-
-unsigned
-ia_css_binary_max_vf_width(void);
-
-void
-ia_css_binary_destroy_isp_parameters(struct ia_css_binary *binary);
-
-void
-ia_css_binary_get_isp_binaries(struct ia_css_binary_xinfo **binaries,
-			       uint32_t *num_isp_binaries);
+int ia_css_binary_get_shading_info(
+	const struct ia_css_binary *binary,
+	enum ia_css_shading_correction_type type,
+	unsigned int required_bds_factor,
+	const struct ia_css_stream_config *stream_config,
+	struct ia_css_shading_info *shading_info,
+	struct ia_css_pipe_config *pipe_config);
+
+int ia_css_binary_3a_grid_info(const struct ia_css_binary *binary,
+			       struct ia_css_grid_info *info,
+			       struct ia_css_pipe *pipe);
+
+void ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
+				 struct ia_css_grid_info *info,
+				 struct ia_css_pipe *pipe);
+
+void ia_css_binary_dvs_stat_grid_info(const struct ia_css_binary *binary,
+				      struct ia_css_grid_info *info,
+				      struct ia_css_pipe *pipe);
+
+unsigned ia_css_binary_max_vf_width(void);
+
+void ia_css_binary_destroy_isp_parameters(struct ia_css_binary *binary);
+
+void ia_css_binary_get_isp_binaries(struct ia_css_binary_xinfo **binaries,
+				    uint32_t *num_isp_binaries);
 
 #endif /* _IA_CSS_BINARY_H_ */
diff --git a/drivers/staging/media/atomisp/pci/runtime/binary/src/binary.c b/drivers/staging/media/atomisp/pci/runtime/binary/src/binary.c
index af93ca96747c43c32e6dfa072151b786d9710377..059bf51c5da0b8728ec2338d871e7abc496279ce 100644
--- a/drivers/staging/media/atomisp/pci/runtime/binary/src/binary.c
+++ b/drivers/staging/media/atomisp/pci/runtime/binary/src/binary.c
@@ -7,11 +7,11 @@
 #include <linux/math.h>
 
 #include <math_support.h>
-#include <gdc_device.h>	/* HR_GDC_N */
+#include <gdc_device.h> /* HR_GDC_N */
 
 #include "hmm.h"
 
-#include "isp.h"	/* ISP_VEC_NELEMS */
+#include "isp.h" /* ISP_VEC_NELEMS */
 
 #include "ia_css_binary.h"
 #include "ia_css_debug.h"
@@ -28,25 +28,27 @@
 #include "vf/vf_1.0/ia_css_vf.host.h"
 #include "sc/sc_1.0/ia_css_sc.host.h"
 #include "sdis/sdis_1.0/ia_css_sdis.host.h"
-#include "fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h"	/* FRAC_ACC */
+#include "fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h" /* FRAC_ACC */
 
 #include "camera/pipe/interface/ia_css_pipe_binarydesc.h"
 
 #include "assert_support.h"
 
 static struct ia_css_binary_xinfo *all_binaries; /* ISP binaries only (no SP) */
-static struct ia_css_binary_xinfo
-	*binary_infos[IA_CSS_BINARY_NUM_MODES] = { NULL, };
+static struct ia_css_binary_xinfo *binary_infos[IA_CSS_BINARY_NUM_MODES] = {
+	NULL,
+};
 
-static void
-ia_css_binary_dvs_env(const struct ia_css_binary_info *info,
-		      const struct ia_css_resolution *dvs_env,
-		      struct ia_css_resolution *binary_dvs_env)
+static void ia_css_binary_dvs_env(const struct ia_css_binary_info *info,
+				  const struct ia_css_resolution *dvs_env,
+				  struct ia_css_resolution *binary_dvs_env)
 {
 	if (info->enable.dvs_envelope) {
 		assert(dvs_env);
-		binary_dvs_env->width  = max(dvs_env->width, SH_CSS_MIN_DVS_ENVELOPE);
-		binary_dvs_env->height = max(dvs_env->height, SH_CSS_MIN_DVS_ENVELOPE);
+		binary_dvs_env->width =
+			max(dvs_env->width, SH_CSS_MIN_DVS_ENVELOPE);
+		binary_dvs_env->height =
+			max(dvs_env->height, SH_CSS_MIN_DVS_ENVELOPE);
 	}
 }
 
@@ -58,8 +60,7 @@ ia_css_binary_internal_res(const struct ia_css_frame_info *in_info,
 			   const struct ia_css_binary_info *info,
 			   struct ia_css_resolution *internal_res)
 {
-	unsigned int isp_tmp_internal_width = 0,
-		     isp_tmp_internal_height = 0;
+	unsigned int isp_tmp_internal_width = 0, isp_tmp_internal_height = 0;
 	bool binary_supports_yuv_ds = info->enable.ds & 2;
 	struct ia_css_resolution binary_dvs_env;
 
@@ -69,10 +70,12 @@ ia_css_binary_internal_res(const struct ia_css_frame_info *in_info,
 
 	if (binary_supports_yuv_ds) {
 		if (in_info) {
-			isp_tmp_internal_width = in_info->res.width
-						 + info->pipeline.left_cropping + binary_dvs_env.width;
-			isp_tmp_internal_height = in_info->res.height
-						  + info->pipeline.top_cropping + binary_dvs_env.height;
+			isp_tmp_internal_width = in_info->res.width +
+						 info->pipeline.left_cropping +
+						 binary_dvs_env.width;
+			isp_tmp_internal_height = in_info->res.height +
+						  info->pipeline.top_cropping +
+						  binary_dvs_env.height;
 		}
 	} else if ((bds_out_info) && (out_info) &&
 		   /* TODO: hack to make video_us case work. this should be reverted after
@@ -89,33 +92,32 @@ ia_css_binary_internal_res(const struct ia_css_frame_info *in_info,
 
 	/* We first calculate the resolutions used by the ISP. After that,
 	 * we use those resolutions to compute sizes for tables etc. */
-	internal_res->width = __ISP_INTERNAL_WIDTH(isp_tmp_internal_width,
-			      (int)binary_dvs_env.width,
-			      info->pipeline.left_cropping, info->pipeline.mode,
-			      info->pipeline.c_subsampling,
-			      info->output.num_chunks, info->pipeline.pipelining);
-	internal_res->height = __ISP_INTERNAL_HEIGHT(isp_tmp_internal_height,
-			       info->pipeline.top_cropping,
-			       binary_dvs_env.height);
+	internal_res->width = __ISP_INTERNAL_WIDTH(
+		isp_tmp_internal_width, (int)binary_dvs_env.width,
+		info->pipeline.left_cropping, info->pipeline.mode,
+		info->pipeline.c_subsampling, info->output.num_chunks,
+		info->pipeline.pipelining);
+	internal_res->height = __ISP_INTERNAL_HEIGHT(
+		isp_tmp_internal_height, info->pipeline.top_cropping,
+		binary_dvs_env.height);
 }
 
 /* Computation results of the origin coordinate of bayer on the shading table. */
 struct sh_css_shading_table_bayer_origin_compute_results {
-	u32 bayer_scale_hor_ratio_in;	/* Horizontal ratio (in) of bayer scaling. */
-	u32 bayer_scale_hor_ratio_out;	/* Horizontal ratio (out) of bayer scaling. */
-	u32 bayer_scale_ver_ratio_in;	/* Vertical ratio (in) of bayer scaling. */
-	u32 bayer_scale_ver_ratio_out;	/* Vertical ratio (out) of bayer scaling. */
+	u32 bayer_scale_hor_ratio_in; /* Horizontal ratio (in) of bayer scaling. */
+	u32 bayer_scale_hor_ratio_out; /* Horizontal ratio (out) of bayer scaling. */
+	u32 bayer_scale_ver_ratio_in; /* Vertical ratio (in) of bayer scaling. */
+	u32 bayer_scale_ver_ratio_out; /* Vertical ratio (out) of bayer scaling. */
 	u32 sc_bayer_origin_x_bqs_on_shading_table; /* X coordinate (in bqs) of bayer origin on shading table. */
 	u32 sc_bayer_origin_y_bqs_on_shading_table; /* Y coordinate (in bqs) of bayer origin on shading table. */
 };
 
 /* Get the requirements for the shading correction. */
-static int
-ia_css_binary_compute_shading_table_bayer_origin(
-    const struct ia_css_binary *binary,				/* [in] */
-    unsigned int required_bds_factor,				/* [in] */
-    const struct ia_css_stream_config *stream_config,		/* [in] */
-    struct sh_css_shading_table_bayer_origin_compute_results *res)	/* [out] */
+static int ia_css_binary_compute_shading_table_bayer_origin(
+	const struct ia_css_binary *binary, /* [in] */
+	unsigned int required_bds_factor, /* [in] */
+	const struct ia_css_stream_config *stream_config, /* [in] */
+	struct sh_css_shading_table_bayer_origin_compute_results *res) /* [out] */
 {
 	int err;
 
@@ -123,23 +125,23 @@ ia_css_binary_compute_shading_table_bayer_origin(
 	struct u32_fract bds;
 
 	/* Left padding set by InputFormatter. */
-	unsigned int left_padding_bqs;			/* in bqs */
+	unsigned int left_padding_bqs; /* in bqs */
 
 	/* Flag for the NEED_BDS_FACTOR_2_00 macro defined in isp kernels. */
 	unsigned int need_bds_factor_2_00;
 
 	/* Left padding adjusted inside the isp. */
-	unsigned int left_padding_adjusted_bqs;		/* in bqs */
+	unsigned int left_padding_adjusted_bqs; /* in bqs */
 
 	/* Bad pixels caused by filters.
 	NxN-filter (before/after bayer scaling) moves the image position
 	to right/bottom directions by a few pixels.
 	It causes bad pixels at left/top sides,
 	and effective bayer size decreases. */
-	unsigned int bad_bqs_on_left_before_bs;	/* in bqs */
-	unsigned int bad_bqs_on_left_after_bs;	/* in bqs */
-	unsigned int bad_bqs_on_top_before_bs;	/* in bqs */
-	unsigned int bad_bqs_on_top_after_bs;	/* in bqs */
+	unsigned int bad_bqs_on_left_before_bs; /* in bqs */
+	unsigned int bad_bqs_on_left_after_bs; /* in bqs */
+	unsigned int bad_bqs_on_top_before_bs; /* in bqs */
+	unsigned int bad_bqs_on_top_after_bs; /* in bqs */
 
 	/* Get the rational fraction of bayer downscaling factor. */
 	err = sh_css_bds_factor_get_fract(required_bds_factor, &bds);
@@ -150,8 +152,9 @@ ia_css_binary_compute_shading_table_bayer_origin(
 	if (stream_config->left_padding == -1)
 		left_padding_bqs = _ISP_BQS(binary->left_padding);
 	else
-		left_padding_bqs = (unsigned int)((int)ISP_VEC_NELEMS
-				   - _ISP_BQS(stream_config->left_padding));
+		left_padding_bqs =
+			(unsigned int)((int)ISP_VEC_NELEMS -
+				       _ISP_BQS(stream_config->left_padding));
 
 	/* Set the left padding adjusted inside the isp.
 	When bds_factor 2.00 is needed, some padding is added to left_padding
@@ -159,15 +162,16 @@ ia_css_binary_compute_shading_table_bayer_origin(
 	(Hopefully, left_crop/left_padding/top_crop should be defined in css
 	appropriately, depending on bds_factor.)
 	*/
-	need_bds_factor_2_00 = ((binary->info->sp.bds.supported_bds_factors &
-				(PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_2_00) |
-				 PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_2_50) |
-				 PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_3_00) |
-				 PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_4_00) |
-				 PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_4_50) |
-				 PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_5_00) |
-				 PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_6_00) |
-				 PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_8_00))) != 0);
+	need_bds_factor_2_00 =
+		((binary->info->sp.bds.supported_bds_factors &
+		  (PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_2_00) |
+		   PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_2_50) |
+		   PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_3_00) |
+		   PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_4_00) |
+		   PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_4_50) |
+		   PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_5_00) |
+		   PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_6_00) |
+		   PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_8_00))) != 0);
 
 	if (need_bds_factor_2_00 && binary->info->sp.pipeline.left_cropping > 0)
 		left_padding_adjusted_bqs = left_padding_bqs + ISP_VEC_NELEMS;
@@ -202,29 +206,33 @@ ia_css_binary_compute_shading_table_bayer_origin(
 	/* Calculate the origin of bayer (real sensor data area)
 	located on the shading table during the shading correction. */
 	res->sc_bayer_origin_x_bqs_on_shading_table =
-		((left_padding_adjusted_bqs + bad_bqs_on_left_before_bs)
-		* bds.denominator + bds.numerator / 2) / bds.numerator
-		+ bad_bqs_on_left_after_bs;
+		((left_padding_adjusted_bqs + bad_bqs_on_left_before_bs) *
+			 bds.denominator +
+		 bds.numerator / 2) /
+			bds.numerator +
+		bad_bqs_on_left_after_bs;
 	/* "+ bds.numerator / 2": rounding for division by bds.numerator */
 	res->sc_bayer_origin_y_bqs_on_shading_table =
-		(bad_bqs_on_top_before_bs * bds.denominator + bds.numerator / 2) / bds.numerator
-		+ bad_bqs_on_top_after_bs;
+		(bad_bqs_on_top_before_bs * bds.denominator +
+		 bds.numerator / 2) /
+			bds.numerator +
+		bad_bqs_on_top_after_bs;
 	/* "+ bds.numerator / 2": rounding for division by bds.numerator */
 
-	res->bayer_scale_hor_ratio_in  = bds.numerator;
+	res->bayer_scale_hor_ratio_in = bds.numerator;
 	res->bayer_scale_hor_ratio_out = bds.denominator;
-	res->bayer_scale_ver_ratio_in  = bds.numerator;
+	res->bayer_scale_ver_ratio_in = bds.numerator;
 	res->bayer_scale_ver_ratio_out = bds.denominator;
 
 	return err;
 }
 
 /* Get the shading information of Shading Correction Type 1. */
-static int
-binary_get_shading_info_type_1(const struct ia_css_binary *binary,	/* [in] */
-			       unsigned int required_bds_factor,			/* [in] */
-			       const struct ia_css_stream_config *stream_config,	/* [in] */
-			       struct ia_css_shading_info *info)			/* [out] */
+static int binary_get_shading_info_type_1(
+	const struct ia_css_binary *binary, /* [in] */
+	unsigned int required_bds_factor, /* [in] */
+	const struct ia_css_stream_config *stream_config, /* [in] */
+	struct ia_css_shading_info *info) /* [out] */
 {
 	int err;
 	struct sh_css_shading_table_bayer_origin_compute_results res;
@@ -234,53 +242,56 @@ binary_get_shading_info_type_1(const struct ia_css_binary *binary,	/* [in] */
 
 	info->type = IA_CSS_SHADING_CORRECTION_TYPE_1;
 
-	info->info.type_1.enable	    = binary->info->sp.enable.sc;
-	info->info.type_1.num_hor_grids	    = binary->sctbl_width_per_color;
-	info->info.type_1.num_ver_grids	    = binary->sctbl_height;
+	info->info.type_1.enable = binary->info->sp.enable.sc;
+	info->info.type_1.num_hor_grids = binary->sctbl_width_per_color;
+	info->info.type_1.num_ver_grids = binary->sctbl_height;
 	info->info.type_1.bqs_per_grid_cell = (1 << binary->deci_factor_log2);
 
 	/* Initialize by default values. */
-	info->info.type_1.bayer_scale_hor_ratio_in	= 1;
-	info->info.type_1.bayer_scale_hor_ratio_out	= 1;
-	info->info.type_1.bayer_scale_ver_ratio_in	= 1;
-	info->info.type_1.bayer_scale_ver_ratio_out	= 1;
+	info->info.type_1.bayer_scale_hor_ratio_in = 1;
+	info->info.type_1.bayer_scale_hor_ratio_out = 1;
+	info->info.type_1.bayer_scale_ver_ratio_in = 1;
+	info->info.type_1.bayer_scale_ver_ratio_out = 1;
 	info->info.type_1.sc_bayer_origin_x_bqs_on_shading_table = 0;
 	info->info.type_1.sc_bayer_origin_y_bqs_on_shading_table = 0;
 
 	err = ia_css_binary_compute_shading_table_bayer_origin(
-	    binary,
-	    required_bds_factor,
-	    stream_config,
-	    &res);
+		binary, required_bds_factor, stream_config, &res);
 	if (err)
 		return err;
 
-	info->info.type_1.bayer_scale_hor_ratio_in	= res.bayer_scale_hor_ratio_in;
-	info->info.type_1.bayer_scale_hor_ratio_out	= res.bayer_scale_hor_ratio_out;
-	info->info.type_1.bayer_scale_ver_ratio_in	= res.bayer_scale_ver_ratio_in;
-	info->info.type_1.bayer_scale_ver_ratio_out	= res.bayer_scale_ver_ratio_out;
-	info->info.type_1.sc_bayer_origin_x_bqs_on_shading_table = res.sc_bayer_origin_x_bqs_on_shading_table;
-	info->info.type_1.sc_bayer_origin_y_bqs_on_shading_table = res.sc_bayer_origin_y_bqs_on_shading_table;
+	info->info.type_1.bayer_scale_hor_ratio_in =
+		res.bayer_scale_hor_ratio_in;
+	info->info.type_1.bayer_scale_hor_ratio_out =
+		res.bayer_scale_hor_ratio_out;
+	info->info.type_1.bayer_scale_ver_ratio_in =
+		res.bayer_scale_ver_ratio_in;
+	info->info.type_1.bayer_scale_ver_ratio_out =
+		res.bayer_scale_ver_ratio_out;
+	info->info.type_1.sc_bayer_origin_x_bqs_on_shading_table =
+		res.sc_bayer_origin_x_bqs_on_shading_table;
+	info->info.type_1.sc_bayer_origin_y_bqs_on_shading_table =
+		res.sc_bayer_origin_y_bqs_on_shading_table;
 
 	return err;
 }
 
-
-int
-ia_css_binary_get_shading_info(const struct ia_css_binary *binary,			/* [in] */
-			       enum ia_css_shading_correction_type type,		/* [in] */
-			       unsigned int required_bds_factor,			/* [in] */
-			       const struct ia_css_stream_config *stream_config,	/* [in] */
-			       struct ia_css_shading_info *shading_info,		/* [out] */
-			       struct ia_css_pipe_config *pipe_config)			/* [out] */
+int ia_css_binary_get_shading_info(
+	const struct ia_css_binary *binary, /* [in] */
+	enum ia_css_shading_correction_type type, /* [in] */
+	unsigned int required_bds_factor, /* [in] */
+	const struct ia_css_stream_config *stream_config, /* [in] */
+	struct ia_css_shading_info *shading_info, /* [out] */
+	struct ia_css_pipe_config *pipe_config) /* [out] */
 {
 	int err;
 
 	assert(binary);
 	assert(shading_info);
 
-	IA_CSS_ENTER_PRIVATE("binary=%p, type=%d, required_bds_factor=%d, stream_config=%p",
-			     binary, type, required_bds_factor, stream_config);
+	IA_CSS_ENTER_PRIVATE(
+		"binary=%p, type=%d, required_bds_factor=%d, stream_config=%p",
+		binary, type, required_bds_factor, stream_config);
 
 	if (type == IA_CSS_SHADING_CORRECTION_TYPE_1)
 		err = binary_get_shading_info_type_1(binary,
@@ -295,7 +306,7 @@ ia_css_binary_get_shading_info(const struct ia_css_binary *binary,			/* [in] */
 }
 
 static void sh_css_binary_common_grid_info(const struct ia_css_binary *binary,
-	struct ia_css_grid_info *info)
+					   struct ia_css_grid_info *info)
 {
 	assert(binary);
 	assert(info);
@@ -306,10 +317,9 @@ static void sh_css_binary_common_grid_info(const struct ia_css_binary *binary,
 	info->vamem_type = IA_CSS_VAMEM_TYPE_2;
 }
 
-void
-ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
-			    struct ia_css_grid_info *info,
-			    struct ia_css_pipe *pipe)
+void ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
+				 struct ia_css_grid_info *info,
+				 struct ia_css_pipe *pipe)
 {
 	struct ia_css_dvs_grid_info *dvs_info;
 
@@ -324,60 +334,56 @@ ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 	 * than the 3a grid size, it indicates that the outer values are not
 	 * valid for DIS.
 	 */
-	dvs_info->enable            = binary->info->sp.enable.dis;
-	dvs_info->width             = binary->dis.grid.dim.width;
-	dvs_info->height            = binary->dis.grid.dim.height;
-	dvs_info->aligned_width     = binary->dis.grid.pad.width;
-	dvs_info->aligned_height    = binary->dis.grid.pad.height;
+	dvs_info->enable = binary->info->sp.enable.dis;
+	dvs_info->width = binary->dis.grid.dim.width;
+	dvs_info->height = binary->dis.grid.dim.height;
+	dvs_info->aligned_width = binary->dis.grid.pad.width;
+	dvs_info->aligned_height = binary->dis.grid.pad.height;
 	dvs_info->bqs_per_grid_cell = 1 << binary->dis.deci_factor_log2;
-	dvs_info->num_hor_coefs     = binary->dis.coef.dim.width;
-	dvs_info->num_ver_coefs     = binary->dis.coef.dim.height;
+	dvs_info->num_hor_coefs = binary->dis.coef.dim.width;
+	dvs_info->num_ver_coefs = binary->dis.coef.dim.height;
 
 	sh_css_binary_common_grid_info(binary, info);
 }
 
-void
-ia_css_binary_dvs_stat_grid_info(
-    const struct ia_css_binary *binary,
-    struct ia_css_grid_info *info,
-    struct ia_css_pipe *pipe)
+void ia_css_binary_dvs_stat_grid_info(const struct ia_css_binary *binary,
+				      struct ia_css_grid_info *info,
+				      struct ia_css_pipe *pipe)
 {
 	(void)pipe;
 	sh_css_binary_common_grid_info(binary, info);
 	return;
 }
 
-int
-ia_css_binary_3a_grid_info(const struct ia_css_binary *binary,
-			   struct ia_css_grid_info *info,
-			   struct ia_css_pipe *pipe) {
+int ia_css_binary_3a_grid_info(const struct ia_css_binary *binary,
+			       struct ia_css_grid_info *info,
+			       struct ia_css_pipe *pipe)
+{
 	struct ia_css_3a_grid_info *s3a_info;
 	int err = 0;
 
-	IA_CSS_ENTER_PRIVATE("binary=%p, info=%p, pipe=%p",
-			     binary, info, pipe);
+	IA_CSS_ENTER_PRIVATE("binary=%p, info=%p, pipe=%p", binary, info, pipe);
 
 	assert(binary);
 	assert(info);
 	s3a_info = &info->s3a_grid;
 
 	/* 3A statistics grid */
-	s3a_info->enable            = binary->info->sp.enable.s3a;
-	s3a_info->width             = binary->s3atbl_width;
-	s3a_info->height            = binary->s3atbl_height;
-	s3a_info->aligned_width     = binary->s3atbl_isp_width;
-	s3a_info->aligned_height    = binary->s3atbl_isp_height;
+	s3a_info->enable = binary->info->sp.enable.s3a;
+	s3a_info->width = binary->s3atbl_width;
+	s3a_info->height = binary->s3atbl_height;
+	s3a_info->aligned_width = binary->s3atbl_isp_width;
+	s3a_info->aligned_height = binary->s3atbl_isp_height;
 	s3a_info->bqs_per_grid_cell = (1 << binary->deci_factor_log2);
-	s3a_info->deci_factor_log2  = binary->deci_factor_log2;
-	s3a_info->elem_bit_depth    = SH_CSS_BAYER_BITS;
-	s3a_info->use_dmem          = binary->info->sp.s3a.s3atbl_use_dmem;
-	s3a_info->has_histogram     = 0;
+	s3a_info->deci_factor_log2 = binary->deci_factor_log2;
+	s3a_info->elem_bit_depth = SH_CSS_BAYER_BITS;
+	s3a_info->use_dmem = binary->info->sp.s3a.s3atbl_use_dmem;
+	s3a_info->has_histogram = 0;
 	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
-static void
-binary_init_pc_histogram(struct sh_css_pc_histogram *histo)
+static void binary_init_pc_histogram(struct sh_css_pc_histogram *histo)
 {
 	assert(histo);
 
@@ -386,15 +392,14 @@ binary_init_pc_histogram(struct sh_css_pc_histogram *histo)
 	histo->stall = NULL;
 }
 
-static void
-binary_init_metrics(struct sh_css_binary_metrics *metrics,
-		    const struct ia_css_binary_info *info)
+static void binary_init_metrics(struct sh_css_binary_metrics *metrics,
+				const struct ia_css_binary_info *info)
 {
 	assert(metrics);
 	assert(info);
 
 	metrics->mode = info->pipeline.mode;
-	metrics->id   = info->id;
+	metrics->id = info->id;
 	metrics->next = NULL;
 	binary_init_pc_histogram(&metrics->isp_histogram);
 	binary_init_pc_histogram(&metrics->sp_histogram);
@@ -416,9 +421,8 @@ binary_supports_output_format(const struct ia_css_binary_xinfo *info,
 	return false;
 }
 
-static bool
-binary_supports_vf_format(const struct ia_css_binary_xinfo *info,
-			  enum ia_css_frame_format format)
+static bool binary_supports_vf_format(const struct ia_css_binary_xinfo *info,
+				      enum ia_css_frame_format format)
 {
 	int i;
 
@@ -432,16 +436,14 @@ binary_supports_vf_format(const struct ia_css_binary_xinfo *info,
 }
 
 /* move to host part of bds module */
-static bool
-supports_bds_factor(u32 supported_factors,
-		    uint32_t bds_factor)
+static bool supports_bds_factor(u32 supported_factors, uint32_t bds_factor)
 {
 	return ((supported_factors & PACK_BDS_FACTOR(bds_factor)) != 0);
 }
 
-static int
-binary_init_info(struct ia_css_binary_xinfo *info, unsigned int i,
-		 bool *binary_found) {
+static int binary_init_info(struct ia_css_binary_xinfo *info, unsigned int i,
+			    bool *binary_found)
+{
 	const unsigned char *blob = sh_css_blob_info[i].blob;
 	unsigned int size = sh_css_blob_info[i].header.blob.size;
 
@@ -464,10 +466,11 @@ binary_init_info(struct ia_css_binary_xinfo *info, unsigned int i,
 /* When binaries are put at the beginning, they will only
  * be selected if no other primary matches.
  */
-int
-ia_css_binary_init_infos(void) {
+int ia_css_binary_init_infos(void)
+{
 	unsigned int i;
-	unsigned int num_of_isp_binaries = sh_css_num_binaries - NUM_OF_SPS - NUM_OF_BLS;
+	unsigned int num_of_isp_binaries =
+		sh_css_num_binaries - NUM_OF_SPS - NUM_OF_BLS;
 
 	if (num_of_isp_binaries == 0)
 		return 0;
@@ -477,8 +480,7 @@ ia_css_binary_init_infos(void) {
 	if (!all_binaries)
 		return -ENOMEM;
 
-	for (i = 0; i < num_of_isp_binaries; i++)
-	{
+	for (i = 0; i < num_of_isp_binaries; i++) {
 		int ret;
 		struct ia_css_binary_xinfo *binary = &all_binaries[i];
 		bool binary_found;
@@ -497,13 +499,12 @@ ia_css_binary_init_infos(void) {
 	return 0;
 }
 
-int
-ia_css_binary_uninit(void) {
+int ia_css_binary_uninit(void)
+{
 	unsigned int i;
 	struct ia_css_binary_xinfo *b;
 
-	for (i = 0; i < IA_CSS_BINARY_NUM_MODES; i++)
-	{
+	for (i = 0; i < IA_CSS_BINARY_NUM_MODES; i++) {
 		for (b = binary_infos[i]; b; b = b->next) {
 			if (b->xmem_addr)
 				hmm_free(b->xmem_addr);
@@ -521,8 +522,7 @@ ia_css_binary_uninit(void) {
  * @param[in]	height	Frame height in pixels.
  * @return	Log2 of decimation factor (= grid cell size) in bayer quads.
  */
-static int
-binary_grid_deci_factor_log2(int width, int height)
+static int binary_grid_deci_factor_log2(int width, int height)
 {
 	/* 3A/Shading decimation factor specification (at August 2008)
 	 * ------------------------------------------------------------------
@@ -533,27 +533,28 @@ binary_grid_deci_factor_log2(int width, int height)
 	 * ------------------------------------------------------------------
 	 */
 	/* Maximum and minimum decimation factor by the specification */
-#define MAX_SPEC_DECI_FACT_LOG2		5
-#define MIN_SPEC_DECI_FACT_LOG2		3
+#define MAX_SPEC_DECI_FACT_LOG2 5
+#define MIN_SPEC_DECI_FACT_LOG2 3
 	/* the smallest frame width in bayer quads when decimation factor (log2) is 5 or 4, by the specification */
-#define DECI_FACT_LOG2_5_SMALLEST_FRAME_WIDTH_BQ	1280
-#define DECI_FACT_LOG2_4_SMALLEST_FRAME_WIDTH_BQ	640
+#define DECI_FACT_LOG2_5_SMALLEST_FRAME_WIDTH_BQ 1280
+#define DECI_FACT_LOG2_4_SMALLEST_FRAME_WIDTH_BQ 640
 
 	int smallest_factor; /* the smallest factor (log2) where the number of cells does not exceed the limitation */
-	int spec_factor;     /* the factor (log2) which satisfies the specification */
+	int spec_factor; /* the factor (log2) which satisfies the specification */
 
 	/* Currently supported maximum width and height are 5120(=80*64) and 3840(=60*64). */
-	assert(ISP_BQ_GRID_WIDTH(width,
-				 MAX_SPEC_DECI_FACT_LOG2) <= SH_CSS_MAX_BQ_GRID_WIDTH);
-	assert(ISP_BQ_GRID_HEIGHT(height,
-				  MAX_SPEC_DECI_FACT_LOG2) <= SH_CSS_MAX_BQ_GRID_HEIGHT);
+	assert(ISP_BQ_GRID_WIDTH(width, MAX_SPEC_DECI_FACT_LOG2) <=
+	       SH_CSS_MAX_BQ_GRID_WIDTH);
+	assert(ISP_BQ_GRID_HEIGHT(height, MAX_SPEC_DECI_FACT_LOG2) <=
+	       SH_CSS_MAX_BQ_GRID_HEIGHT);
 
 	/* Compute the smallest factor. */
 	smallest_factor = MAX_SPEC_DECI_FACT_LOG2;
-	while (ISP_BQ_GRID_WIDTH(width,
-				 smallest_factor - 1) <= SH_CSS_MAX_BQ_GRID_WIDTH &&
-	       ISP_BQ_GRID_HEIGHT(height, smallest_factor - 1) <= SH_CSS_MAX_BQ_GRID_HEIGHT
-	       && smallest_factor > MIN_SPEC_DECI_FACT_LOG2)
+	while (ISP_BQ_GRID_WIDTH(width, smallest_factor - 1) <=
+		       SH_CSS_MAX_BQ_GRID_WIDTH &&
+	       ISP_BQ_GRID_HEIGHT(height, smallest_factor - 1) <=
+		       SH_CSS_MAX_BQ_GRID_HEIGHT &&
+	       smallest_factor > MIN_SPEC_DECI_FACT_LOG2)
 		smallest_factor--;
 
 	/* Get the factor by the specification. */
@@ -583,16 +584,14 @@ binary_grid_deci_factor_log2(int width, int height)
 #undef DECI_FACT_LOG2_4_SMALLEST_FRAME_WIDTH_BQ
 }
 
-static int
-binary_in_frame_padded_width(int in_frame_width,
-			     int isp_internal_width,
-			     int dvs_env_width,
-			     int stream_config_left_padding,
-			     int left_cropping,
-			     bool need_scaling)
+static int binary_in_frame_padded_width(int in_frame_width,
+					int isp_internal_width,
+					int dvs_env_width,
+					int stream_config_left_padding,
+					int left_cropping, bool need_scaling)
 {
 	int rval;
-	int nr_of_left_paddings;	/* number of paddings pixels on the left of an image line */
+	int nr_of_left_paddings; /* number of paddings pixels on the left of an image line */
 
 	if (IS_ISP2401) {
 		/* the output image line of Input System 2401 does not have the left paddings  */
@@ -607,16 +606,16 @@ binary_in_frame_padded_width(int in_frame_width,
 		 * primary and the video binary. */
 		if (stream_config_left_padding != -1) {
 			/* Different than before, we do left&right padding. */
-			rval =
-			    CEIL_MUL(in_frame_width + nr_of_left_paddings,
-				     2 * ISP_VEC_NELEMS);
+			rval = CEIL_MUL(in_frame_width + nr_of_left_paddings,
+					2 * ISP_VEC_NELEMS);
 		} else {
 			/* Different than before, we do left&right padding. */
 			in_frame_width += dvs_env_width;
-			rval =
-			    CEIL_MUL(in_frame_width +
-				     (left_cropping ? nr_of_left_paddings : 0),
-				     2 * ISP_VEC_NELEMS);
+			rval = CEIL_MUL(in_frame_width +
+						(left_cropping ?
+							 nr_of_left_paddings :
+							 0),
+					2 * ISP_VEC_NELEMS);
 		}
 	} else {
 		rval = isp_internal_width;
@@ -625,34 +624,26 @@ binary_in_frame_padded_width(int in_frame_width,
 	return rval;
 }
 
-int
-ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
-			bool online,
-			bool two_ppc,
-			enum atomisp_input_format stream_format,
-			const struct ia_css_frame_info *in_info, /* can be NULL */
-			const struct ia_css_frame_info *bds_out_info, /* can be NULL */
-			const struct ia_css_frame_info *out_info[], /* can be NULL */
-			const struct ia_css_frame_info *vf_info, /* can be NULL */
-			struct ia_css_binary *binary,
-			struct ia_css_resolution *dvs_env,
-			int stream_config_left_padding,
-			bool accelerator) {
+int ia_css_binary_fill_info(
+	const struct ia_css_binary_xinfo *xinfo, bool online, bool two_ppc,
+	enum atomisp_input_format stream_format,
+	const struct ia_css_frame_info *in_info, /* can be NULL */
+	const struct ia_css_frame_info *bds_out_info, /* can be NULL */
+	const struct ia_css_frame_info *out_info[], /* can be NULL */
+	const struct ia_css_frame_info *vf_info, /* can be NULL */
+	struct ia_css_binary *binary, struct ia_css_resolution *dvs_env,
+	int stream_config_left_padding, bool accelerator)
+{
 	const struct ia_css_binary_info *info = &xinfo->sp;
-	unsigned int dvs_env_width = 0,
-	dvs_env_height = 0,
-	vf_log_ds = 0,
-	s3a_log_deci = 0,
-	bits_per_pixel = 0,
-	/* Resolution at SC/3A/DIS kernel. */
-	sc_3a_dis_width = 0,
-	/* Resolution at SC/3A/DIS kernel. */
-	sc_3a_dis_padded_width = 0,
-	/* Resolution at SC/3A/DIS kernel. */
-	sc_3a_dis_height = 0,
-	isp_internal_width = 0,
-	isp_internal_height = 0,
-	s3a_isp_width = 0;
+	unsigned int dvs_env_width = 0, dvs_env_height = 0, vf_log_ds = 0,
+		     s3a_log_deci = 0, bits_per_pixel = 0,
+		     /* Resolution at SC/3A/DIS kernel. */
+		sc_3a_dis_width = 0,
+		     /* Resolution at SC/3A/DIS kernel. */
+		sc_3a_dis_padded_width = 0,
+		     /* Resolution at SC/3A/DIS kernel. */
+		sc_3a_dis_height = 0, isp_internal_width = 0,
+		     isp_internal_height = 0, s3a_isp_width = 0;
 
 	bool need_scaling = false;
 	struct ia_css_resolution binary_dvs_env, internal_res;
@@ -664,27 +655,25 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 	assert(binary);
 
 	binary->info = xinfo;
-	if (!accelerator)
-	{
+	if (!accelerator) {
 		/* binary->css_params has been filled by accelerator itself. */
 		err = ia_css_isp_param_allocate_isp_parameters(
-		    &binary->mem_params, &binary->css_params,
-		    &info->mem_initializers);
+			&binary->mem_params, &binary->css_params,
+			&info->mem_initializers);
 		if (err) {
 			return err;
 		}
 	}
-	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
-	{
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
 		if (out_info[i] && (out_info[i]->res.width != 0)) {
 			bin_out_info = out_info[i];
 			break;
 		}
 	}
-	if (in_info && bin_out_info)
-	{
-		need_scaling = (in_info->res.width != bin_out_info->res.width) ||
-			       (in_info->res.height != bin_out_info->res.height);
+	if (in_info && bin_out_info) {
+		need_scaling =
+			(in_info->res.width != bin_out_info->res.width) ||
+			(in_info->res.height != bin_out_info->res.height);
 	}
 
 	/* binary_dvs_env has to be equal or larger than SH_CSS_MIN_DVS_ENVELOPE */
@@ -693,7 +682,7 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 	ia_css_binary_dvs_env(info, dvs_env, &binary_dvs_env);
 	dvs_env_width = binary_dvs_env.width;
 	dvs_env_height = binary_dvs_env.height;
-	binary->dvs_envelope.width  = dvs_env_width;
+	binary->dvs_envelope.width = dvs_env_width;
 	binary->dvs_envelope.height = dvs_env_height;
 
 	/* internal resolution calculation */
@@ -708,55 +697,56 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 	if (bin_out_info) /* { */
 		binary->internal_frame_info.format = bin_out_info->format;
 	/* } */
-	binary->internal_frame_info.res.width       = isp_internal_width;
-	binary->internal_frame_info.padded_width    = CEIL_MUL(isp_internal_width, 2 * ISP_VEC_NELEMS);
-	binary->internal_frame_info.res.height      = isp_internal_height;
-	binary->internal_frame_info.raw_bit_depth   = bits_per_pixel;
+	binary->internal_frame_info.res.width = isp_internal_width;
+	binary->internal_frame_info.padded_width =
+		CEIL_MUL(isp_internal_width, 2 * ISP_VEC_NELEMS);
+	binary->internal_frame_info.res.height = isp_internal_height;
+	binary->internal_frame_info.raw_bit_depth = bits_per_pixel;
 
-	if (in_info)
-	{
+	if (in_info) {
 		binary->effective_in_frame_res.width = in_info->res.width;
 		binary->effective_in_frame_res.height = in_info->res.height;
 
 		bits_per_pixel = in_info->raw_bit_depth;
 
 		/* input info */
-		binary->in_frame_info.res.width = in_info->res.width +
-						  info->pipeline.left_cropping;
-		binary->in_frame_info.res.height = in_info->res.height +
-						   info->pipeline.top_cropping;
+		binary->in_frame_info.res.width =
+			in_info->res.width + info->pipeline.left_cropping;
+		binary->in_frame_info.res.height =
+			in_info->res.height + info->pipeline.top_cropping;
 
 		binary->in_frame_info.res.width += dvs_env_width;
 		binary->in_frame_info.res.height += dvs_env_height;
 
 		binary->in_frame_info.padded_width =
-		    binary_in_frame_padded_width(in_info->res.width,
-						 isp_internal_width,
-						 dvs_env_width,
-						 stream_config_left_padding,
-						 info->pipeline.left_cropping,
-						 need_scaling);
+			binary_in_frame_padded_width(
+				in_info->res.width, isp_internal_width,
+				dvs_env_width, stream_config_left_padding,
+				info->pipeline.left_cropping, need_scaling);
 
 		binary->in_frame_info.format = in_info->format;
-		binary->in_frame_info.raw_bayer_order = in_info->raw_bayer_order;
+		binary->in_frame_info.raw_bayer_order =
+			in_info->raw_bayer_order;
 		binary->in_frame_info.crop_info = in_info->crop_info;
 	}
 
-	if (online)
-	{
-		bits_per_pixel = ia_css_util_input_format_bpp(
-				     stream_format, two_ppc);
+	if (online) {
+		bits_per_pixel =
+			ia_css_util_input_format_bpp(stream_format, two_ppc);
 	}
 	binary->in_frame_info.raw_bit_depth = bits_per_pixel;
 
-	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
-	{
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
 		if (out_info[i]) {
-			binary->out_frame_info[i].res.width     = out_info[i]->res.width;
-			binary->out_frame_info[i].res.height    = out_info[i]->res.height;
-			binary->out_frame_info[i].padded_width  = out_info[i]->padded_width;
+			binary->out_frame_info[i].res.width =
+				out_info[i]->res.width;
+			binary->out_frame_info[i].res.height =
+				out_info[i]->res.height;
+			binary->out_frame_info[i].padded_width =
+				out_info[i]->padded_width;
 			if (info->pipeline.mode == IA_CSS_BINARY_MODE_COPY) {
-				binary->out_frame_info[i].raw_bit_depth = bits_per_pixel;
+				binary->out_frame_info[i].raw_bit_depth =
+					bits_per_pixel;
 			} else {
 				/* Only relevant for RAW format.
 				 * At the moment, all outputs are raw, 16 bit per pixel, except for copy.
@@ -765,38 +755,37 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 				 */
 				binary->out_frame_info[i].raw_bit_depth = 16;
 			}
-			binary->out_frame_info[i].format        = out_info[i]->format;
+			binary->out_frame_info[i].format = out_info[i]->format;
 		}
 	}
 
-	if (vf_info && (vf_info->res.width != 0))
-	{
+	if (vf_info && (vf_info->res.width != 0)) {
 		err = ia_css_vf_configure(binary, bin_out_info,
-					  (struct ia_css_frame_info *)vf_info, &vf_log_ds);
+					  (struct ia_css_frame_info *)vf_info,
+					  &vf_log_ds);
 		if (err) {
 			if (!accelerator) {
 				ia_css_isp_param_destroy_isp_parameters(
-				    &binary->mem_params,
-				    &binary->css_params);
+					&binary->mem_params,
+					&binary->css_params);
 			}
 			return err;
 		}
 	}
 	binary->vf_downscale_log2 = vf_log_ds;
 
-	binary->online            = online;
-	binary->input_format      = stream_format;
+	binary->online = online;
+	binary->input_format = stream_format;
 
 	/* viewfinder output info */
-	if ((vf_info) && (vf_info->res.width != 0))
-	{
+	if ((vf_info) && (vf_info->res.width != 0)) {
 		unsigned int vf_out_vecs, vf_out_width, vf_out_height;
 
 		binary->vf_frame_info.format = vf_info->format;
 		if (!bin_out_info)
 			return -EINVAL;
-		vf_out_vecs = __ISP_VF_OUTPUT_WIDTH_VECS(bin_out_info->padded_width,
-			      vf_log_ds);
+		vf_out_vecs = __ISP_VF_OUTPUT_WIDTH_VECS(
+			bin_out_info->padded_width, vf_log_ds);
 		vf_out_width = _ISP_VF_OUTPUT_WIDTH(vf_out_vecs);
 		vf_out_height = _ISP_VF_OUTPUT_HEIGHT(bin_out_info->res.height,
 						      vf_log_ds);
@@ -804,42 +793,39 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 		/* For preview mode, output pin is used instead of vf. */
 		if (info->pipeline.mode == IA_CSS_BINARY_MODE_PREVIEW) {
 			binary->out_frame_info[0].res.width =
-			    (bin_out_info->res.width >> vf_log_ds);
+				(bin_out_info->res.width >> vf_log_ds);
 			binary->out_frame_info[0].padded_width = vf_out_width;
-			binary->out_frame_info[0].res.height   = vf_out_height;
+			binary->out_frame_info[0].res.height = vf_out_height;
 
-			binary->vf_frame_info.res.width    = 0;
+			binary->vf_frame_info.res.width = 0;
 			binary->vf_frame_info.padded_width = 0;
-			binary->vf_frame_info.res.height   = 0;
+			binary->vf_frame_info.res.height = 0;
 		} else {
 			/* we also store the raw downscaled width. This is
 			 * used for digital zoom in preview to zoom only on
 			 * the width that we actually want to keep, not on
 			 * the aligned width. */
 			binary->vf_frame_info.res.width =
-			    (bin_out_info->res.width >> vf_log_ds);
+				(bin_out_info->res.width >> vf_log_ds);
 			binary->vf_frame_info.padded_width = vf_out_width;
-			binary->vf_frame_info.res.height   = vf_out_height;
+			binary->vf_frame_info.res.height = vf_out_height;
 		}
-	} else
-	{
-		binary->vf_frame_info.res.width    = 0;
+	} else {
+		binary->vf_frame_info.res.width = 0;
 		binary->vf_frame_info.padded_width = 0;
-		binary->vf_frame_info.res.height   = 0;
+		binary->vf_frame_info.res.height = 0;
 	}
 
-	if (info->enable.ca_gdc)
-	{
+	if (info->enable.ca_gdc) {
 		binary->morph_tbl_width =
-		    _ISP_MORPH_TABLE_WIDTH(isp_internal_width);
-		binary->morph_tbl_aligned_width  =
-		    _ISP_MORPH_TABLE_ALIGNED_WIDTH(isp_internal_width);
+			_ISP_MORPH_TABLE_WIDTH(isp_internal_width);
+		binary->morph_tbl_aligned_width =
+			_ISP_MORPH_TABLE_ALIGNED_WIDTH(isp_internal_width);
 		binary->morph_tbl_height =
-		    _ISP_MORPH_TABLE_HEIGHT(isp_internal_height);
-	} else
-	{
-		binary->morph_tbl_width  = 0;
-		binary->morph_tbl_aligned_width  = 0;
+			_ISP_MORPH_TABLE_HEIGHT(isp_internal_height);
+	} else {
+		binary->morph_tbl_width = 0;
+		binary->morph_tbl_aligned_width = 0;
 		binary->morph_tbl_height = 0;
 	}
 
@@ -847,85 +833,76 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 	sc_3a_dis_padded_width = binary->in_frame_info.padded_width;
 	sc_3a_dis_height = binary->in_frame_info.res.height;
 	if (bds_out_info && in_info &&
-	    bds_out_info->res.width != in_info->res.width)
-	{
+	    bds_out_info->res.width != in_info->res.width) {
 		/* TODO: Next, "internal_frame_info" should be derived from
 		 * bds_out. So this part will change once it is in place! */
-		sc_3a_dis_width = bds_out_info->res.width + info->pipeline.left_cropping;
+		sc_3a_dis_width =
+			bds_out_info->res.width + info->pipeline.left_cropping;
 		sc_3a_dis_padded_width = isp_internal_width;
 		sc_3a_dis_height = isp_internal_height;
 	}
 
 	s3a_isp_width = _ISP_S3A_ELEMS_ISP_WIDTH(sc_3a_dis_padded_width,
-			info->pipeline.left_cropping);
-	if (info->s3a.fixed_s3a_deci_log)
-	{
+						 info->pipeline.left_cropping);
+	if (info->s3a.fixed_s3a_deci_log) {
 		s3a_log_deci = info->s3a.fixed_s3a_deci_log;
-	} else
-	{
+	} else {
 		s3a_log_deci = binary_grid_deci_factor_log2(s3a_isp_width,
-			       sc_3a_dis_height);
+							    sc_3a_dis_height);
 	}
-	binary->deci_factor_log2  = s3a_log_deci;
+	binary->deci_factor_log2 = s3a_log_deci;
 
-	if (info->enable.s3a)
-	{
-		binary->s3atbl_width  =
-		    _ISP_S3ATBL_WIDTH(sc_3a_dis_width,
-				      s3a_log_deci);
+	if (info->enable.s3a) {
+		binary->s3atbl_width =
+			_ISP_S3ATBL_WIDTH(sc_3a_dis_width, s3a_log_deci);
 		binary->s3atbl_height =
-		    _ISP_S3ATBL_HEIGHT(sc_3a_dis_height,
-				       s3a_log_deci);
+			_ISP_S3ATBL_HEIGHT(sc_3a_dis_height, s3a_log_deci);
 		binary->s3atbl_isp_width =
-		    _ISP_S3ATBL_ISP_WIDTH(s3a_isp_width,
-					  s3a_log_deci);
+			_ISP_S3ATBL_ISP_WIDTH(s3a_isp_width, s3a_log_deci);
 		binary->s3atbl_isp_height =
-		    _ISP_S3ATBL_ISP_HEIGHT(sc_3a_dis_height,
-					   s3a_log_deci);
-	} else
-	{
-		binary->s3atbl_width  = 0;
+			_ISP_S3ATBL_ISP_HEIGHT(sc_3a_dis_height, s3a_log_deci);
+	} else {
+		binary->s3atbl_width = 0;
 		binary->s3atbl_height = 0;
-		binary->s3atbl_isp_width  = 0;
+		binary->s3atbl_isp_width = 0;
 		binary->s3atbl_isp_height = 0;
 	}
 
-	if (info->enable.sc)
-	{
-		binary->sctbl_width_per_color = _ISP_SCTBL_WIDTH_PER_COLOR(sc_3a_dis_padded_width, s3a_log_deci);
-		binary->sctbl_aligned_width_per_color = SH_CSS_MAX_SCTBL_ALIGNED_WIDTH_PER_COLOR;
-		binary->sctbl_height = _ISP_SCTBL_HEIGHT(sc_3a_dis_height, s3a_log_deci);
-	} else
-	{
-		binary->sctbl_width_per_color         = 0;
+	if (info->enable.sc) {
+		binary->sctbl_width_per_color = _ISP_SCTBL_WIDTH_PER_COLOR(
+			sc_3a_dis_padded_width, s3a_log_deci);
+		binary->sctbl_aligned_width_per_color =
+			SH_CSS_MAX_SCTBL_ALIGNED_WIDTH_PER_COLOR;
+		binary->sctbl_height =
+			_ISP_SCTBL_HEIGHT(sc_3a_dis_height, s3a_log_deci);
+	} else {
+		binary->sctbl_width_per_color = 0;
 		binary->sctbl_aligned_width_per_color = 0;
-		binary->sctbl_height                  = 0;
+		binary->sctbl_height = 0;
 	}
-	ia_css_sdis_init_info(&binary->dis,
-			      sc_3a_dis_width,
-			      sc_3a_dis_padded_width,
-			      sc_3a_dis_height,
+	ia_css_sdis_init_info(&binary->dis, sc_3a_dis_width,
+			      sc_3a_dis_padded_width, sc_3a_dis_height,
 			      info->pipeline.isp_pipe_version,
 			      info->enable.dis);
 	if (info->pipeline.left_cropping)
-		binary->left_padding = 2 * ISP_VEC_NELEMS - info->pipeline.left_cropping;
+		binary->left_padding =
+			2 * ISP_VEC_NELEMS - info->pipeline.left_cropping;
 	else
 		binary->left_padding = 0;
 
 	return 0;
 }
 
-int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *binary)
+int ia_css_binary_find(struct ia_css_binary_descr *descr,
+		       struct ia_css_binary *binary)
 {
 	int mode;
 	bool online;
 	bool two_ppc;
 	enum atomisp_input_format stream_format;
-	const struct ia_css_frame_info *req_in_info,
-		*req_bds_out_info,
+	const struct ia_css_frame_info *req_in_info, *req_bds_out_info,
 		*req_out_info[IA_CSS_BINARY_MAX_OUTPUT_PORTS],
-		*req_bin_out_info = NULL,
-		*req_vf_info;
+		*req_bin_out_info = NULL, *req_vf_info;
 
 	struct ia_css_binary_xinfo *xcandidate;
 	bool need_ds, need_dz, need_dvs, need_xnr, need_dpc;
@@ -945,7 +922,8 @@ int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *
 	/* MW: used after an error check, may accept NULL, but doubtful */
 	assert(binary);
 
-	dev_dbg(atomisp_dev, "ia_css_binary_find() enter: descr=%p, (mode=%d), binary=%p\n",
+	dev_dbg(atomisp_dev,
+		"ia_css_binary_find() enter: descr=%p, (mode=%d), binary=%p\n",
 		descr, descr->mode, binary);
 
 	mode = descr->mode;
@@ -971,7 +949,7 @@ int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *
 
 	enable_yuv_ds = descr->enable_yuv_ds;
 	enable_high_speed = descr->enable_high_speed;
-	enable_dvs_6axis  = descr->enable_dvs_6axis;
+	enable_dvs_6axis = descr->enable_dvs_6axis;
 	enable_reduced_pipe = descr->enable_reduced_pipe;
 	enable_capture_pp_bli = descr->enable_capture_pp_bli;
 	continuous = descr->continuous;
@@ -997,8 +975,10 @@ int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *
 		if (xcandidate) {
 			dev_dbg(atomisp_dev, "%d:\n", i);
 			while (xcandidate) {
-				dev_dbg(atomisp_dev, " Name:%s Type:%d Cont:%d\n",
-					xcandidate->blob->name, xcandidate->type,
+				dev_dbg(atomisp_dev,
+					" Name:%s Type:%d Cont:%d\n",
+					xcandidate->blob->name,
+					xcandidate->type,
 					xcandidate->sp.enable.continuous);
 				xcandidate = xcandidate->next;
 			}
@@ -1020,8 +1000,8 @@ int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *
 		 * be used in a continuous preview/video mode unless it is
 		 * the copy mode and runs on SP.
 		*/
-		if (!candidate->enable.continuous &&
-		    continuous && (mode != IA_CSS_BINARY_MODE_COPY)) {
+		if (!candidate->enable.continuous && continuous &&
+		    (mode != IA_CSS_BINARY_MODE_COPY)) {
 			dev_dbg(atomisp_dev,
 				"ia_css_binary_find() [%d] continue: !%d && %d && (%d != %d)\n",
 				__LINE__, candidate->enable.continuous,
@@ -1039,43 +1019,56 @@ int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *
 		    (mode != IA_CSS_BINARY_MODE_COPY) &&
 		    (mode != IA_CSS_BINARY_MODE_CAPTURE_PP) &&
 		    (mode != IA_CSS_BINARY_MODE_VF_PP)) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: (%d != %d)\n",
-				__LINE__, candidate->pipeline.isp_pipe_version, isp_pipe_version);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: (%d != %d)\n",
+				__LINE__, candidate->pipeline.isp_pipe_version,
+				isp_pipe_version);
 			continue;
 		}
 		if (!candidate->enable.reduced_pipe && enable_reduced_pipe) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: !%d && %d\n",
-				__LINE__, candidate->enable.reduced_pipe, enable_reduced_pipe);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
+				__LINE__, candidate->enable.reduced_pipe,
+				enable_reduced_pipe);
 			continue;
 		}
 		if (!candidate->enable.dvs_6axis && enable_dvs_6axis) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: !%d && %d\n",
-				__LINE__, candidate->enable.dvs_6axis, enable_dvs_6axis);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
+				__LINE__, candidate->enable.dvs_6axis,
+				enable_dvs_6axis);
 			continue;
 		}
 		if (candidate->enable.high_speed && !enable_high_speed) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: %d && !%d\n",
-				__LINE__, candidate->enable.high_speed, enable_high_speed);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: %d && !%d\n",
+				__LINE__, candidate->enable.high_speed,
+				enable_high_speed);
 			continue;
 		}
 		if (!candidate->enable.xnr && need_xnr) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: %d && !%d\n",
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: %d && !%d\n",
 				__LINE__, candidate->enable.xnr, need_xnr);
 			continue;
 		}
 		if (!(candidate->enable.ds & 2) && enable_yuv_ds) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: !%d && %d\n",
-				__LINE__, ((candidate->enable.ds & 2) != 0), enable_yuv_ds);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
+				__LINE__, ((candidate->enable.ds & 2) != 0),
+				enable_yuv_ds);
 			continue;
 		}
 		if ((candidate->enable.ds & 2) && !enable_yuv_ds) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: %d && !%d\n",
-				__LINE__, ((candidate->enable.ds & 2) != 0), enable_yuv_ds);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: %d && !%d\n",
+				__LINE__, ((candidate->enable.ds & 2) != 0),
+				enable_yuv_ds);
 			continue;
 		}
 
-		if (mode == IA_CSS_BINARY_MODE_VIDEO &&
-		    candidate->enable.ds && need_ds)
+		if (mode == IA_CSS_BINARY_MODE_VIDEO && candidate->enable.ds &&
+		    need_ds)
 			need_dz = false;
 
 		/* when we require vf output, we need to have vf_veceven */
@@ -1086,48 +1079,62 @@ int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *
 				       xcandidate->num_output_pins > 1)) {
 			dev_dbg(atomisp_dev,
 				"ia_css_binary_find() [%d] continue: (%p != NULL) && !(%d || %d || (%d >%d))\n",
-				__LINE__, req_vf_info, candidate->enable.vf_veceven,
-				candidate->vf_dec.is_variable, xcandidate->num_output_pins, 1);
+				__LINE__, req_vf_info,
+				candidate->enable.vf_veceven,
+				candidate->vf_dec.is_variable,
+				xcandidate->num_output_pins, 1);
 			continue;
 		}
 		if (!candidate->enable.dvs_envelope && need_dvs) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: !%d && %d\n",
-				__LINE__, candidate->enable.dvs_envelope, (int)need_dvs);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
+				__LINE__, candidate->enable.dvs_envelope,
+				(int)need_dvs);
 			continue;
 		}
 		/* internal_res check considers input, output, and dvs envelope sizes */
 		ia_css_binary_internal_res(req_in_info, req_bds_out_info,
-					   req_bin_out_info, &dvs_env, candidate, &internal_res);
+					   req_bin_out_info, &dvs_env,
+					   candidate, &internal_res);
 		if (internal_res.width > candidate->internal.max_width) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: (%d > %d)\n",
-				__LINE__, internal_res.width, candidate->internal.max_width);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: (%d > %d)\n",
+				__LINE__, internal_res.width,
+				candidate->internal.max_width);
 			continue;
 		}
 		if (internal_res.height > candidate->internal.max_height) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: (%d > %d)\n",
-				__LINE__, internal_res.height, candidate->internal.max_height);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: (%d > %d)\n",
+				__LINE__, internal_res.height,
+				candidate->internal.max_height);
 			continue;
 		}
-		if (!candidate->enable.ds && need_ds && !(xcandidate->num_output_pins > 1)) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: !%d && %d\n",
+		if (!candidate->enable.ds && need_ds &&
+		    !(xcandidate->num_output_pins > 1)) {
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
 				__LINE__, candidate->enable.ds, (int)need_ds);
 			continue;
 		}
-		if (!candidate->enable.uds && !candidate->enable.dvs_6axis && need_dz) {
+		if (!candidate->enable.uds && !candidate->enable.dvs_6axis &&
+		    need_dz) {
 			dev_dbg(atomisp_dev,
 				"ia_css_binary_find() [%d] continue: !%d && !%d && %d\n",
-				__LINE__, candidate->enable.uds, candidate->enable.dvs_6axis,
-				(int)need_dz);
+				__LINE__, candidate->enable.uds,
+				candidate->enable.dvs_6axis, (int)need_dz);
 			continue;
 		}
-		if (online && candidate->input.source == IA_CSS_BINARY_INPUT_MEMORY) {
+		if (online &&
+		    candidate->input.source == IA_CSS_BINARY_INPUT_MEMORY) {
 			dev_dbg(atomisp_dev,
 				"ia_css_binary_find() [%d] continue: %d && (%d == %d)\n",
 				__LINE__, online, candidate->input.source,
 				IA_CSS_BINARY_INPUT_MEMORY);
 			continue;
 		}
-		if (!online && candidate->input.source == IA_CSS_BINARY_INPUT_SENSOR) {
+		if (!online &&
+		    candidate->input.source == IA_CSS_BINARY_INPUT_SENSOR) {
 			dev_dbg(atomisp_dev,
 				"ia_css_binary_find() [%d] continue: !%d && (%d == %d)\n",
 				__LINE__, online, candidate->input.source,
@@ -1139,14 +1146,16 @@ int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *
 			dev_dbg(atomisp_dev,
 				"ia_css_binary_find() [%d] continue: (%d > %d) || (%d < %d)\n",
 				__LINE__, req_bin_out_info->padded_width,
-				candidate->output.min_width, req_bin_out_info->padded_width,
+				candidate->output.min_width,
+				req_bin_out_info->padded_width,
 				candidate->output.max_width);
 			continue;
 		}
 		if (xcandidate->num_output_pins > 1 &&
 		    /* in case we have a second output pin, */
 		    req_vf_info) { /* and we need vf output. */
-			if (req_vf_info->res.width > candidate->output.max_width) {
+			if (req_vf_info->res.width >
+			    candidate->output.max_width) {
 				dev_dbg(atomisp_dev,
 					"ia_css_binary_find() [%d] continue: (%d < %d)\n",
 					__LINE__, req_vf_info->res.width,
@@ -1155,45 +1164,56 @@ int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *
 			}
 		}
 		if (req_in_info->padded_width > candidate->input.max_width) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: (%d > %d)\n",
-				__LINE__, req_in_info->padded_width, candidate->input.max_width);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: (%d > %d)\n",
+				__LINE__, req_in_info->padded_width,
+				candidate->input.max_width);
 			continue;
 		}
-		if (!binary_supports_output_format(xcandidate, req_bin_out_info->format)) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: !%d\n",
-				__LINE__, binary_supports_output_format(xcandidate,
-									req_bin_out_info->format));
+		if (!binary_supports_output_format(xcandidate,
+						   req_bin_out_info->format)) {
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: !%d\n",
+				__LINE__,
+				binary_supports_output_format(
+					xcandidate, req_bin_out_info->format));
 			continue;
 		}
 		if (xcandidate->num_output_pins > 1 &&
 		    /* in case we have a second output pin, */
-		    req_vf_info                   && /* and we need vf output. */
+		    req_vf_info && /* and we need vf output. */
 		    /* check if the required vf format
 		    is supported. */
-		    !binary_supports_output_format(xcandidate, req_vf_info->format)) {
+		    !binary_supports_output_format(xcandidate,
+						   req_vf_info->format)) {
 			dev_dbg(atomisp_dev,
 				"ia_css_binary_find() [%d] continue: (%d > %d) && (%p != NULL) && !%d\n",
-				__LINE__, xcandidate->num_output_pins, 1, req_vf_info,
-				binary_supports_output_format(xcandidate, req_vf_info->format));
+				__LINE__, xcandidate->num_output_pins, 1,
+				req_vf_info,
+				binary_supports_output_format(
+					xcandidate, req_vf_info->format));
 			continue;
 		}
 
 		/* Check if vf_veceven supports the requested vf format */
-		if (xcandidate->num_output_pins == 1 &&
-		    req_vf_info && candidate->enable.vf_veceven &&
-		    !binary_supports_vf_format(xcandidate, req_vf_info->format)) {
+		if (xcandidate->num_output_pins == 1 && req_vf_info &&
+		    candidate->enable.vf_veceven &&
+		    !binary_supports_vf_format(xcandidate,
+					       req_vf_info->format)) {
 			dev_dbg(atomisp_dev,
 				"ia_css_binary_find() [%d] continue: (%d == %d) && (%p != NULL) && %d && !%d\n",
 				__LINE__, xcandidate->num_output_pins, 1,
 				req_vf_info, candidate->enable.vf_veceven,
-				binary_supports_vf_format(xcandidate, req_vf_info->format));
+				binary_supports_vf_format(xcandidate,
+							  req_vf_info->format));
 			continue;
 		}
 
 		/* Check if vf_veceven supports the requested vf width */
-		if (xcandidate->num_output_pins == 1 &&
-		    req_vf_info && candidate->enable.vf_veceven) { /* and we need vf output. */
-			if (req_vf_info->res.width > candidate->output.max_width) {
+		if (xcandidate->num_output_pins == 1 && req_vf_info &&
+		    candidate->enable.vf_veceven) { /* and we need vf output. */
+			if (req_vf_info->res.width >
+			    candidate->output.max_width) {
 				dev_dbg(atomisp_dev,
 					"ia_css_binary_find() [%d] continue: (%d < %d)\n",
 					__LINE__, req_vf_info->res.width,
@@ -1204,32 +1224,34 @@ int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *
 
 		if (!supports_bds_factor(candidate->bds.supported_bds_factors,
 					 descr->required_bds_factor)) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: 0x%x & 0x%x)\n",
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: 0x%x & 0x%x)\n",
 				__LINE__, candidate->bds.supported_bds_factors,
 				descr->required_bds_factor);
 			continue;
 		}
 
 		if (!candidate->enable.dpc && need_dpc) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: 0x%x & 0x%x)\n",
-				__LINE__, candidate->enable.dpc, descr->enable_dpc);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: 0x%x & 0x%x)\n",
+				__LINE__, candidate->enable.dpc,
+				descr->enable_dpc);
 			continue;
 		}
 
 		if (candidate->uds.use_bci && enable_capture_pp_bli) {
-			dev_dbg(atomisp_dev, "ia_css_binary_find() [%d] continue: 0x%x & 0x%x)\n",
-				__LINE__, candidate->uds.use_bci, descr->enable_capture_pp_bli);
+			dev_dbg(atomisp_dev,
+				"ia_css_binary_find() [%d] continue: 0x%x & 0x%x)\n",
+				__LINE__, candidate->uds.use_bci,
+				descr->enable_capture_pp_bli);
 			continue;
 		}
 
 		/* reconfigure any variable properties of the binary */
-		err = ia_css_binary_fill_info(xcandidate, online, two_ppc,
-					      stream_format, req_in_info,
-					      req_bds_out_info,
-					      req_out_info, req_vf_info,
-					      binary, &dvs_env,
-					      descr->stream_config_left_padding,
-					      false);
+		err = ia_css_binary_fill_info(
+			xcandidate, online, two_ppc, stream_format, req_in_info,
+			req_bds_out_info, req_out_info, req_vf_info, binary,
+			&dvs_env, descr->stream_config_left_padding, false);
 
 		if (err)
 			break;
@@ -1238,29 +1260,30 @@ int ia_css_binary_find(struct ia_css_binary_descr *descr, struct ia_css_binary *
 	}
 
 	if (!err && xcandidate)
-		dev_dbg(atomisp_dev, "Using binary %s (id %d), type %d, mode %d, continuous %s\n",
-			xcandidate->blob->name, xcandidate->sp.id, xcandidate->type,
-			xcandidate->sp.pipeline.mode,
+		dev_dbg(atomisp_dev,
+			"Using binary %s (id %d), type %d, mode %d, continuous %s\n",
+			xcandidate->blob->name, xcandidate->sp.id,
+			xcandidate->type, xcandidate->sp.pipeline.mode,
 			xcandidate->sp.enable.continuous ? "true" : "false");
 
 	if (err)
-		dev_err(atomisp_dev, "Failed to find a firmware binary matching the pipeline parameters\n");
+		dev_err(atomisp_dev,
+			"Failed to find a firmware binary matching the pipeline parameters\n");
 
 	return err;
 }
 
-unsigned
-ia_css_binary_max_vf_width(void)
+unsigned ia_css_binary_max_vf_width(void)
 {
 	/* This is (should be) true for IPU1 and IPU2 */
 	/* For IPU3 (SkyCam) this pointer is guaranteed to be NULL simply because such a binary does not exist  */
 	if (binary_infos[IA_CSS_BINARY_MODE_VF_PP])
-		return binary_infos[IA_CSS_BINARY_MODE_VF_PP]->sp.output.max_width;
+		return binary_infos[IA_CSS_BINARY_MODE_VF_PP]
+			->sp.output.max_width;
 	return 0;
 }
 
-void
-ia_css_binary_destroy_isp_parameters(struct ia_css_binary *binary)
+void ia_css_binary_destroy_isp_parameters(struct ia_css_binary *binary)
 {
 	if (binary) {
 		ia_css_isp_param_destroy_isp_parameters(&binary->mem_params,
@@ -1268,9 +1291,8 @@ ia_css_binary_destroy_isp_parameters(struct ia_css_binary *binary)
 	}
 }
 
-void
-ia_css_binary_get_isp_binaries(struct ia_css_binary_xinfo **binaries,
-			       uint32_t *num_isp_binaries)
+void ia_css_binary_get_isp_binaries(struct ia_css_binary_xinfo **binaries,
+				    uint32_t *num_isp_binaries)
 {
 	assert(binaries);
 
diff --git a/drivers/staging/media/atomisp/pci/runtime/bufq/interface/ia_css_bufq.h b/drivers/staging/media/atomisp/pci/runtime/bufq/interface/ia_css_bufq.h
index 3e7dadca6d707b5ad174e7e85decc7370df26aa8..e686a38be21e19551ca912a5c8af442f2b200dee 100644
--- a/drivers/staging/media/atomisp/pci/runtime/bufq/interface/ia_css_bufq.h
+++ b/drivers/staging/media/atomisp/pci/runtime/bufq/interface/ia_css_bufq.h
@@ -23,11 +23,9 @@
  *	true, if the query succeeds;
  *	false, if the query fails.
  */
-bool ia_css_query_internal_queue_id(
-    enum ia_css_buffer_type buf_type,
-    unsigned int thread_id,
-    enum sh_css_queue_id *val
-);
+bool ia_css_query_internal_queue_id(enum ia_css_buffer_type buf_type,
+				    unsigned int thread_id,
+				    enum sh_css_queue_id *val);
 
 /**
  * @brief  Map buffer type to a internal queue id.
@@ -37,11 +35,8 @@ bool ia_css_query_internal_queue_id(
  * @param[in] map		boolean flag to specify map or unmap
  * @return none
  */
-void ia_css_queue_map(
-    unsigned int thread_id,
-    enum ia_css_buffer_type buf_type,
-    bool map
-);
+void ia_css_queue_map(unsigned int thread_id, enum ia_css_buffer_type buf_type,
+		      bool map);
 
 /**
  * @brief  Initialize buffer type to a queue id mapping
@@ -72,10 +67,7 @@ void ia_css_bufq_init(void);
  * @return	0 or error code upon error.
  *
 */
-int ia_css_bufq_enqueue_buffer(
-    int thread_index,
-    int queue_id,
-    uint32_t item);
+int ia_css_bufq_enqueue_buffer(int thread_index, int queue_id, uint32_t item);
 
 /**
 * @brief Dequeues an item from SP to host buffer queue.
@@ -86,9 +78,7 @@ int ia_css_bufq_enqueue_buffer(
  * @return	0 or error code upon error.
  *
 */
-int ia_css_bufq_dequeue_buffer(
-    int queue_id,
-    uint32_t *item);
+int ia_css_bufq_dequeue_buffer(int queue_id, uint32_t *item);
 
 /**
 * @brief  Enqueue an event item into host to SP communication event queue.
@@ -100,12 +90,8 @@ int ia_css_bufq_dequeue_buffer(
  * @return	0 or error code upon error.
  *
 */
-int ia_css_bufq_enqueue_psys_event(
-    u8 evt_id,
-    u8 evt_payload_0,
-    u8 evt_payload_1,
-    uint8_t evt_payload_2
-);
+int ia_css_bufq_enqueue_psys_event(u8 evt_id, u8 evt_payload_0,
+				   u8 evt_payload_1, uint8_t evt_payload_2);
 
 /**
  * @brief   Dequeue an item from  SP to host communication event queue.
@@ -114,8 +100,7 @@ int ia_css_bufq_enqueue_psys_event(
  * @return	0 or error code upon error.
  *
 */
-int ia_css_bufq_dequeue_psys_event(
-    u8 item[BUFQ_EVENT_SIZE]
+int ia_css_bufq_dequeue_psys_event(u8 item[BUFQ_EVENT_SIZE]
 
 );
 
@@ -126,8 +111,7 @@ int ia_css_bufq_dequeue_psys_event(
  * @return	0 or error code upon error.
  *
  */
-int ia_css_bufq_enqueue_isys_event(
-    uint8_t evt_id);
+int ia_css_bufq_enqueue_isys_event(uint8_t evt_id);
 
 /**
 * @brief   Dequeue an item from  SP to host communication EOF event queue.
@@ -137,8 +121,7 @@ int ia_css_bufq_enqueue_isys_event(
  * @return	0 or error code upon error.
  *
  */
-int ia_css_bufq_dequeue_isys_event(
-    u8 item[BUFQ_EVENT_SIZE]);
+int ia_css_bufq_dequeue_isys_event(u8 item[BUFQ_EVENT_SIZE]);
 
 /**
 * @brief   Enqueue a tagger command item into tagger command queue..
@@ -147,8 +130,7 @@ int ia_css_bufq_dequeue_isys_event(
  * @return	0 or error code upon error.
  *
 */
-int ia_css_bufq_enqueue_tag_cmd(
-    uint32_t item);
+int ia_css_bufq_enqueue_tag_cmd(uint32_t item);
 
 /**
 * @brief  Uninitializes bufq module.
@@ -166,4 +148,4 @@ int ia_css_bufq_deinit(void);
 */
 void ia_css_bufq_dump_queue_info(void);
 
-#endif	/* _IA_CSS_BUFQ_H */
+#endif /* _IA_CSS_BUFQ_H */
diff --git a/drivers/staging/media/atomisp/pci/runtime/bufq/interface/ia_css_bufq_comm.h b/drivers/staging/media/atomisp/pci/runtime/bufq/interface/ia_css_bufq_comm.h
index fb8067fd64a1c35db10a78e83cd8af2745c9aa3d..d7c23500a1829ea1e0a39d34b4cfa1be25d3f990 100644
--- a/drivers/staging/media/atomisp/pci/runtime/bufq/interface/ia_css_bufq_comm.h
+++ b/drivers/staging/media/atomisp/pci/runtime/bufq/interface/ia_css_bufq_comm.h
@@ -10,7 +10,7 @@
 #include "system_global.h"
 
 enum sh_css_queue_id {
-	SH_CSS_INVALID_QUEUE_ID     = -1,
+	SH_CSS_INVALID_QUEUE_ID = -1,
 	SH_CSS_QUEUE_A_ID = 0,
 	SH_CSS_QUEUE_B_ID,
 	SH_CSS_QUEUE_C_ID,
diff --git a/drivers/staging/media/atomisp/pci/runtime/bufq/src/bufq.c b/drivers/staging/media/atomisp/pci/runtime/bufq/src/bufq.c
index bda35614c862455e1a3ad6ea58f05027508a6fce..9982ca095b8b045ca2121f1c12ec4ac579c30e2f 100644
--- a/drivers/staging/media/atomisp/pci/runtime/bufq/src/bufq.c
+++ b/drivers/staging/media/atomisp/pci/runtime/bufq/src/bufq.c
@@ -4,21 +4,21 @@
  * Copyright (c) 2015, Intel Corporation.
  */
 
-#include "assert_support.h"		/* assert */
+#include "assert_support.h" /* assert */
 #include "ia_css_buffer.h"
 #include "sp.h"
-#include "ia_css_bufq.h"		/* Bufq API's */
-#include "ia_css_queue.h"		/* ia_css_queue_t */
-#include "sw_event_global.h"		/* Event IDs.*/
-#include "ia_css_eventq.h"		/* ia_css_eventq_recv()*/
-#include "ia_css_debug.h"		/* ia_css_debug_dtrace*/
-#include "sh_css_internal.h"		/* sh_css_queue_type */
-#include "sp_local.h"			/* sp_address_of */
-#include "sh_css_firmware.h"		/* sh_css_sp_fw*/
+#include "ia_css_bufq.h" /* Bufq API's */
+#include "ia_css_queue.h" /* ia_css_queue_t */
+#include "sw_event_global.h" /* Event IDs.*/
+#include "ia_css_eventq.h" /* ia_css_eventq_recv()*/
+#include "ia_css_debug.h" /* ia_css_debug_dtrace*/
+#include "sh_css_internal.h" /* sh_css_queue_type */
+#include "sp_local.h" /* sp_address_of */
+#include "sh_css_firmware.h" /* sh_css_sp_fw*/
 
 #define BUFQ_DUMP_FILE_NAME_PREFIX_SIZE 256
 
-static char prefix[BUFQ_DUMP_FILE_NAME_PREFIX_SIZE] = {0};
+static char prefix[BUFQ_DUMP_FILE_NAME_PREFIX_SIZE] = { 0 };
 
 /*********************************************************/
 /* Global Queue objects used by CSS                      */
@@ -26,11 +26,10 @@ static char prefix[BUFQ_DUMP_FILE_NAME_PREFIX_SIZE] = {0};
 
 struct sh_css_queues {
 	/* Host2SP buffer queue */
-	ia_css_queue_t host2sp_buffer_queue_handles
-	[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES];
+	ia_css_queue_t host2sp_buffer_queue_handles[SH_CSS_MAX_SP_THREADS]
+						   [SH_CSS_MAX_NUM_QUEUES];
 	/* SP2Host buffer queue */
-	ia_css_queue_t sp2host_buffer_queue_handles
-	[SH_CSS_MAX_NUM_QUEUES];
+	ia_css_queue_t sp2host_buffer_queue_handles[SH_CSS_MAX_NUM_QUEUES];
 
 	/* Host2SP event queue */
 	ia_css_queue_t host2sp_psys_event_queue_handle;
@@ -52,27 +51,20 @@ struct sh_css_queues {
 ********************************************************/
 static struct sh_css_queues css_queues;
 
-static int
-buffer_type_to_queue_id_map[SH_CSS_MAX_SP_THREADS][IA_CSS_NUM_DYNAMIC_BUFFER_TYPE];
+static int buffer_type_to_queue_id_map[SH_CSS_MAX_SP_THREADS]
+				      [IA_CSS_NUM_DYNAMIC_BUFFER_TYPE];
 static bool queue_availability[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES];
 
 /*******************************************************
 *** Static functions
 ********************************************************/
-static void map_buffer_type_to_queue_id(
-    unsigned int thread_id,
-    enum ia_css_buffer_type buf_type
-);
-static void unmap_buffer_type_to_queue_id(
-    unsigned int thread_id,
-    enum ia_css_buffer_type buf_type
-);
-
-static ia_css_queue_t *bufq_get_qhandle(
-    enum sh_css_queue_type type,
-    enum sh_css_queue_id id,
-    int thread
-);
+static void map_buffer_type_to_queue_id(unsigned int thread_id,
+					enum ia_css_buffer_type buf_type);
+static void unmap_buffer_type_to_queue_id(unsigned int thread_id,
+					  enum ia_css_buffer_type buf_type);
+
+static ia_css_queue_t *bufq_get_qhandle(enum sh_css_queue_type type,
+					enum sh_css_queue_id id, int thread);
 
 /*******************************************************
 *** Public functions
@@ -88,20 +80,21 @@ void ia_css_queue_map_init(void)
 
 	for (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {
 		for (j = 0; j < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE; j++)
-			buffer_type_to_queue_id_map[i][j] = SH_CSS_INVALID_QUEUE_ID;
+			buffer_type_to_queue_id_map[i][j] =
+				SH_CSS_INVALID_QUEUE_ID;
 	}
 }
 
-void ia_css_queue_map(
-    unsigned int thread_id,
-    enum ia_css_buffer_type buf_type,
-    bool map)
+void ia_css_queue_map(unsigned int thread_id, enum ia_css_buffer_type buf_type,
+		      bool map)
 {
 	assert(buf_type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE);
 	assert(thread_id < SH_CSS_MAX_SP_THREADS);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_queue_map() enter: buf_type=%d, thread_id=%d\n", buf_type, thread_id);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_queue_map() enter: buf_type=%d, thread_id=%d\n",
+		buf_type, thread_id);
 
 	if (map)
 		map_buffer_type_to_queue_id(thread_id, buf_type);
@@ -112,12 +105,12 @@ void ia_css_queue_map(
 /*
  * @brief Query the internal queue ID.
  */
-bool ia_css_query_internal_queue_id(
-    enum ia_css_buffer_type buf_type,
-    unsigned int thread_id,
-    enum sh_css_queue_id *val)
+bool ia_css_query_internal_queue_id(enum ia_css_buffer_type buf_type,
+				    unsigned int thread_id,
+				    enum sh_css_queue_id *val)
 {
-	IA_CSS_ENTER("buf_type=%d, thread_id=%d, val = %p", buf_type, thread_id, val);
+	IA_CSS_ENTER("buf_type=%d, thread_id=%d, val = %p", buf_type, thread_id,
+		     val);
 
 	if ((!val) || (thread_id >= SH_CSS_MAX_SP_THREADS) ||
 	    (buf_type >= IA_CSS_NUM_DYNAMIC_BUFFER_TYPE)) {
@@ -126,7 +119,8 @@ bool ia_css_query_internal_queue_id(
 	}
 
 	*val = buffer_type_to_queue_id_map[thread_id][buf_type];
-	if ((*val == SH_CSS_INVALID_QUEUE_ID) || (*val >= SH_CSS_MAX_NUM_QUEUES)) {
+	if ((*val == SH_CSS_INVALID_QUEUE_ID) ||
+	    (*val >= SH_CSS_MAX_NUM_QUEUES)) {
 		IA_CSS_LOG("INVALID queue ID MAP = %d\n", *val);
 		IA_CSS_LEAVE("return_val = false");
 		return false;
@@ -138,9 +132,8 @@ bool ia_css_query_internal_queue_id(
 /*******************************************************
 *** Static functions
 ********************************************************/
-static void map_buffer_type_to_queue_id(
-    unsigned int thread_id,
-    enum ia_css_buffer_type buf_type)
+static void map_buffer_type_to_queue_id(unsigned int thread_id,
+					enum ia_css_buffer_type buf_type)
 {
 	unsigned int i;
 
@@ -151,19 +144,25 @@ static void map_buffer_type_to_queue_id(
 
 	/* queue 0 is reserved for parameters because it doesn't depend on events */
 	if (buf_type == IA_CSS_BUFFER_TYPE_PARAMETER_SET) {
-		assert(queue_availability[thread_id][IA_CSS_PARAMETER_SET_QUEUE_ID]);
-		queue_availability[thread_id][IA_CSS_PARAMETER_SET_QUEUE_ID] = false;
+		assert(queue_availability[thread_id]
+					 [IA_CSS_PARAMETER_SET_QUEUE_ID]);
+		queue_availability[thread_id][IA_CSS_PARAMETER_SET_QUEUE_ID] =
+			false;
 		buffer_type_to_queue_id_map[thread_id][buf_type] =
-		    IA_CSS_PARAMETER_SET_QUEUE_ID;
+			IA_CSS_PARAMETER_SET_QUEUE_ID;
 		return;
 	}
 
 	/* queue 1 is reserved for per frame parameters because it doesn't depend on events */
 	if (buf_type == IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET) {
-		assert(queue_availability[thread_id][IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID]);
-		queue_availability[thread_id][IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID] = false;
+		assert(queue_availability
+			       [thread_id]
+			       [IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID]);
+		queue_availability[thread_id]
+				  [IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID] =
+					  false;
 		buffer_type_to_queue_id_map[thread_id][buf_type] =
-		    IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID;
+			IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID;
 		return;
 	}
 
@@ -179,9 +178,8 @@ static void map_buffer_type_to_queue_id(
 	return;
 }
 
-static void unmap_buffer_type_to_queue_id(
-    unsigned int thread_id,
-    enum ia_css_buffer_type buf_type)
+static void unmap_buffer_type_to_queue_id(unsigned int thread_id,
+					  enum ia_css_buffer_type buf_type)
 {
 	int queue_id;
 
@@ -191,14 +189,13 @@ static void unmap_buffer_type_to_queue_id(
 	       SH_CSS_INVALID_QUEUE_ID);
 
 	queue_id = buffer_type_to_queue_id_map[thread_id][buf_type];
-	buffer_type_to_queue_id_map[thread_id][buf_type] = SH_CSS_INVALID_QUEUE_ID;
+	buffer_type_to_queue_id_map[thread_id][buf_type] =
+		SH_CSS_INVALID_QUEUE_ID;
 	queue_availability[thread_id][queue_id] = true;
 }
 
-static ia_css_queue_t *bufq_get_qhandle(
-    enum sh_css_queue_type type,
-    enum sh_css_queue_id id,
-    int thread)
+static ia_css_queue_t *bufq_get_qhandle(enum sh_css_queue_type type,
+					enum sh_css_queue_id id, int thread)
 {
 	ia_css_queue_t *q = NULL;
 
@@ -239,10 +236,8 @@ static ia_css_queue_t *bufq_get_qhandle(
 /* Local function to initialize a buffer queue. This reduces
  * the chances of copy-paste errors or typos.
  */
-static inline void
-init_bufq(unsigned int desc_offset,
-	  unsigned int elems_offset,
-	  ia_css_queue_t *handle)
+static inline void init_bufq(unsigned int desc_offset,
+			     unsigned int elems_offset, ia_css_queue_t *handle)
 {
 	const struct ia_css_fw_info *fw;
 	unsigned int q_base_addr;
@@ -269,55 +264,64 @@ void ia_css_bufq_init(void)
 	/* Setup all the local queue descriptors for Host2SP Buffer Queues */
 	for (i = 0; i < SH_CSS_MAX_SP_THREADS; i++)
 		for (j = 0; j < SH_CSS_MAX_NUM_QUEUES; j++) {
-			init_bufq((uint32_t)offsetof(struct host_sp_queues,
-						     host2sp_buffer_queues_desc[i][j]),
-				  (uint32_t)offsetof(struct host_sp_queues, host2sp_buffer_queues_elems[i][j]),
-				  &css_queues.host2sp_buffer_queue_handles[i][j]);
+			init_bufq(
+				(uint32_t)offsetof(
+					struct host_sp_queues,
+					host2sp_buffer_queues_desc[i][j]),
+				(uint32_t)offsetof(
+					struct host_sp_queues,
+					host2sp_buffer_queues_elems[i][j]),
+				&css_queues.host2sp_buffer_queue_handles[i][j]);
 		}
 
 	/* Setup all the local queue descriptors for SP2Host Buffer Queues */
 	for (i = 0; i < SH_CSS_MAX_NUM_QUEUES; i++) {
-		init_bufq(offsetof(struct host_sp_queues, sp2host_buffer_queues_desc[i]),
-			  offsetof(struct host_sp_queues, sp2host_buffer_queues_elems[i]),
+		init_bufq(offsetof(struct host_sp_queues,
+				   sp2host_buffer_queues_desc[i]),
+			  offsetof(struct host_sp_queues,
+				   sp2host_buffer_queues_elems[i]),
 			  &css_queues.sp2host_buffer_queue_handles[i]);
 	}
 
 	/* Host2SP event queue*/
 	init_bufq((uint32_t)offsetof(struct host_sp_queues,
 				     host2sp_psys_event_queue_desc),
-		  (uint32_t)offsetof(struct host_sp_queues, host2sp_psys_event_queue_elems),
+		  (uint32_t)offsetof(struct host_sp_queues,
+				     host2sp_psys_event_queue_elems),
 		  &css_queues.host2sp_psys_event_queue_handle);
 
 	/* SP2Host event queue */
 	init_bufq((uint32_t)offsetof(struct host_sp_queues,
 				     sp2host_psys_event_queue_desc),
-		  (uint32_t)offsetof(struct host_sp_queues, sp2host_psys_event_queue_elems),
+		  (uint32_t)offsetof(struct host_sp_queues,
+				     sp2host_psys_event_queue_elems),
 		  &css_queues.sp2host_psys_event_queue_handle);
 
 	/* Host2SP ISYS event queue */
 	init_bufq((uint32_t)offsetof(struct host_sp_queues,
 				     host2sp_isys_event_queue_desc),
-		  (uint32_t)offsetof(struct host_sp_queues, host2sp_isys_event_queue_elems),
+		  (uint32_t)offsetof(struct host_sp_queues,
+				     host2sp_isys_event_queue_elems),
 		  &css_queues.host2sp_isys_event_queue_handle);
 
 	/* SP2Host ISYS event queue*/
 	init_bufq((uint32_t)offsetof(struct host_sp_queues,
 				     sp2host_isys_event_queue_desc),
-		  (uint32_t)offsetof(struct host_sp_queues, sp2host_isys_event_queue_elems),
+		  (uint32_t)offsetof(struct host_sp_queues,
+				     sp2host_isys_event_queue_elems),
 		  &css_queues.sp2host_isys_event_queue_handle);
 
 	/* Host2SP tagger command queue */
-	init_bufq((uint32_t)offsetof(struct host_sp_queues, host2sp_tag_cmd_queue_desc),
-		  (uint32_t)offsetof(struct host_sp_queues, host2sp_tag_cmd_queue_elems),
+	init_bufq((uint32_t)offsetof(struct host_sp_queues,
+				     host2sp_tag_cmd_queue_desc),
+		  (uint32_t)offsetof(struct host_sp_queues,
+				     host2sp_tag_cmd_queue_elems),
 		  &css_queues.host2sp_tag_cmd_queue_handle);
 
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
-int ia_css_bufq_enqueue_buffer(
-    int thread_index,
-    int queue_id,
-    uint32_t item)
+int ia_css_bufq_enqueue_buffer(int thread_index, int queue_id, uint32_t item)
 {
 	ia_css_queue_t *q;
 	int error;
@@ -328,8 +332,7 @@ int ia_css_bufq_enqueue_buffer(
 		return -EINVAL;
 
 	/* Get the queue for communication */
-	q = bufq_get_qhandle(sh_css_host2sp_buffer_queue,
-			     queue_id,
+	q = bufq_get_qhandle(sh_css_host2sp_buffer_queue, queue_id,
 			     thread_index);
 	if (q) {
 		error = ia_css_queue_enqueue(q, item);
@@ -342,23 +345,17 @@ int ia_css_bufq_enqueue_buffer(
 	return error;
 }
 
-int ia_css_bufq_dequeue_buffer(
-    int queue_id,
-    uint32_t *item)
+int ia_css_bufq_dequeue_buffer(int queue_id, uint32_t *item)
 {
 	int error;
 	ia_css_queue_t *q;
 
 	IA_CSS_ENTER_PRIVATE("queue_id=%d", queue_id);
-	if ((!item) ||
-	    (queue_id <= SH_CSS_INVALID_QUEUE_ID) ||
-	    (queue_id >= SH_CSS_MAX_NUM_QUEUES)
-	   )
+	if ((!item) || (queue_id <= SH_CSS_INVALID_QUEUE_ID) ||
+	    (queue_id >= SH_CSS_MAX_NUM_QUEUES))
 		return -EINVAL;
 
-	q = bufq_get_qhandle(sh_css_sp2host_buffer_queue,
-			     queue_id,
-			     -1);
+	q = bufq_get_qhandle(sh_css_sp2host_buffer_queue, queue_id, -1);
 	if (q) {
 		error = ia_css_queue_dequeue(q, item);
 	} else {
@@ -370,11 +367,8 @@ int ia_css_bufq_dequeue_buffer(
 	return error;
 }
 
-int ia_css_bufq_enqueue_psys_event(
-    u8 evt_id,
-    u8 evt_payload_0,
-    u8 evt_payload_1,
-    uint8_t evt_payload_2)
+int ia_css_bufq_enqueue_psys_event(u8 evt_id, u8 evt_payload_0,
+				   u8 evt_payload_1, uint8_t evt_payload_2)
 {
 	int error = 0;
 	ia_css_queue_t *q;
@@ -386,15 +380,14 @@ int ia_css_bufq_enqueue_psys_event(
 		return -EBUSY;
 	}
 
-	error = ia_css_eventq_send(q,
-				   evt_id, evt_payload_0, evt_payload_1, evt_payload_2);
+	error = ia_css_eventq_send(q, evt_id, evt_payload_0, evt_payload_1,
+				   evt_payload_2);
 
 	IA_CSS_LEAVE_ERR_PRIVATE(error);
 	return error;
 }
 
-int ia_css_bufq_dequeue_psys_event(
-    u8 item[BUFQ_EVENT_SIZE])
+int ia_css_bufq_dequeue_psys_event(u8 item[BUFQ_EVENT_SIZE])
 {
 	int error = 0;
 	ia_css_queue_t *q;
@@ -415,8 +408,7 @@ int ia_css_bufq_dequeue_psys_event(
 	return error;
 }
 
-int ia_css_bufq_dequeue_isys_event(
-    u8 item[BUFQ_EVENT_SIZE])
+int ia_css_bufq_dequeue_isys_event(u8 item[BUFQ_EVENT_SIZE])
 {
 	int error = 0;
 	ia_css_queue_t *q;
@@ -454,8 +446,7 @@ int ia_css_bufq_enqueue_isys_event(uint8_t evt_id)
 	return error;
 }
 
-int ia_css_bufq_enqueue_tag_cmd(
-    uint32_t item)
+int ia_css_bufq_enqueue_tag_cmd(uint32_t item)
 {
 	int error;
 	ia_css_queue_t *q;
@@ -484,8 +475,8 @@ static void bufq_dump_queue_info(const char *prefix, ia_css_queue_t *qhandle)
 	assert(prefix && qhandle);
 	ia_css_queue_get_used_space(qhandle, &used);
 	ia_css_queue_get_free_space(qhandle, &free);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s: used=%u free=%u\n",
-			    prefix, used, free);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s: used=%u free=%u\n", prefix,
+			    used, free);
 }
 
 void ia_css_bufq_dump_queue_info(void)
@@ -498,16 +489,17 @@ void ia_css_bufq_dump_queue_info(void)
 		for (j = 0; j < SH_CSS_MAX_NUM_QUEUES; j++) {
 			snprintf(prefix, BUFQ_DUMP_FILE_NAME_PREFIX_SIZE,
 				 "host2sp_buffer_queue[%u][%u]", i, j);
-			bufq_dump_queue_info(prefix,
-					     &css_queues.host2sp_buffer_queue_handles[i][j]);
+			bufq_dump_queue_info(
+				prefix,
+				&css_queues.host2sp_buffer_queue_handles[i][j]);
 		}
 	}
 
 	for (i = 0; i < SH_CSS_MAX_NUM_QUEUES; i++) {
 		snprintf(prefix, BUFQ_DUMP_FILE_NAME_PREFIX_SIZE,
 			 "sp2host_buffer_queue[%u]", i);
-		bufq_dump_queue_info(prefix,
-				     &css_queues.sp2host_buffer_queue_handles[i]);
+		bufq_dump_queue_info(
+			prefix, &css_queues.sp2host_buffer_queue_handles[i]);
 	}
 	bufq_dump_queue_info("host2sp_psys_event",
 			     &css_queues.host2sp_psys_event_queue_handle);
diff --git a/drivers/staging/media/atomisp/pci/runtime/debug/interface/ia_css_debug.h b/drivers/staging/media/atomisp/pci/runtime/debug/interface/ia_css_debug.h
index 2d0e906530af45cba598d34e5539dc455e8e77ff..3b1c737899dc4dd0138842efcd22d75ad47b45db 100644
--- a/drivers/staging/media/atomisp/pci/runtime/debug/interface/ia_css_debug.h
+++ b/drivers/staging/media/atomisp/pci/runtime/debug/interface/ia_css_debug.h
@@ -24,19 +24,19 @@
 
 /* available levels */
 /*! Level for tracing errors */
-#define IA_CSS_DEBUG_ERROR   1
+#define IA_CSS_DEBUG_ERROR 1
 /*! Level for tracing warnings */
 #define IA_CSS_DEBUG_WARNING 3
 /*! Level for tracing debug messages */
-#define IA_CSS_DEBUG_VERBOSE   5
+#define IA_CSS_DEBUG_VERBOSE 5
 /*! Level for tracing trace messages a.o. ia_css public function calls */
-#define IA_CSS_DEBUG_TRACE   6
+#define IA_CSS_DEBUG_TRACE 6
 /*! Level for tracing trace messages a.o. ia_css private function calls */
-#define IA_CSS_DEBUG_TRACE_PRIVATE   7
+#define IA_CSS_DEBUG_TRACE_PRIVATE 7
 /*! Level for tracing parameter messages e.g. in and out params of functions */
-#define IA_CSS_DEBUG_PARAM   8
+#define IA_CSS_DEBUG_PARAM 8
 /*! Level for tracing info messages */
-#define IA_CSS_DEBUG_INFO    9
+#define IA_CSS_DEBUG_INFO 9
 
 /* Global variable which controls the verbosity levels of the debug tracing */
 extern int dbg_level;
@@ -45,75 +45,80 @@ extern int dbg_level;
  *  Values can be combined to dump a combination of sets.
  */
 enum ia_css_debug_enable_param_dump {
-	IA_CSS_DEBUG_DUMP_FPN = BIT(0),  /** FPN table */
-	IA_CSS_DEBUG_DUMP_OB  = BIT(1),  /** OB table */
-	IA_CSS_DEBUG_DUMP_SC  = BIT(2),  /** Shading table */
-	IA_CSS_DEBUG_DUMP_WB  = BIT(3),  /** White balance */
-	IA_CSS_DEBUG_DUMP_DP  = BIT(4),  /** Defect Pixel */
-	IA_CSS_DEBUG_DUMP_BNR = BIT(5),  /** Bayer Noise Reductions */
-	IA_CSS_DEBUG_DUMP_S3A = BIT(6),  /** 3A Statistics */
-	IA_CSS_DEBUG_DUMP_DE  = BIT(7),  /** De Mosaicing */
-	IA_CSS_DEBUG_DUMP_YNR = BIT(8),  /** Luma Noise Reduction */
-	IA_CSS_DEBUG_DUMP_CSC = BIT(9),  /** Color Space Conversion */
-	IA_CSS_DEBUG_DUMP_GC  = BIT(10), /** Gamma Correction */
+	IA_CSS_DEBUG_DUMP_FPN = BIT(0), /** FPN table */
+	IA_CSS_DEBUG_DUMP_OB = BIT(1), /** OB table */
+	IA_CSS_DEBUG_DUMP_SC = BIT(2), /** Shading table */
+	IA_CSS_DEBUG_DUMP_WB = BIT(3), /** White balance */
+	IA_CSS_DEBUG_DUMP_DP = BIT(4), /** Defect Pixel */
+	IA_CSS_DEBUG_DUMP_BNR = BIT(5), /** Bayer Noise Reductions */
+	IA_CSS_DEBUG_DUMP_S3A = BIT(6), /** 3A Statistics */
+	IA_CSS_DEBUG_DUMP_DE = BIT(7), /** De Mosaicing */
+	IA_CSS_DEBUG_DUMP_YNR = BIT(8), /** Luma Noise Reduction */
+	IA_CSS_DEBUG_DUMP_CSC = BIT(9), /** Color Space Conversion */
+	IA_CSS_DEBUG_DUMP_GC = BIT(10), /** Gamma Correction */
 	IA_CSS_DEBUG_DUMP_TNR = BIT(11), /** Temporal Noise Reduction */
 	IA_CSS_DEBUG_DUMP_ANR = BIT(12), /** Advanced Noise Reduction */
-	IA_CSS_DEBUG_DUMP_CE  = BIT(13), /** Chroma Enhancement */
+	IA_CSS_DEBUG_DUMP_CE = BIT(13), /** Chroma Enhancement */
 	IA_CSS_DEBUG_DUMP_ALL = BIT(14), /** Dump all device parameters */
 };
 
-#define IA_CSS_ERROR(fmt, ...) \
-	ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, \
-		"%s() %d: error: " fmt "\n", __func__, __LINE__, ##__VA_ARGS__)
+#define IA_CSS_ERROR(fmt, ...)                                               \
+	ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "%s() %d: error: " fmt "\n", \
+			    __func__, __LINE__, ##__VA_ARGS__)
 
-#define IA_CSS_WARNING(fmt, ...) \
-	ia_css_debug_dtrace(IA_CSS_DEBUG_WARNING, \
-		"%s() %d: warning: " fmt "\n", __func__, __LINE__, ##__VA_ARGS__)
+#define IA_CSS_WARNING(fmt, ...)                                               \
+	ia_css_debug_dtrace(IA_CSS_DEBUG_WARNING,                              \
+			    "%s() %d: warning: " fmt "\n", __func__, __LINE__, \
+			    ##__VA_ARGS__)
 
 /* Logging macros for public functions (API functions) */
-#define IA_CSS_ENTER(fmt, ...) \
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \
-		"%s(): enter: " fmt "\n", __func__, ##__VA_ARGS__)
+#define IA_CSS_ENTER(fmt, ...)                                            \
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s(): enter: " fmt "\n", \
+			    __func__, ##__VA_ARGS__)
 
 /* Use this macro for small functions that do not call other functions. */
-#define IA_CSS_ENTER_LEAVE(fmt, ...) \
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \
-		"%s(): enter: leave: " fmt "\n", __func__, ##__VA_ARGS__)
+#define IA_CSS_ENTER_LEAVE(fmt, ...)                                   \
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,                        \
+			    "%s(): enter: leave: " fmt "\n", __func__, \
+			    ##__VA_ARGS__)
 
-#define IA_CSS_LEAVE(fmt, ...) \
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \
-		"%s(): leave: " fmt "\n", __func__, ##__VA_ARGS__)
+#define IA_CSS_LEAVE(fmt, ...)                                            \
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s(): leave: " fmt "\n", \
+			    __func__, ##__VA_ARGS__)
 
 /* Shorthand for returning an int return value */
-#define IA_CSS_LEAVE_ERR(__err) \
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \
-		"%s() %d: leave: return_err=%d\n", __func__, __LINE__, __err)
+#define IA_CSS_LEAVE_ERR(__err)                                          \
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,                          \
+			    "%s() %d: leave: return_err=%d\n", __func__, \
+			    __LINE__, __err)
 
 /* Use this macro for logging other than enter/leave.
  * Note that this macro always uses the PRIVATE logging level.
  */
-#define IA_CSS_LOG(fmt, ...) \
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \
-		"%s(): " fmt "\n", __func__, ##__VA_ARGS__)
+#define IA_CSS_LOG(fmt, ...)                                               \
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s(): " fmt "\n", \
+			    __func__, ##__VA_ARGS__)
 
 /* Logging macros for non-API functions. These have a lower trace level */
-#define IA_CSS_ENTER_PRIVATE(fmt, ...) \
+#define IA_CSS_ENTER_PRIVATE(fmt, ...)                  \
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \
-		"%s(): enter: " fmt "\n", __func__, ##__VA_ARGS__)
+			    "%s(): enter: " fmt "\n", __func__, ##__VA_ARGS__)
 
-#define IA_CSS_LEAVE_PRIVATE(fmt, ...) \
+#define IA_CSS_LEAVE_PRIVATE(fmt, ...)                  \
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \
-		"%s(): leave: " fmt "\n", __func__, ##__VA_ARGS__)
+			    "%s(): leave: " fmt "\n", __func__, ##__VA_ARGS__)
 
 /* Shorthand for returning an int return value */
-#define IA_CSS_LEAVE_ERR_PRIVATE(__err) \
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \
-		"%s() %d: leave: return_err=%d\n", __func__, __LINE__, __err)
+#define IA_CSS_LEAVE_ERR_PRIVATE(__err)                                  \
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,                  \
+			    "%s() %d: leave: return_err=%d\n", __func__, \
+			    __LINE__, __err)
 
 /* Use this macro for small functions that do not call other functions. */
-#define IA_CSS_ENTER_LEAVE_PRIVATE(fmt, ...) \
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \
-		"%s(): enter: leave: " fmt "\n", __func__, ##__VA_ARGS__)
+#define IA_CSS_ENTER_LEAVE_PRIVATE(fmt, ...)                           \
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,                \
+			    "%s(): enter: leave: " fmt "\n", __func__, \
+			    ##__VA_ARGS__)
 
 /*! @brief Function for tracing to the provided printf function in the
  *	environment.
@@ -121,24 +126,21 @@ enum ia_css_debug_enable_param_dump {
  * @param[in]	fmt		printf like format string
  * @param[in]	args		arguments for the format string
  */
-static inline void __printf(2, 0) ia_css_debug_vdtrace(unsigned int level,
-						       const char *fmt,
-						       va_list args)
+static inline void __printf(2, 0)
+	ia_css_debug_vdtrace(unsigned int level, const char *fmt, va_list args)
 {
 	if (dbg_level >= level)
 		sh_css_vprint(fmt, args);
 }
 
-__printf(2, 3) void ia_css_debug_dtrace(unsigned int level,
-					const char *fmt, ...);
-
+__printf(2, 3) void ia_css_debug_dtrace(unsigned int level, const char *fmt,
+					...);
 
 /*! @brief Function to set the global dtrace verbosity level.
  * @param[in]	trace_level	Maximum level of the messages to be traced.
  * @return	None
  */
-void ia_css_debug_set_dtrace_level(
-    const unsigned int	trace_level);
+void ia_css_debug_set_dtrace_level(const unsigned int trace_level);
 
 /*! @brief Function to get the global dtrace verbosity level.
  * @return	global dtrace verbosity level
@@ -161,15 +163,14 @@ void ia_css_debug_dump_sp_sw_debug_info(void);
 
 #if SP_DEBUG != SP_DEBUG_NONE
 void ia_css_debug_print_sp_debug_state(
-    const struct sh_css_sp_debug_state *state);
+	const struct sh_css_sp_debug_state *state);
 #endif
 
 /*! @brief Dump all related binary info data
  * @param[in]  bi	Binary info struct.
  * @return	None
  */
-void ia_css_debug_binary_print(
-    const struct ia_css_binary *bi);
+void ia_css_debug_binary_print(const struct ia_css_binary *bi);
 
 void ia_css_debug_sp_dump_mipi_fifo_high_water(void);
 
@@ -203,9 +204,8 @@ void ia_css_debug_dump_all_fifo_state(void);
  * @param[in]	descr		description output along with the frame info
  * @return	None
  */
-void ia_css_debug_frame_print(
-    const struct ia_css_frame	*frame,
-    const char	*descr);
+void ia_css_debug_frame_print(const struct ia_css_frame *frame,
+			      const char *descr);
 
 /*! @brief Function to enable sp sleep mode.
  * Function that enables sp sleep mode
@@ -240,9 +240,8 @@ void sh_css_dump_sp_raw_copy_linecount(bool reduced);
  * @param[in]	label	description of resolution output
  * @return	None
  */
-void ia_css_debug_dump_resolution(
-    const struct ia_css_resolution *res,
-    const char *label);
+void ia_css_debug_dump_resolution(const struct ia_css_resolution *res,
+				  const char *label);
 
 /*! @brief Dump the frame info to the trace output
  * Dumps the frame info to the trace output.
@@ -250,9 +249,8 @@ void ia_css_debug_dump_resolution(
  * @param[in]	label	description of frame_info output
  * @return	None
  */
-void ia_css_debug_dump_frame_info(
-    const struct ia_css_frame_info *info,
-    const char *label);
+void ia_css_debug_dump_frame_info(const struct ia_css_frame_info *info,
+				  const char *label);
 
 /*! @brief Dump the capture config info to the trace output
  * Dumps the capture config info to the trace output.
@@ -260,7 +258,7 @@ void ia_css_debug_dump_frame_info(
  * @return	None
  */
 void ia_css_debug_dump_capture_config(
-    const struct ia_css_capture_config *config);
+	const struct ia_css_capture_config *config);
 
 /*! @brief Dump the pipe extra config info to the trace output
  * Dumps the pipe extra config info to the trace output.
@@ -268,15 +266,14 @@ void ia_css_debug_dump_capture_config(
  * @return	None
  */
 void ia_css_debug_dump_pipe_extra_config(
-    const struct ia_css_pipe_extra_config *extra_config);
+	const struct ia_css_pipe_extra_config *extra_config);
 
 /*! @brief Dump the pipe config info to the trace output
  * Dumps the pipe config info to the trace output.
  * @param[in]	config	pointer to struct ia_css_pipe_config
  * @return	None
  */
-void ia_css_debug_dump_pipe_config(
-    const struct ia_css_pipe_config *config);
+void ia_css_debug_dump_pipe_config(const struct ia_css_pipe_config *config);
 
 /*! @brief Dump the stream config source info to the trace output
  * Dumps the stream config source info to the trace output.
@@ -284,7 +281,7 @@ void ia_css_debug_dump_pipe_config(
  * @return	None
  */
 void ia_css_debug_dump_stream_config_source(
-    const struct ia_css_stream_config *config);
+	const struct ia_css_stream_config *config);
 
 /*! @brief Dump the mipi buffer config info to the trace output
  * Dumps the mipi buffer config info to the trace output.
@@ -292,7 +289,7 @@ void ia_css_debug_dump_stream_config_source(
  * @return	None
  */
 void ia_css_debug_dump_mipi_buffer_config(
-    const struct ia_css_mipi_buffer_config *config);
+	const struct ia_css_mipi_buffer_config *config);
 
 /*! @brief Dump the metadata config info to the trace output
  * Dumps the metadata config info to the trace output.
@@ -300,7 +297,7 @@ void ia_css_debug_dump_mipi_buffer_config(
  * @return	None
  */
 void ia_css_debug_dump_metadata_config(
-    const struct ia_css_metadata_config *config);
+	const struct ia_css_metadata_config *config);
 
 /*! @brief Dump the stream config info to the trace output
  * Dumps the stream config info to the trace output.
@@ -308,9 +305,8 @@ void ia_css_debug_dump_metadata_config(
  * @param[in]	num_pipes	number of pipes for the stream
  * @return	None
  */
-void ia_css_debug_dump_stream_config(
-    const struct ia_css_stream_config *config,
-    int num_pipes);
+void ia_css_debug_dump_stream_config(const struct ia_css_stream_config *config,
+				     int num_pipes);
 
 /**
  * @brief Initialize the debug mode.
@@ -340,10 +336,8 @@ bool ia_css_debug_mode_init(void);
  *	- true, if it is successful.
  *	- false, otherwise.
  */
-bool ia_css_debug_mode_disable_dma_channel(
-    int dma_ID,
-    int channel_id,
-    int request_type);
+bool ia_css_debug_mode_disable_dma_channel(int dma_ID, int channel_id,
+					   int request_type);
 /**
  * @brief Enable the DMA channel.
  *
@@ -358,10 +352,8 @@ bool ia_css_debug_mode_disable_dma_channel(
  *	- true, if it is successful.
  *	- false, otherwise.
  */
-bool ia_css_debug_mode_enable_dma_channel(
-    int dma_ID,
-    int channel_id,
-    int request_type);
+bool ia_css_debug_mode_enable_dma_channel(int dma_ID, int channel_id,
+					  int request_type);
 
 /**
  * @brief Dump tracer data.
@@ -393,8 +385,7 @@ void ia_css_debug_pc_dump(sp_ID_t id, unsigned int num_of_dumps);
  *
  * @return	None
  */
-void ia_css_debug_dump_hang_status(
-    struct ia_css_pipe *pipe);
+void ia_css_debug_dump_hang_status(struct ia_css_pipe *pipe);
 
 /*! @brief External command handler
  * External command handler
diff --git a/drivers/staging/media/atomisp/pci/runtime/debug/interface/ia_css_debug_pipe.h b/drivers/staging/media/atomisp/pci/runtime/debug/interface/ia_css_debug_pipe.h
index 80c58cb934d5e9ea28112c6b34d63c26f6aa8047..2dfae8487bd17b94236680c57e28c75fc847a837 100644
--- a/drivers/staging/media/atomisp/pci/runtime/debug/interface/ia_css_debug_pipe.h
+++ b/drivers/staging/media/atomisp/pci/runtime/debug/interface/ia_css_debug_pipe.h
@@ -34,9 +34,8 @@ void ia_css_debug_pipe_graph_dump_epilogue(void);
  *
  * @return	None
  */
-void ia_css_debug_pipe_graph_dump_stage(
-    struct ia_css_pipeline_stage *stage,
-    enum ia_css_pipe_id id);
+void ia_css_debug_pipe_graph_dump_stage(struct ia_css_pipeline_stage *stage,
+					enum ia_css_pipe_id id);
 
 /**
  * @brief Internal debug support for constructing a pipe graph.
@@ -44,8 +43,7 @@ void ia_css_debug_pipe_graph_dump_stage(
  *
  * @return	None
  */
-void ia_css_debug_pipe_graph_dump_sp_raw_copy(
-    struct ia_css_frame *out_frame);
+void ia_css_debug_pipe_graph_dump_sp_raw_copy(struct ia_css_frame *out_frame);
 
 /**
  * @brief Internal debug support for constructing a pipe graph.
@@ -54,6 +52,6 @@ void ia_css_debug_pipe_graph_dump_sp_raw_copy(
  * @return	None
  */
 void ia_css_debug_pipe_graph_dump_stream_config(
-    const struct ia_css_stream_config *stream_config);
+	const struct ia_css_stream_config *stream_config);
 
 #endif /* _IA_CSS_DEBUG_PIPE_H_ */
diff --git a/drivers/staging/media/atomisp/pci/runtime/debug/src/ia_css_debug.c b/drivers/staging/media/atomisp/pci/runtime/debug/src/ia_css_debug.c
index 84220359c9576b0021ea7ac7ba13548bd77e49fd..19fd49e3133769fea25a1a4314495bad648a56af 100644
--- a/drivers/staging/media/atomisp/pci/runtime/debug/src/ia_css_debug.c
+++ b/drivers/staging/media/atomisp/pci/runtime/debug/src/ia_css_debug.c
@@ -52,16 +52,16 @@
 #include "isp.h"
 #include "type_support.h"
 #include "math_support.h" /* CEIL_DIV */
-#include "input_system.h"	/* input_formatter_reg_load */
+#include "input_system.h" /* input_formatter_reg_load */
 #include "ia_css_tagger_common.h"
 
 #include "sh_css_internal.h"
 #include "ia_css_isys.h"
-#include "sh_css_sp.h"		/* sh_css_sp_get_debug_state() */
+#include "sh_css_sp.h" /* sh_css_sp_get_debug_state() */
 
-#include "css_trace.h"      /* tracer */
+#include "css_trace.h" /* tracer */
 
-#include "device_access.h"	/* for ia_css_device_load_uint32 */
+#include "device_access.h" /* for ia_css_device_load_uint32 */
 
 /* Include all kernel host interfaces for ISP1 */
 #include "anr/anr_1.0/ia_css_anr.host.h"
@@ -89,7 +89,7 @@
 #include "ynr/ynr_2/ia_css_ynr2.host.h"
 
 #define DPG_START "ia_css_debug_pipe_graph_dump_start "
-#define DPG_END   " ia_css_debug_pipe_graph_dump_end\n"
+#define DPG_END " ia_css_debug_pipe_graph_dump_end\n"
 
 #define ENABLE_LINE_MAX_LENGTH (25)
 
@@ -100,25 +100,25 @@ static struct pipe_graph_class {
 	int eff_height;
 	int eff_width;
 	enum atomisp_input_format stream_format;
-} pg_inst = {true, 0, 0, 0, 0, N_ATOMISP_INPUT_FORMAT};
+} pg_inst = { true, 0, 0, 0, 0, N_ATOMISP_INPUT_FORMAT };
 
 static const char *const queue_id_to_str[] = {
-	/* [SH_CSS_QUEUE_A_ID]     =*/ "queue_A",
-	/* [SH_CSS_QUEUE_B_ID]     =*/ "queue_B",
-	/* [SH_CSS_QUEUE_C_ID]     =*/ "queue_C",
-	/* [SH_CSS_QUEUE_D_ID]     =*/ "queue_D",
-	/* [SH_CSS_QUEUE_E_ID]     =*/ "queue_E",
-	/* [SH_CSS_QUEUE_F_ID]     =*/ "queue_F",
-	/* [SH_CSS_QUEUE_G_ID]     =*/ "queue_G",
-	/* [SH_CSS_QUEUE_H_ID]     =*/ "queue_H"
+	/* [SH_CSS_QUEUE_A_ID]     =*/"queue_A",
+	/* [SH_CSS_QUEUE_B_ID]     =*/"queue_B",
+	/* [SH_CSS_QUEUE_C_ID]     =*/"queue_C",
+	/* [SH_CSS_QUEUE_D_ID]     =*/"queue_D",
+	/* [SH_CSS_QUEUE_E_ID]     =*/"queue_E",
+	/* [SH_CSS_QUEUE_F_ID]     =*/"queue_F",
+	/* [SH_CSS_QUEUE_G_ID]     =*/"queue_G",
+	/* [SH_CSS_QUEUE_H_ID]     =*/"queue_H"
 };
 
 static const char *const pipe_id_to_str[] = {
-	/* [IA_CSS_PIPE_ID_PREVIEW]   =*/ "preview",
-	/* [IA_CSS_PIPE_ID_COPY]      =*/ "copy",
-	/* [IA_CSS_PIPE_ID_VIDEO]     =*/ "video",
-	/* [IA_CSS_PIPE_ID_CAPTURE]   =*/ "capture",
-	/* [IA_CSS_PIPE_ID_YUVPP]     =*/ "yuvpp",
+	/* [IA_CSS_PIPE_ID_PREVIEW]   =*/"preview",
+	/* [IA_CSS_PIPE_ID_COPY]      =*/"copy",
+	/* [IA_CSS_PIPE_ID_VIDEO]     =*/"video",
+	/* [IA_CSS_PIPE_ID_CAPTURE]   =*/"capture",
+	/* [IA_CSS_PIPE_ID_YUVPP]     =*/"yuvpp",
 };
 
 /* 27 is combined length of _stage%d(pipe%d)\0. */
@@ -145,8 +145,8 @@ unsigned int ia_css_debug_get_dtrace_level(void)
 	return dbg_level;
 }
 
-static const char *debug_stream_format2str(const enum atomisp_input_format
-	stream_format)
+static const char *
+debug_stream_format2str(const enum atomisp_input_format stream_format)
 {
 	switch (stream_format) {
 	case ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY:
@@ -234,8 +234,8 @@ static const char *debug_stream_format2str(const enum atomisp_input_format
 	}
 };
 
-static const char *debug_frame_format2str(const enum ia_css_frame_format
-	frame_format)
+static const char *
+debug_frame_format2str(const enum ia_css_frame_format frame_format)
 {
 	switch (frame_format) {
 	case IA_CSS_FRAME_FORMAT_NV11:
@@ -302,7 +302,7 @@ static const char *debug_frame_format2str(const enum ia_css_frame_format
 }
 
 static void debug_print_fifo_channel_state(const fifo_channel_state_t *state,
-	const char *descr)
+					   const char *descr)
 {
 	assert(state);
 	assert(descr);
@@ -323,10 +323,10 @@ void ia_css_debug_dump_pif_a_isp_fifo_state(void)
 {
 	fifo_channel_state_t pif_to_isp, isp_to_pif;
 
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);
+	fifo_channel_get_state(FIFO_MONITOR0_ID, FIFO_CHANNEL_IF0_TO_ISP0,
+			       &pif_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID, FIFO_CHANNEL_ISP0_TO_IF0,
+			       &isp_to_pif);
 	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF A to ISP");
 	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF A");
 }
@@ -335,10 +335,10 @@ void ia_css_debug_dump_pif_b_isp_fifo_state(void)
 {
 	fifo_channel_state_t pif_to_isp, isp_to_pif;
 
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_IF1_TO_ISP0, &pif_to_isp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_ISP0_TO_IF1, &isp_to_pif);
+	fifo_channel_get_state(FIFO_MONITOR0_ID, FIFO_CHANNEL_IF1_TO_ISP0,
+			       &pif_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID, FIFO_CHANNEL_ISP0_TO_IF1,
+			       &isp_to_pif);
 	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF B to ISP");
 	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF B");
 }
@@ -373,20 +373,24 @@ static void debug_binary_info_print(const struct ia_css_binary_xinfo *info)
 	assert(info);
 	ia_css_debug_dtrace(2, "id = %d\n", info->sp.id);
 	ia_css_debug_dtrace(2, "mode = %d\n", info->sp.pipeline.mode);
-	ia_css_debug_dtrace(2, "max_input_width = %d\n", info->sp.input.max_width);
+	ia_css_debug_dtrace(2, "max_input_width = %d\n",
+			    info->sp.input.max_width);
 	ia_css_debug_dtrace(2, "min_output_width = %d\n",
 			    info->sp.output.min_width);
 	ia_css_debug_dtrace(2, "max_output_width = %d\n",
 			    info->sp.output.max_width);
-	ia_css_debug_dtrace(2, "top_cropping = %d\n", info->sp.pipeline.top_cropping);
-	ia_css_debug_dtrace(2, "left_cropping = %d\n", info->sp.pipeline.left_cropping);
+	ia_css_debug_dtrace(2, "top_cropping = %d\n",
+			    info->sp.pipeline.top_cropping);
+	ia_css_debug_dtrace(2, "left_cropping = %d\n",
+			    info->sp.pipeline.left_cropping);
 	ia_css_debug_dtrace(2, "xmem_addr = %d\n", info->xmem_addr);
 	ia_css_debug_dtrace(2, "enable_vf_veceven = %d\n",
 			    info->sp.enable.vf_veceven);
 	ia_css_debug_dtrace(2, "enable_dis = %d\n", info->sp.enable.dis);
 	ia_css_debug_dtrace(2, "enable_uds = %d\n", info->sp.enable.uds);
 	ia_css_debug_dtrace(2, "enable ds = %d\n", info->sp.enable.ds);
-	ia_css_debug_dtrace(2, "s3atbl_use_dmem = %d\n", info->sp.s3a.s3atbl_use_dmem);
+	ia_css_debug_dtrace(2, "s3atbl_use_dmem = %d\n",
+			    info->sp.s3a.s3atbl_use_dmem);
 	return;
 }
 
@@ -395,12 +399,10 @@ void ia_css_debug_binary_print(const struct ia_css_binary *bi)
 	unsigned int i;
 
 	debug_binary_info_print(bi->info);
-	ia_css_debug_dtrace(2,
-			    "input:  %dx%d, format = %d, padded width = %d\n",
-			    bi->in_frame_info.res.width,
-			    bi->in_frame_info.res.height,
-			    bi->in_frame_info.format,
-			    bi->in_frame_info.padded_width);
+	ia_css_debug_dtrace(
+		2, "input:  %dx%d, format = %d, padded width = %d\n",
+		bi->in_frame_info.res.width, bi->in_frame_info.res.height,
+		bi->in_frame_info.format, bi->in_frame_info.padded_width);
 	ia_css_debug_dtrace(2,
 			    "internal :%dx%d, format = %d, padded width = %d\n",
 			    bi->internal_frame_info.res.width,
@@ -409,21 +411,19 @@ void ia_css_debug_binary_print(const struct ia_css_binary *bi)
 			    bi->internal_frame_info.padded_width);
 	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
 		if (bi->out_frame_info[i].res.width != 0) {
-			ia_css_debug_dtrace(2,
-					    "out%d:    %dx%d, format = %d, padded width = %d\n",
-					    i,
-					    bi->out_frame_info[i].res.width,
-					    bi->out_frame_info[i].res.height,
-					    bi->out_frame_info[i].format,
-					    bi->out_frame_info[i].padded_width);
+			ia_css_debug_dtrace(
+				2,
+				"out%d:    %dx%d, format = %d, padded width = %d\n",
+				i, bi->out_frame_info[i].res.width,
+				bi->out_frame_info[i].res.height,
+				bi->out_frame_info[i].format,
+				bi->out_frame_info[i].padded_width);
 		}
 	}
-	ia_css_debug_dtrace(2,
-			    "vf out: %dx%d, format = %d, padded width = %d\n",
-			    bi->vf_frame_info.res.width,
-			    bi->vf_frame_info.res.height,
-			    bi->vf_frame_info.format,
-			    bi->vf_frame_info.padded_width);
+	ia_css_debug_dtrace(
+		2, "vf out: %dx%d, format = %d, padded width = %d\n",
+		bi->vf_frame_info.res.width, bi->vf_frame_info.res.height,
+		bi->vf_frame_info.format, bi->vf_frame_info.padded_width);
 	ia_css_debug_dtrace(2, "online = %d\n", bi->online);
 	ia_css_debug_dtrace(2, "input_buf_vectors = %d\n",
 			    bi->input_buf_vectors);
@@ -456,10 +456,12 @@ void ia_css_debug_frame_print(const struct ia_css_frame *frame,
 	data = (char *)HOST_ADDRESS(frame->data);
 	ia_css_debug_dtrace(2, "frame %s (%p):\n", descr, frame);
 	ia_css_debug_dtrace(2, "  resolution    = %dx%d\n",
-			    frame->frame_info.res.width, frame->frame_info.res.height);
+			    frame->frame_info.res.width,
+			    frame->frame_info.res.height);
 	ia_css_debug_dtrace(2, "  padded width  = %d\n",
 			    frame->frame_info.padded_width);
-	ia_css_debug_dtrace(2, "  format        = %d\n", frame->frame_info.format);
+	ia_css_debug_dtrace(2, "  format        = %d\n",
+			    frame->frame_info.format);
 	switch (frame->frame_info.format) {
 	case IA_CSS_FRAME_FORMAT_NV12:
 	case IA_CSS_FRAME_FORMAT_NV16:
@@ -532,8 +534,7 @@ void ia_css_debug_frame_print(const struct ia_css_frame *frame,
 
 #if SP_DEBUG != SP_DEBUG_NONE
 
-void ia_css_debug_print_sp_debug_state(const struct sh_css_sp_debug_state
-				       *state)
+void ia_css_debug_print_sp_debug_state(const struct sh_css_sp_debug_state *state)
 {
 #endif
 
@@ -574,10 +575,10 @@ void ia_css_debug_print_sp_debug_state(const struct sh_css_sp_debug_state
 	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
 			    "num of stages of current pipeline: 0x%x\n",
 			    state->debug[11]);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "DDR address of stage 1: 0x%x\n",
-			    state->debug[12]);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "DDR address of stage 2: 0x%x\n",
-			    state->debug[13]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "DDR address of stage 1: 0x%x\n", state->debug[12]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "DDR address of stage 2: 0x%x\n", state->debug[13]);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
 			    "current stage out_vf buffer idx: 0x%x\n",
 			    state->debug[14]);
@@ -590,8 +591,8 @@ void ia_css_debug_print_sp_debug_state(const struct sh_css_sp_debug_state
 	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
 			    "first char of current stage name: 0x%x\n",
 			    state->debug[17]);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "current SP thread id: 0x%x\n",
-			    state->debug[18]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "current SP thread id: 0x%x\n", state->debug[18]);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
 			    "empty output buffer address 1: 0x%x\n",
 			    state->debug[19]);
@@ -664,7 +665,8 @@ void ia_css_debug_print_sp_debug_state(const struct sh_css_sp_debug_state
 	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
 			    "number of calling flash close function: 0x%x\n",
 			    state->debug[42]);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "number of flashed frame: 0x%x\n",
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "number of flashed frame: 0x%x\n",
 			    state->debug[43]);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "flash in use flag: 0x%x\n",
 			    state->debug[44]);
@@ -677,135 +679,128 @@ void ia_css_debug_print_sp_debug_state(const struct sh_css_sp_debug_state
 
 #elif SP_DEBUG == SP_DEBUG_COPY
 
-	/* Remember last_index because we only want to print new entries */
-	static int last_index;
-	int sp_index = state->index;
-	int n;
-
-	assert(state);
-	if (sp_index < last_index) {
-		/* SP has been reset */
-		last_index = 0;
-	}
+/* Remember last_index because we only want to print new entries */
+static int last_index;
+int sp_index = state->index;
+int n;
 
-	if (last_index == 0) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
-				    "copy-trace init: sp_dbg_if_start_line=%d, sp_dbg_if_start_column=%d, sp_dbg_if_cropped_height=%d, sp_debg_if_cropped_width=%d\n",
-				    state->if_start_line,
-				    state->if_start_column,
-				    state->if_cropped_height,
-				    state->if_cropped_width);
-	}
+assert(state);
+if (sp_index < last_index) {
+	/* SP has been reset */
+	last_index = 0;
+}
 
-	if ((last_index + SH_CSS_SP_DBG_TRACE_DEPTH) < sp_index) {
-		/* last index can be multiple rounds behind */
-		/* while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH */
-		last_index = sp_index - SH_CSS_SP_DBG_TRACE_DEPTH;
-	}
+if (last_index == 0) {
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_VERBOSE,
+		"copy-trace init: sp_dbg_if_start_line=%d, sp_dbg_if_start_column=%d, sp_dbg_if_cropped_height=%d, sp_debg_if_cropped_width=%d\n",
+		state->if_start_line, state->if_start_column,
+		state->if_cropped_height, state->if_cropped_width);
+}
 
-	for (n = last_index; n < sp_index; n++) {
-		int i = n % SH_CSS_SP_DBG_TRACE_DEPTH;
+if ((last_index + SH_CSS_SP_DBG_TRACE_DEPTH) < sp_index) {
+	/* last index can be multiple rounds behind */
+	/* while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH */
+	last_index = sp_index - SH_CSS_SP_DBG_TRACE_DEPTH;
+}
 
-		if (state->trace[i].frame != 0) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
-					    "copy-trace: frame=%d, line=%d, pixel_distance=%d, mipi_used_dword=%d, sp_index=%d\n",
-					    state->trace[i].frame,
-					    state->trace[i].line,
-					    state->trace[i].pixel_distance,
-					    state->trace[i].mipi_used_dword,
-					    state->trace[i].sp_index);
-		}
+for (n = last_index; n < sp_index; n++) {
+	int i = n % SH_CSS_SP_DBG_TRACE_DEPTH;
+
+	if (state->trace[i].frame != 0) {
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_VERBOSE,
+			"copy-trace: frame=%d, line=%d, pixel_distance=%d, mipi_used_dword=%d, sp_index=%d\n",
+			state->trace[i].frame, state->trace[i].line,
+			state->trace[i].pixel_distance,
+			state->trace[i].mipi_used_dword,
+			state->trace[i].sp_index);
 	}
+}
 
-	last_index = sp_index;
+last_index = sp_index;
 
 #elif SP_DEBUG == SP_DEBUG_TRACE
 
-	/*
+/*
 	 * This is just an example how TRACE_FILE_ID (see ia_css_debug.sp.h) will
 	 * me mapped on the file name string.
 	 *
 	 * Adjust this to your trace case!
 	 */
-	static char const *const id2filename[8] = {
-		"param_buffer.sp.c | tagger.sp.c | pipe_data.sp.c",
-		"isp_init.sp.c",
-		"sp_raw_copy.hive.c",
-		"dma_configure.sp.c",
-		"sp.hive.c",
-		"event_proxy_sp.hive.c",
-		"circular_buffer.sp.c",
-		"frame_buffer.sp.c"
-	};
-
-	/* Example SH_CSS_SP_DBG_NR_OF_TRACES==1 */
-	/* Adjust this to your trace case */
-	static char const *trace_name[SH_CSS_SP_DBG_NR_OF_TRACES] = {
-		"default"
-	};
-
-	/* Remember host_index_last because we only want to print new entries */
-	static int host_index_last[SH_CSS_SP_DBG_NR_OF_TRACES] = { 0 };
-	int t, n;
+static char const *const id2filename[8] = {
+	"param_buffer.sp.c | tagger.sp.c | pipe_data.sp.c",
+	"isp_init.sp.c",
+	"sp_raw_copy.hive.c",
+	"dma_configure.sp.c",
+	"sp.hive.c",
+	"event_proxy_sp.hive.c",
+	"circular_buffer.sp.c",
+	"frame_buffer.sp.c"
+};
 
-	assert(state);
+/* Example SH_CSS_SP_DBG_NR_OF_TRACES==1 */
+/* Adjust this to your trace case */
+static char const *trace_name[SH_CSS_SP_DBG_NR_OF_TRACES] = { "default" };
 
-	for (t = 0; t < SH_CSS_SP_DBG_NR_OF_TRACES; t++) {
-		int sp_index_last = state->index_last[t];
+/* Remember host_index_last because we only want to print new entries */
+static int host_index_last[SH_CSS_SP_DBG_NR_OF_TRACES] = { 0 };
+int t, n;
 
-		if (sp_index_last < host_index_last[t]) {
-			/* SP has been reset */
-			host_index_last[t] = 0;
-		}
+assert(state);
 
-		if ((host_index_last[t] + SH_CSS_SP_DBG_TRACE_DEPTH) <
-		    sp_index_last) {
-			/* last index can be multiple rounds behind */
-			/* while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH */
-			ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
-					    "Warning: trace %s has gap of %d traces\n",
-					    trace_name[t],
-					    (sp_index_last -
-					     (host_index_last[t] +
-					      SH_CSS_SP_DBG_TRACE_DEPTH)));
-
-			host_index_last[t] =
-			    sp_index_last - SH_CSS_SP_DBG_TRACE_DEPTH;
-		}
+for (t = 0; t < SH_CSS_SP_DBG_NR_OF_TRACES; t++) {
+	int sp_index_last = state->index_last[t];
 
-		for (n = host_index_last[t]; n < sp_index_last; n++) {
-			int i = n % SH_CSS_SP_DBG_TRACE_DEPTH;
-			int l = state->trace[t][i].location &
-				((1 << SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS) - 1);
-			int fid = state->trace[t][i].location >>
-				  SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS;
-			int ts = state->trace[t][i].time_stamp;
-
-			if (ts) {
-				ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
-						    "%05d trace=%s, file=%s:%d, data=0x%08x\n",
-						    ts,
-						    trace_name[t],
-						    id2filename[fid], l,
-						    state->trace[t][i].data);
-			}
+	if (sp_index_last < host_index_last[t]) {
+		/* SP has been reset */
+		host_index_last[t] = 0;
+	}
+
+	if ((host_index_last[t] + SH_CSS_SP_DBG_TRACE_DEPTH) < sp_index_last) {
+		/* last index can be multiple rounds behind */
+		/* while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH */
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_VERBOSE,
+			"Warning: trace %s has gap of %d traces\n",
+			trace_name[t],
+			(sp_index_last -
+			 (host_index_last[t] + SH_CSS_SP_DBG_TRACE_DEPTH)));
+
+		host_index_last[t] = sp_index_last - SH_CSS_SP_DBG_TRACE_DEPTH;
+	}
+
+	for (n = host_index_last[t]; n < sp_index_last; n++) {
+		int i = n % SH_CSS_SP_DBG_TRACE_DEPTH;
+		int l = state->trace[t][i].location &
+			((1 << SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS) - 1);
+		int fid = state->trace[t][i].location >>
+			  SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS;
+		int ts = state->trace[t][i].time_stamp;
+
+		if (ts) {
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_VERBOSE,
+				"%05d trace=%s, file=%s:%d, data=0x%08x\n", ts,
+				trace_name[t], id2filename[fid], l,
+				state->trace[t][i].data);
 		}
-		host_index_last[t] = sp_index_last;
 	}
+	host_index_last[t] = sp_index_last;
+}
 
 #elif SP_DEBUG == SP_DEBUG_MINIMAL
-	int i;
-	int base = 0;
-	int limit = SH_CSS_NUM_SP_DEBUG;
-	int step = 1;
+int i;
+int base;
+int limit = SH_CSS_NUM_SP_DEBUG;
+int step = 1;
 
-	assert(state);
+assert(state);
 
-	for (i = base; i < limit; i += step) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
-				    "sp_dbg_trace[%d] = %d\n",
-				    i, state->debug[i]);
-	}
+for (i = base; i < limit; i += step) {
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "sp_dbg_trace[%d] = %d\n", i,
+			    state->debug[i]);
+}
 #endif
 
 #if SP_DEBUG != SP_DEBUG_NONE
@@ -840,10 +835,9 @@ void ia_css_debug_enable_sp_sleep_mode(enum ia_css_sp_sleep_mode mode)
 	fw = &sh_css_sp_fw;
 	HIVE_ADDR_sp_sleep_mode = fw->info.sp.sleep_mode;
 
-	(void)HIVE_ADDR_sp_sleep_mode;	/* Suppress warnings in CRUN */
+	(void)HIVE_ADDR_sp_sleep_mode; /* Suppress warnings in CRUN */
 
-	sp_dmem_store_uint32(SP0_ID,
-			     (unsigned int)sp_address_of(sp_sleep_mode),
+	sp_dmem_store_uint32(SP0_ID, (unsigned int)sp_address_of(sp_sleep_mode),
 			     (uint32_t)mode);
 }
 
@@ -853,30 +847,36 @@ void ia_css_debug_wake_up_sp(void)
 	sp_ctrl_setbit(SP0_ID, SP_SC_REG, SP_START_BIT);
 }
 
-#define FIND_DMEM_PARAMS_TYPE(stream, kernel, type) \
-	(struct CONCATENATE(CONCATENATE(sh_css_isp_, type), _params) *) \
-	findf_dmem_params(stream, offsetof(struct ia_css_memory_offsets, dmem.kernel))
+#define FIND_DMEM_PARAMS_TYPE(stream, kernel, type)                     ( \
+	(struct CONCATENATE(CONCATENATE(sh_css_isp_, type), _params) *)  \
+		findf_dmem_params(stream,                                \
+				  offsetof(struct ia_css_memory_offsets, \
+					   dmem.kernel)))
 
-#define FIND_DMEM_PARAMS(stream, kernel) FIND_DMEM_PARAMS_TYPE(stream, kernel, kernel)
+#define FIND_DMEM_PARAMS(stream, kernel) \
+	FIND_DMEM_PARAMS_TYPE(stream, kernel, kernel)
 
 /* Find a stage that support the kernel and return the parameters for that kernel */
-static char *
-findf_dmem_params(struct ia_css_stream *stream, short idx)
+static char *findf_dmem_params(struct ia_css_stream *stream, short idx)
 {
 	int i;
 
 	for (i = 0; i < stream->num_pipes; i++) {
 		struct ia_css_pipe *pipe = stream->pipes[i];
-		struct ia_css_pipeline *pipeline = ia_css_pipe_get_pipeline(pipe);
+		struct ia_css_pipeline *pipeline =
+			ia_css_pipe_get_pipeline(pipe);
 		struct ia_css_pipeline_stage *stage;
 
 		for (stage = pipeline->stages; stage; stage = stage->next) {
 			struct ia_css_binary *binary = stage->binary;
-			short *offsets = (short *)&binary->info->mem_offsets.offsets.param->dmem;
+			short *offsets = (short *)&binary->info->mem_offsets
+						 .offsets.param->dmem;
 			short dmem_offset = offsets[idx];
 			const struct ia_css_host_data *isp_data =
-			    ia_css_isp_param_get_mem_init(&binary->mem_params,
-							  IA_CSS_PARAM_CLASS_PARAM, IA_CSS_ISP_DMEM0);
+				ia_css_isp_param_get_mem_init(
+					&binary->mem_params,
+					IA_CSS_PARAM_CLASS_PARAM,
+					IA_CSS_ISP_DMEM0);
 			if (dmem_offset < 0)
 				continue;
 			return &isp_data->address[dmem_offset];
@@ -891,66 +891,81 @@ void ia_css_debug_dump_isp_params(struct ia_css_stream *stream,
 	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "ISP PARAMETERS:\n");
 
 	assert(stream);
-	if ((enable & IA_CSS_DEBUG_DUMP_FPN)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_fpn_dump(FIND_DMEM_PARAMS(stream, fpn), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_FPN) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_fpn_dump(FIND_DMEM_PARAMS(stream, fpn),
+				IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_OB)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_ob_dump(FIND_DMEM_PARAMS(stream, ob), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_OB) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_ob_dump(FIND_DMEM_PARAMS(stream, ob),
+			       IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_SC)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_sc_dump(FIND_DMEM_PARAMS(stream, sc), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_SC) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_sc_dump(FIND_DMEM_PARAMS(stream, sc),
+			       IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_WB)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_wb_dump(FIND_DMEM_PARAMS(stream, wb), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_WB) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_wb_dump(FIND_DMEM_PARAMS(stream, wb),
+			       IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_DP)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_dp_dump(FIND_DMEM_PARAMS(stream, dp), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_DP) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_dp_dump(FIND_DMEM_PARAMS(stream, dp),
+			       IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_BNR)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_bnr_dump(FIND_DMEM_PARAMS(stream, bnr), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_BNR) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_bnr_dump(FIND_DMEM_PARAMS(stream, bnr),
+				IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_S3A)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_s3a_dump(FIND_DMEM_PARAMS(stream, s3a), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_S3A) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_s3a_dump(FIND_DMEM_PARAMS(stream, s3a),
+				IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_DE)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_de_dump(FIND_DMEM_PARAMS(stream, de), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_DE) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_de_dump(FIND_DMEM_PARAMS(stream, de),
+			       IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_YNR)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_nr_dump(FIND_DMEM_PARAMS_TYPE(stream, nr, ynr),  IA_CSS_DEBUG_VERBOSE);
-		ia_css_yee_dump(FIND_DMEM_PARAMS(stream, yee), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_YNR) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_nr_dump(FIND_DMEM_PARAMS_TYPE(stream, nr, ynr),
+			       IA_CSS_DEBUG_VERBOSE);
+		ia_css_yee_dump(FIND_DMEM_PARAMS(stream, yee),
+				IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_CSC)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_csc_dump(FIND_DMEM_PARAMS(stream, csc), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_CSC) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_csc_dump(FIND_DMEM_PARAMS(stream, csc),
+				IA_CSS_DEBUG_VERBOSE);
 		ia_css_yuv2rgb_dump(FIND_DMEM_PARAMS_TYPE(stream, yuv2rgb, csc),
 				    IA_CSS_DEBUG_VERBOSE);
 		ia_css_rgb2yuv_dump(FIND_DMEM_PARAMS_TYPE(stream, rgb2yuv, csc),
 				    IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_GC)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_gc_dump(FIND_DMEM_PARAMS(stream, gc), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_GC) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_gc_dump(FIND_DMEM_PARAMS(stream, gc),
+			       IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_TNR)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_tnr_dump(FIND_DMEM_PARAMS(stream, tnr), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_TNR) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_tnr_dump(FIND_DMEM_PARAMS(stream, tnr),
+				IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_ANR)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_anr_dump(FIND_DMEM_PARAMS(stream, anr), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_ANR) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_anr_dump(FIND_DMEM_PARAMS(stream, anr),
+				IA_CSS_DEBUG_VERBOSE);
 	}
-	if ((enable & IA_CSS_DEBUG_DUMP_CE)
-	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
-		ia_css_ce_dump(FIND_DMEM_PARAMS(stream, ce), IA_CSS_DEBUG_VERBOSE);
+	if ((enable & IA_CSS_DEBUG_DUMP_CE) ||
+	    (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_ce_dump(FIND_DMEM_PARAMS(stream, ce),
+			       IA_CSS_DEBUG_VERBOSE);
 	}
 }
 
@@ -962,24 +977,23 @@ void sh_css_dump_sp_raw_copy_linecount(bool reduced)
 	static s32 prev_raw_copy_line_count = -1;
 
 	fw = &sh_css_sp_fw;
-	HIVE_ADDR_raw_copy_line_count =
-	    fw->info.sp.raw_copy_line_count;
+	HIVE_ADDR_raw_copy_line_count = fw->info.sp.raw_copy_line_count;
 
 	(void)HIVE_ADDR_raw_copy_line_count;
 
-	sp_dmem_load(SP0_ID,
-		     (unsigned int)sp_address_of(raw_copy_line_count),
-		     &raw_copy_line_count,
-		     sizeof(raw_copy_line_count));
+	sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(raw_copy_line_count),
+		     &raw_copy_line_count, sizeof(raw_copy_line_count));
 
 	/* only indicate if copy loop is active */
 	if (reduced)
-		raw_copy_line_count = (raw_copy_line_count < 0) ? raw_copy_line_count : 1;
+		raw_copy_line_count =
+			(raw_copy_line_count < 0) ? raw_copy_line_count : 1;
 	/* do the handling */
 	if (prev_raw_copy_line_count != raw_copy_line_count) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
-				    "sh_css_dump_sp_raw_copy_linecount() line_count=%d\n",
-				    raw_copy_line_count);
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_VERBOSE,
+			"sh_css_dump_sp_raw_copy_linecount() line_count=%d\n",
+			raw_copy_line_count);
 		prev_raw_copy_line_count = raw_copy_line_count;
 	}
 }
@@ -999,17 +1013,16 @@ void ia_css_debug_dump_isp_binary(void)
 
 	sp_dmem_load(SP0_ID,
 		     (unsigned int)sp_address_of(pipeline_sp_curr_binary_id),
-		     &curr_binary_id,
-		     sizeof(curr_binary_id));
+		     &curr_binary_id, sizeof(curr_binary_id));
 
 	/* do the handling */
 	sample_count++;
 	if (prev_binary_id != curr_binary_id) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
-				    "sh_css_dump_isp_binary() pipe_id=%d, binary_id=%d, sample_count=%d\n",
-				    (curr_binary_id >> 16),
-				    (curr_binary_id & 0x0ffff),
-				    sample_count);
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_VERBOSE,
+			"sh_css_dump_isp_binary() pipe_id=%d, binary_id=%d, sample_count=%d\n",
+			(curr_binary_id >> 16), (curr_binary_id & 0x0ffff),
+			sample_count);
 		sample_count = 0;
 		prev_binary_id = curr_binary_id;
 	}
@@ -1031,9 +1044,8 @@ bool ia_css_debug_mode_init(void)
  * @brief Disable the DMA channel.
  * Refer to "ia_css_debug.h" for more details.
  */
-bool
-ia_css_debug_mode_disable_dma_channel(int dma_id,
-				      int channel_id, int request_type)
+bool ia_css_debug_mode_disable_dma_channel(int dma_id, int channel_id,
+					   int request_type)
 {
 	bool rc;
 
@@ -1046,9 +1058,8 @@ ia_css_debug_mode_disable_dma_channel(int dma_id,
  * @brief Enable the DMA channel.
  * Refer to "ia_css_debug.h" for more details.
  */
-bool
-ia_css_debug_mode_enable_dma_channel(int dma_id,
-				     int channel_id, int request_type)
+bool ia_css_debug_mode_enable_dma_channel(int dma_id, int channel_id,
+					  int request_type)
 {
 	bool rc;
 
@@ -1070,13 +1081,11 @@ static void __printf(1, 2) dtrace_dot(const char *fmt, ...)
 	va_end(ap);
 }
 
-static void
-ia_css_debug_pipe_graph_dump_frame(
-    const struct ia_css_frame *frame,
-    enum ia_css_pipe_id id,
-    char const *blob_name,
-    char const *frame_name,
-    bool in_frame)
+static void ia_css_debug_pipe_graph_dump_frame(const struct ia_css_frame *frame,
+					       enum ia_css_pipe_id id,
+					       char const *blob_name,
+					       char const *frame_name,
+					       bool in_frame)
 {
 	char bufinfo[100];
 
@@ -1088,38 +1097,30 @@ ia_css_debug_pipe_graph_dump_frame(
 			 queue_id_to_str[frame->dynamic_queue_id]);
 	}
 	dtrace_dot(
-	    "node [shape = box, fixedsize=true, width=2, height=0.7]; \"%p\" [label = \"%s\\n%d(%d) x %d, %dbpp\\n%s\"];",
-	    frame,
-	    debug_frame_format2str(frame->frame_info.format),
-	    frame->frame_info.res.width,
-	    frame->frame_info.padded_width,
-	    frame->frame_info.res.height,
-	    frame->frame_info.raw_bit_depth,
-	    bufinfo);
+		"node [shape = box, fixedsize=true, width=2, height=0.7]; \"%p\" [label = \"%s\\n%d(%d) x %d, %dbpp\\n%s\"];",
+		frame, debug_frame_format2str(frame->frame_info.format),
+		frame->frame_info.res.width, frame->frame_info.padded_width,
+		frame->frame_info.res.height, frame->frame_info.raw_bit_depth,
+		bufinfo);
 
 	if (in_frame) {
-		dtrace_dot(
-		    "\"%p\"->\"%s(pipe%d)\" [label = %s_frame];",
-		    frame,
-		    blob_name, id, frame_name);
+		dtrace_dot("\"%p\"->\"%s(pipe%d)\" [label = %s_frame];", frame,
+			   blob_name, id, frame_name);
 	} else {
-		dtrace_dot(
-		    "\"%s(pipe%d)\"->\"%p\" [label = %s_frame];",
-		    blob_name, id,
-		    frame,
-		    frame_name);
+		dtrace_dot("\"%s(pipe%d)\"->\"%p\" [label = %s_frame];",
+			   blob_name, id, frame, frame_name);
 	}
 }
 
-void
-ia_css_debug_pipe_graph_dump_prologue(void)
+void ia_css_debug_pipe_graph_dump_prologue(void)
 {
 	dtrace_dot("digraph sh_css_pipe_graph {");
 	dtrace_dot("rankdir=LR;");
 
 	dtrace_dot("fontsize=9;");
-	dtrace_dot("label = \"\\nEnable options: rp=reduced pipe, vfve=vf_veceven, dvse=dvs_envelope, dvs6=dvs_6axis, bo=block_out, fbds=fixed_bayer_ds, bf6=bayer_fir_6db, rawb=raw_binning, cont=continuous, disc=dis_crop\\n"
-		   "dp2a=dp_2adjacent, outp=output, outt=out_table, reff=ref_frame, par=params, gam=gamma, cagdc=ca_gdc, ispa=isp_addresses, inf=in_frame, outf=out_frame, hs=high_speed, inpc=input_chunking\"");
+	dtrace_dot(
+		"label = \"\\nEnable options: rp=reduced pipe, vfve=vf_veceven, dvse=dvs_envelope, dvs6=dvs_6axis, bo=block_out, fbds=fixed_bayer_ds, bf6=bayer_fir_6db, rawb=raw_binning, cont=continuous, disc=dis_crop\\n"
+		"dp2a=dp_2adjacent, outp=output, outt=out_table, reff=ref_frame, par=params, gam=gamma, cagdc=ca_gdc, ispa=isp_addresses, inf=in_frame, outf=out_frame, hs=high_speed, inpc=input_chunking\"");
 }
 
 void ia_css_debug_pipe_graph_dump_epilogue(void)
@@ -1134,20 +1135,20 @@ void ia_css_debug_pipe_graph_dump_epilogue(void)
 		 */
 
 		dtrace_dot(
-		    "node [shape = doublecircle, fixedsize=true, width=2.5]; \"input_system\" [label = \"Input system\"];");
+			"node [shape = doublecircle, fixedsize=true, width=2.5]; \"input_system\" [label = \"Input system\"];");
 
-		dtrace_dot(
-		    "\"input_system\"->\"%s\" [label = \"%s\"];",
-		    dot_id_input_bin, debug_stream_format2str(pg_inst.stream_format));
+		dtrace_dot("\"input_system\"->\"%s\" [label = \"%s\"];",
+			   dot_id_input_bin,
+			   debug_stream_format2str(pg_inst.stream_format));
 
 		dtrace_dot(
-		    "node [shape = doublecircle, fixedsize=true, width=2.5]; \"sensor\" [label = \"Sensor\"];");
+			"node [shape = doublecircle, fixedsize=true, width=2.5]; \"sensor\" [label = \"Sensor\"];");
 
 		dtrace_dot(
-		    "\"sensor\"->\"input_system\" [label = \"%s\\n%d x %d\\n(%d x %d)\"];",
-		    debug_stream_format2str(pg_inst.stream_format),
-		    pg_inst.width, pg_inst.height,
-		    pg_inst.eff_width, pg_inst.eff_height);
+			"\"sensor\"->\"input_system\" [label = \"%s\\n%d x %d\\n(%d x %d)\"];",
+			debug_stream_format2str(pg_inst.stream_format),
+			pg_inst.width, pg_inst.height, pg_inst.eff_width,
+			pg_inst.eff_height);
 	}
 
 	dtrace_dot("}");
@@ -1164,10 +1165,8 @@ void ia_css_debug_pipe_graph_dump_epilogue(void)
 	pg_inst.stream_format = N_ATOMISP_INPUT_FORMAT;
 }
 
-void
-ia_css_debug_pipe_graph_dump_stage(
-    struct ia_css_pipeline_stage *stage,
-    enum ia_css_pipe_id id)
+void ia_css_debug_pipe_graph_dump_stage(struct ia_css_pipeline_stage *stage,
+					enum ia_css_pipe_id id)
 {
 	char blob_name[SH_CSS_MAX_BINARY_NAME + 10] = "<unknown type>";
 	char const *bin_type = "<unknown type>";
@@ -1186,7 +1185,8 @@ ia_css_debug_pipe_graph_dump_stage(
 		bin_type = "binary";
 		if (stage->binary->info->blob)
 			snprintf(blob_name, sizeof(blob_name), "%s_stage%d",
-				 stage->binary->info->blob->name, stage->stage_num);
+				 stage->binary->info->blob->name,
+				 stage->stage_num);
 	} else if (stage->firmware) {
 		bin_type = "firmware";
 
@@ -1207,40 +1207,38 @@ ia_css_debug_pipe_graph_dump_stage(
 		 */
 		snprintf(enable_info1, sizeof(enable_info1),
 			 "%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
-			 bi->enable.reduced_pipe ?	"rp," : "",
-			 bi->enable.vf_veceven ?		"vfve," : "",
-			 bi->enable.dis ?		"dis," : "",
-			 bi->enable.dvs_envelope ?	"dvse," : "",
-			 bi->enable.uds ?		"uds," : "",
-			 bi->enable.dvs_6axis ?		"dvs6," : "",
-			 bi->enable.block_output ?	"bo," : "",
-			 bi->enable.ds ?			"ds," : "",
-			 bi->enable.bayer_fir_6db ?	"bf6," : "",
-			 bi->enable.raw_binning ?	"rawb," : "",
-			 bi->enable.continuous ?		"cont," : "",
-			 bi->enable.s3a ?		"s3a," : "",
-			 bi->enable.fpnr ?		"fpnr," : "",
-			 bi->enable.sc ?			"sc," : ""
-			);
+			 bi->enable.reduced_pipe ? "rp," : "",
+			 bi->enable.vf_veceven ? "vfve," : "",
+			 bi->enable.dis ? "dis," : "",
+			 bi->enable.dvs_envelope ? "dvse," : "",
+			 bi->enable.uds ? "uds," : "",
+			 bi->enable.dvs_6axis ? "dvs6," : "",
+			 bi->enable.block_output ? "bo," : "",
+			 bi->enable.ds ? "ds," : "",
+			 bi->enable.bayer_fir_6db ? "bf6," : "",
+			 bi->enable.raw_binning ? "rawb," : "",
+			 bi->enable.continuous ? "cont," : "",
+			 bi->enable.s3a ? "s3a," : "",
+			 bi->enable.fpnr ? "fpnr," : "",
+			 bi->enable.sc ? "sc," : "");
 
 		snprintf(enable_info2, sizeof(enable_info2),
 			 "%s%s%s%s%s%s%s%s%s%s%s",
-			 bi->enable.macc ?		"macc," : "",
-			 bi->enable.output ?		"outp," : "",
-			 bi->enable.ref_frame ?		"reff," : "",
-			 bi->enable.tnr ?		"tnr," : "",
-			 bi->enable.xnr ?		"xnr," : "",
-			 bi->enable.params ?		"par," : "",
-			 bi->enable.ca_gdc ?		"cagdc," : "",
-			 bi->enable.isp_addresses ?	"ispa," : "",
-			 bi->enable.in_frame ?		"inf," : "",
-			 bi->enable.out_frame ?		"outf," : "",
-			 bi->enable.high_speed ?		"hs," : ""
-			);
+			 bi->enable.macc ? "macc," : "",
+			 bi->enable.output ? "outp," : "",
+			 bi->enable.ref_frame ? "reff," : "",
+			 bi->enable.tnr ? "tnr," : "",
+			 bi->enable.xnr ? "xnr," : "",
+			 bi->enable.params ? "par," : "",
+			 bi->enable.ca_gdc ? "cagdc," : "",
+			 bi->enable.isp_addresses ? "ispa," : "",
+			 bi->enable.in_frame ? "inf," : "",
+			 bi->enable.out_frame ? "outf," : "",
+			 bi->enable.high_speed ? "hs," : "");
 
 		/* And merge them into one string */
-		snprintf(enable_info, sizeof(enable_info), "%s%s",
-			 enable_info1, enable_info2);
+		snprintf(enable_info, sizeof(enable_info), "%s%s", enable_info1,
+			 enable_info2);
 		{
 			int l, p;
 			char *ei = enable_info;
@@ -1258,7 +1256,9 @@ ia_css_debug_pipe_graph_dump_stage(
 					p--;
 				/* Last comma found, copy till that comma */
 				strscpy(enable_info1, ei,
-                                        p > sizeof(enable_info1) ? sizeof(enable_info1) : p);
+					p > sizeof(enable_info1) ?
+						sizeof(enable_info1) :
+						p);
 
 				ei += p + 1;
 				l = strlen(ei);
@@ -1270,9 +1270,12 @@ ia_css_debug_pipe_graph_dump_stage(
 					 */
 
 					strscpy(enable_info2, ei,
-						l > sizeof(enable_info2) ? sizeof(enable_info2) : l);
+						l > sizeof(enable_info2) ?
+							sizeof(enable_info2) :
+							l);
 
-					snprintf(enable_info, sizeof(enable_info), "%s\\n%s",
+					snprintf(enable_info,
+						 sizeof(enable_info), "%s\\n%s",
 						 enable_info1, enable_info2);
 
 				} else {
@@ -1282,7 +1285,9 @@ ia_css_debug_pipe_graph_dump_stage(
 						p--;
 
 					strscpy(enable_info2, ei,
-						p > sizeof(enable_info2) ? sizeof(enable_info2) : p);
+						p > sizeof(enable_info2) ?
+							sizeof(enable_info2) :
+							p);
 
 					ei += p + 1;
 					l = strlen(ei);
@@ -1294,9 +1299,11 @@ ia_css_debug_pipe_graph_dump_stage(
 						*/
 						strscpy(enable_info3, ei,
 							sizeof(enable_info3));
-						snprintf(enable_info, sizeof(enable_info),
+						snprintf(enable_info,
+							 sizeof(enable_info),
 							 "%s\\n%s\\n%s",
-							 enable_info1, enable_info2,
+							 enable_info1,
+							 enable_info2,
 							 enable_info3);
 					} else {
 						/* 3rd line is still too long */
@@ -1304,24 +1311,30 @@ ia_css_debug_pipe_graph_dump_stage(
 						while (ei[p] != ',')
 							p--;
 						strscpy(enable_info3, ei,
-							p > sizeof(enable_info3) ? sizeof(enable_info3) : p);
+							p > sizeof(enable_info3) ?
+								sizeof(enable_info3) :
+								p);
 						ei += p + 1;
 						strscpy(enable_info3, ei,
 							sizeof(enable_info3));
-						snprintf(enable_info, sizeof(enable_info),
+						snprintf(enable_info,
+							 sizeof(enable_info),
 							 "%s\\n%s\\n%s",
-							 enable_info1, enable_info2,
+							 enable_info1,
+							 enable_info2,
 							 enable_info3);
 					}
 				}
 			}
 		}
 
-		dtrace_dot("node [shape = circle, fixedsize=true, width=2.5, label=\"%s\\n%s\\n\\n%s\"]; \"%s(pipe%d)\"",
-			   bin_type, blob_name, enable_info, blob_name, id);
+		dtrace_dot(
+			"node [shape = circle, fixedsize=true, width=2.5, label=\"%s\\n%s\\n\\n%s\"]; \"%s(pipe%d)\"",
+			bin_type, blob_name, enable_info, blob_name, id);
 	} else {
-		dtrace_dot("node [shape = circle, fixedsize=true, width=2.5, label=\"%s\\n%s\\n\"]; \"%s(pipe%d)\"",
-			   bin_type, blob_name, blob_name, id);
+		dtrace_dot(
+			"node [shape = circle, fixedsize=true, width=2.5, label=\"%s\\n%s\\n\"]; \"%s(pipe%d)\"",
+			bin_type, blob_name, blob_name, id);
 	}
 
 	if (stage->stage_num == 0) {
@@ -1339,45 +1352,41 @@ ia_css_debug_pipe_graph_dump_stage(
 	}
 
 	if (stage->args.in_frame) {
-		ia_css_debug_pipe_graph_dump_frame(
-		    stage->args.in_frame, id, blob_name,
-		    "in", true);
+		ia_css_debug_pipe_graph_dump_frame(stage->args.in_frame, id,
+						   blob_name, "in", true);
 	}
 
 	for (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++) {
 		if (stage->args.tnr_frames[i]) {
 			ia_css_debug_pipe_graph_dump_frame(
-			    stage->args.tnr_frames[i], id,
-			    blob_name, "tnr_frame", true);
+				stage->args.tnr_frames[i], id, blob_name,
+				"tnr_frame", true);
 		}
 	}
 
 	for (i = 0; i < MAX_NUM_VIDEO_DELAY_FRAMES; i++) {
 		if (stage->args.delay_frames[i]) {
 			ia_css_debug_pipe_graph_dump_frame(
-			    stage->args.delay_frames[i], id,
-			    blob_name, "delay_frame", true);
+				stage->args.delay_frames[i], id, blob_name,
+				"delay_frame", true);
 		}
 	}
 
 	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
 		if (stage->args.out_frame[i]) {
 			ia_css_debug_pipe_graph_dump_frame(
-			    stage->args.out_frame[i], id, blob_name,
-			    "out", false);
+				stage->args.out_frame[i], id, blob_name, "out",
+				false);
 		}
 	}
 
 	if (stage->args.out_vf_frame) {
-		ia_css_debug_pipe_graph_dump_frame(
-		    stage->args.out_vf_frame, id, blob_name,
-		    "out_vf", false);
+		ia_css_debug_pipe_graph_dump_frame(stage->args.out_vf_frame, id,
+						   blob_name, "out_vf", false);
 	}
 }
 
-void
-ia_css_debug_pipe_graph_dump_sp_raw_copy(
-    struct ia_css_frame *out_frame)
+void ia_css_debug_pipe_graph_dump_sp_raw_copy(struct ia_css_frame *out_frame)
 {
 	assert(out_frame);
 	if (pg_inst.do_init) {
@@ -1385,30 +1394,29 @@ ia_css_debug_pipe_graph_dump_sp_raw_copy(
 		pg_inst.do_init = false;
 	}
 
-	dtrace_dot("node [shape = circle, fixedsize=true, width=2.5, label=\"%s\\n%s\"]; \"%s(pipe%d)\"",
-		   "sp-binary", "sp_raw_copy", "sp_raw_copy", 1);
+	dtrace_dot(
+		"node [shape = circle, fixedsize=true, width=2.5, label=\"%s\\n%s\"]; \"%s(pipe%d)\"",
+		"sp-binary", "sp_raw_copy", "sp_raw_copy", 1);
 
-	snprintf(ring_buffer, sizeof(ring_buffer),
-		 "node [shape = box, fixedsize=true, width=2, height=0.7]; \"%p\" [label = \"%s\\n%d(%d) x %d\\nRingbuffer\"];",
-		 out_frame,
-		 debug_frame_format2str(out_frame->frame_info.format),
-		 out_frame->frame_info.res.width,
-		 out_frame->frame_info.padded_width,
-		 out_frame->frame_info.res.height);
+	snprintf(
+		ring_buffer, sizeof(ring_buffer),
+		"node [shape = box, fixedsize=true, width=2, height=0.7]; \"%p\" [label = \"%s\\n%d(%d) x %d\\nRingbuffer\"];",
+		out_frame, debug_frame_format2str(out_frame->frame_info.format),
+		out_frame->frame_info.res.width,
+		out_frame->frame_info.padded_width,
+		out_frame->frame_info.res.height);
 
 	dtrace_dot(ring_buffer);
 
-	dtrace_dot(
-	    "\"%s(pipe%d)\"->\"%p\" [label = out_frame];",
-	    "sp_raw_copy", 1, out_frame);
+	dtrace_dot("\"%s(pipe%d)\"->\"%p\" [label = out_frame];", "sp_raw_copy",
+		   1, out_frame);
 
 	snprintf(dot_id_input_bin, sizeof(dot_id_input_bin), "%s(pipe%d)",
 		 "sp_raw_copy", 1);
 }
 
-void
-ia_css_debug_pipe_graph_dump_stream_config(
-    const struct ia_css_stream_config *stream_config)
+void ia_css_debug_pipe_graph_dump_stream_config(
+	const struct ia_css_stream_config *stream_config)
 {
 	pg_inst.width = stream_config->input_config.input_res.width;
 	pg_inst.height = stream_config->input_config.input_res.height;
@@ -1417,19 +1425,15 @@ ia_css_debug_pipe_graph_dump_stream_config(
 	pg_inst.stream_format = stream_config->input_config.format;
 }
 
-void
-ia_css_debug_dump_resolution(
-    const struct ia_css_resolution *res,
-    const char *label)
+void ia_css_debug_dump_resolution(const struct ia_css_resolution *res,
+				  const char *label)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s: =%d x =%d\n",
-			    label, res->width, res->height);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s: =%d x =%d\n", label,
+			    res->width, res->height);
 }
 
-void
-ia_css_debug_dump_frame_info(
-    const struct ia_css_frame_info *info,
-    const char *label)
+void ia_css_debug_dump_frame_info(const struct ia_css_frame_info *info,
+				  const char *label)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s\n", label);
 	ia_css_debug_dump_resolution(&info->res, "res");
@@ -1442,9 +1446,7 @@ ia_css_debug_dump_frame_info(
 			    info->raw_bayer_order);
 }
 
-void
-ia_css_debug_dump_capture_config(
-    const struct ia_css_capture_config *config)
+void ia_css_debug_dump_capture_config(const struct ia_css_capture_config *config)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s\n", __func__);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "mode: %d\n", config->mode);
@@ -1454,9 +1456,8 @@ ia_css_debug_dump_capture_config(
 			    config->enable_raw_output);
 }
 
-void
-ia_css_debug_dump_pipe_extra_config(
-    const struct ia_css_pipe_extra_config *extra_config)
+void ia_css_debug_dump_pipe_extra_config(
+	const struct ia_css_pipe_extra_config *extra_config)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s\n", __func__);
 	if (extra_config) {
@@ -1482,9 +1483,7 @@ ia_css_debug_dump_pipe_extra_config(
 	}
 }
 
-void
-ia_css_debug_dump_pipe_config(
-    const struct ia_css_pipe_config *config)
+void ia_css_debug_dump_pipe_config(const struct ia_css_pipe_config *config)
 {
 	unsigned int i;
 
@@ -1499,18 +1498,18 @@ ia_css_debug_dump_pipe_config(
 			    config->isp_pipe_version);
 	ia_css_debug_dump_resolution(&config->bayer_ds_out_res,
 				     "bayer_ds_out_res");
-	ia_css_debug_dump_resolution(&config->capt_pp_in_res,
-				     "capt_pp_in_res");
+	ia_css_debug_dump_resolution(&config->capt_pp_in_res, "capt_pp_in_res");
 	ia_css_debug_dump_resolution(&config->vf_pp_in_res, "vf_pp_in_res");
 
 	if (IS_ISP2401) {
 		ia_css_debug_dump_resolution(&config->output_system_in_res,
-					    "output_system_in_res");
+					     "output_system_in_res");
 	}
 	ia_css_debug_dump_resolution(&config->dvs_crop_out_res,
 				     "dvs_crop_out_res");
 	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
-		ia_css_debug_dump_frame_info(&config->output_info[i], "output_info");
+		ia_css_debug_dump_frame_info(&config->output_info[i],
+					     "output_info");
 		ia_css_debug_dump_frame_info(&config->vf_output_info[i],
 					     "vf_output_info");
 	}
@@ -1523,9 +1522,8 @@ ia_css_debug_dump_pipe_config(
 	IA_CSS_LEAVE_PRIVATE("");
 }
 
-void
-ia_css_debug_dump_stream_config_source(
-    const struct ia_css_stream_config *config)
+void ia_css_debug_dump_stream_config_source(
+	const struct ia_css_stream_config *config)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s()\n", __func__);
 	switch (config->mode) {
@@ -1561,9 +1559,8 @@ ia_css_debug_dump_stream_config_source(
 	}
 }
 
-void
-ia_css_debug_dump_mipi_buffer_config(
-    const struct ia_css_mipi_buffer_config *config)
+void ia_css_debug_dump_mipi_buffer_config(
+	const struct ia_css_mipi_buffer_config *config)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s()\n", __func__);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "size_mem_words: %d\n",
@@ -1572,9 +1569,8 @@ ia_css_debug_dump_mipi_buffer_config(
 			    config->nof_mipi_buffers);
 }
 
-void
-ia_css_debug_dump_metadata_config(
-    const struct ia_css_metadata_config *config)
+void ia_css_debug_dump_metadata_config(
+	const struct ia_css_metadata_config *config)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s()\n", __func__);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "data_type: %d\n",
@@ -1582,10 +1578,8 @@ ia_css_debug_dump_metadata_config(
 	ia_css_debug_dump_resolution(&config->resolution, "resolution");
 }
 
-void
-ia_css_debug_dump_stream_config(
-    const struct ia_css_stream_config *config,
-    int num_pipes)
+void ia_css_debug_dump_stream_config(const struct ia_css_stream_config *config,
+				     int num_pipes)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s()\n", __func__);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "num_pipes: %d\n", num_pipes);
@@ -1593,7 +1587,8 @@ ia_css_debug_dump_stream_config(
 	ia_css_debug_dump_stream_config_source(config);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "channel_id: %d\n",
 			    config->channel_id);
-	ia_css_debug_dump_resolution(&config->input_config.input_res, "input_res");
+	ia_css_debug_dump_resolution(&config->input_config.input_res,
+				     "input_res");
 	ia_css_debug_dump_resolution(&config->input_config.effective_res,
 				     "effective_res");
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "format: %d\n",
@@ -1604,12 +1599,10 @@ ia_css_debug_dump_stream_config(
 			    config->sensor_binning_factor);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "pixels_per_clock: %d\n",
 			    config->pixels_per_clock);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "online: %d\n",
-			    config->online);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "online: %d\n", config->online);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "init_num_cont_raw_buf: %d\n",
 			    config->init_num_cont_raw_buf);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "target_num_cont_raw_buf: %d\n",
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "target_num_cont_raw_buf: %d\n",
 			    config->target_num_cont_raw_buf);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "pack_raw_pixels: %d\n",
 			    config->pack_raw_pixels);
@@ -1668,7 +1661,7 @@ static void debug_dump_one_trace(enum TRACE_CORE_ID proc_id)
 
 	int i, j, max_trace_points, point_num, limit = -1;
 	/* using a static buffer here as the driver has issues allocating memory */
-	static u32 trace_read_buf[TRACE_BUFF_SIZE] = {0};
+	static u32 trace_read_buf[TRACE_BUFF_SIZE] = { 0 };
 	static struct trace_header_t header;
 	u8 *header_arr;
 
@@ -1697,8 +1690,9 @@ static void debug_dump_one_trace(enum TRACE_CORE_ID proc_id)
 		max_trace_points = TRACE_ISP_MAX_POINTS;
 		break;
 	default:
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "\t\ttraces are not supported for this processor ID - exiting\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE,
+			"\t\ttraces are not supported for this processor ID - exiting\n");
 		return;
 	}
 
@@ -1706,60 +1700,69 @@ static void debug_dump_one_trace(enum TRACE_CORE_ID proc_id)
 		tmp = ia_css_device_load_uint32(start_addr);
 		point_num = (tmp >> 16) & 0xFFFF;
 
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, " ver %d %d points\n", tmp & 0xFF,
-				    point_num);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, " ver %d %d points\n",
+				    tmp & 0xFF, point_num);
 	} else {
 		/* Loading byte-by-byte as using the master routine had issues */
 		header_arr = (uint8_t *)&header;
 		for (i = 0; i < (int)sizeof(struct trace_header_t); i++)
-			header_arr[i] = ia_css_device_load_uint8(start_addr + (i));
+			header_arr[i] =
+				ia_css_device_load_uint8(start_addr + (i));
 
 		point_num = header.max_tracer_points;
 
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, " ver %d %d points\n", header.version,
-				    point_num);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, " ver %d %d points\n",
+				    header.version, point_num);
 
 		tmp = header.version;
 	}
 	if ((tmp & 0xFF) != TRACER_VER) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\t\tUnknown version - exiting\n");
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				    "\t\tUnknown version - exiting\n");
 		return;
 	}
 	if (point_num > max_trace_points) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\t\tToo many points - exiting\n");
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				    "\t\tToo many points - exiting\n");
 		return;
 	}
 	/* copy the TPs and find the first 0 */
 	for (i = 0; i < point_num; i++) {
 		trace_read_buf[i] = ia_css_device_load_uint32(start_addr_data +
-				    (i * item_size));
+							      (i * item_size));
 		if ((limit == (-1)) && (trace_read_buf[i] == 0))
 			limit = i;
 	}
 	if (IS_ISP2401) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "Status:\n");
 		for (i = 0; i < SH_CSS_MAX_SP_THREADS; i++)
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-					    "\tT%d: %3d (%02x)  %6d (%04x)  %10d (%08x)\n", i,
-					    header.thr_status_byte[i], header.thr_status_byte[i],
-					    header.thr_status_word[i], header.thr_status_word[i],
-					    header.thr_status_dword[i], header.thr_status_dword[i]);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE,
+				"\tT%d: %3d (%02x)  %6d (%04x)  %10d (%08x)\n",
+				i, header.thr_status_byte[i],
+				header.thr_status_byte[i],
+				header.thr_status_word[i],
+				header.thr_status_word[i],
+				header.thr_status_dword[i],
+				header.thr_status_dword[i]);
 		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "Scratch:\n");
 		for (i = 0; i < MAX_SCRATCH_DATA; i++)
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%10d (%08x)  ",
-					    header.scratch_debug[i], header.scratch_debug[i]);
+					    header.scratch_debug[i],
+					    header.scratch_debug[i]);
 		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\n");
 	}
 	/* two 0s in the beginning: empty buffer */
 	if ((trace_read_buf[0] == 0) && (trace_read_buf[1] == 0)) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\t\tEmpty tracer - exiting\n");
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				    "\t\tEmpty tracer - exiting\n");
 		return;
 	}
 	/* no overrun: start from 0 */
 	if ((limit == point_num - 1) ||
 	    /* first 0 is at the end - border case */
 	    (trace_read_buf[limit + 1] ==
-	     0))   /* did not make a full cycle after the memset */
+	     0)) /* did not make a full cycle after the memset */
 		limit = 0;
 	/* overrun: limit is the first non-zero after the first zero */
 	else
@@ -1770,7 +1773,8 @@ static void debug_dump_one_trace(enum TRACE_CORE_ID proc_id)
 		j = (limit + i) % point_num;
 		if (trace_read_buf[j]) {
 			if (!IS_ISP2401) {
-				TRACE_DUMP_FORMAT dump_format = FIELD_FORMAT_UNPACK(trace_read_buf[j]);
+				TRACE_DUMP_FORMAT dump_format =
+					FIELD_FORMAT_UNPACK(trace_read_buf[j]);
 			} else {
 				tid_val = FIELD_TID_UNPACK(trace_read_buf[j]);
 				dump_format = TRACE_DUMP_FORMAT_POINT;
@@ -1780,72 +1784,82 @@ static void debug_dump_one_trace(enum TRACE_CORE_ID proc_id)
 				* tid val is ignored, major field contains 2 bits (msb) for format type
 				*/
 				if (tid_val == FIELD_TID_SEL_FORMAT_PAT) {
-					dump_format = FIELD_FORMAT_UNPACK(trace_read_buf[j]);
+					dump_format = FIELD_FORMAT_UNPACK(
+						trace_read_buf[j]);
 				}
 			}
 			switch (dump_format) {
 			case TRACE_DUMP_FORMAT_POINT:
 				ia_css_debug_dtrace(
-				    IA_CSS_DEBUG_TRACE,	"\t\t%d %d:%d value - %d\n",
-				    j, FIELD_MAJOR_UNPACK(trace_read_buf[j]),
-				    FIELD_MINOR_UNPACK(trace_read_buf[j]),
-				    FIELD_VALUE_UNPACK(trace_read_buf[j]));
+					IA_CSS_DEBUG_TRACE,
+					"\t\t%d %d:%d value - %d\n", j,
+					FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+					FIELD_MINOR_UNPACK(trace_read_buf[j]),
+					FIELD_VALUE_UNPACK(trace_read_buf[j]));
 				break;
 			/* ISP2400 */
 			case TRACE_DUMP_FORMAT_VALUE24_HEX:
 				ia_css_debug_dtrace(
-				    IA_CSS_DEBUG_TRACE,	"\t\t%d, %d, 24bit value %x H\n",
-				    j,
-				    FIELD_MAJOR_UNPACK(trace_read_buf[j]),
-				    FIELD_VALUE_24_UNPACK(trace_read_buf[j]));
+					IA_CSS_DEBUG_TRACE,
+					"\t\t%d, %d, 24bit value %x H\n", j,
+					FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+					FIELD_VALUE_24_UNPACK(
+						trace_read_buf[j]));
 				break;
 			/* ISP2400 */
 			case TRACE_DUMP_FORMAT_VALUE24_DEC:
 				ia_css_debug_dtrace(
-				    IA_CSS_DEBUG_TRACE,	"\t\t%d, %d, 24bit value %d D\n",
-				    j,
-				    FIELD_MAJOR_UNPACK(trace_read_buf[j]),
-				    FIELD_VALUE_24_UNPACK(trace_read_buf[j]));
+					IA_CSS_DEBUG_TRACE,
+					"\t\t%d, %d, 24bit value %d D\n", j,
+					FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+					FIELD_VALUE_24_UNPACK(
+						trace_read_buf[j]));
 				break;
 			/* ISP2401 */
 			case TRACE_DUMP_FORMAT_POINT_NO_TID:
 				ia_css_debug_dtrace(
-				    IA_CSS_DEBUG_TRACE,	"\t\t%d %d:%d value - %x (%d)\n",
-				    j,
-				    FIELD_MAJOR_W_FMT_UNPACK(trace_read_buf[j]),
-				    FIELD_MINOR_UNPACK(trace_read_buf[j]),
-				    FIELD_VALUE_UNPACK(trace_read_buf[j]),
-				    FIELD_VALUE_UNPACK(trace_read_buf[j]));
+					IA_CSS_DEBUG_TRACE,
+					"\t\t%d %d:%d value - %x (%d)\n", j,
+					FIELD_MAJOR_W_FMT_UNPACK(
+						trace_read_buf[j]),
+					FIELD_MINOR_UNPACK(trace_read_buf[j]),
+					FIELD_VALUE_UNPACK(trace_read_buf[j]),
+					FIELD_VALUE_UNPACK(trace_read_buf[j]));
 				break;
 			/* ISP2401 */
 			case TRACE_DUMP_FORMAT_VALUE24:
 				ia_css_debug_dtrace(
-				    IA_CSS_DEBUG_TRACE,	"\t\t%d, %d, 24bit value %x (%d)\n",
-				    j,
-				    FIELD_MAJOR_UNPACK(trace_read_buf[j]),
-				    FIELD_MAJOR_W_FMT_UNPACK(trace_read_buf[j]),
-				    FIELD_VALUE_24_UNPACK(trace_read_buf[j]),
-				    FIELD_VALUE_24_UNPACK(trace_read_buf[j]));
+					IA_CSS_DEBUG_TRACE,
+					"\t\t%d, %d, 24bit value %x (%d)\n", j,
+					FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+					FIELD_MAJOR_W_FMT_UNPACK(
+						trace_read_buf[j]),
+					FIELD_VALUE_24_UNPACK(
+						trace_read_buf[j]),
+					FIELD_VALUE_24_UNPACK(
+						trace_read_buf[j]));
 				break;
 			case TRACE_DUMP_FORMAT_VALUE24_TIMING:
 				ia_css_debug_dtrace(
-				    IA_CSS_DEBUG_TRACE,	"\t\t%d, %d, timing %x\n",
-				    j,
-				    FIELD_MAJOR_UNPACK(trace_read_buf[j]),
-				    FIELD_VALUE_24_UNPACK(trace_read_buf[j]));
+					IA_CSS_DEBUG_TRACE,
+					"\t\t%d, %d, timing %x\n", j,
+					FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+					FIELD_VALUE_24_UNPACK(
+						trace_read_buf[j]));
 				break;
 			case TRACE_DUMP_FORMAT_VALUE24_TIMING_DELTA:
 				ia_css_debug_dtrace(
-				    IA_CSS_DEBUG_TRACE,	"\t\t%d, %d, timing delta %x\n",
-				    j,
-				    FIELD_MAJOR_UNPACK(trace_read_buf[j]),
-				    FIELD_VALUE_24_UNPACK(trace_read_buf[j]));
+					IA_CSS_DEBUG_TRACE,
+					"\t\t%d, %d, timing delta %x\n", j,
+					FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+					FIELD_VALUE_24_UNPACK(
+						trace_read_buf[j]));
 				break;
 			default:
 				ia_css_debug_dtrace(
-				    IA_CSS_DEBUG_TRACE,
-				    "no such trace dump format %d",
-				    dump_format);
+					IA_CSS_DEBUG_TRACE,
+					"no such trace dump format %d",
+					dump_format);
 				break;
 			}
 		}
@@ -1876,11 +1890,14 @@ void ia_css_debug_pc_dump(sp_ID_t id, unsigned int num_of_dumps)
 	unsigned int i;
 	hrt_data sc = sp_ctrl_load(id, SP_SC_REG);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "SP%-1d Status reg: 0x%X\n", id, sc);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "SP%-1d Status reg: 0x%X\n", id,
+			    sc);
 	sc = sp_ctrl_load(id, SP_CTRL_SINK_REG);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "SP%-1d Stall reg: 0x%X\n", id, sc);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "SP%-1d Stall reg: 0x%X\n", id,
+			    sc);
 	for (i = 0; i < num_of_dumps; i++) {
 		pc = sp_ctrl_load(id, SP_PC_REG);
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "SP%-1d PC: 0x%X\n", id, pc);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "SP%-1d PC: 0x%X\n", id,
+				    pc);
 	}
 }
diff --git a/drivers/staging/media/atomisp/pci/runtime/event/interface/ia_css_event.h b/drivers/staging/media/atomisp/pci/runtime/event/interface/ia_css_event.h
index d0c3278b0fd95d279fc466bda762f60ac2b78972..e36947620ec222f0a85136844bc6582b2a38087f 100644
--- a/drivers/staging/media/atomisp/pci/runtime/event/interface/ia_css_event.h
+++ b/drivers/staging/media/atomisp/pci/runtime/event/interface/ia_css_event.h
@@ -8,15 +8,10 @@
 #define _IA_CSS_EVENT_H
 
 #include <type_support.h>
-#include "sw_event_global.h"    /*event macros.TODO : Change File Name..???*/
+#include "sw_event_global.h" /*event macros.TODO : Change File Name..???*/
 
-bool ia_css_event_encode(
-    u8	*in,
-    u8	nr,
-    uint32_t	*out);
+bool ia_css_event_encode(u8 *in, u8 nr, uint32_t *out);
 
-void ia_css_event_decode(
-    u32 event,
-    uint8_t *payload);
+void ia_css_event_decode(u32 event, uint8_t *payload);
 
 #endif /*_IA_CSS_EVENT_H*/
diff --git a/drivers/staging/media/atomisp/pci/runtime/event/src/event.c b/drivers/staging/media/atomisp/pci/runtime/event/src/event.c
index 6154dda2d968baccb4b381fba9fe54e034a23a63..580d01b5e8084009347e0f0b5180327ee5dfa78f 100644
--- a/drivers/staging/media/atomisp/pci/runtime/event/src/event.c
+++ b/drivers/staging/media/atomisp/pci/runtime/event/src/event.c
@@ -6,7 +6,7 @@
 
 #include "sh_css_sp.h"
 
-#include "dma.h"	/* N_DMA_CHANNEL_ID */
+#include "dma.h" /* N_DMA_CHANNEL_ID */
 
 #include <type_support.h>
 #include "ia_css_binary.h"
@@ -17,22 +17,19 @@
 #include "ia_css_debug_internal.h"
 #include "sh_css_legacy.h"
 
-#include "gdc_device.h"				/* HRT_GDC_N */
+#include "gdc_device.h" /* HRT_GDC_N */
 
-/*#include "sp.h"*/	/* host2sp_enqueue_frame_data() */
+/*#include "sp.h"*/ /* host2sp_enqueue_frame_data() */
 
 #include "assert_support.h"
 
-#include "ia_css_queue.h"	/* host_sp_enqueue_XXX */
-#include "ia_css_event.h"	/* ia_css_event_encode */
+#include "ia_css_queue.h" /* host_sp_enqueue_XXX */
+#include "ia_css_event.h" /* ia_css_event_encode */
 /*
  * @brief Encode the information into the software-event.
  * Refer to "sw_event_public.h" for details.
  */
-bool ia_css_event_encode(
-    u8	*in,
-    u8	nr,
-    uint32_t	*out)
+bool ia_css_event_encode(u8 *in, u8 nr, uint32_t *out)
 {
 	bool ret;
 	u32 nr_of_bits;
@@ -60,9 +57,7 @@ bool ia_css_event_encode(
 	return ret;
 }
 
-void ia_css_event_decode(
-    u32 event,
-    uint8_t *payload)
+void ia_css_event_decode(u32 event, uint8_t *payload)
 {
 	assert(payload[1] == 0);
 	assert(payload[2] == 0);
@@ -77,7 +72,7 @@ void ia_css_event_decode(
 	 * This is somewhat ugly but probably somewhat efficient
 	 * (and it avoids some code duplication)
 	 */
-	payload[0] = event & 0xff;  /*event_code */
+	payload[0] = event & 0xff; /*event_code */
 	payload[1] = (event >> 8) & 0xff;
 	payload[2] = (event >> 16) & 0xff;
 	payload[3] = 0;
diff --git a/drivers/staging/media/atomisp/pci/runtime/eventq/interface/ia_css_eventq.h b/drivers/staging/media/atomisp/pci/runtime/eventq/interface/ia_css_eventq.h
index 9b058e296c93d73f1ac02afdc00560333ebba424..648776d726c45309003867808ce10a2ca7db92ca 100644
--- a/drivers/staging/media/atomisp/pci/runtime/eventq/interface/ia_css_eventq.h
+++ b/drivers/staging/media/atomisp/pci/runtime/eventq/interface/ia_css_eventq.h
@@ -7,7 +7,7 @@
 #ifndef _IA_CSS_EVENTQ_H
 #define _IA_CSS_EVENTQ_H
 
-#include "ia_css_queue.h"	/* queue APIs */
+#include "ia_css_queue.h" /* queue APIs */
 
 /**
  * @brief HOST receives event from SP.
@@ -18,9 +18,7 @@
  * @return	-EINVAL		- Invalid argument.
  * @return	-ENODATA		- Queue is empty.
  */
-int ia_css_eventq_recv(
-    ia_css_queue_t *eventq_handle,
-    uint8_t *payload);
+int ia_css_eventq_recv(ia_css_queue_t *eventq_handle, uint8_t *payload);
 
 /**
  * @brief The Host sends the event to SP.
@@ -36,10 +34,7 @@ int ia_css_eventq_recv(
  * @return	-EINVAL		- Invalid argument.
  * @return	-ENOBUFS		- Queue is full.
  */
-int ia_css_eventq_send(
-    ia_css_queue_t *eventq_handle,
-    u8 evt_id,
-    u8 evt_payload_0,
-    u8 evt_payload_1,
-    uint8_t evt_payload_2);
+int ia_css_eventq_send(ia_css_queue_t *eventq_handle, u8 evt_id,
+		       u8 evt_payload_0, u8 evt_payload_1,
+		       uint8_t evt_payload_2);
 #endif /* _IA_CSS_EVENTQ_H */
diff --git a/drivers/staging/media/atomisp/pci/runtime/eventq/src/eventq.c b/drivers/staging/media/atomisp/pci/runtime/eventq/src/eventq.c
index fb1710ddcf48052ac4e6838b55fd79ac4318fb59..3e780de2b62069ed98c3499f2d788a76d0d1bc2c 100644
--- a/drivers/staging/media/atomisp/pci/runtime/eventq/src/eventq.c
+++ b/drivers/staging/media/atomisp/pci/runtime/eventq/src/eventq.c
@@ -8,12 +8,10 @@
 #include "assert_support.h"
 #include "ia_css_queue.h" /* sp2host_dequeue_irq_event() */
 #include "ia_css_eventq.h"
-#include "ia_css_event.h"	/* ia_css_event_encode()
+#include "ia_css_event.h" /* ia_css_event_encode()
 				ia_css_event_decode()
 				*/
-int ia_css_eventq_recv(
-    ia_css_queue_t *eventq_handle,
-    uint8_t *payload)
+int ia_css_eventq_recv(ia_css_queue_t *eventq_handle, uint8_t *payload)
 {
 	u32 sp_event;
 	int error;
@@ -31,12 +29,9 @@ int ia_css_eventq_recv(
  * @brief The Host sends the event to the SP.
  * Refer to "sh_css_sp.h" for details.
  */
-int ia_css_eventq_send(
-    ia_css_queue_t *eventq_handle,
-    u8 evt_id,
-    u8 evt_payload_0,
-    u8 evt_payload_1,
-    uint8_t evt_payload_2)
+int ia_css_eventq_send(ia_css_queue_t *eventq_handle, u8 evt_id,
+		       u8 evt_payload_0, u8 evt_payload_1,
+		       uint8_t evt_payload_2)
 {
 	u8 tmp[4];
 	u32 sw_event;
@@ -53,7 +48,7 @@ int ia_css_eventq_send(
 	ia_css_event_encode(tmp, 4, &sw_event);
 
 	/* queue the software event (busy-waiting) */
-	for ( ; ; ) {
+	for (;;) {
 		error = ia_css_queue_enqueue(eventq_handle, sw_event);
 		if (error != -ENOBUFS) {
 			/* We were able to successfully send the event
diff --git a/drivers/staging/media/atomisp/pci/runtime/frame/interface/ia_css_frame.h b/drivers/staging/media/atomisp/pci/runtime/frame/interface/ia_css_frame.h
index 45d4bb87af7aa0618b83513a35cfc11edbeba166..6345fa13a555089d363c6fed2edf39d32c4a8053 100644
--- a/drivers/staging/media/atomisp/pci/runtime/frame/interface/ia_css_frame.h
+++ b/drivers/staging/media/atomisp/pci/runtime/frame/interface/ia_css_frame.h
@@ -49,8 +49,7 @@ void ia_css_frame_info_set_format(struct ia_css_frame_info *info,
  * @param[in]	aligned     The aligned to be set to info
  * @return
  */
-void ia_css_frame_info_init(struct ia_css_frame_info *info,
-			    unsigned int width,
+void ia_css_frame_info_init(struct ia_css_frame_info *info, unsigned int width,
 			    unsigned int height,
 			    enum ia_css_frame_format format,
 			    unsigned int aligned);
@@ -63,8 +62,8 @@ void ia_css_frame_info_init(struct ia_css_frame_info *info,
  * @return      Returns true if the frames are equal
  */
 bool ia_css_frame_info_is_same_resolution(
-    const struct ia_css_frame_info *info_a,
-    const struct ia_css_frame_info *info_b);
+	const struct ia_css_frame_info *info_a,
+	const struct ia_css_frame_info *info_b);
 
 /* @brief Check the frame info is valid
  *
@@ -115,9 +114,8 @@ int ia_css_frame_allocate_with_buffer_size(struct ia_css_frame **frame,
  * @param[in]	frame_b         The second frame to be compared
  * @return      Returns true if the frames are equal
  */
-bool ia_css_frame_is_same_type(
-    const struct ia_css_frame *frame_a,
-    const struct ia_css_frame *frame_b);
+bool ia_css_frame_is_same_type(const struct ia_css_frame *frame_a,
+			       const struct ia_css_frame *frame_b);
 
 /* @brief Configure a dma port from frame info
  *
@@ -129,6 +127,7 @@ bool ia_css_frame_is_same_type(
 int ia_css_dma_configure_from_info(struct dma_port_config *config,
 				   const struct ia_css_frame_info *info);
 
-unsigned int ia_css_frame_pad_width(unsigned int width, enum ia_css_frame_format format);
+unsigned int ia_css_frame_pad_width(unsigned int width,
+				    enum ia_css_frame_format format);
 
 #endif /* __IA_CSS_FRAME_H__ */
diff --git a/drivers/staging/media/atomisp/pci/runtime/frame/interface/ia_css_frame_comm.h b/drivers/staging/media/atomisp/pci/runtime/frame/interface/ia_css_frame_comm.h
index d1031f824896d3ec1087a6d2d62c0bc6a619aab2..a01b9bd0111dfdb8c7f62db323c9c00ec21ae7a8 100644
--- a/drivers/staging/media/atomisp/pci/runtime/frame/interface/ia_css_frame_comm.h
+++ b/drivers/staging/media/atomisp/pci/runtime/frame/interface/ia_css_frame_comm.h
@@ -10,7 +10,7 @@
 #include "type_support.h"
 #include "platform_support.h"
 #include "runtime/bufq/interface/ia_css_bufq_comm.h"
-#include <system_local.h>	 /* ia_css_ptr */
+#include <system_local.h> /* ia_css_ptr */
 
 /*
  * These structs are derived from structs defined in ia_css_types.h
@@ -18,7 +18,7 @@
  * All the fields that are not needed by the SP are removed.
  */
 struct ia_css_frame_sp_plane {
-	unsigned int offset;	/* offset in bytes to start of frame data */
+	unsigned int offset; /* offset in bytes to start of frame data */
 	/* offset is wrt data in sh_css_sp_sp_frame */
 };
 
@@ -54,8 +54,8 @@ struct ia_css_frame_sp_plane6 {
 };
 
 struct ia_css_sp_resolution {
-	u16 width;		/* width of valid data in pixels */
-	u16 height;	/* Height of valid data in lines */
+	u16 width; /* width of valid data in pixels */
+	u16 height; /* Height of valid data in lines */
 };
 
 /*
@@ -63,14 +63,14 @@ struct ia_css_sp_resolution {
  */
 struct ia_css_frame_sp_info {
 	struct ia_css_sp_resolution res;
-	u16 padded_width;		/* stride of line in memory
+	u16 padded_width; /* stride of line in memory
 					(in pixels) */
-	unsigned char format;		/* format of the frame data */
-	unsigned char raw_bit_depth;	/* number of valid bits per pixel,
+	unsigned char format; /* format of the frame data */
+	unsigned char raw_bit_depth; /* number of valid bits per pixel,
 					only valid for RAW bayer frames */
-	unsigned char raw_bayer_order;	/* bayer order, only valid
+	unsigned char raw_bayer_order; /* bayer order, only valid
 					for RAW bayer frames */
-	unsigned char padding[3];	/* Extend to 32 bit multiple */
+	unsigned char padding[3]; /* Extend to 32 bit multiple */
 };
 
 struct ia_css_buffer_sp {
@@ -96,12 +96,10 @@ struct ia_css_frame_sp {
 	} planes;
 };
 
-void ia_css_frame_info_to_frame_sp_info(
-    struct ia_css_frame_sp_info *sp_info,
-    const struct ia_css_frame_info *info);
+void ia_css_frame_info_to_frame_sp_info(struct ia_css_frame_sp_info *sp_info,
+					const struct ia_css_frame_info *info);
 
-void ia_css_resolution_to_sp_resolution(
-    struct ia_css_sp_resolution *sp_info,
-    const struct ia_css_resolution *info);
+void ia_css_resolution_to_sp_resolution(struct ia_css_sp_resolution *sp_info,
+					const struct ia_css_resolution *info);
 
 #endif /*__IA_CSS_FRAME_COMM_H__*/
diff --git a/drivers/staging/media/atomisp/pci/runtime/frame/src/frame.c b/drivers/staging/media/atomisp/pci/runtime/frame/src/frame.c
index 4f610f57e6c117df8a7a5d3da6b75fd69ce795a1..ebc79738068d39a0c03199b99e0b8a6f40daf024 100644
--- a/drivers/staging/media/atomisp/pci/runtime/frame/src/frame.c
+++ b/drivers/staging/media/atomisp/pci/runtime/frame/src/frame.c
@@ -14,17 +14,15 @@
 #include "sh_css_internal.h"
 #include "atomisp_internal.h"
 
-#define NV12_TILEY_TILE_WIDTH  128
-#define NV12_TILEY_TILE_HEIGHT  32
+#define NV12_TILEY_TILE_WIDTH 128
+#define NV12_TILEY_TILE_HEIGHT 32
 
 /**************************************************************************
 **	Static functions declarations
 **************************************************************************/
 static void frame_init_plane(struct ia_css_frame_plane *plane,
-			     unsigned int width,
-			     unsigned int stride,
-			     unsigned int height,
-			     unsigned int offset);
+			     unsigned int width, unsigned int stride,
+			     unsigned int height, unsigned int offset);
 
 static void frame_init_single_plane(struct ia_css_frame *frame,
 				    struct ia_css_frame_plane *plane,
@@ -32,12 +30,11 @@ static void frame_init_single_plane(struct ia_css_frame *frame,
 				    unsigned int subpixels_per_line,
 				    unsigned int bytes_per_pixel);
 
-static void frame_init_raw_single_plane(
-    struct ia_css_frame *frame,
-    struct ia_css_frame_plane *plane,
-    unsigned int height,
-    unsigned int subpixels_per_line,
-    unsigned int bits_per_pixel);
+static void frame_init_raw_single_plane(struct ia_css_frame *frame,
+					struct ia_css_frame_plane *plane,
+					unsigned int height,
+					unsigned int subpixels_per_line,
+					unsigned int bits_per_pixel);
 
 static void frame_init_nv_planes(struct ia_css_frame *frame,
 				 unsigned int horizontal_decimation,
@@ -47,8 +44,7 @@ static void frame_init_nv_planes(struct ia_css_frame *frame,
 static void frame_init_yuv_planes(struct ia_css_frame *frame,
 				  unsigned int horizontal_decimation,
 				  unsigned int vertical_decimation,
-				  bool swap_uv,
-				  unsigned int bytes_per_element);
+				  bool swap_uv, unsigned int bytes_per_element);
 
 static void frame_init_rgb_planes(struct ia_css_frame *frame,
 				  unsigned int bytes_per_element);
@@ -58,29 +54,25 @@ static void frame_init_qplane6_planes(struct ia_css_frame *frame);
 static int frame_allocate_buffer_data(struct ia_css_frame *frame);
 
 static int frame_allocate_with_data(struct ia_css_frame **frame,
-	unsigned int width,
-	unsigned int height,
-	enum ia_css_frame_format format,
-	unsigned int padded_width,
-	unsigned int raw_bit_depth);
+				    unsigned int width, unsigned int height,
+				    enum ia_css_frame_format format,
+				    unsigned int padded_width,
+				    unsigned int raw_bit_depth);
 
-static struct ia_css_frame *frame_create(unsigned int width,
-	unsigned int height,
-	enum ia_css_frame_format format,
-	unsigned int padded_width,
-	unsigned int raw_bit_depth,
-	bool valid);
+static struct ia_css_frame *
+frame_create(unsigned int width, unsigned int height,
+	     enum ia_css_frame_format format, unsigned int padded_width,
+	     unsigned int raw_bit_depth, bool valid);
 
 static unsigned
-ia_css_elems_bytes_from_info(
-    const struct ia_css_frame_info *info);
+ia_css_elems_bytes_from_info(const struct ia_css_frame_info *info);
 
 /**************************************************************************
 **	CSS API functions, exposed by ia_css.h
 **************************************************************************/
 
 int ia_css_frame_allocate_from_info(struct ia_css_frame **frame,
-	const struct ia_css_frame_info *info)
+				    const struct ia_css_frame_info *info)
 {
 	int err = 0;
 
@@ -88,42 +80,41 @@ int ia_css_frame_allocate_from_info(struct ia_css_frame **frame,
 		return -EINVAL;
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
 			    "ia_css_frame_allocate_from_info() enter:\n");
-	err =
-	    ia_css_frame_allocate(frame, info->res.width, info->res.height,
-				  info->format, info->padded_width,
-				  info->raw_bit_depth);
+	err = ia_css_frame_allocate(frame, info->res.width, info->res.height,
+				    info->format, info->padded_width,
+				    info->raw_bit_depth);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
 			    "ia_css_frame_allocate_from_info() leave:\n");
 	return err;
 }
 
-int ia_css_frame_allocate(struct ia_css_frame **frame,
-				      unsigned int width,
-				      unsigned int height,
-				      enum ia_css_frame_format format,
-				      unsigned int padded_width,
-				      unsigned int raw_bit_depth)
+int ia_css_frame_allocate(struct ia_css_frame **frame, unsigned int width,
+			  unsigned int height, enum ia_css_frame_format format,
+			  unsigned int padded_width, unsigned int raw_bit_depth)
 {
 	int err = 0;
 
 	if (!frame || width == 0 || height == 0)
 		return -EINVAL;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_frame_allocate() enter: width=%d, height=%d, format=%d, padded_width=%d, raw_bit_depth=%d\n",
-			    width, height, format, padded_width, raw_bit_depth);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_allocate() enter: width=%d, height=%d, format=%d, padded_width=%d, raw_bit_depth=%d\n",
+		width, height, format, padded_width, raw_bit_depth);
 
 	err = frame_allocate_with_data(frame, width, height, format,
 				       padded_width, raw_bit_depth);
 
 	if ((*frame) && err == 0)
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "ia_css_frame_allocate() leave: frame=%p, data(DDR address)=0x%x\n", *frame,
-				    (*frame)->data);
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE,
+			"ia_css_frame_allocate() leave: frame=%p, data(DDR address)=0x%x\n",
+			*frame, (*frame)->data);
 	else
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "ia_css_frame_allocate() leave: frame=%p, data(DDR address)=0x%x\n",
-				    (void *)-1, (unsigned int)-1);
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE,
+			"ia_css_frame_allocate() leave: frame=%p, data(DDR address)=0x%x\n",
+			(void *)-1, (unsigned int)-1);
 
 	return err;
 }
@@ -159,7 +150,8 @@ int ia_css_frame_init_planes(struct ia_css_frame *frame)
 	switch (frame->frame_info.format) {
 	case IA_CSS_FRAME_FORMAT_MIPI:
 		dev_err(atomisp_dev,
-			"%s: unexpected use of IA_CSS_FRAME_FORMAT_MIPI\n", __func__);
+			"%s: unexpected use of IA_CSS_FRAME_FORMAT_MIPI\n",
+			__func__);
 		return -EINVAL;
 	case IA_CSS_FRAME_FORMAT_RAW_PACKED:
 		frame_init_raw_single_plane(frame, &frame->planes.raw,
@@ -168,10 +160,10 @@ int ia_css_frame_init_planes(struct ia_css_frame *frame)
 					    frame->frame_info.raw_bit_depth);
 		break;
 	case IA_CSS_FRAME_FORMAT_RAW:
-		frame_init_single_plane(frame, &frame->planes.raw,
-					frame->frame_info.res.height,
-					frame->frame_info.padded_width,
-					frame->frame_info.raw_bit_depth <= 8 ? 1 : 2);
+		frame_init_single_plane(
+			frame, &frame->planes.raw, frame->frame_info.res.height,
+			frame->frame_info.padded_width,
+			frame->frame_info.raw_bit_depth <= 8 ? 1 : 2);
 		break;
 	case IA_CSS_FRAME_FORMAT_RGB565:
 		frame_init_single_plane(frame, &frame->planes.rgb,
@@ -200,7 +192,8 @@ int ia_css_frame_init_planes(struct ia_css_frame *frame)
 	case IA_CSS_FRAME_FORMAT_YUV_LINE:
 		/* Needs 3 extra lines to allow vf_pp prefetching */
 		frame_init_single_plane(frame, &frame->planes.yuyv,
-					frame->frame_info.res.height * 3 / 2 + 3,
+					frame->frame_info.res.height * 3 / 2 +
+						3,
 					frame->frame_info.padded_width, 1);
 		break;
 	case IA_CSS_FRAME_FORMAT_NV11:
@@ -260,7 +253,8 @@ int ia_css_frame_init_planes(struct ia_css_frame *frame)
 	return 0;
 }
 
-unsigned int ia_css_frame_pad_width(unsigned int width, enum ia_css_frame_format format)
+unsigned int ia_css_frame_pad_width(unsigned int width,
+				    enum ia_css_frame_format format)
 {
 	switch (format) {
 	/*
@@ -318,21 +312,21 @@ void ia_css_frame_info_set_format(struct ia_css_frame_info *info,
 	info->format = format;
 }
 
-void ia_css_frame_info_init(struct ia_css_frame_info *info,
-			    unsigned int width,
+void ia_css_frame_info_init(struct ia_css_frame_info *info, unsigned int width,
 			    unsigned int height,
 			    enum ia_css_frame_format format,
 			    unsigned int aligned)
 {
-	IA_CSS_ENTER_PRIVATE("info = %p, width = %d, height = %d, format = %d, aligned = %d",
-			     info, width, height, format, aligned);
+	IA_CSS_ENTER_PRIVATE(
+		"info = %p, width = %d, height = %d, format = %d, aligned = %d",
+		info, width, height, format, aligned);
 	if (!info) {
 		IA_CSS_ERROR("NULL input parameter");
 		IA_CSS_LEAVE_PRIVATE("");
 		return;
 	}
 	info->res.height = height;
-	info->format     = format;
+	info->format = format;
 	ia_css_frame_info_set_width(info, width, aligned);
 	IA_CSS_LEAVE_PRIVATE("");
 }
@@ -355,9 +349,9 @@ int ia_css_frame_allocate_with_buffer_size(struct ia_css_frame **frame,
 {
 	/* AM: Body copied from frame_allocate_with_data(). */
 	int err;
-	struct ia_css_frame *me = frame_create(0, 0,
-					       IA_CSS_FRAME_FORMAT_NUM,/* Not valid format yet */
-					       0, 0, false);
+	struct ia_css_frame *me = frame_create(
+		0, 0, IA_CSS_FRAME_FORMAT_NUM, /* Not valid format yet */
+		0, 0, false);
 
 	if (!me)
 		return -ENOMEM;
@@ -378,8 +372,8 @@ int ia_css_frame_allocate_with_buffer_size(struct ia_css_frame **frame,
 }
 
 bool ia_css_frame_info_is_same_resolution(
-    const struct ia_css_frame_info *info_a,
-    const struct ia_css_frame_info *info_b)
+	const struct ia_css_frame_info *info_a,
+	const struct ia_css_frame_info *info_b)
 {
 	if (!info_a || !info_b)
 		return false;
@@ -414,20 +408,24 @@ bool ia_css_frame_is_same_type(const struct ia_css_frame *frame_a,
 int ia_css_dma_configure_from_info(struct dma_port_config *config,
 				   const struct ia_css_frame_info *info)
 {
-	unsigned int is_raw_packed = info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED;
-	unsigned int bits_per_pixel = is_raw_packed ? info->raw_bit_depth :
-				      ia_css_elems_bytes_from_info(info) * 8;
+	unsigned int is_raw_packed = info->format ==
+				     IA_CSS_FRAME_FORMAT_RAW_PACKED;
+	unsigned int bits_per_pixel =
+		is_raw_packed ? info->raw_bit_depth :
+				ia_css_elems_bytes_from_info(info) * 8;
 	unsigned int pix_per_ddrword = HIVE_ISP_DDR_WORD_BITS / bits_per_pixel;
-	unsigned int words_per_line = CEIL_DIV(info->padded_width, pix_per_ddrword);
+	unsigned int words_per_line =
+		CEIL_DIV(info->padded_width, pix_per_ddrword);
 	unsigned int elems_b = pix_per_ddrword;
 
 	config->stride = HIVE_ISP_DDR_WORD_BYTES * words_per_line;
-	config->elems  = (uint8_t)elems_b;
-	config->width  = (uint16_t)info->res.width;
-	config->crop   = 0;
+	config->elems = (uint8_t)elems_b;
+	config->width = (uint16_t)info->res.width;
+	config->crop = 0;
 
 	if (config->width > info->padded_width) {
-		dev_err(atomisp_dev, "internal error: padded_width is too small!\n");
+		dev_err(atomisp_dev,
+			"internal error: padded_width is too small!\n");
 		return -EINVAL;
 	}
 
@@ -439,10 +437,8 @@ int ia_css_dma_configure_from_info(struct dma_port_config *config,
 **************************************************************************/
 
 static void frame_init_plane(struct ia_css_frame_plane *plane,
-			     unsigned int width,
-			     unsigned int stride,
-			     unsigned int height,
-			     unsigned int offset)
+			     unsigned int width, unsigned int stride,
+			     unsigned int height, unsigned int offset)
 {
 	plane->height = height;
 	plane->width = width;
@@ -470,12 +466,11 @@ static void frame_init_single_plane(struct ia_css_frame *frame,
 	return;
 }
 
-static void frame_init_raw_single_plane(
-    struct ia_css_frame *frame,
-    struct ia_css_frame_plane *plane,
-    unsigned int height,
-    unsigned int subpixels_per_line,
-    unsigned int bits_per_pixel)
+static void frame_init_raw_single_plane(struct ia_css_frame *frame,
+					struct ia_css_frame_plane *plane,
+					unsigned int height,
+					unsigned int subpixels_per_line,
+					unsigned int bits_per_pixel)
 {
 	unsigned int stride;
 
@@ -509,9 +504,9 @@ static void frame_init_nv_planes(struct ia_css_frame *frame,
 	uv_height = y_height / vertical_decimation;
 
 	if (frame->frame_info.format == IA_CSS_FRAME_FORMAT_NV12_TILEY) {
-		y_width   = CEIL_MUL(y_width,   NV12_TILEY_TILE_WIDTH);
-		uv_width  = CEIL_MUL(uv_width,  NV12_TILEY_TILE_WIDTH);
-		y_height  = CEIL_MUL(y_height,  NV12_TILEY_TILE_HEIGHT);
+		y_width = CEIL_MUL(y_width, NV12_TILEY_TILE_WIDTH);
+		uv_width = CEIL_MUL(uv_width, NV12_TILEY_TILE_WIDTH);
+		y_height = CEIL_MUL(y_height, NV12_TILEY_TILE_HEIGHT);
 		uv_height = CEIL_MUL(uv_height, NV12_TILEY_TILE_HEIGHT);
 	}
 
@@ -522,22 +517,21 @@ static void frame_init_nv_planes(struct ia_css_frame *frame,
 
 	frame->data_bytes = y_bytes + uv_bytes;
 	frame_init_plane(&frame->planes.nv.y, y_width, y_stride, y_height, 0);
-	frame_init_plane(&frame->planes.nv.uv, uv_width,
-			 uv_stride, uv_height, y_bytes);
+	frame_init_plane(&frame->planes.nv.uv, uv_width, uv_stride, uv_height,
+			 y_bytes);
 	return;
 }
 
 static void frame_init_yuv_planes(struct ia_css_frame *frame,
 				  unsigned int horizontal_decimation,
 				  unsigned int vertical_decimation,
-				  bool swap_uv,
-				  unsigned int bytes_per_element)
+				  bool swap_uv, unsigned int bytes_per_element)
 {
 	unsigned int y_width = frame->frame_info.padded_width,
 		     y_height = frame->frame_info.res.height,
 		     uv_width = y_width / horizontal_decimation,
-		     uv_height = y_height / vertical_decimation,
-		     y_stride, y_bytes, uv_bytes, uv_stride;
+		     uv_height = y_height / vertical_decimation, y_stride,
+		     y_bytes, uv_bytes, uv_stride;
 
 	y_stride = y_width * bytes_per_element;
 	uv_stride = uv_width * bytes_per_element;
@@ -570,10 +564,10 @@ static void frame_init_rgb_planes(struct ia_css_frame *frame,
 	bytes = stride * height;
 	frame->data_bytes = 3 * bytes;
 	frame_init_plane(&frame->planes.planar_rgb.r, width, stride, height, 0);
-	frame_init_plane(&frame->planes.planar_rgb.g,
-			 width, stride, height, 1 * bytes);
-	frame_init_plane(&frame->planes.planar_rgb.b,
-			 width, stride, height, 2 * bytes);
+	frame_init_plane(&frame->planes.planar_rgb.g, width, stride, height,
+			 1 * bytes);
+	frame_init_plane(&frame->planes.planar_rgb.b, width, stride, height,
+			 2 * bytes);
 	return;
 }
 
@@ -586,18 +580,18 @@ static void frame_init_qplane6_planes(struct ia_css_frame *frame)
 	bytes = stride * height;
 
 	frame->data_bytes = 6 * bytes;
-	frame_init_plane(&frame->planes.plane6.r,
-			 width, stride, height, 0 * bytes);
-	frame_init_plane(&frame->planes.plane6.r_at_b,
-			 width, stride, height, 1 * bytes);
-	frame_init_plane(&frame->planes.plane6.gr,
-			 width, stride, height, 2 * bytes);
-	frame_init_plane(&frame->planes.plane6.gb,
-			 width, stride, height, 3 * bytes);
-	frame_init_plane(&frame->planes.plane6.b,
-			 width, stride, height, 4 * bytes);
-	frame_init_plane(&frame->planes.plane6.b_at_r,
-			 width, stride, height, 5 * bytes);
+	frame_init_plane(&frame->planes.plane6.r, width, stride, height,
+			 0 * bytes);
+	frame_init_plane(&frame->planes.plane6.r_at_b, width, stride, height,
+			 1 * bytes);
+	frame_init_plane(&frame->planes.plane6.gr, width, stride, height,
+			 2 * bytes);
+	frame_init_plane(&frame->planes.plane6.gb, width, stride, height,
+			 3 * bytes);
+	frame_init_plane(&frame->planes.plane6.b, width, stride, height,
+			 4 * bytes);
+	frame_init_plane(&frame->planes.plane6.b_at_r, width, stride, height,
+			 5 * bytes);
 	return;
 }
 
@@ -610,19 +604,14 @@ static int frame_allocate_buffer_data(struct ia_css_frame *frame)
 }
 
 static int frame_allocate_with_data(struct ia_css_frame **frame,
-	unsigned int width,
-	unsigned int height,
-	enum ia_css_frame_format format,
-	unsigned int padded_width,
-	unsigned int raw_bit_depth)
+				    unsigned int width, unsigned int height,
+				    enum ia_css_frame_format format,
+				    unsigned int padded_width,
+				    unsigned int raw_bit_depth)
 {
 	int err;
-	struct ia_css_frame *me = frame_create(width,
-					       height,
-					       format,
-					       padded_width,
-					       raw_bit_depth,
-					       true);
+	struct ia_css_frame *me = frame_create(
+		width, height, format, padded_width, raw_bit_depth, true);
 
 	if (!me)
 		return -ENOMEM;
@@ -643,11 +632,10 @@ static int frame_allocate_with_data(struct ia_css_frame **frame,
 }
 
 static struct ia_css_frame *frame_create(unsigned int width,
-	unsigned int height,
-	enum ia_css_frame_format format,
-	unsigned int padded_width,
-	unsigned int raw_bit_depth,
-	bool valid)
+					 unsigned int height,
+					 enum ia_css_frame_format format,
+					 unsigned int padded_width,
+					 unsigned int raw_bit_depth, bool valid)
 {
 	struct ia_css_frame *me = kvmalloc(sizeof(*me), GFP_KERNEL);
 
@@ -687,8 +675,8 @@ ia_css_elems_bytes_from_info(const struct ia_css_frame_info *info)
 	if (info->format == IA_CSS_FRAME_FORMAT_NV12_16)
 		return 1; /* bytes per pixel */
 
-	if (info->format == IA_CSS_FRAME_FORMAT_RAW
-	    || (info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED)) {
+	if (info->format == IA_CSS_FRAME_FORMAT_RAW ||
+	    (info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED)) {
 		if (info->raw_bit_depth)
 			return CEIL_DIV(info->raw_bit_depth, 8);
 		else
@@ -703,9 +691,8 @@ ia_css_elems_bytes_from_info(const struct ia_css_frame_info *info)
 	return 1; /* Default is 1 byte per pixel */
 }
 
-void ia_css_frame_info_to_frame_sp_info(
-    struct ia_css_frame_sp_info *to,
-    const struct ia_css_frame_info *from)
+void ia_css_frame_info_to_frame_sp_info(struct ia_css_frame_sp_info *to,
+					const struct ia_css_frame_info *from)
 {
 	ia_css_resolution_to_sp_resolution(&to->res, &from->res);
 	to->padded_width = (uint16_t)from->padded_width;
@@ -714,11 +701,10 @@ void ia_css_frame_info_to_frame_sp_info(
 	to->raw_bayer_order = from->raw_bayer_order;
 }
 
-void ia_css_resolution_to_sp_resolution(
-    struct ia_css_sp_resolution *to,
-    const struct ia_css_resolution *from)
+void ia_css_resolution_to_sp_resolution(struct ia_css_sp_resolution *to,
+					const struct ia_css_resolution *from)
 {
-	to->width  = (uint16_t)from->width;
+	to->width = (uint16_t)from->width;
 	to->height = (uint16_t)from->height;
 }
 
diff --git a/drivers/staging/media/atomisp/pci/runtime/ifmtr/interface/ia_css_ifmtr.h b/drivers/staging/media/atomisp/pci/runtime/ifmtr/interface/ia_css_ifmtr.h
index 01b89cdaf83589927d71c44fe6f852c3f535e4e3..76c6c24d9057940d5ca61a5964701c6e82d29c62 100644
--- a/drivers/staging/media/atomisp/pci/runtime/ifmtr/interface/ia_css_ifmtr.h
+++ b/drivers/staging/media/atomisp/pci/runtime/ifmtr/interface/ia_css_ifmtr.h
@@ -14,12 +14,12 @@
 extern bool ifmtr_set_if_blocking_mode_reset;
 
 unsigned int ia_css_ifmtr_lines_needed_for_bayer_order(
-    const struct ia_css_stream_config *config);
+	const struct ia_css_stream_config *config);
 
 unsigned int ia_css_ifmtr_columns_needed_for_bayer_order(
-    const struct ia_css_stream_config *config);
+	const struct ia_css_stream_config *config);
 
 int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
-				       struct ia_css_binary *binary);
+			   struct ia_css_binary *binary);
 
 #endif /* __IA_CSS_IFMTR_H__ */
diff --git a/drivers/staging/media/atomisp/pci/runtime/ifmtr/src/ifmtr.c b/drivers/staging/media/atomisp/pci/runtime/ifmtr/src/ifmtr.c
index d57ffb335fc0cc12224177732853159709cca9fd..b52f551f3be40a3bd0db7e7d613b20fba6e82a7f 100644
--- a/drivers/staging/media/atomisp/pci/runtime/ifmtr/src/ifmtr.c
+++ b/drivers/staging/media/atomisp/pci/runtime/ifmtr/src/ifmtr.c
@@ -7,7 +7,6 @@
 #include "system_global.h"
 #include <linux/kernel.h>
 
-
 #include "ia_css_ifmtr.h"
 #include <math_support.h>
 #include "sh_css_internal.h"
@@ -19,19 +18,16 @@
 /************************************************************
  * Static functions declarations
  ************************************************************/
-static int ifmtr_start_column(
-    const struct ia_css_stream_config *config,
-    unsigned int bin_in,
-    unsigned int *start_column);
+static int ifmtr_start_column(const struct ia_css_stream_config *config,
+			      unsigned int bin_in, unsigned int *start_column);
 
-static int ifmtr_input_start_line(
-    const struct ia_css_stream_config *config,
-    unsigned int bin_in,
-    unsigned int *start_line);
+static int ifmtr_input_start_line(const struct ia_css_stream_config *config,
+				  unsigned int bin_in,
+				  unsigned int *start_line);
 
-static void ifmtr_set_if_blocking_mode(
-    const input_formatter_cfg_t *const config_a,
-    const input_formatter_cfg_t *const config_b);
+static void
+ifmtr_set_if_blocking_mode(const input_formatter_cfg_t *const config_a,
+			   const input_formatter_cfg_t *const config_b);
 
 /************************************************************
  * Public functions
@@ -41,51 +37,38 @@ static void ifmtr_set_if_blocking_mode(
  * to correct in case the input bayer order is different.
  */
 unsigned int ia_css_ifmtr_lines_needed_for_bayer_order(
-    const struct ia_css_stream_config *config)
+	const struct ia_css_stream_config *config)
 {
 	assert(config);
-	if ((config->input_config.bayer_order == IA_CSS_BAYER_ORDER_BGGR)
-	    || (config->input_config.bayer_order == IA_CSS_BAYER_ORDER_GBRG))
+	if ((config->input_config.bayer_order == IA_CSS_BAYER_ORDER_BGGR) ||
+	    (config->input_config.bayer_order == IA_CSS_BAYER_ORDER_GBRG))
 		return 1;
 
 	return 0;
 }
 
 unsigned int ia_css_ifmtr_columns_needed_for_bayer_order(
-    const struct ia_css_stream_config *config)
+	const struct ia_css_stream_config *config)
 {
 	assert(config);
-	if ((config->input_config.bayer_order == IA_CSS_BAYER_ORDER_RGGB)
-	    || (config->input_config.bayer_order == IA_CSS_BAYER_ORDER_GBRG))
+	if ((config->input_config.bayer_order == IA_CSS_BAYER_ORDER_RGGB) ||
+	    (config->input_config.bayer_order == IA_CSS_BAYER_ORDER_GBRG))
 		return 1;
 
 	return 0;
 }
 
 int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
-				       struct ia_css_binary *binary)
+			   struct ia_css_binary *binary)
 {
-	unsigned int start_line, start_column = 0,
-				 cropped_height,
-				 cropped_width,
-				 num_vectors,
-				 buffer_height = 2,
-				 buffer_width,
-				 two_ppc,
-				 vmem_increment = 0,
-				 deinterleaving = 0,
-				 deinterleaving_b = 0,
-				 width_a = 0,
-				 width_b = 0,
-				 bits_per_pixel,
-				 vectors_per_buffer,
-				 vectors_per_line = 0,
-				 buffers_per_line = 0,
-				 buf_offset_a = 0,
-				 buf_offset_b = 0,
-				 line_width = 0,
-				 width_b_factor = 1, start_column_b,
-				 left_padding = 0;
+	unsigned int start_line,
+		start_column = 0, cropped_height, cropped_width, num_vectors,
+		buffer_height = 2, buffer_width, two_ppc, vmem_increment = 0,
+		deinterleaving = 0, deinterleaving_b = 0, width_a = 0,
+		width_b = 0, bits_per_pixel, vectors_per_buffer,
+		vectors_per_line = 0, buffers_per_line = 0, buf_offset_a = 0,
+		buf_offset_b = 0, line_width = 0, width_b_factor = 1,
+		start_column_b, left_padding = 0;
 	input_formatter_cfg_t if_a_config, if_b_config;
 	enum atomisp_input_format input_format;
 	int err = 0;
@@ -102,7 +85,8 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 		ISP binaries in input_buf.isp.h */
 		if (binary->info->sp.enable.continuous &&
 		    binary->info->sp.pipeline.mode != IA_CSS_BINARY_MODE_COPY)
-			buffer_width = MAX_VECTORS_PER_INPUT_LINE_CONT * ISP_VEC_NELEMS;
+			buffer_width = MAX_VECTORS_PER_INPUT_LINE_CONT *
+				       ISP_VEC_NELEMS;
 		else
 			buffer_width = binary->info->sp.input.max_width;
 		input_format = binary->input_format;
@@ -114,8 +98,8 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 		input_format = config->input_config.format;
 	}
 	two_ppc = config->pixels_per_clock == 2;
-	if (config->mode == IA_CSS_INPUT_MODE_SENSOR
-	    || config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+	if (config->mode == IA_CSS_INPUT_MODE_SENSOR ||
+	    config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
 		port = config->source.port.port;
 		if_config_index = (uint8_t)(port - MIPI_PORT0_ID);
 	} else if (config->mode == IA_CSS_INPUT_MODE_MEMORY) {
@@ -124,8 +108,8 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 		if_config_index = 0;
 	}
 
-	assert(if_config_index <= SH_CSS_MAX_IF_CONFIGS
-	       || if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED);
+	assert(if_config_index <= SH_CSS_MAX_IF_CONFIGS ||
+	       if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED);
 
 	/* TODO: check to see if input is RAW and if current mode interprets
 	 * RAW data in any particular bayer order. copy binary with output
@@ -149,8 +133,8 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 		left_padding = 2 * ISP_VEC_NELEMS - config->left_padding;
 
 	if (left_padding) {
-		num_vectors = CEIL_DIV(cropped_width + left_padding,
-				       ISP_VEC_NELEMS);
+		num_vectors =
+			CEIL_DIV(cropped_width + left_padding, ISP_VEC_NELEMS);
 	} else {
 		num_vectors = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);
 		num_vectors *= buffer_height;
@@ -161,8 +145,8 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 
 	start_column_b = start_column;
 
-	bits_per_pixel = input_formatter_get_alignment(INPUT_FORMATTER0_ID)
-			 * 8 / ISP_VEC_NELEMS;
+	bits_per_pixel = input_formatter_get_alignment(INPUT_FORMATTER0_ID) *
+			 8 / ISP_VEC_NELEMS;
 	switch (input_format) {
 	case ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY:
 		if (two_ppc) {
@@ -181,7 +165,8 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 			vectors_per_line = num_vectors / buffer_height;
 			/* Even lines are half size */
 			line_width = vectors_per_line *
-				     input_formatter_get_alignment(INPUT_FORMATTER0_ID) /
+				     input_formatter_get_alignment(
+					     INPUT_FORMATTER0_ID) /
 				     2;
 			start_column /= 2;
 		} else {
@@ -207,7 +192,8 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 			vectors_per_line = num_vectors / buffer_height;
 			/* Even lines are half size */
 			line_width = vectors_per_line *
-				     input_formatter_get_alignment(INPUT_FORMATTER0_ID) /
+				     input_formatter_get_alignment(
+					     INPUT_FORMATTER0_ID) /
 				     2;
 			start_column *= deinterleaving;
 			start_column /= 2;
@@ -249,14 +235,14 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 	case ATOMISP_INPUT_FORMAT_RGB_888:
 		num_vectors *= 2;
 		if (two_ppc) {
-			deinterleaving = 2;	/* BR in if_a, G in if_b */
-			deinterleaving_b = 1;	/* BR in if_a, G in if_b */
+			deinterleaving = 2; /* BR in if_a, G in if_b */
+			deinterleaving_b = 1; /* BR in if_a, G in if_b */
 			buffers_per_line = 4;
 			start_column_b = start_column;
 			start_column *= deinterleaving;
 			start_column_b *= deinterleaving_b;
 		} else {
-			deinterleaving = 3;	/* BGR */
+			deinterleaving = 3; /* BGR */
 			buffers_per_line = 3;
 			start_column *= deinterleaving;
 		}
@@ -285,15 +271,16 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 			 * output offsets to interleave the bayer pattern in
 			 * the correct order.
 			 */
-			buf_offset_a   = crop_col ? 1 : 0;
-			buf_offset_b   = crop_col ? 0 : 1;
+			buf_offset_a = crop_col ? 1 : 0;
+			buf_offset_b = crop_col ? 0 : 1;
 			start_column_b = start_column / 2;
-			start_column   = start_column / 2 + crop_col;
+			start_column = start_column / 2 + crop_col;
 		} else {
 			vmem_increment = 1;
 			deinterleaving = 2;
-			if ((!binary) || (config->continuous && binary
-					  && binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_COPY)) {
+			if ((!binary) || (config->continuous && binary &&
+					  binary->info->sp.pipeline.mode ==
+						  IA_CSS_BINARY_MODE_COPY)) {
 				/* !binary -> sp raw copy pipe, no deinterleaving */
 				deinterleaving = 1;
 			}
@@ -358,8 +345,8 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 	if (left_padding)
 		vectors_per_line = num_vectors;
 	if (!vectors_per_line) {
-		vectors_per_line = CEIL_MUL(num_vectors / buffer_height,
-					    deinterleaving);
+		vectors_per_line =
+			CEIL_MUL(num_vectors / buffer_height, deinterleaving);
 		line_width = 0;
 	}
 	if (!line_width)
@@ -367,9 +354,9 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 			     input_formatter_get_alignment(INPUT_FORMATTER0_ID);
 	if (!buffers_per_line)
 		buffers_per_line = deinterleaving;
-	line_width = CEIL_MUL(line_width,
-			      input_formatter_get_alignment(INPUT_FORMATTER0_ID)
-			      * vmem_increment);
+	line_width = CEIL_MUL(
+		line_width, input_formatter_get_alignment(INPUT_FORMATTER0_ID) *
+				    vmem_increment);
 
 	vectors_per_buffer = buffer_height * buffer_width / ISP_VEC_NELEMS;
 
@@ -383,11 +370,11 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 	if_a_config.buf_start_index = buf_offset_a;
 	if_a_config.buf_increment = vmem_increment;
 	if_a_config.buf_eol_offset =
-	    buffer_width * bits_per_pixel / 8 - line_width;
+		buffer_width * bits_per_pixel / 8 - line_width;
 	if_a_config.is_yuv420_format =
-	    (input_format == ATOMISP_INPUT_FORMAT_YUV420_8)
-	    || (input_format == ATOMISP_INPUT_FORMAT_YUV420_10)
-	    || (input_format == ATOMISP_INPUT_FORMAT_YUV420_16);
+		(input_format == ATOMISP_INPUT_FORMAT_YUV420_8) ||
+		(input_format == ATOMISP_INPUT_FORMAT_YUV420_10) ||
+		(input_format == ATOMISP_INPUT_FORMAT_YUV420_16);
 	if_a_config.block_no_reqs = (config->mode != IA_CSS_INPUT_MODE_SENSOR);
 
 	if (two_ppc) {
@@ -396,11 +383,12 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 			width_b = cropped_width * deinterleaving;
 			buffer_width *= deinterleaving;
 			/* Patch from bayer to rgb */
-			num_vectors = num_vectors / 2 *
-				      deinterleaving * width_b_factor;
+			num_vectors = num_vectors / 2 * deinterleaving *
+				      width_b_factor;
 			vectors_per_line = num_vectors / buffer_height;
 			line_width = vectors_per_line *
-				     input_formatter_get_alignment(INPUT_FORMATTER0_ID);
+				     input_formatter_get_alignment(
+					     INPUT_FORMATTER0_ID);
 		}
 		if_b_config.start_line = start_line;
 		if_b_config.start_column = start_column_b;
@@ -412,13 +400,13 @@ int ia_css_ifmtr_configure(struct ia_css_stream_config *config,
 		if_b_config.buf_start_index = buf_offset_b;
 		if_b_config.buf_increment = vmem_increment;
 		if_b_config.buf_eol_offset =
-		    buffer_width * bits_per_pixel / 8 - line_width;
+			buffer_width * bits_per_pixel / 8 - line_width;
 		if_b_config.is_yuv420_format =
-		    input_format == ATOMISP_INPUT_FORMAT_YUV420_8
-		    || input_format == ATOMISP_INPUT_FORMAT_YUV420_10
-		    || input_format == ATOMISP_INPUT_FORMAT_YUV420_16;
+			input_format == ATOMISP_INPUT_FORMAT_YUV420_8 ||
+			input_format == ATOMISP_INPUT_FORMAT_YUV420_10 ||
+			input_format == ATOMISP_INPUT_FORMAT_YUV420_16;
 		if_b_config.block_no_reqs =
-		    (config->mode != IA_CSS_INPUT_MODE_SENSOR);
+			(config->mode != IA_CSS_INPUT_MODE_SENSOR);
 
 		if (if_config_index != SH_CSS_IF_CONFIG_NOT_NEEDED) {
 			assert(if_config_index <= SH_CSS_MAX_IF_CONFIGS);
@@ -447,9 +435,9 @@ bool ifmtr_set_if_blocking_mode_reset = true;
 /************************************************************
  * Static functions
  ************************************************************/
-static void ifmtr_set_if_blocking_mode(
-    const input_formatter_cfg_t *const config_a,
-    const input_formatter_cfg_t *const config_b)
+static void
+ifmtr_set_if_blocking_mode(const input_formatter_cfg_t *const config_a,
+			   const input_formatter_cfg_t *const config_b)
 {
 	int i;
 	bool block[] = { false, false, false, false };
@@ -476,13 +464,12 @@ static void ifmtr_set_if_blocking_mode(
 	return;
 }
 
-static int ifmtr_start_column(
-    const struct ia_css_stream_config *config,
-    unsigned int bin_in,
-    unsigned int *start_column)
+static int ifmtr_start_column(const struct ia_css_stream_config *config,
+			      unsigned int bin_in, unsigned int *start_column)
 {
 	unsigned int in = config->input_config.input_res.width, start,
-		     for_bayer = ia_css_ifmtr_columns_needed_for_bayer_order(config);
+		     for_bayer = ia_css_ifmtr_columns_needed_for_bayer_order(
+			     config);
 
 	if (bin_in + 2 * for_bayer > in)
 		return -EINVAL;
@@ -502,13 +489,12 @@ static int ifmtr_start_column(
 	return 0;
 }
 
-static int ifmtr_input_start_line(
-    const struct ia_css_stream_config *config,
-    unsigned int bin_in,
-    unsigned int *start_line)
+static int ifmtr_input_start_line(const struct ia_css_stream_config *config,
+				  unsigned int bin_in, unsigned int *start_line)
 {
 	unsigned int in = config->input_config.input_res.height, start,
-		     for_bayer = ia_css_ifmtr_lines_needed_for_bayer_order(config);
+		     for_bayer =
+			     ia_css_ifmtr_lines_needed_for_bayer_order(config);
 
 	if (bin_in + 2 * for_bayer > in)
 		return -EINVAL;
@@ -528,4 +514,3 @@ static int ifmtr_input_start_line(
 	*start_line = start;
 	return 0;
 }
-
diff --git a/drivers/staging/media/atomisp/pci/runtime/inputfifo/interface/ia_css_inputfifo.h b/drivers/staging/media/atomisp/pci/runtime/inputfifo/interface/ia_css_inputfifo.h
index a95c3098c82ab1694713f94bfe6754e1fc87dc75..0659e8d3df05de98788a8a3d45b4dfd588bf4ea4 100644
--- a/drivers/staging/media/atomisp/pci/runtime/inputfifo/interface/ia_css_inputfifo.h
+++ b/drivers/staging/media/atomisp/pci/runtime/inputfifo/interface/ia_css_inputfifo.h
@@ -13,33 +13,25 @@
 #include "ia_css_stream_format.h"
 
 /* SP access */
-void ia_css_inputfifo_send_input_frame(
-    const unsigned short	*data,
-    unsigned int	width,
-    unsigned int	height,
-    unsigned int	ch_id,
-    enum atomisp_input_format	input_format,
-    bool			two_ppc);
-
-void ia_css_inputfifo_start_frame(
-    unsigned int	ch_id,
-    enum atomisp_input_format	input_format,
-    bool			two_ppc);
-
-void ia_css_inputfifo_send_line(
-    unsigned int	ch_id,
-    const unsigned short	*data,
-    unsigned int	width,
-    const unsigned short	*data2,
-    unsigned int	width2);
-
-void ia_css_inputfifo_send_embedded_line(
-    unsigned int	ch_id,
-    enum atomisp_input_format	data_type,
-    const unsigned short	*data,
-    unsigned int	width);
-
-void ia_css_inputfifo_end_frame(
-    unsigned int	ch_id);
+void ia_css_inputfifo_send_input_frame(const unsigned short *data,
+				       unsigned int width, unsigned int height,
+				       unsigned int ch_id,
+				       enum atomisp_input_format input_format,
+				       bool two_ppc);
+
+void ia_css_inputfifo_start_frame(unsigned int ch_id,
+				  enum atomisp_input_format input_format,
+				  bool two_ppc);
+
+void ia_css_inputfifo_send_line(unsigned int ch_id, const unsigned short *data,
+				unsigned int width, const unsigned short *data2,
+				unsigned int width2);
+
+void ia_css_inputfifo_send_embedded_line(unsigned int ch_id,
+					 enum atomisp_input_format data_type,
+					 const unsigned short *data,
+					 unsigned int width);
+
+void ia_css_inputfifo_end_frame(unsigned int ch_id);
 
 #endif /* _IA_CSS_INPUTFIFO_H */
diff --git a/drivers/staging/media/atomisp/pci/runtime/inputfifo/src/inputfifo.c b/drivers/staging/media/atomisp/pci/runtime/inputfifo/src/inputfifo.c
index 8e1efeb6372c00f0fcdfcfdc14e7f1d029ea1ae2..7d193a62ea446172ab8f3d0e968499f6b57cc6c9 100644
--- a/drivers/staging/media/atomisp/pci/runtime/inputfifo/src/inputfifo.c
+++ b/drivers/staging/media/atomisp/pci/runtime/inputfifo/src/inputfifo.c
@@ -23,7 +23,7 @@
 #include "event_fifo.h"
 #define __INLINE_SP__
 
-#include "input_system.h"	/* MIPI_PREDICTOR_NONE,... */
+#include "input_system.h" /* MIPI_PREDICTOR_NONE,... */
 
 #include "assert_support.h"
 
@@ -54,36 +54,34 @@ enum inputfifo_mipi_data_type {
 
 static unsigned int inputfifo_curr_ch_id, inputfifo_curr_fmt_type;
 struct inputfifo_instance {
-	unsigned int				ch_id;
-	enum atomisp_input_format	input_format;
-	bool						two_ppc;
-	bool						streaming;
-	unsigned int				hblank_cycles;
-	unsigned int				marker_cycles;
-	unsigned int				fmt_type;
-	enum inputfifo_mipi_data_type	type;
+	unsigned int ch_id;
+	enum atomisp_input_format input_format;
+	bool two_ppc;
+	bool streaming;
+	unsigned int hblank_cycles;
+	unsigned int marker_cycles;
+	unsigned int fmt_type;
+	enum inputfifo_mipi_data_type type;
 };
 
 /*
  * Maintain a basic streaming to Mipi administration with ch_id as index
  * ch_id maps on the "Mipi virtual channel ID" and can have value 0..3
  */
-#define INPUTFIFO_NR_OF_S2M_CHANNELS	(4)
+#define INPUTFIFO_NR_OF_S2M_CHANNELS (4)
 static struct inputfifo_instance
 	inputfifo_inst_admin[INPUTFIFO_NR_OF_S2M_CHANNELS];
 
 /* Streaming to MIPI */
 static unsigned int inputfifo_wrap_marker(
-    /* static inline unsigned inputfifo_wrap_marker( */
-    unsigned int marker)
+	/* static inline unsigned inputfifo_wrap_marker( */
+	unsigned int marker)
 {
-	return marker |
-	       (inputfifo_curr_ch_id << HIVE_STR_TO_MIPI_CH_ID_LSB) |
+	return marker | (inputfifo_curr_ch_id << HIVE_STR_TO_MIPI_CH_ID_LSB) |
 	       (inputfifo_curr_fmt_type << _HIVE_STR_TO_MIPI_FMT_TYPE_LSB);
 }
 
-static inline void
-_sh_css_fifo_snd(unsigned int token)
+static inline void _sh_css_fifo_snd(unsigned int token)
 {
 	while (!can_event_send_token(STR2MIPI_EVENT_ID))
 		udelay(1);
@@ -92,8 +90,8 @@ _sh_css_fifo_snd(unsigned int token)
 }
 
 static void inputfifo_send_data_a(
-    /* static inline void inputfifo_send_data_a( */
-    unsigned int data)
+	/* static inline void inputfifo_send_data_a( */
+	unsigned int data)
 {
 	unsigned int token = (1 << HIVE_STR_TO_MIPI_VALID_A_BIT) |
 			     (data << HIVE_STR_TO_MIPI_DATA_A_LSB);
@@ -102,8 +100,8 @@ static void inputfifo_send_data_a(
 }
 
 static void inputfifo_send_data_b(
-    /* static inline void inputfifo_send_data_b( */
-    unsigned int data)
+	/* static inline void inputfifo_send_data_b( */
+	unsigned int data)
 {
 	unsigned int token = (1 << HIVE_STR_TO_MIPI_VALID_B_BIT) |
 			     (data << _HIVE_STR_TO_MIPI_DATA_B_LSB);
@@ -112,9 +110,8 @@ static void inputfifo_send_data_b(
 }
 
 static void inputfifo_send_data(
-    /* static inline void inputfifo_send_data( */
-    unsigned int a,
-    unsigned int b)
+	/* static inline void inputfifo_send_data( */
+	unsigned int a, unsigned int b)
 {
 	unsigned int token = ((1 << HIVE_STR_TO_MIPI_VALID_A_BIT) |
 			      (1 << HIVE_STR_TO_MIPI_VALID_B_BIT) |
@@ -127,8 +124,7 @@ static void inputfifo_send_data(
 static void inputfifo_send_sol(void)
 /* static inline void inputfifo_send_sol(void) */
 {
-	hrt_data	token = inputfifo_wrap_marker(
-				1 << HIVE_STR_TO_MIPI_SOL_BIT);
+	hrt_data token = inputfifo_wrap_marker(1 << HIVE_STR_TO_MIPI_SOL_BIT);
 
 	_sh_css_fifo_snd(token);
 	return;
@@ -137,8 +133,7 @@ static void inputfifo_send_sol(void)
 static void inputfifo_send_eol(void)
 /* static inline void inputfifo_send_eol(void) */
 {
-	hrt_data	token = inputfifo_wrap_marker(
-				1 << HIVE_STR_TO_MIPI_EOL_BIT);
+	hrt_data token = inputfifo_wrap_marker(1 << HIVE_STR_TO_MIPI_EOL_BIT);
 	_sh_css_fifo_snd(token);
 	return;
 }
@@ -146,8 +141,7 @@ static void inputfifo_send_eol(void)
 static void inputfifo_send_sof(void)
 /* static inline void inputfifo_send_sof(void) */
 {
-	hrt_data	token = inputfifo_wrap_marker(
-				1 << HIVE_STR_TO_MIPI_SOF_BIT);
+	hrt_data token = inputfifo_wrap_marker(1 << HIVE_STR_TO_MIPI_SOF_BIT);
 
 	_sh_css_fifo_snd(token);
 	return;
@@ -156,19 +150,17 @@ static void inputfifo_send_sof(void)
 static void inputfifo_send_eof(void)
 /* static inline void inputfifo_send_eof(void) */
 {
-	hrt_data	token = inputfifo_wrap_marker(
-				1 << HIVE_STR_TO_MIPI_EOF_BIT);
+	hrt_data token = inputfifo_wrap_marker(1 << HIVE_STR_TO_MIPI_EOF_BIT);
 	_sh_css_fifo_snd(token);
 	return;
 }
 
 static void inputfifo_send_ch_id_and_fmt_type(
-    /* static inline
+	/* static inline
     void inputfifo_send_ch_id_and_fmt_type( */
-    unsigned int ch_id,
-    unsigned int fmt_type)
+	unsigned int ch_id, unsigned int fmt_type)
 {
-	hrt_data	token;
+	hrt_data token;
 
 	inputfifo_curr_ch_id = ch_id & _HIVE_ISP_CH_ID_MASK;
 	inputfifo_curr_fmt_type = fmt_type & _HIVE_ISP_FMT_TYPE_MASK;
@@ -183,24 +175,22 @@ static void inputfifo_send_ch_id_and_fmt_type(
 static void inputfifo_send_empty_token(void)
 /* static inline void inputfifo_send_empty_token(void) */
 {
-	hrt_data	token = inputfifo_wrap_marker(0);
+	hrt_data token = inputfifo_wrap_marker(0);
 
 	_sh_css_fifo_snd(token);
 	return;
 }
 
 static void inputfifo_start_frame(
-    /* static inline void inputfifo_start_frame( */
-    unsigned int ch_id,
-    unsigned int fmt_type)
+	/* static inline void inputfifo_start_frame( */
+	unsigned int ch_id, unsigned int fmt_type)
 {
 	inputfifo_send_ch_id_and_fmt_type(ch_id, fmt_type);
 	inputfifo_send_sof();
 	return;
 }
 
-static void inputfifo_end_frame(
-    unsigned int marker_cycles)
+static void inputfifo_end_frame(unsigned int marker_cycles)
 {
 	unsigned int i;
 
@@ -210,15 +200,11 @@ static void inputfifo_end_frame(
 	return;
 }
 
-static void inputfifo_send_line2(
-    const unsigned short *data,
-    unsigned int width,
-    const unsigned short *data2,
-    unsigned int width2,
-    unsigned int hblank_cycles,
-    unsigned int marker_cycles,
-    unsigned int two_ppc,
-    enum inputfifo_mipi_data_type type)
+static void
+inputfifo_send_line2(const unsigned short *data, unsigned int width,
+		     const unsigned short *data2, unsigned int width2,
+		     unsigned int hblank_cycles, unsigned int marker_cycles,
+		     unsigned int two_ppc, enum inputfifo_mipi_data_type type)
 {
 	unsigned int i, is_rgb = 0, is_legacy = 0;
 
@@ -249,11 +235,9 @@ static void inputfifo_send_line2(
 				/* for jpg (binary) copy, this can occur
 				 * if the file contains an odd number of bytes.
 				 */
-				inputfifo_send_data(
-				    data[0], 0);
+				inputfifo_send_data(data[0], 0);
 			} else {
-				inputfifo_send_data(
-				    data[0], data[1]);
+				inputfifo_send_data(data[0], data[1]);
 			}
 			/* Additional increment because we send 2 pixels */
 			data++;
@@ -279,11 +263,9 @@ static void inputfifo_send_line2(
 				/* for jpg (binary) copy, this can occur
 				 * if the file contains an odd number of bytes.
 				 */
-				inputfifo_send_data(
-				    data2[0], 0);
+				inputfifo_send_data(data2[0], 0);
 			} else {
-				inputfifo_send_data(
-				    data2[0], data2[1]);
+				inputfifo_send_data(data2[0], data2[1]);
 			}
 			/* Additional increment because we send 2 pixels */
 			data2++;
@@ -300,20 +282,15 @@ static void inputfifo_send_line2(
 	return;
 }
 
-static void
-inputfifo_send_line(const unsigned short *data,
-		    unsigned int width,
-		    unsigned int hblank_cycles,
-		    unsigned int marker_cycles,
-		    unsigned int two_ppc,
-		    enum inputfifo_mipi_data_type type)
+static void inputfifo_send_line(const unsigned short *data, unsigned int width,
+				unsigned int hblank_cycles,
+				unsigned int marker_cycles,
+				unsigned int two_ppc,
+				enum inputfifo_mipi_data_type type)
 {
 	assert(data);
-	inputfifo_send_line2(data, width, NULL, 0,
-			     hblank_cycles,
-			     marker_cycles,
-			     two_ppc,
-			     type);
+	inputfifo_send_line2(data, width, NULL, 0, hblank_cycles, marker_cycles,
+			     two_ppc, type);
 }
 
 /* Send a frame of data into the input network via the GP FIFO.
@@ -344,16 +321,13 @@ inputfifo_send_line(const unsigned short *data,
  * documentation for details on the data formats.
  */
 
-static void inputfifo_send_frame(
-    const unsigned short *data,
-    unsigned int width,
-    unsigned int height,
-    unsigned int ch_id,
-    unsigned int fmt_type,
-    unsigned int hblank_cycles,
-    unsigned int marker_cycles,
-    unsigned int two_ppc,
-    enum inputfifo_mipi_data_type type)
+static void inputfifo_send_frame(const unsigned short *data, unsigned int width,
+				 unsigned int height, unsigned int ch_id,
+				 unsigned int fmt_type,
+				 unsigned int hblank_cycles,
+				 unsigned int marker_cycles,
+				 unsigned int two_ppc,
+				 enum inputfifo_mipi_data_type type)
 {
 	unsigned int i;
 
@@ -361,18 +335,13 @@ static void inputfifo_send_frame(
 	inputfifo_start_frame(ch_id, fmt_type);
 
 	for (i = 0; i < height; i++) {
-		if ((type == inputfifo_mipi_data_type_yuv420) &&
-		    (i & 1) == 1) {
-			inputfifo_send_line(data, 2 * width,
-					    hblank_cycles,
-					    marker_cycles,
-					    two_ppc, type);
+		if ((type == inputfifo_mipi_data_type_yuv420) && (i & 1) == 1) {
+			inputfifo_send_line(data, 2 * width, hblank_cycles,
+					    marker_cycles, two_ppc, type);
 			data += 2 * width;
 		} else {
-			inputfifo_send_line(data, width,
-					    hblank_cycles,
-					    marker_cycles,
-					    two_ppc, type);
+			inputfifo_send_line(data, width, hblank_cycles,
+					    marker_cycles, two_ppc, type);
 			data += width;
 		}
 	}
@@ -380,41 +349,35 @@ static void inputfifo_send_frame(
 	return;
 }
 
-static enum inputfifo_mipi_data_type inputfifo_determine_type(
-    enum atomisp_input_format input_format)
+static enum inputfifo_mipi_data_type
+inputfifo_determine_type(enum atomisp_input_format input_format)
 {
 	enum inputfifo_mipi_data_type type;
 
 	type = inputfifo_mipi_data_type_regular;
 	if (input_format == ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY) {
-		type =
-		    inputfifo_mipi_data_type_yuv420_legacy;
-	} else if (input_format == ATOMISP_INPUT_FORMAT_YUV420_8  ||
+		type = inputfifo_mipi_data_type_yuv420_legacy;
+	} else if (input_format == ATOMISP_INPUT_FORMAT_YUV420_8 ||
 		   input_format == ATOMISP_INPUT_FORMAT_YUV420_10 ||
 		   input_format == ATOMISP_INPUT_FORMAT_YUV420_16) {
-		type =
-		    inputfifo_mipi_data_type_yuv420;
+		type = inputfifo_mipi_data_type_yuv420;
 	} else if (input_format >= ATOMISP_INPUT_FORMAT_RGB_444 &&
 		   input_format <= ATOMISP_INPUT_FORMAT_RGB_888) {
-		type =
-		    inputfifo_mipi_data_type_rgb;
+		type = inputfifo_mipi_data_type_rgb;
 	}
 	return type;
 }
 
-static struct inputfifo_instance *inputfifo_get_inst(
-    unsigned int ch_id)
+static struct inputfifo_instance *inputfifo_get_inst(unsigned int ch_id)
 {
 	return &inputfifo_inst_admin[ch_id];
 }
 
-void ia_css_inputfifo_send_input_frame(
-    const unsigned short *data,
-    unsigned int width,
-    unsigned int height,
-    unsigned int ch_id,
-    enum atomisp_input_format input_format,
-    bool two_ppc)
+void ia_css_inputfifo_send_input_frame(const unsigned short *data,
+				       unsigned int width, unsigned int height,
+				       unsigned int ch_id,
+				       enum atomisp_input_format input_format,
+				       bool two_ppc)
 {
 	unsigned int fmt_type, hblank_cycles, marker_cycles;
 	enum inputfifo_mipi_data_type type;
@@ -422,30 +385,26 @@ void ia_css_inputfifo_send_input_frame(
 	assert(data);
 	hblank_cycles = HBLANK_CYCLES;
 	marker_cycles = MARKER_CYCLES;
-	ia_css_isys_convert_stream_format_to_mipi_format(input_format,
-		MIPI_PREDICTOR_NONE,
-		&fmt_type);
+	ia_css_isys_convert_stream_format_to_mipi_format(
+		input_format, MIPI_PREDICTOR_NONE, &fmt_type);
 
 	type = inputfifo_determine_type(input_format);
 
-	inputfifo_send_frame(data, width, height,
-			     ch_id, fmt_type, hblank_cycles, marker_cycles,
-			     two_ppc, type);
+	inputfifo_send_frame(data, width, height, ch_id, fmt_type,
+			     hblank_cycles, marker_cycles, two_ppc, type);
 }
 
-void ia_css_inputfifo_start_frame(
-    unsigned int ch_id,
-    enum atomisp_input_format input_format,
-    bool two_ppc)
+void ia_css_inputfifo_start_frame(unsigned int ch_id,
+				  enum atomisp_input_format input_format,
+				  bool two_ppc)
 {
 	struct inputfifo_instance *s2mi;
 
 	s2mi = inputfifo_get_inst(ch_id);
 
 	s2mi->ch_id = ch_id;
-	ia_css_isys_convert_stream_format_to_mipi_format(input_format,
-		MIPI_PREDICTOR_NONE,
-		&s2mi->fmt_type);
+	ia_css_isys_convert_stream_format_to_mipi_format(
+		input_format, MIPI_PREDICTOR_NONE, &s2mi->fmt_type);
 	s2mi->two_ppc = two_ppc;
 	s2mi->type = inputfifo_determine_type(input_format);
 	s2mi->hblank_cycles = HBLANK_CYCLES;
@@ -456,12 +415,9 @@ void ia_css_inputfifo_start_frame(
 	return;
 }
 
-void ia_css_inputfifo_send_line(
-    unsigned int ch_id,
-    const unsigned short *data,
-    unsigned int width,
-    const unsigned short *data2,
-    unsigned int width2)
+void ia_css_inputfifo_send_line(unsigned int ch_id, const unsigned short *data,
+				unsigned int width, const unsigned short *data2,
+				unsigned int width2)
 {
 	struct inputfifo_instance *s2mi;
 
@@ -473,36 +429,32 @@ void ia_css_inputfifo_send_line(
 	inputfifo_curr_ch_id = (s2mi->ch_id) & _HIVE_ISP_CH_ID_MASK;
 	inputfifo_curr_fmt_type = (s2mi->fmt_type) & _HIVE_ISP_FMT_TYPE_MASK;
 
-	inputfifo_send_line2(data, width, data2, width2,
-			     s2mi->hblank_cycles,
-			     s2mi->marker_cycles,
-			     s2mi->two_ppc,
-			     s2mi->type);
+	inputfifo_send_line2(data, width, data2, width2, s2mi->hblank_cycles,
+			     s2mi->marker_cycles, s2mi->two_ppc, s2mi->type);
 }
 
-void ia_css_inputfifo_send_embedded_line(
-    unsigned int	ch_id,
-    enum atomisp_input_format	data_type,
-    const unsigned short	*data,
-    unsigned int	width)
+void ia_css_inputfifo_send_embedded_line(unsigned int ch_id,
+					 enum atomisp_input_format data_type,
+					 const unsigned short *data,
+					 unsigned int width)
 {
 	struct inputfifo_instance *s2mi;
 	unsigned int fmt_type;
 
 	assert(data);
 	s2mi = inputfifo_get_inst(ch_id);
-	ia_css_isys_convert_stream_format_to_mipi_format(data_type,
-		MIPI_PREDICTOR_NONE, &fmt_type);
+	ia_css_isys_convert_stream_format_to_mipi_format(
+		data_type, MIPI_PREDICTOR_NONE, &fmt_type);
 
 	/* Set format_type for metadata line. */
 	inputfifo_curr_fmt_type = fmt_type & _HIVE_ISP_FMT_TYPE_MASK;
 
-	inputfifo_send_line(data, width, s2mi->hblank_cycles, s2mi->marker_cycles,
-			    s2mi->two_ppc, inputfifo_mipi_data_type_regular);
+	inputfifo_send_line(data, width, s2mi->hblank_cycles,
+			    s2mi->marker_cycles, s2mi->two_ppc,
+			    inputfifo_mipi_data_type_regular);
 }
 
-void ia_css_inputfifo_end_frame(
-    unsigned int	ch_id)
+void ia_css_inputfifo_end_frame(unsigned int ch_id)
 {
 	struct inputfifo_instance *s2mi;
 
diff --git a/drivers/staging/media/atomisp/pci/runtime/isp_param/interface/ia_css_isp_param.h b/drivers/staging/media/atomisp/pci/runtime/isp_param/interface/ia_css_isp_param.h
index ff9050fede105937338109779dd5b7461d10d28b..03ceba0ec00376be3e1c1cf42f117884435e081a 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isp_param/interface/ia_css_isp_param.h
+++ b/drivers/staging/media/atomisp/pci/runtime/isp_param/interface/ia_css_isp_param.h
@@ -11,84 +11,65 @@
 #include "ia_css_isp_param_types.h"
 
 /* Set functions for parameter memory descriptors */
-void
-ia_css_isp_param_set_mem_init(
-    struct ia_css_isp_param_host_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem,
-    char *address, size_t size);
+void ia_css_isp_param_set_mem_init(
+	struct ia_css_isp_param_host_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem,
+	char *address, size_t size);
 
-void
-ia_css_isp_param_set_css_mem_init(
-    struct ia_css_isp_param_css_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem,
-    ia_css_ptr address, size_t size);
+void ia_css_isp_param_set_css_mem_init(
+	struct ia_css_isp_param_css_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem,
+	ia_css_ptr address, size_t size);
 
-void
-ia_css_isp_param_set_isp_mem_init(
-    struct ia_css_isp_param_isp_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem,
-    u32 address, size_t size);
+void ia_css_isp_param_set_isp_mem_init(
+	struct ia_css_isp_param_isp_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem,
+	u32 address, size_t size);
 
 /* Get functions for parameter memory descriptors */
-const struct ia_css_host_data *
-ia_css_isp_param_get_mem_init(
-    const struct ia_css_isp_param_host_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem);
+const struct ia_css_host_data *ia_css_isp_param_get_mem_init(
+	const struct ia_css_isp_param_host_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem);
 
-const struct ia_css_data *
-ia_css_isp_param_get_css_mem_init(
-    const struct ia_css_isp_param_css_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem);
+const struct ia_css_data *ia_css_isp_param_get_css_mem_init(
+	const struct ia_css_isp_param_css_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem);
 
-const struct ia_css_isp_data *
-ia_css_isp_param_get_isp_mem_init(
-    const struct ia_css_isp_param_isp_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem);
+const struct ia_css_isp_data *ia_css_isp_param_get_isp_mem_init(
+	const struct ia_css_isp_param_isp_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem);
 
 /* Initialize the memory interface sizes and addresses */
-void
-ia_css_init_memory_interface(
-    struct ia_css_isp_param_css_segments *isp_mem_if,
-    const struct ia_css_isp_param_host_segments *mem_params,
-    const struct ia_css_isp_param_css_segments *css_params);
+void ia_css_init_memory_interface(
+	struct ia_css_isp_param_css_segments *isp_mem_if,
+	const struct ia_css_isp_param_host_segments *mem_params,
+	const struct ia_css_isp_param_css_segments *css_params);
 
 /* Allocate memory parameters */
-int
-ia_css_isp_param_allocate_isp_parameters(
-    struct ia_css_isp_param_host_segments *mem_params,
-    struct ia_css_isp_param_css_segments *css_params,
-    const struct ia_css_isp_param_isp_segments *mem_initializers);
+int ia_css_isp_param_allocate_isp_parameters(
+	struct ia_css_isp_param_host_segments *mem_params,
+	struct ia_css_isp_param_css_segments *css_params,
+	const struct ia_css_isp_param_isp_segments *mem_initializers);
 
 /* Destroy memory parameters */
-void
-ia_css_isp_param_destroy_isp_parameters(
-    struct ia_css_isp_param_host_segments *mem_params,
-    struct ia_css_isp_param_css_segments *css_params);
+void ia_css_isp_param_destroy_isp_parameters(
+	struct ia_css_isp_param_host_segments *mem_params,
+	struct ia_css_isp_param_css_segments *css_params);
 
 /* Load fw parameters */
-void
-ia_css_isp_param_load_fw_params(
-    const char *fw,
-    union ia_css_all_memory_offsets *mem_offsets,
-    const struct ia_css_isp_param_memory_offsets *memory_offsets,
-    bool init);
+void ia_css_isp_param_load_fw_params(
+	const char *fw, union ia_css_all_memory_offsets *mem_offsets,
+	const struct ia_css_isp_param_memory_offsets *memory_offsets,
+	bool init);
 
 /* Copy host parameter images to ddr */
-int
-ia_css_isp_param_copy_isp_mem_if_to_ddr(
-    struct ia_css_isp_param_css_segments *ddr,
-    const struct ia_css_isp_param_host_segments *host,
-    enum ia_css_param_class pclass);
+int ia_css_isp_param_copy_isp_mem_if_to_ddr(
+	struct ia_css_isp_param_css_segments *ddr,
+	const struct ia_css_isp_param_host_segments *host,
+	enum ia_css_param_class pclass);
 
 /* Enable a pipeline by setting the control field in the isp dmem parameters */
-void
-ia_css_isp_param_enable_pipeline(
-    const struct ia_css_isp_param_host_segments *mem_params);
+void ia_css_isp_param_enable_pipeline(
+	const struct ia_css_isp_param_host_segments *mem_params);
 
 #endif /* _IA_CSS_ISP_PARAM_H_ */
diff --git a/drivers/staging/media/atomisp/pci/runtime/isp_param/interface/ia_css_isp_param_types.h b/drivers/staging/media/atomisp/pci/runtime/isp_param/interface/ia_css_isp_param_types.h
index d6d60508c1bf0cdc4990effba0d54689115b2e49..5149f06c8485db08cf01b1dc9b2b952ced0d0b63 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isp_param/interface/ia_css_isp_param_types.h
+++ b/drivers/staging/media/atomisp/pci/runtime/isp_param/interface/ia_css_isp_param_types.h
@@ -21,9 +21,11 @@ Copyright (c) 2010 - 2015, Intel Corporation.
 
 /* Explicit member numbering to avoid fish type checker bug */
 enum ia_css_param_class {
-	IA_CSS_PARAM_CLASS_PARAM  = 0,	/* Late binding parameters, like 3A */
-	IA_CSS_PARAM_CLASS_CONFIG = 1,	/* Pipe config time parameters, like resolution */
-	IA_CSS_PARAM_CLASS_STATE  = 2,  /* State parameters, like tnr buffer index */
+	IA_CSS_PARAM_CLASS_PARAM = 0, /* Late binding parameters, like 3A */
+	IA_CSS_PARAM_CLASS_CONFIG =
+		1, /* Pipe config time parameters, like resolution */
+	IA_CSS_PARAM_CLASS_STATE =
+		2, /* State parameters, like tnr buffer index */
 #if 0 /* Not yet implemented */
 	IA_CSS_PARAM_CLASS_FRAME  = 3,  /* Frame time parameters, like output buffer */
 #endif
@@ -34,27 +36,29 @@ enum ia_css_param_class {
 /* ISP parameter descriptor */
 struct ia_css_isp_parameter {
 	u32 offset; /* Offset in isp_<mem>)parameters, etc. */
-	u32 size;   /* Disabled if 0 */
+	u32 size; /* Disabled if 0 */
 };
 
 /* Address/size of each parameter class in each isp memory, host memory pointers */
 struct ia_css_isp_param_host_segments {
-	struct ia_css_host_data params[IA_CSS_NUM_PARAM_CLASSES][IA_CSS_NUM_MEMORIES];
+	struct ia_css_host_data params[IA_CSS_NUM_PARAM_CLASSES]
+				      [IA_CSS_NUM_MEMORIES];
 };
 
 /* Address/size of each parameter class in each isp memory, css memory pointers */
 struct ia_css_isp_param_css_segments {
-	struct ia_css_data      params[IA_CSS_NUM_PARAM_CLASSES][IA_CSS_NUM_MEMORIES];
+	struct ia_css_data params[IA_CSS_NUM_PARAM_CLASSES][IA_CSS_NUM_MEMORIES];
 };
 
 /* Address/size of each parameter class in each isp memory, isp memory pointers */
 struct ia_css_isp_param_isp_segments {
-	struct ia_css_isp_data  params[IA_CSS_NUM_PARAM_CLASSES][IA_CSS_NUM_MEMORIES];
+	struct ia_css_isp_data params[IA_CSS_NUM_PARAM_CLASSES]
+				     [IA_CSS_NUM_MEMORIES];
 };
 
 /* Memory offsets in binary info */
 struct ia_css_isp_param_memory_offsets {
-	u32 offsets[IA_CSS_NUM_PARAM_CLASSES];  /** offset wrt hdr in bytes */
+	u32 offsets[IA_CSS_NUM_PARAM_CLASSES]; /** offset wrt hdr in bytes */
 };
 
 /* Offsets for ISP kernel parameters per isp memory.
@@ -62,9 +66,9 @@ struct ia_css_isp_param_memory_offsets {
  */
 union ia_css_all_memory_offsets {
 	struct {
-		CSS_ALIGN(struct ia_css_memory_offsets	      *param, 8);
+		CSS_ALIGN(struct ia_css_memory_offsets *param, 8);
 		CSS_ALIGN(struct ia_css_config_memory_offsets *config, 8);
-		CSS_ALIGN(struct ia_css_state_memory_offsets  *state, 8);
+		CSS_ALIGN(struct ia_css_state_memory_offsets *state, 8);
 	} offsets;
 	struct {
 		CSS_ALIGN(void *ptr, 8);
diff --git a/drivers/staging/media/atomisp/pci/runtime/isp_param/src/isp_param.c b/drivers/staging/media/atomisp/pci/runtime/isp_param/src/isp_param.c
index 251dd75a761356f3da712072ba884ed951e8f45a..44988fd43b6bef2306a0a9808868ed0f26a385af 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isp_param/src/isp_param.c
+++ b/drivers/staging/media/atomisp/pci/runtime/isp_param/src/isp_param.c
@@ -11,119 +11,109 @@
 
 /* Set functions for parameter memory descriptors */
 
-void
-ia_css_isp_param_set_mem_init(
-    struct ia_css_isp_param_host_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem,
-    char *address, size_t size)
+void ia_css_isp_param_set_mem_init(
+	struct ia_css_isp_param_host_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem,
+	char *address, size_t size)
 {
 	mem_init->params[pclass][mem].address = address;
 	mem_init->params[pclass][mem].size = (uint32_t)size;
 }
 
-void
-ia_css_isp_param_set_css_mem_init(
-    struct ia_css_isp_param_css_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem,
-    ia_css_ptr address, size_t size)
+void ia_css_isp_param_set_css_mem_init(
+	struct ia_css_isp_param_css_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem,
+	ia_css_ptr address, size_t size)
 {
 	mem_init->params[pclass][mem].address = address;
 	mem_init->params[pclass][mem].size = (uint32_t)size;
 }
 
-void
-ia_css_isp_param_set_isp_mem_init(
-    struct ia_css_isp_param_isp_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem,
-    u32 address, size_t size)
+void ia_css_isp_param_set_isp_mem_init(
+	struct ia_css_isp_param_isp_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem,
+	u32 address, size_t size)
 {
 	mem_init->params[pclass][mem].address = address;
 	mem_init->params[pclass][mem].size = (uint32_t)size;
 }
 
 /* Get functions for parameter memory descriptors */
-const struct ia_css_host_data *
-ia_css_isp_param_get_mem_init(
-    const struct ia_css_isp_param_host_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem)
+const struct ia_css_host_data *ia_css_isp_param_get_mem_init(
+	const struct ia_css_isp_param_host_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem)
 {
 	return &mem_init->params[pclass][mem];
 }
 
-const struct ia_css_data *
-ia_css_isp_param_get_css_mem_init(
-    const struct ia_css_isp_param_css_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem)
+const struct ia_css_data *ia_css_isp_param_get_css_mem_init(
+	const struct ia_css_isp_param_css_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem)
 {
 	return &mem_init->params[pclass][mem];
 }
 
-const struct ia_css_isp_data *
-ia_css_isp_param_get_isp_mem_init(
-    const struct ia_css_isp_param_isp_segments *mem_init,
-    enum ia_css_param_class pclass,
-    enum ia_css_isp_memories mem)
+const struct ia_css_isp_data *ia_css_isp_param_get_isp_mem_init(
+	const struct ia_css_isp_param_isp_segments *mem_init,
+	enum ia_css_param_class pclass, enum ia_css_isp_memories mem)
 {
 	return &mem_init->params[pclass][mem];
 }
 
-void
-ia_css_init_memory_interface(
-    struct ia_css_isp_param_css_segments *isp_mem_if,
-    const struct ia_css_isp_param_host_segments *mem_params,
-    const struct ia_css_isp_param_css_segments *css_params)
+void ia_css_init_memory_interface(
+	struct ia_css_isp_param_css_segments *isp_mem_if,
+	const struct ia_css_isp_param_host_segments *mem_params,
+	const struct ia_css_isp_param_css_segments *css_params)
 {
 	unsigned int pclass, mem;
 
 	for (pclass = 0; pclass < IA_CSS_NUM_PARAM_CLASSES; pclass++) {
-		memset(isp_mem_if->params[pclass], 0, sizeof(isp_mem_if->params[pclass]));
+		memset(isp_mem_if->params[pclass], 0,
+		       sizeof(isp_mem_if->params[pclass]));
 		for (mem = 0; mem < IA_CSS_NUM_MEMORIES; mem++) {
 			if (!mem_params->params[pclass][mem].address)
 				continue;
-			isp_mem_if->params[pclass][mem].size = mem_params->params[pclass][mem].size;
+			isp_mem_if->params[pclass][mem].size =
+				mem_params->params[pclass][mem].size;
 			if (pclass != IA_CSS_PARAM_CLASS_PARAM)
 				isp_mem_if->params[pclass][mem].address =
-				    css_params->params[pclass][mem].address;
+					css_params->params[pclass][mem].address;
 		}
 	}
 }
 
-int
-ia_css_isp_param_allocate_isp_parameters(
-    struct ia_css_isp_param_host_segments *mem_params,
-    struct ia_css_isp_param_css_segments *css_params,
-    const struct ia_css_isp_param_isp_segments *mem_initializers) {
+int ia_css_isp_param_allocate_isp_parameters(
+	struct ia_css_isp_param_host_segments *mem_params,
+	struct ia_css_isp_param_css_segments *css_params,
+	const struct ia_css_isp_param_isp_segments *mem_initializers)
+{
 	int err = 0;
 	unsigned int mem, pclass;
 
 	pclass = IA_CSS_PARAM_CLASS_PARAM;
-	for (mem = 0; mem < IA_CSS_NUM_MEMORIES; mem++)
-	{
+	for (mem = 0; mem < IA_CSS_NUM_MEMORIES; mem++) {
 		for (pclass = 0; pclass < IA_CSS_NUM_PARAM_CLASSES; pclass++) {
 			u32 size = 0;
 
 			if (mem_initializers)
-				size = mem_initializers->params[pclass][mem].size;
+				size = mem_initializers->params[pclass][mem]
+					       .size;
 			mem_params->params[pclass][mem].size = size;
 			mem_params->params[pclass][mem].address = NULL;
 			css_params->params[pclass][mem].size = size;
 			css_params->params[pclass][mem].address = 0x0;
 			if (size) {
-				mem_params->params[pclass][mem].address = kvcalloc(1,
-										   size,
-										   GFP_KERNEL);
+				mem_params->params[pclass][mem].address =
+					kvcalloc(1, size, GFP_KERNEL);
 				if (!mem_params->params[pclass][mem].address) {
 					err = -ENOMEM;
 					goto cleanup;
 				}
 				if (pclass != IA_CSS_PARAM_CLASS_PARAM) {
-					css_params->params[pclass][mem].address = hmm_alloc(size);
-					if (!css_params->params[pclass][mem].address) {
+					css_params->params[pclass][mem].address =
+						hmm_alloc(size);
+					if (!css_params->params[pclass][mem]
+						     .address) {
 						err = -ENOMEM;
 						goto cleanup;
 					}
@@ -137,10 +127,9 @@ ia_css_isp_param_allocate_isp_parameters(
 	return err;
 }
 
-void
-ia_css_isp_param_destroy_isp_parameters(
-    struct ia_css_isp_param_host_segments *mem_params,
-    struct ia_css_isp_param_css_segments *css_params)
+void ia_css_isp_param_destroy_isp_parameters(
+	struct ia_css_isp_param_host_segments *mem_params,
+	struct ia_css_isp_param_css_segments *css_params)
 {
 	unsigned int mem, pclass;
 
@@ -148,41 +137,39 @@ ia_css_isp_param_destroy_isp_parameters(
 		for (pclass = 0; pclass < IA_CSS_NUM_PARAM_CLASSES; pclass++) {
 			kvfree(mem_params->params[pclass][mem].address);
 			if (css_params->params[pclass][mem].address)
-				hmm_free(css_params->params[pclass][mem].address);
+				hmm_free(
+					css_params->params[pclass][mem].address);
 			mem_params->params[pclass][mem].address = NULL;
 			css_params->params[pclass][mem].address = 0x0;
 		}
 	}
 }
 
-void
-ia_css_isp_param_load_fw_params(
-    const char *fw,
-    union ia_css_all_memory_offsets *mem_offsets,
-    const struct ia_css_isp_param_memory_offsets *memory_offsets,
-    bool init)
+void ia_css_isp_param_load_fw_params(
+	const char *fw, union ia_css_all_memory_offsets *mem_offsets,
+	const struct ia_css_isp_param_memory_offsets *memory_offsets, bool init)
 {
 	unsigned int pclass;
 
 	for (pclass = 0; pclass < IA_CSS_NUM_PARAM_CLASSES; pclass++) {
 		mem_offsets->array[pclass].ptr = NULL;
 		if (init)
-			mem_offsets->array[pclass].ptr = (void *)(fw + memory_offsets->offsets[pclass]);
+			mem_offsets->array[pclass].ptr =
+				(void *)(fw + memory_offsets->offsets[pclass]);
 	}
 }
 
-int
-ia_css_isp_param_copy_isp_mem_if_to_ddr(
-    struct ia_css_isp_param_css_segments *ddr,
-    const struct ia_css_isp_param_host_segments *host,
-    enum ia_css_param_class pclass) {
+int ia_css_isp_param_copy_isp_mem_if_to_ddr(
+	struct ia_css_isp_param_css_segments *ddr,
+	const struct ia_css_isp_param_host_segments *host,
+	enum ia_css_param_class pclass)
+{
 	unsigned int mem;
 
-	for (mem = 0; mem < N_IA_CSS_ISP_MEMORIES; mem++)
-	{
-		size_t       size	  = host->params[pclass][mem].size;
-		ia_css_ptr ddr_mem_ptr  = ddr->params[pclass][mem].address;
-		char	    *host_mem_ptr = host->params[pclass][mem].address;
+	for (mem = 0; mem < N_IA_CSS_ISP_MEMORIES; mem++) {
+		size_t size = host->params[pclass][mem].size;
+		ia_css_ptr ddr_mem_ptr = ddr->params[pclass][mem].address;
+		char *host_mem_ptr = host->params[pclass][mem].address;
 
 		if (size != ddr->params[pclass][mem].size)
 			return -EINVAL;
@@ -193,18 +180,18 @@ ia_css_isp_param_copy_isp_mem_if_to_ddr(
 	return 0;
 }
 
-void
-ia_css_isp_param_enable_pipeline(
-    const struct ia_css_isp_param_host_segments *mem_params)
+void ia_css_isp_param_enable_pipeline(
+	const struct ia_css_isp_param_host_segments *mem_params)
 {
 	/* By protocol b0 of the mandatory uint32_t first field of the
 	   input parameter is a disable bit*/
 	short dmem_offset = 0;
 
-	if (mem_params->params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM0].size == 0)
+	if (mem_params->params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM0]
+		    .size == 0)
 		return;
 
-	*(uint32_t *)
-	&mem_params->params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM0].address[dmem_offset]
-	    = 0x0;
+	*(uint32_t *)&mem_params
+		 ->params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM0]
+		 .address[dmem_offset] = 0x0;
 }
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/interface/ia_css_isys.h b/drivers/staging/media/atomisp/pci/runtime/isys/interface/ia_css_isys.h
index 29eebe8f90782efd5edd0cb343b5fff7b98b3b81..d74bf6c6f468efd43d75868165e5564c81b61e15 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/interface/ia_css_isys.h
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/interface/ia_css_isys.h
@@ -18,15 +18,12 @@
 /**
  * Virtual Input System. (Input System 2401)
  */
-typedef isp2401_input_system_cfg_t	ia_css_isys_descr_t;
+typedef isp2401_input_system_cfg_t ia_css_isys_descr_t;
 /* end of Virtual Input System */
 
-
 input_system_err_t ia_css_isys_init(void);
 void ia_css_isys_uninit(void);
-enum mipi_port_id ia_css_isys_port_to_mipi_port(
-    enum mipi_port_id api_port);
-
+enum mipi_port_id ia_css_isys_port_to_mipi_port(enum mipi_port_id api_port);
 
 /**
  * @brief Register one (virtual) stream. This is used to track when all
@@ -39,9 +36,8 @@ enum mipi_port_id ia_css_isys_port_to_mipi_port(
  * @return			0 if successful, -EINVAL if
  *				there is already a stream registered with the same handle
  */
-int ia_css_isys_csi_rx_register_stream(
-    enum mipi_port_id port,
-    uint32_t isys_stream_id);
+int ia_css_isys_csi_rx_register_stream(enum mipi_port_id port,
+				       uint32_t isys_stream_id);
 
 /**
  * @brief Unregister one (virtual) stream. This is used to track when all
@@ -54,20 +50,18 @@ int ia_css_isys_csi_rx_register_stream(
  * @return			0 if successful, -EINVAL if
  *				there is no stream registered with that handle
  */
-int ia_css_isys_csi_rx_unregister_stream(
-    enum mipi_port_id port,
-    uint32_t isys_stream_id);
+int ia_css_isys_csi_rx_unregister_stream(enum mipi_port_id port,
+					 uint32_t isys_stream_id);
 
 int ia_css_isys_convert_compressed_format(
-    struct ia_css_csi2_compression *comp,
-    struct isp2401_input_system_cfg_s *cfg);
+	struct ia_css_csi2_compression *comp,
+	struct isp2401_input_system_cfg_s *cfg);
 unsigned int ia_css_csi2_calculate_input_system_alignment(
-    enum atomisp_input_format fmt_type);
+	enum atomisp_input_format fmt_type);
 
 /* CSS Receiver */
-void ia_css_isys_rx_configure(
-    const rx_cfg_t *config,
-    const enum ia_css_input_mode input_mode);
+void ia_css_isys_rx_configure(const rx_cfg_t *config,
+			      const enum ia_css_input_mode input_mode);
 
 void ia_css_isys_rx_disable(void);
 
@@ -80,7 +74,6 @@ void ia_css_isys_rx_clear_irq_info(enum mipi_port_id port,
 				   unsigned int irq_infos);
 unsigned int ia_css_isys_rx_translate_irq_infos(unsigned int bits);
 
-
 /* @brief Translate format and compression to format type.
  *
  * @param[in]	input_format	The input format.
@@ -93,75 +86,64 @@ unsigned int ia_css_isys_rx_translate_irq_infos(unsigned int bits);
  * format type must be sumitted correctly by the application.
  */
 int ia_css_isys_convert_stream_format_to_mipi_format(
-    enum atomisp_input_format input_format,
-    mipi_predictor_t compression,
-    unsigned int *fmt_type);
+	enum atomisp_input_format input_format, mipi_predictor_t compression,
+	unsigned int *fmt_type);
 
 /**
  * Virtual Input System. (Input System 2401)
  */
-ia_css_isys_error_t ia_css_isys_stream_create(
-    ia_css_isys_descr_t	*isys_stream_descr,
-    ia_css_isys_stream_h	isys_stream,
-    uint32_t isys_stream_id);
+ia_css_isys_error_t
+ia_css_isys_stream_create(ia_css_isys_descr_t *isys_stream_descr,
+			  ia_css_isys_stream_h isys_stream,
+			  uint32_t isys_stream_id);
 
-void ia_css_isys_stream_destroy(
-    ia_css_isys_stream_h	isys_stream);
+void ia_css_isys_stream_destroy(ia_css_isys_stream_h isys_stream);
 
-ia_css_isys_error_t ia_css_isys_stream_calculate_cfg(
-    ia_css_isys_stream_h		isys_stream,
-    ia_css_isys_descr_t		*isys_stream_descr,
-    ia_css_isys_stream_cfg_t	*isys_stream_cfg);
+ia_css_isys_error_t
+ia_css_isys_stream_calculate_cfg(ia_css_isys_stream_h isys_stream,
+				 ia_css_isys_descr_t *isys_stream_descr,
+				 ia_css_isys_stream_cfg_t *isys_stream_cfg);
 
 void ia_css_isys_csi_rx_lut_rmgr_init(void);
 
 void ia_css_isys_csi_rx_lut_rmgr_uninit(void);
 
-bool ia_css_isys_csi_rx_lut_rmgr_acquire(
-    csi_rx_backend_ID_t		backend,
-    csi_mipi_packet_type_t		packet_type,
-    csi_rx_backend_lut_entry_t	*entry);
+bool ia_css_isys_csi_rx_lut_rmgr_acquire(csi_rx_backend_ID_t backend,
+					 csi_mipi_packet_type_t packet_type,
+					 csi_rx_backend_lut_entry_t *entry);
 
-void ia_css_isys_csi_rx_lut_rmgr_release(
-    csi_rx_backend_ID_t		backend,
-    csi_mipi_packet_type_t		packet_type,
-    csi_rx_backend_lut_entry_t	*entry);
+void ia_css_isys_csi_rx_lut_rmgr_release(csi_rx_backend_ID_t backend,
+					 csi_mipi_packet_type_t packet_type,
+					 csi_rx_backend_lut_entry_t *entry);
 
 void ia_css_isys_ibuf_rmgr_init(void);
 
 void ia_css_isys_ibuf_rmgr_uninit(void);
 
-bool ia_css_isys_ibuf_rmgr_acquire(
-    u32	size,
-    uint32_t	*start_addr);
+bool ia_css_isys_ibuf_rmgr_acquire(u32 size, uint32_t *start_addr);
 
-void ia_css_isys_ibuf_rmgr_release(
-    uint32_t	*start_addr);
+void ia_css_isys_ibuf_rmgr_release(uint32_t *start_addr);
 
 void ia_css_isys_dma_channel_rmgr_init(void);
 
 void ia_css_isys_dma_channel_rmgr_uninit(void);
 
-bool ia_css_isys_dma_channel_rmgr_acquire(
-    isys2401_dma_ID_t	dma_id,
-    isys2401_dma_channel	*channel);
+bool ia_css_isys_dma_channel_rmgr_acquire(isys2401_dma_ID_t dma_id,
+					  isys2401_dma_channel *channel);
 
-void ia_css_isys_dma_channel_rmgr_release(
-    isys2401_dma_ID_t	dma_id,
-    isys2401_dma_channel	*channel);
+void ia_css_isys_dma_channel_rmgr_release(isys2401_dma_ID_t dma_id,
+					  isys2401_dma_channel *channel);
 
 void ia_css_isys_stream2mmio_sid_rmgr_init(void);
 
 void ia_css_isys_stream2mmio_sid_rmgr_uninit(void);
 
-bool ia_css_isys_stream2mmio_sid_rmgr_acquire(
-    stream2mmio_ID_t	stream2mmio,
-    stream2mmio_sid_ID_t	*sid);
+bool ia_css_isys_stream2mmio_sid_rmgr_acquire(stream2mmio_ID_t stream2mmio,
+					      stream2mmio_sid_ID_t *sid);
 
-void ia_css_isys_stream2mmio_sid_rmgr_release(
-    stream2mmio_ID_t	stream2mmio,
-    stream2mmio_sid_ID_t	*sid);
+void ia_css_isys_stream2mmio_sid_rmgr_release(stream2mmio_ID_t stream2mmio,
+					      stream2mmio_sid_ID_t *sid);
 
 /* end of Virtual Input System */
 
-#endif				/* __IA_CSS_ISYS_H__ */
+#endif /* __IA_CSS_ISYS_H__ */
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/interface/ia_css_isys_comm.h b/drivers/staging/media/atomisp/pci/runtime/isys/interface/ia_css_isys_comm.h
index 3d4c0cd2f2a6a5a2677e995a6336d5f6953bfe58..b217ff93008fa155017e8d14e4c3cbb9dff5e56f 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/interface/ia_css_isys_comm.h
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/interface/ia_css_isys_comm.h
@@ -10,12 +10,13 @@
 #include <type_support.h>
 #include <input_system.h>
 
-#include <platform_support.h>		/* inline */
+#include <platform_support.h> /* inline */
 #include <input_system_global.h>
-#include <ia_css_stream_public.h>	/* IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH */
+#include <ia_css_stream_public.h> /* IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH */
 
-#define SH_CSS_NODES_PER_THREAD		2
-#define SH_CSS_MAX_ISYS_CHANNEL_NODES	(SH_CSS_MAX_SP_THREADS * SH_CSS_NODES_PER_THREAD)
+#define SH_CSS_NODES_PER_THREAD 2
+#define SH_CSS_MAX_ISYS_CHANNEL_NODES \
+	(SH_CSS_MAX_SP_THREADS * SH_CSS_NODES_PER_THREAD)
 
 /*
  * a) ia_css_isys_stream_h & ia_css_isys_stream_cfg_t come from host.
@@ -25,19 +26,18 @@
  * communication channel to interpret that opaque handle(this handle is
  * maintained by host and needs to be populated to sp for every stream open)
  * */
-typedef virtual_input_system_stream_t		*ia_css_isys_stream_h;
-typedef virtual_input_system_stream_cfg_t	ia_css_isys_stream_cfg_t;
+typedef virtual_input_system_stream_t *ia_css_isys_stream_h;
+typedef virtual_input_system_stream_cfg_t ia_css_isys_stream_cfg_t;
 
 /*
  * error check for ISYS APIs.
  * */
 typedef bool ia_css_isys_error_t;
 
-static inline uint32_t ia_css_isys_generate_stream_id(
-    u32	sp_thread_id,
-    uint32_t	stream_id)
+static inline uint32_t ia_css_isys_generate_stream_id(u32 sp_thread_id,
+						      uint32_t stream_id)
 {
 	return sp_thread_id * IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH + stream_id;
 }
 
-#endif  /*_IA_CSS_ISYS_COMM_H */
+#endif /*_IA_CSS_ISYS_COMM_H */
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/csi_rx_rmgr.c b/drivers/staging/media/atomisp/pci/runtime/isys/src/csi_rx_rmgr.c
index 7490d189f39d49c8a6ef38796b9d07473998c889..178c0595c953ae38b9237a671482e849ddafd25f 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/csi_rx_rmgr.c
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/csi_rx_rmgr.c
@@ -6,18 +6,17 @@
 
 #include "system_global.h"
 
-
 #include "assert_support.h"
 #include "platform_support.h"
 #include "ia_css_isys.h"
 #include "bitop_support.h"
-#include "ia_css_pipeline.h"	/* ia_css_pipeline_get_pipe_io_status() */
-#include "sh_css_internal.h"	/* sh_css_sp_pipeline_io_status
+#include "ia_css_pipeline.h" /* ia_css_pipeline_get_pipe_io_status() */
+#include "sh_css_internal.h" /* sh_css_sp_pipeline_io_status
 				 * SH_CSS_MAX_SP_THREADS
 				 */
 #include "csi_rx_rmgr.h"
 
-static isys_csi_rx_rsrc_t  isys_csi_rx_rsrc[N_CSI_RX_BACKEND_ID];
+static isys_csi_rx_rsrc_t isys_csi_rx_rsrc[N_CSI_RX_BACKEND_ID];
 
 void ia_css_isys_csi_rx_lut_rmgr_init(void)
 {
@@ -29,10 +28,9 @@ void ia_css_isys_csi_rx_lut_rmgr_uninit(void)
 	memset(isys_csi_rx_rsrc, 0, sizeof(isys_csi_rx_rsrc));
 }
 
-bool ia_css_isys_csi_rx_lut_rmgr_acquire(
-    csi_rx_backend_ID_t		backend,
-    csi_mipi_packet_type_t		packet_type,
-    csi_rx_backend_lut_entry_t	*entry)
+bool ia_css_isys_csi_rx_lut_rmgr_acquire(csi_rx_backend_ID_t backend,
+					 csi_mipi_packet_type_t packet_type,
+					 csi_rx_backend_lut_entry_t *entry)
 {
 	bool retval = false;
 	u32 max_num_packets_of_type;
@@ -48,19 +46,23 @@ bool ia_css_isys_csi_rx_lut_rmgr_acquire(
 	if ((backend < N_CSI_RX_BACKEND_ID) && (entry)) {
 		cur_rsrc = &isys_csi_rx_rsrc[backend];
 		if (packet_type == CSI_MIPI_PACKET_TYPE_LONG) {
-			max_num_packets_of_type = N_LONG_PACKET_LUT_ENTRIES[backend];
+			max_num_packets_of_type =
+				N_LONG_PACKET_LUT_ENTRIES[backend];
 			num_active_of_type = cur_rsrc->num_long_packets;
 		} else {
-			max_num_packets_of_type = N_SHORT_PACKET_LUT_ENTRIES[backend];
+			max_num_packets_of_type =
+				N_SHORT_PACKET_LUT_ENTRIES[backend];
 			num_active_of_type = cur_rsrc->num_short_packets;
 		}
 
 		if (num_active_of_type < max_num_packets_of_type) {
 			for (i = 0; i < max_num_packets_of_type; i++) {
-				if (bitop_getbit(cur_rsrc->active_table, i) == 0) {
+				if (bitop_getbit(cur_rsrc->active_table, i) ==
+				    0) {
 					bitop_setbit(cur_rsrc->active_table, i);
 
-					if (packet_type == CSI_MIPI_PACKET_TYPE_LONG) {
+					if (packet_type ==
+					    CSI_MIPI_PACKET_TYPE_LONG) {
 						entry->long_packet_entry = i;
 						entry->short_packet_entry = 0;
 						cur_rsrc->num_long_packets++;
@@ -79,10 +81,9 @@ bool ia_css_isys_csi_rx_lut_rmgr_acquire(
 	return retval;
 }
 
-void ia_css_isys_csi_rx_lut_rmgr_release(
-    csi_rx_backend_ID_t		backend,
-    csi_mipi_packet_type_t		packet_type,
-    csi_rx_backend_lut_entry_t	*entry)
+void ia_css_isys_csi_rx_lut_rmgr_release(csi_rx_backend_ID_t backend,
+					 csi_mipi_packet_type_t packet_type,
+					 csi_rx_backend_lut_entry_t *entry)
 {
 	u32 max_num_packets;
 	isys_csi_rx_rsrc_t *cur_rsrc = NULL;
@@ -103,9 +104,12 @@ void ia_css_isys_csi_rx_lut_rmgr_release(
 		}
 
 		cur_rsrc = &isys_csi_rx_rsrc[backend];
-		if ((packet_entry < max_num_packets) && (cur_rsrc->num_active > 0)) {
-			if (bitop_getbit(cur_rsrc->active_table, packet_entry) == 1) {
-				bitop_clearbit(cur_rsrc->active_table, packet_entry);
+		if ((packet_entry < max_num_packets) &&
+		    (cur_rsrc->num_active > 0)) {
+			if (bitop_getbit(cur_rsrc->active_table,
+					 packet_entry) == 1) {
+				bitop_clearbit(cur_rsrc->active_table,
+					       packet_entry);
 
 				if (packet_type == CSI_MIPI_PACKET_TYPE_LONG)
 					cur_rsrc->num_long_packets--;
@@ -117,9 +121,8 @@ void ia_css_isys_csi_rx_lut_rmgr_release(
 	}
 }
 
-int ia_css_isys_csi_rx_register_stream(
-    enum mipi_port_id port,
-    uint32_t isys_stream_id)
+int ia_css_isys_csi_rx_register_stream(enum mipi_port_id port,
+				       uint32_t isys_stream_id)
 {
 	int retval = -EINVAL;
 
@@ -128,8 +131,10 @@ int ia_css_isys_csi_rx_register_stream(
 		struct sh_css_sp_pipeline_io_status *pipe_io_status;
 
 		pipe_io_status = ia_css_pipeline_get_pipe_io_status();
-		if (bitop_getbit(pipe_io_status->active[port], isys_stream_id) == 0) {
-			bitop_setbit(pipe_io_status->active[port], isys_stream_id);
+		if (bitop_getbit(pipe_io_status->active[port],
+				 isys_stream_id) == 0) {
+			bitop_setbit(pipe_io_status->active[port],
+				     isys_stream_id);
 			pipe_io_status->running[port] = 0;
 			retval = 0;
 		}
@@ -137,9 +142,8 @@ int ia_css_isys_csi_rx_register_stream(
 	return retval;
 }
 
-int ia_css_isys_csi_rx_unregister_stream(
-    enum mipi_port_id port,
-    uint32_t isys_stream_id)
+int ia_css_isys_csi_rx_unregister_stream(enum mipi_port_id port,
+					 uint32_t isys_stream_id)
 {
 	int retval = -EINVAL;
 
@@ -148,8 +152,10 @@ int ia_css_isys_csi_rx_unregister_stream(
 		struct sh_css_sp_pipeline_io_status *pipe_io_status;
 
 		pipe_io_status = ia_css_pipeline_get_pipe_io_status();
-		if (bitop_getbit(pipe_io_status->active[port], isys_stream_id) == 1) {
-			bitop_clearbit(pipe_io_status->active[port], isys_stream_id);
+		if (bitop_getbit(pipe_io_status->active[port],
+				 isys_stream_id) == 1) {
+			bitop_clearbit(pipe_io_status->active[port],
+				       isys_stream_id);
 			retval = 0;
 		}
 	}
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/csi_rx_rmgr.h b/drivers/staging/media/atomisp/pci/runtime/isys/src/csi_rx_rmgr.h
index e68386e544691bb9e424f5bc3348d49d5c411697..e9250b849ec64618152fc54802e943e0135d1a05 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/csi_rx_rmgr.h
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/csi_rx_rmgr.h
@@ -9,10 +9,10 @@
 
 typedef struct isys_csi_rx_rsrc_s isys_csi_rx_rsrc_t;
 struct isys_csi_rx_rsrc_s {
-	u32	active_table;
-	u32        num_active;
-	u16	num_long_packets;
-	u16	num_short_packets;
+	u32 active_table;
+	u32 num_active;
+	u16 num_long_packets;
+	u16 num_short_packets;
 };
 
 #endif /* __CSI_RX_RMGR_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.c b/drivers/staging/media/atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.c
index b8d431dcd6c14b3cd475b85aa65f7216d778102a..66008e6b5800076f9f65a0ea2302a0c5e70ddb86 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.c
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.c
@@ -11,7 +11,7 @@
 #include "ia_css_isys.h"
 #include "ibuf_ctrl_rmgr.h"
 
-static ibuf_rsrc_t	ibuf_rsrc;
+static ibuf_rsrc_t ibuf_rsrc;
 
 static ibuf_handle_t *getHandle(uint16_t index)
 {
@@ -34,9 +34,7 @@ void ia_css_isys_ibuf_rmgr_uninit(void)
 	ibuf_rsrc.free_size = MAX_INPUT_BUFFER_SIZE;
 }
 
-bool ia_css_isys_ibuf_rmgr_acquire(
-    u32	size,
-    uint32_t	*start_addr)
+bool ia_css_isys_ibuf_rmgr_acquire(u32 size, uint32_t *start_addr)
 {
 	bool retval = false;
 	bool input_buffer_found = false;
@@ -73,9 +71,9 @@ bool ia_css_isys_ibuf_rmgr_acquire(
 		if ((ibuf_rsrc.num_allocated < MAX_IBUF_HANDLES) &&
 		    (ibuf_rsrc.free_size >= aligned_size)) {
 			handle = getHandle(ibuf_rsrc.num_allocated);
-			handle->start_addr	= ibuf_rsrc.free_start_addr;
-			handle->size		= aligned_size;
-			handle->active		= true;
+			handle->start_addr = ibuf_rsrc.free_start_addr;
+			handle->size = aligned_size;
+			handle->active = true;
 
 			ibuf_rsrc.free_start_addr += aligned_size;
 			ibuf_rsrc.free_size -= aligned_size;
@@ -94,8 +92,7 @@ bool ia_css_isys_ibuf_rmgr_acquire(
 	return retval;
 }
 
-void ia_css_isys_ibuf_rmgr_release(
-    uint32_t	*start_addr)
+void ia_css_isys_ibuf_rmgr_release(uint32_t *start_addr)
 {
 	u16 i;
 	ibuf_handle_t *handle = NULL;
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.h b/drivers/staging/media/atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.h
index 2345dee7ba08c0816ff24bd87007d6c5d09d0c05..726e9cbbf32275b1f850c9fef04b335ccc5c7b79 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.h
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/ibuf_ctrl_rmgr.h
@@ -7,24 +7,24 @@
 #ifndef __IBUF_CTRL_RMGR_H_INCLUDED__
 #define __IBUF_CTRL_RMGR_H_INCLUDED__
 
-#define MAX_IBUF_HANDLES	24
-#define MAX_INPUT_BUFFER_SIZE	(64 * 1024)
-#define IBUF_ALIGN		8
+#define MAX_IBUF_HANDLES 24
+#define MAX_INPUT_BUFFER_SIZE (64 * 1024)
+#define IBUF_ALIGN 8
 
 typedef struct ibuf_handle_s ibuf_handle_t;
 struct ibuf_handle_s {
-	u32	start_addr;
-	u32	size;
-	bool		active;
+	u32 start_addr;
+	u32 size;
+	bool active;
 };
 
 typedef struct ibuf_rsrc_s ibuf_rsrc_t;
 struct ibuf_rsrc_s {
-	u32	free_start_addr;
-	u32	free_size;
-	u16	num_active;
-	u16	num_allocated;
-	ibuf_handle_t	handles[MAX_IBUF_HANDLES];
+	u32 free_start_addr;
+	u32 free_size;
+	u16 num_active;
+	u16 num_allocated;
+	ibuf_handle_t handles[MAX_IBUF_HANDLES];
 };
 
 #endif /* __IBUF_CTRL_RMGR_H_INCLUDED */
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_dma_rmgr.c b/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_dma_rmgr.c
index 2ce2f32a1946318a585973ab5dfe15cf41890e1a..bf9a09e99fbce2534af8db4a4f4e263f46d3c1bc 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_dma_rmgr.c
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_dma_rmgr.c
@@ -6,7 +6,6 @@
 
 #include "system_global.h"
 
-
 #include "assert_support.h"
 #include "platform_support.h"
 #include "ia_css_isys.h"
@@ -25,14 +24,13 @@ void ia_css_isys_dma_channel_rmgr_uninit(void)
 	memset(&isys_dma_rsrc, 0, sizeof(isys_dma_rsrc_t));
 }
 
-bool ia_css_isys_dma_channel_rmgr_acquire(
-    isys2401_dma_ID_t	dma_id,
-    isys2401_dma_channel	*channel)
+bool ia_css_isys_dma_channel_rmgr_acquire(isys2401_dma_ID_t dma_id,
+					  isys2401_dma_channel *channel)
 {
 	bool retval = false;
-	isys2401_dma_channel	i;
-	isys2401_dma_channel	max_dma_channel;
-	isys_dma_rsrc_t		*cur_rsrc = NULL;
+	isys2401_dma_channel i;
+	isys2401_dma_channel max_dma_channel;
+	isys_dma_rsrc_t *cur_rsrc = NULL;
 
 	assert(dma_id < N_ISYS2401_DMA_ID);
 	assert(channel);
@@ -41,7 +39,8 @@ bool ia_css_isys_dma_channel_rmgr_acquire(
 	cur_rsrc = &isys_dma_rsrc[dma_id];
 
 	if (cur_rsrc->num_active < max_dma_channel) {
-		for (i = ISYS2401_DMA_CHANNEL_0; i < N_ISYS2401_DMA_CHANNEL; i++) {
+		for (i = ISYS2401_DMA_CHANNEL_0; i < N_ISYS2401_DMA_CHANNEL;
+		     i++) {
 			if (bitop_getbit(cur_rsrc->active_table, i) == 0) {
 				bitop_setbit(cur_rsrc->active_table, i);
 				*channel = i;
@@ -55,12 +54,11 @@ bool ia_css_isys_dma_channel_rmgr_acquire(
 	return retval;
 }
 
-void ia_css_isys_dma_channel_rmgr_release(
-    isys2401_dma_ID_t	dma_id,
-    isys2401_dma_channel	*channel)
+void ia_css_isys_dma_channel_rmgr_release(isys2401_dma_ID_t dma_id,
+					  isys2401_dma_channel *channel)
 {
-	isys2401_dma_channel	max_dma_channel;
-	isys_dma_rsrc_t		*cur_rsrc = NULL;
+	isys2401_dma_channel max_dma_channel;
+	isys_dma_rsrc_t *cur_rsrc = NULL;
 
 	assert(dma_id < N_ISYS2401_DMA_ID);
 	assert(channel);
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_dma_rmgr.h b/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_dma_rmgr.h
index 070a06df5f0c8ba5dd09aae6b428e6a0cadfc026..1f76895a2e628f1605a0d723e3bbb4d20e423028 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_dma_rmgr.h
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_dma_rmgr.h
@@ -7,7 +7,7 @@
 #ifndef __ISYS_DMA_RMGR_H_INCLUDED__
 #define __ISYS_DMA_RMGR_H_INCLUDED__
 
-typedef struct isys_dma_rsrc_s	isys_dma_rsrc_t;
+typedef struct isys_dma_rsrc_s isys_dma_rsrc_t;
 struct isys_dma_rsrc_s {
 	u32 active_table;
 	u16 num_active;
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_init.c b/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_init.c
index 46bb3569e139485f41fd019e0574d6281e31fde1..46ea78b73a082d4427f56ed7e5e231c74813ec42 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_init.c
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_init.c
@@ -9,7 +9,7 @@
 #include "ia_css_isys.h"
 #include "platform_support.h"
 
-#include "isys_dma_public.h"	/* isys2401_dma_set_max_burst_size() */
+#include "isys_dma_public.h" /* isys2401_dma_set_max_burst_size() */
 #include "isys_irq.h"
 
 static input_system_err_t ia_css_isys_2400_init(void)
@@ -32,41 +32,41 @@ static input_system_err_t ia_css_isys_2400_init(void)
 		return error;
 
 	error = input_system_csi_xmem_channel_cfg(
-		    0,			/*ch_id                 */
-		    INPUT_SYSTEM_PORT_A,	/*port                  */
-		    backend_ch0,		/*backend_ch            */
-		    32,			/*mem_region_size       */
-		    6,			/*nof_mem_regions       */
-		    acq_mem_region_size,	/*acq_mem_region_size   */
-		    acq_nof_mem_regions,	/*acq_nof_mem_regions   */
-		    targetB,		/*target                */
-		    3);			/*nof_xmem_buffers      */
+		0, /*ch_id                 */
+		INPUT_SYSTEM_PORT_A, /*port                  */
+		backend_ch0, /*backend_ch            */
+		32, /*mem_region_size       */
+		6, /*nof_mem_regions       */
+		acq_mem_region_size, /*acq_mem_region_size   */
+		acq_nof_mem_regions, /*acq_nof_mem_regions   */
+		targetB, /*target                */
+		3); /*nof_xmem_buffers      */
 	if (error != INPUT_SYSTEM_ERR_NO_ERROR)
 		return error;
 
 	error = input_system_csi_xmem_channel_cfg(
-		    1,			/*ch_id                 */
-		    INPUT_SYSTEM_PORT_B,	/*port                  */
-		    backend_ch0,		/*backend_ch            */
-		    16,			/*mem_region_size       */
-		    3,			/*nof_mem_regions       */
-		    acq_mem_region_size,	/*acq_mem_region_size   */
-		    acq_nof_mem_regions,	/*acq_nof_mem_regions   */
-		    targetB,		/*target                */
-		    3);			/*nof_xmem_buffers      */
+		1, /*ch_id                 */
+		INPUT_SYSTEM_PORT_B, /*port                  */
+		backend_ch0, /*backend_ch            */
+		16, /*mem_region_size       */
+		3, /*nof_mem_regions       */
+		acq_mem_region_size, /*acq_mem_region_size   */
+		acq_nof_mem_regions, /*acq_nof_mem_regions   */
+		targetB, /*target                */
+		3); /*nof_xmem_buffers      */
 	if (error != INPUT_SYSTEM_ERR_NO_ERROR)
 		return error;
 
 	error = input_system_csi_xmem_channel_cfg(
-		    2,			/*ch_id                 */
-		    INPUT_SYSTEM_PORT_C,	/*port                  */
-		    backend_ch1,		/*backend_ch            */
-		    32,			/*mem_region_size       */
-		    3,			/*nof_mem_regions       */
-		    acq_mem_region_size,	/*acq_mem_region_size   */
-		    acq_nof_mem_regions,	/*acq_nof_mem_regions   */
-		    targetC,		/*target                */
-		    2);			/*nof_xmem_buffers      */
+		2, /*ch_id                 */
+		INPUT_SYSTEM_PORT_C, /*port                  */
+		backend_ch1, /*backend_ch            */
+		32, /*mem_region_size       */
+		3, /*nof_mem_regions       */
+		acq_mem_region_size, /*acq_mem_region_size   */
+		acq_nof_mem_regions, /*acq_nof_mem_regions   */
+		targetC, /*target                */
+		2); /*nof_xmem_buffers      */
 	if (error != INPUT_SYSTEM_ERR_NO_ERROR)
 		return error;
 
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_stream2mmio_rmgr.c b/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_stream2mmio_rmgr.c
index 9217d26cf632ba27bdfe0662c5f124638f3936de..ad98baf1effdc7edffe6546815e42e4181563ff9 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_stream2mmio_rmgr.c
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_stream2mmio_rmgr.c
@@ -6,14 +6,13 @@
 
 #include "system_global.h"
 
-
 #include "assert_support.h"
 #include "platform_support.h"
 #include "ia_css_isys.h"
 #include "bitop_support.h"
 #include "isys_stream2mmio_rmgr.h"
 
-static isys_stream2mmio_rsrc_t	isys_stream2mmio_rsrc[N_STREAM2MMIO_ID];
+static isys_stream2mmio_rsrc_t isys_stream2mmio_rsrc[N_STREAM2MMIO_ID];
 
 void ia_css_isys_stream2mmio_sid_rmgr_init(void)
 {
@@ -25,14 +24,13 @@ void ia_css_isys_stream2mmio_sid_rmgr_uninit(void)
 	memset(isys_stream2mmio_rsrc, 0, sizeof(isys_stream2mmio_rsrc));
 }
 
-bool ia_css_isys_stream2mmio_sid_rmgr_acquire(
-    stream2mmio_ID_t	stream2mmio,
-    stream2mmio_sid_ID_t	*sid)
+bool ia_css_isys_stream2mmio_sid_rmgr_acquire(stream2mmio_ID_t stream2mmio,
+					      stream2mmio_sid_ID_t *sid)
 {
 	bool retval = false;
 	stream2mmio_sid_ID_t max_sid;
 	isys_stream2mmio_rsrc_t *cur_rsrc = NULL;
-	stream2mmio_sid_ID_t	i;
+	stream2mmio_sid_ID_t i;
 
 	assert(stream2mmio < N_STREAM2MMIO_ID);
 	assert(sid);
@@ -43,7 +41,8 @@ bool ia_css_isys_stream2mmio_sid_rmgr_acquire(
 
 		if (cur_rsrc->num_active < max_sid) {
 			for (i = STREAM2MMIO_SID0_ID; i < max_sid; i++) {
-				if (bitop_getbit(cur_rsrc->active_table, i) == 0) {
+				if (bitop_getbit(cur_rsrc->active_table, i) ==
+				    0) {
 					bitop_setbit(cur_rsrc->active_table, i);
 					*sid = i;
 					cur_rsrc->num_active++;
@@ -56,9 +55,8 @@ bool ia_css_isys_stream2mmio_sid_rmgr_acquire(
 	return retval;
 }
 
-void ia_css_isys_stream2mmio_sid_rmgr_release(
-    stream2mmio_ID_t	stream2mmio,
-    stream2mmio_sid_ID_t	*sid)
+void ia_css_isys_stream2mmio_sid_rmgr_release(stream2mmio_ID_t stream2mmio,
+					      stream2mmio_sid_ID_t *sid)
 {
 	stream2mmio_sid_ID_t max_sid;
 	isys_stream2mmio_rsrc_t *cur_rsrc = NULL;
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_stream2mmio_rmgr.h b/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_stream2mmio_rmgr.h
index c07ee12746d4476d5805278bbc6c7e36b837c2c8..1679815c676d29afb75c77a07f39cb99e939f24a 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_stream2mmio_rmgr.h
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/isys_stream2mmio_rmgr.h
@@ -9,8 +9,8 @@
 
 typedef struct isys_stream2mmio_rsrc_s isys_stream2mmio_rsrc_t;
 struct isys_stream2mmio_rsrc_s {
-	u32	active_table;
-	u16	num_active;
+	u32 active_table;
+	u16 num_active;
 };
 
 #endif /* __ISYS_STREAM2MMIO_RMGR_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/rx.c b/drivers/staging/media/atomisp/pci/runtime/isys/src/rx.c
index 9cfb8bc97e24ffd3aa0c80cf403782179a4888f7..c67306041f7aacd5d5b0db99e85525028b9aeea4 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/rx.c
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/rx.c
@@ -13,9 +13,8 @@
 
 void ia_css_isys_rx_enable_all_interrupts(enum mipi_port_id port)
 {
-	hrt_data bits = receiver_port_reg_load(RX0_ID,
-					       port,
-					       _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
+	hrt_data bits = receiver_port_reg_load(
+		RX0_ID, port, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
 
 	bits |= (1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT) |
 		(1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT) |
@@ -35,8 +34,7 @@ void ia_css_isys_rx_enable_all_interrupts(enum mipi_port_id port)
 		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT);
 	/*(1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT); */
 
-	receiver_port_reg_store(RX0_ID,
-				port,
+	receiver_port_reg_store(RX0_ID, port,
 				_HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, bits);
 
 	/*
@@ -70,8 +68,7 @@ enum mipi_port_id ia_css_isys_port_to_mipi_port(enum mipi_port_id api_port)
 
 unsigned int ia_css_isys_rx_get_interrupt_reg(enum mipi_port_id port)
 {
-	return receiver_port_reg_load(RX0_ID,
-				      port,
+	return receiver_port_reg_load(RX0_ID, port,
 				      _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
 }
 
@@ -155,9 +152,8 @@ void ia_css_rx_port_clear_irq_info(enum mipi_port_id api_port,
 void ia_css_isys_rx_clear_irq_info(enum mipi_port_id port,
 				   unsigned int irq_infos)
 {
-	hrt_data bits = receiver_port_reg_load(RX0_ID,
-					       port,
-					       _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
+	hrt_data bits = receiver_port_reg_load(
+		RX0_ID, port, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
 
 	/* MW: Why do we remap the receiver bitmap */
 	if (irq_infos & IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
@@ -193,8 +189,7 @@ void ia_css_isys_rx_clear_irq_info(enum mipi_port_id port,
 	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
 		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT;
 
-	receiver_port_reg_store(RX0_ID,
-				port,
+	receiver_port_reg_store(RX0_ID, port,
 				_HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, bits);
 
 	return;
@@ -361,9 +356,8 @@ static int ia_css_isys_2401_set_fmt_type(enum atomisp_input_format input_format,
 }
 
 int ia_css_isys_convert_stream_format_to_mipi_format(
-    enum atomisp_input_format input_format,
-    mipi_predictor_t compression,
-    unsigned int *fmt_type)
+	enum atomisp_input_format input_format, mipi_predictor_t compression,
+	unsigned int *fmt_type)
 {
 	assert(fmt_type);
 	/*
@@ -415,7 +409,7 @@ int ia_css_isys_convert_stream_format_to_mipi_format(
 }
 
 static mipi_predictor_t sh_css_csi2_compression_type_2_mipi_predictor(
-    enum ia_css_csi2_compression_type type)
+	enum ia_css_csi2_compression_type type)
 {
 	mipi_predictor_t predictor = MIPI_PREDICTOR_NONE;
 
@@ -432,9 +426,8 @@ static mipi_predictor_t sh_css_csi2_compression_type_2_mipi_predictor(
 	return predictor;
 }
 
-int ia_css_isys_convert_compressed_format(
-    struct ia_css_csi2_compression *comp,
-    struct isp2401_input_system_cfg_s *cfg)
+int ia_css_isys_convert_compressed_format(struct ia_css_csi2_compression *comp,
+					  struct isp2401_input_system_cfg_s *cfg)
 {
 	int err = 0;
 
@@ -455,16 +448,20 @@ int ia_css_isys_convert_compressed_format(
 				110 12-8-12
 			1 bit indicate predictor
 		*/
-		if (comp->uncompressed_bits_per_pixel == UNCOMPRESSED_BITS_PER_PIXEL_10) {
+		if (comp->uncompressed_bits_per_pixel ==
+		    UNCOMPRESSED_BITS_PER_PIXEL_10) {
 			switch (comp->compressed_bits_per_pixel) {
 			case COMPRESSED_BITS_PER_PIXEL_6:
-				cfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_10_6_10;
+				cfg->csi_port_attr.comp_scheme =
+					MIPI_COMPRESSOR_10_6_10;
 				break;
 			case COMPRESSED_BITS_PER_PIXEL_7:
-				cfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_10_7_10;
+				cfg->csi_port_attr.comp_scheme =
+					MIPI_COMPRESSOR_10_7_10;
 				break;
 			case COMPRESSED_BITS_PER_PIXEL_8:
-				cfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_10_8_10;
+				cfg->csi_port_attr.comp_scheme =
+					MIPI_COMPRESSOR_10_8_10;
 				break;
 			default:
 				err = -EINVAL;
@@ -473,13 +470,16 @@ int ia_css_isys_convert_compressed_format(
 			   UNCOMPRESSED_BITS_PER_PIXEL_12) {
 			switch (comp->compressed_bits_per_pixel) {
 			case COMPRESSED_BITS_PER_PIXEL_6:
-				cfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_12_6_12;
+				cfg->csi_port_attr.comp_scheme =
+					MIPI_COMPRESSOR_12_6_12;
 				break;
 			case COMPRESSED_BITS_PER_PIXEL_7:
-				cfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_12_7_12;
+				cfg->csi_port_attr.comp_scheme =
+					MIPI_COMPRESSOR_12_7_12;
 				break;
 			case COMPRESSED_BITS_PER_PIXEL_8:
-				cfg->csi_port_attr.comp_scheme = MIPI_COMPRESSOR_12_8_12;
+				cfg->csi_port_attr.comp_scheme =
+					MIPI_COMPRESSOR_12_8_12;
 				break;
 			default:
 				err = -EINVAL;
@@ -487,15 +487,16 @@ int ia_css_isys_convert_compressed_format(
 		} else
 			err = -EINVAL;
 		cfg->csi_port_attr.comp_predictor =
-		    sh_css_csi2_compression_type_2_mipi_predictor(comp->type);
+			sh_css_csi2_compression_type_2_mipi_predictor(
+				comp->type);
 		cfg->csi_port_attr.comp_enable = true;
 	} else /* No compression */
 		cfg->csi_port_attr.comp_enable = false;
 	return err;
 }
 
-unsigned int ia_css_csi2_calculate_input_system_alignment(
-    enum atomisp_input_format fmt_type)
+unsigned int
+ia_css_csi2_calculate_input_system_alignment(enum atomisp_input_format fmt_type)
 {
 	unsigned int memory_alignment_in_bytes = HIVE_ISP_DDR_WORD_BYTES;
 
@@ -530,16 +531,15 @@ unsigned int ia_css_csi2_calculate_input_system_alignment(
 	return memory_alignment_in_bytes;
 }
 
-
 static const mipi_lane_cfg_t MIPI_PORT_LANES[N_RX_MODE][N_MIPI_PORT_ID] = {
-	{MIPI_4LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
-	{MIPI_3LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
-	{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
-	{MIPI_1LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
-	{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_2LANE_CFG},
-	{MIPI_3LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG},
-	{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG},
-	{MIPI_1LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG}
+	{ MIPI_4LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG },
+	{ MIPI_3LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG },
+	{ MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG },
+	{ MIPI_1LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG },
+	{ MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_2LANE_CFG },
+	{ MIPI_3LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG },
+	{ MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG },
+	{ MIPI_1LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG }
 };
 
 void ia_css_isys_rx_configure(const rx_cfg_t *config,
@@ -548,9 +548,8 @@ void ia_css_isys_rx_configure(const rx_cfg_t *config,
 	bool any_port_enabled = false;
 	enum mipi_port_id port;
 
-	if ((!config)
-	    || (config->mode >= N_RX_MODE)
-	    || (config->port >= N_MIPI_PORT_ID)) {
+	if ((!config) || (config->mode >= N_RX_MODE) ||
+	    (config->port >= N_MIPI_PORT_ID)) {
 		assert(0);
 		return;
 	}
@@ -571,12 +570,12 @@ void ia_css_isys_rx_configure(const rx_cfg_t *config,
 		receiver_port_reg_store(RX0_ID, port,
 					_HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX,
 					config->timeout);
-		receiver_port_reg_store(RX0_ID, port,
-					_HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX,
-					config->initcount);
-		receiver_port_reg_store(RX0_ID, port,
-					_HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX,
-					config->synccount);
+		receiver_port_reg_store(
+			RX0_ID, port, _HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX,
+			config->initcount);
+		receiver_port_reg_store(
+			RX0_ID, port, _HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX,
+			config->synccount);
 		receiver_port_reg_store(RX0_ID, port,
 					_HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX,
 					config->rxcount);
@@ -584,30 +583,30 @@ void ia_css_isys_rx_configure(const rx_cfg_t *config,
 		if (input_mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
 			/* MW: A bit of a hack, straight wiring of the capture
 			 * units,assuming they are linearly enumerated. */
-			input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
-							  GPREGS_UNIT0_ID,
-							  HIVE_ISYS_GPREG_MULTICAST_A_IDX
-							  + (unsigned int)port,
-							  INPUT_SYSTEM_CSI_BACKEND);
+			input_system_sub_system_reg_store(
+				INPUT_SYSTEM0_ID, GPREGS_UNIT0_ID,
+				HIVE_ISYS_GPREG_MULTICAST_A_IDX +
+					(unsigned int)port,
+				INPUT_SYSTEM_CSI_BACKEND);
 			/* MW: Like the integration test example we overwite,
 			 * the GPREG_MUX register */
-			input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
-							  GPREGS_UNIT0_ID,
-							  HIVE_ISYS_GPREG_MUX_IDX,
-							  (input_system_multiplex_t)port);
+			input_system_sub_system_reg_store(
+				INPUT_SYSTEM0_ID, GPREGS_UNIT0_ID,
+				HIVE_ISYS_GPREG_MUX_IDX,
+				(input_system_multiplex_t)port);
 		} else {
 			/*
 			 * AM: A bit of a hack, wiring the input system.
 			 */
-			input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
-							  GPREGS_UNIT0_ID,
-							  HIVE_ISYS_GPREG_MULTICAST_A_IDX
-							  + (unsigned int)port,
-							  INPUT_SYSTEM_INPUT_BUFFER);
-			input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
-							  GPREGS_UNIT0_ID,
-							  HIVE_ISYS_GPREG_MUX_IDX,
-							  INPUT_SYSTEM_ACQUISITION_UNIT);
+			input_system_sub_system_reg_store(
+				INPUT_SYSTEM0_ID, GPREGS_UNIT0_ID,
+				HIVE_ISYS_GPREG_MULTICAST_A_IDX +
+					(unsigned int)port,
+				INPUT_SYSTEM_INPUT_BUFFER);
+			input_system_sub_system_reg_store(
+				INPUT_SYSTEM0_ID, GPREGS_UNIT0_ID,
+				HIVE_ISYS_GPREG_MUX_IDX,
+				INPUT_SYSTEM_ACQUISITION_UNIT);
 		}
 	}
 	/*
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/virtual_isys.c b/drivers/staging/media/atomisp/pci/runtime/isys/src/virtual_isys.c
index b5395aea89fc703c9fafc24d8f1947c3de8abb08..0e914f6361b00f059514e932d71d6bbd30706458 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/virtual_isys.c
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/virtual_isys.c
@@ -10,7 +10,6 @@
 
 #include "system_global.h"
 
-
 #include "ia_css_isys.h"
 #include "ia_css_debug.h"
 #include "virtual_isys.h"
@@ -23,117 +22,90 @@
  *
  *************************************************/
 
-static bool create_input_system_channel(
-    isp2401_input_system_cfg_t	*cfg,
-    bool			metadata,
-    input_system_channel_t	*channel);
+static bool create_input_system_channel(isp2401_input_system_cfg_t *cfg,
+					bool metadata,
+					input_system_channel_t *channel);
 
-static void destroy_input_system_channel(
-    input_system_channel_t	*channel);
+static void destroy_input_system_channel(input_system_channel_t *channel);
 
-static bool create_input_system_input_port(
-    isp2401_input_system_cfg_t		*cfg,
-    input_system_input_port_t	*input_port);
+static bool
+create_input_system_input_port(isp2401_input_system_cfg_t *cfg,
+			       input_system_input_port_t *input_port);
 
-static void destroy_input_system_input_port(
-    input_system_input_port_t	*input_port);
+static void
+destroy_input_system_input_port(input_system_input_port_t *input_port);
 
 static bool calculate_input_system_channel_cfg(
-    input_system_channel_t		*channel,
-    input_system_input_port_t	*input_port,
-    isp2401_input_system_cfg_t		*isys_cfg,
-    input_system_channel_cfg_t	*channel_cfg,
-    bool metadata);
+	input_system_channel_t *channel, input_system_input_port_t *input_port,
+	isp2401_input_system_cfg_t *isys_cfg,
+	input_system_channel_cfg_t *channel_cfg, bool metadata);
 
 static bool calculate_input_system_input_port_cfg(
-    input_system_channel_t		*channel,
-    input_system_input_port_t	*input_port,
-    isp2401_input_system_cfg_t		*isys_cfg,
-    input_system_input_port_cfg_t	*input_port_cfg);
-
-static bool acquire_sid(
-    stream2mmio_ID_t	stream2mmio,
-    stream2mmio_sid_ID_t	*sid);
-
-static void release_sid(
-    stream2mmio_ID_t	stream2mmio,
-    stream2mmio_sid_ID_t	*sid);
-
-static bool acquire_ib_buffer(
-    s32 bits_per_pixel,
-    s32 pixels_per_line,
-    s32 lines_per_frame,
-    s32 align_in_bytes,
-    bool online,
-    isp2401_ib_buffer_t *buf);
-
-static void release_ib_buffer(
-    isp2401_ib_buffer_t *buf);
-
-static bool acquire_dma_channel(
-    isys2401_dma_ID_t	dma_id,
-    isys2401_dma_channel	*channel);
-
-static void release_dma_channel(
-    isys2401_dma_ID_t	dma_id,
-    isys2401_dma_channel	*channel);
-
-static bool acquire_be_lut_entry(
-    csi_rx_backend_ID_t		backend,
-    csi_mipi_packet_type_t		packet_type,
-    csi_rx_backend_lut_entry_t	*entry);
-
-static void release_be_lut_entry(
-    csi_rx_backend_ID_t		backend,
-    csi_mipi_packet_type_t		packet_type,
-    csi_rx_backend_lut_entry_t	*entry);
-
-static bool calculate_prbs_cfg(
-    input_system_channel_t		*channel,
-    input_system_input_port_t	*input_port,
-    isp2401_input_system_cfg_t		*isys_cfg,
-    pixelgen_prbs_cfg_t		*cfg);
-
-static bool calculate_fe_cfg(
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    csi_rx_frontend_cfg_t		*cfg);
-
-static bool calculate_be_cfg(
-    const input_system_input_port_t	*input_port,
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    bool				metadata,
-    csi_rx_backend_cfg_t		*cfg);
-
-static bool calculate_stream2mmio_cfg(
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    bool				metadata,
-    stream2mmio_cfg_t		*cfg);
-
-static bool calculate_ibuf_ctrl_cfg(
-    const input_system_channel_t	*channel,
-    const input_system_input_port_t	*input_port,
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    ibuf_ctrl_cfg_t			*cfg);
-
-static bool calculate_isys2401_dma_cfg(
-    const input_system_channel_t	*channel,
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    isys2401_dma_cfg_t		*cfg);
-
-static bool calculate_isys2401_dma_port_cfg(
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    bool				raw_packed,
-    bool				metadata,
-    isys2401_dma_port_cfg_t		*cfg);
-
-static csi_mipi_packet_type_t get_csi_mipi_packet_type(
-    int32_t data_type);
-
-static int32_t calculate_stride(
-    s32 bits_per_pixel,
-    s32 pixels_per_line,
-    bool	raw_packed,
-    int32_t	align_in_bytes);
+	input_system_channel_t *channel, input_system_input_port_t *input_port,
+	isp2401_input_system_cfg_t *isys_cfg,
+	input_system_input_port_cfg_t *input_port_cfg);
+
+static bool acquire_sid(stream2mmio_ID_t stream2mmio,
+			stream2mmio_sid_ID_t *sid);
+
+static void release_sid(stream2mmio_ID_t stream2mmio,
+			stream2mmio_sid_ID_t *sid);
+
+static bool acquire_ib_buffer(s32 bits_per_pixel, s32 pixels_per_line,
+			      s32 lines_per_frame, s32 align_in_bytes,
+			      bool online, isp2401_ib_buffer_t *buf);
+
+static void release_ib_buffer(isp2401_ib_buffer_t *buf);
+
+static bool acquire_dma_channel(isys2401_dma_ID_t dma_id,
+				isys2401_dma_channel *channel);
+
+static void release_dma_channel(isys2401_dma_ID_t dma_id,
+				isys2401_dma_channel *channel);
+
+static bool acquire_be_lut_entry(csi_rx_backend_ID_t backend,
+				 csi_mipi_packet_type_t packet_type,
+				 csi_rx_backend_lut_entry_t *entry);
+
+static void release_be_lut_entry(csi_rx_backend_ID_t backend,
+				 csi_mipi_packet_type_t packet_type,
+				 csi_rx_backend_lut_entry_t *entry);
+
+static bool calculate_prbs_cfg(input_system_channel_t *channel,
+			       input_system_input_port_t *input_port,
+			       isp2401_input_system_cfg_t *isys_cfg,
+			       pixelgen_prbs_cfg_t *cfg);
+
+static bool calculate_fe_cfg(const isp2401_input_system_cfg_t *isys_cfg,
+			     csi_rx_frontend_cfg_t *cfg);
+
+static bool calculate_be_cfg(const input_system_input_port_t *input_port,
+			     const isp2401_input_system_cfg_t *isys_cfg,
+			     bool metadata, csi_rx_backend_cfg_t *cfg);
+
+static bool
+calculate_stream2mmio_cfg(const isp2401_input_system_cfg_t *isys_cfg,
+			  bool metadata, stream2mmio_cfg_t *cfg);
+
+static bool calculate_ibuf_ctrl_cfg(const input_system_channel_t *channel,
+				    const input_system_input_port_t *input_port,
+				    const isp2401_input_system_cfg_t *isys_cfg,
+				    ibuf_ctrl_cfg_t *cfg);
+
+static bool
+calculate_isys2401_dma_cfg(const input_system_channel_t *channel,
+			   const isp2401_input_system_cfg_t *isys_cfg,
+			   isys2401_dma_cfg_t *cfg);
+
+static bool
+calculate_isys2401_dma_port_cfg(const isp2401_input_system_cfg_t *isys_cfg,
+				bool raw_packed, bool metadata,
+				isys2401_dma_port_cfg_t *cfg);
+
+static csi_mipi_packet_type_t get_csi_mipi_packet_type(int32_t data_type);
+
+static int32_t calculate_stride(s32 bits_per_pixel, s32 pixels_per_line,
+				bool raw_packed, int32_t align_in_bytes);
 
 /* end of Forwarded Declaration */
 
@@ -142,16 +114,16 @@ static int32_t calculate_stride(
  * Public Methods
  *
  **************************************************/
-ia_css_isys_error_t ia_css_isys_stream_create(
-    ia_css_isys_descr_t	*isys_stream_descr,
-    ia_css_isys_stream_h	isys_stream,
-    uint32_t isys_stream_id)
+ia_css_isys_error_t
+ia_css_isys_stream_create(ia_css_isys_descr_t *isys_stream_descr,
+			  ia_css_isys_stream_h isys_stream,
+			  uint32_t isys_stream_id)
 {
 	ia_css_isys_error_t rc;
 
 	if (!isys_stream_descr || !isys_stream ||
 	    isys_stream_id >= SH_CSS_MAX_ISYS_CHANNEL_NODES)
-		return	false;
+		return false;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_isys_stream_create() enter:\n");
@@ -161,7 +133,8 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 	isys_stream->enable_metadata = isys_stream_descr->metadata.enable;
 	isys_stream->id = isys_stream_id;
 
-	isys_stream->linked_isys_stream_id = isys_stream_descr->linked_isys_stream_id;
+	isys_stream->linked_isys_stream_id =
+		isys_stream_descr->linked_isys_stream_id;
 	rc = create_input_system_input_port(isys_stream_descr,
 					    &isys_stream->input_port);
 	if (!rc)
@@ -179,7 +152,8 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 		rc = create_input_system_channel(isys_stream_descr, true,
 						 &isys_stream->md_channel);
 		if (!rc) {
-			destroy_input_system_input_port(&isys_stream->input_port);
+			destroy_input_system_input_port(
+				&isys_stream->input_port);
 			destroy_input_system_channel(&isys_stream->channel);
 			return false;
 		}
@@ -190,8 +164,7 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 	return true;
 }
 
-void ia_css_isys_stream_destroy(
-    ia_css_isys_stream_h	isys_stream)
+void ia_css_isys_stream_destroy(ia_css_isys_stream_h isys_stream)
 {
 	destroy_input_system_input_port(&isys_stream->input_port);
 	destroy_input_system_channel(&isys_stream->channel);
@@ -201,48 +174,39 @@ void ia_css_isys_stream_destroy(
 	}
 }
 
-ia_css_isys_error_t ia_css_isys_stream_calculate_cfg(
-    ia_css_isys_stream_h		isys_stream,
-    ia_css_isys_descr_t		*isys_stream_descr,
-    ia_css_isys_stream_cfg_t	*isys_stream_cfg)
+ia_css_isys_error_t
+ia_css_isys_stream_calculate_cfg(ia_css_isys_stream_h isys_stream,
+				 ia_css_isys_descr_t *isys_stream_descr,
+				 ia_css_isys_stream_cfg_t *isys_stream_cfg)
 {
 	ia_css_isys_error_t rc;
 
-	if (!isys_stream_cfg		||
-	    !isys_stream_descr	||
-	    !isys_stream)
+	if (!isys_stream_cfg || !isys_stream_descr || !isys_stream)
 		return false;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_isys_stream_calculate_cfg() enter:\n");
 
-	rc  = calculate_input_system_channel_cfg(
-		  &isys_stream->channel,
-		  &isys_stream->input_port,
-		  isys_stream_descr,
-		  &isys_stream_cfg->channel_cfg,
-		  false);
+	rc = calculate_input_system_channel_cfg(
+		&isys_stream->channel, &isys_stream->input_port,
+		isys_stream_descr, &isys_stream_cfg->channel_cfg, false);
 	if (!rc)
 		return false;
 
 	/* configure metadata channel */
 	if (isys_stream_descr->metadata.enable) {
 		isys_stream_cfg->enable_metadata = true;
-		rc  = calculate_input_system_channel_cfg(
-			  &isys_stream->md_channel,
-			  &isys_stream->input_port,
-			  isys_stream_descr,
-			  &isys_stream_cfg->md_channel_cfg,
-			  true);
+		rc = calculate_input_system_channel_cfg(
+			&isys_stream->md_channel, &isys_stream->input_port,
+			isys_stream_descr, &isys_stream_cfg->md_channel_cfg,
+			true);
 		if (!rc)
 			return false;
 	}
 
 	rc = calculate_input_system_input_port_cfg(
-		 &isys_stream->channel,
-		 &isys_stream->input_port,
-		 isys_stream_descr,
-		 &isys_stream_cfg->input_port_cfg);
+		&isys_stream->channel, &isys_stream->input_port,
+		isys_stream_descr, &isys_stream_cfg->input_port_cfg);
 	if (!rc)
 		return false;
 
@@ -260,10 +224,9 @@ ia_css_isys_error_t ia_css_isys_stream_calculate_cfg(
  * Private Methods
  *
  **************************************************/
-static bool create_input_system_channel(
-    isp2401_input_system_cfg_t	*cfg,
-    bool			metadata,
-    input_system_channel_t	*me)
+static bool create_input_system_channel(isp2401_input_system_cfg_t *cfg,
+					bool metadata,
+					input_system_channel_t *me)
 {
 	bool rc = true;
 
@@ -300,16 +263,15 @@ static bool create_input_system_channel(
 	}
 
 	if (!acquire_ib_buffer(
-		metadata ? cfg->metadata.bits_per_pixel :
-		cfg->input_port_resolution.bits_per_pixel,
-		metadata ? cfg->metadata.pixels_per_line :
-		cfg->input_port_resolution.pixels_per_line,
-		metadata ? cfg->metadata.lines_per_frame :
-		cfg->input_port_resolution.lines_per_frame,
-		metadata ? cfg->metadata.align_req_in_bytes :
-		cfg->input_port_resolution.align_req_in_bytes,
-		cfg->online,
-		&me->ib_buffer)) {
+		    metadata ? cfg->metadata.bits_per_pixel :
+			       cfg->input_port_resolution.bits_per_pixel,
+		    metadata ? cfg->metadata.pixels_per_line :
+			       cfg->input_port_resolution.pixels_per_line,
+		    metadata ? cfg->metadata.lines_per_frame :
+			       cfg->input_port_resolution.lines_per_frame,
+		    metadata ? cfg->metadata.align_req_in_bytes :
+			       cfg->input_port_resolution.align_req_in_bytes,
+		    cfg->online, &me->ib_buffer)) {
 		release_sid(me->stream2mmio_id, &me->stream2mmio_sid_id);
 		return false;
 	}
@@ -323,20 +285,17 @@ static bool create_input_system_channel(
 	return true;
 }
 
-static void destroy_input_system_channel(
-    input_system_channel_t	*me)
+static void destroy_input_system_channel(input_system_channel_t *me)
 {
-	release_sid(me->stream2mmio_id,
-		    &me->stream2mmio_sid_id);
+	release_sid(me->stream2mmio_id, &me->stream2mmio_sid_id);
 
 	release_ib_buffer(&me->ib_buffer);
 
 	release_dma_channel(me->dma_id, &me->dma_channel);
 }
 
-static bool create_input_system_input_port(
-    isp2401_input_system_cfg_t		*cfg,
-    input_system_input_port_t	*me)
+static bool create_input_system_input_port(isp2401_input_system_cfg_t *cfg,
+					   input_system_input_port_t *me)
 {
 	csi_mipi_packet_type_t packet_type;
 	bool rc = true;
@@ -346,13 +305,12 @@ static bool create_input_system_input_port(
 		me->csi_rx.frontend_id = CSI_RX_FRONTEND0_ID;
 		me->csi_rx.backend_id = CSI_RX_BACKEND0_ID;
 
-		packet_type = get_csi_mipi_packet_type(cfg->csi_port_attr.fmt_type);
+		packet_type =
+			get_csi_mipi_packet_type(cfg->csi_port_attr.fmt_type);
 		me->csi_rx.packet_type = packet_type;
 
-		rc = acquire_be_lut_entry(
-			 me->csi_rx.backend_id,
-			 packet_type,
-			 &me->csi_rx.backend_lut_entry);
+		rc = acquire_be_lut_entry(me->csi_rx.backend_id, packet_type,
+					  &me->csi_rx.backend_lut_entry);
 		break;
 	case INPUT_SYSTEM_PIXELGEN_PORT0_ID:
 		me->pixelgen.pixelgen_id = PIXELGEN0_ID;
@@ -361,13 +319,12 @@ static bool create_input_system_input_port(
 		me->csi_rx.frontend_id = CSI_RX_FRONTEND1_ID;
 		me->csi_rx.backend_id = CSI_RX_BACKEND1_ID;
 
-		packet_type = get_csi_mipi_packet_type(cfg->csi_port_attr.fmt_type);
+		packet_type =
+			get_csi_mipi_packet_type(cfg->csi_port_attr.fmt_type);
 		me->csi_rx.packet_type = packet_type;
 
-		rc = acquire_be_lut_entry(
-			 me->csi_rx.backend_id,
-			 packet_type,
-			 &me->csi_rx.backend_lut_entry);
+		rc = acquire_be_lut_entry(me->csi_rx.backend_id, packet_type,
+					  &me->csi_rx.backend_lut_entry);
 		break;
 	case INPUT_SYSTEM_PIXELGEN_PORT1_ID:
 		me->pixelgen.pixelgen_id = PIXELGEN1_ID;
@@ -377,13 +334,12 @@ static bool create_input_system_input_port(
 		me->csi_rx.frontend_id = CSI_RX_FRONTEND2_ID;
 		me->csi_rx.backend_id = CSI_RX_BACKEND2_ID;
 
-		packet_type = get_csi_mipi_packet_type(cfg->csi_port_attr.fmt_type);
+		packet_type =
+			get_csi_mipi_packet_type(cfg->csi_port_attr.fmt_type);
 		me->csi_rx.packet_type = packet_type;
 
-		rc = acquire_be_lut_entry(
-			 me->csi_rx.backend_id,
-			 packet_type,
-			 &me->csi_rx.backend_lut_entry);
+		rc = acquire_be_lut_entry(me->csi_rx.backend_id, packet_type,
+					  &me->csi_rx.backend_lut_entry);
 		break;
 	case INPUT_SYSTEM_PIXELGEN_PORT2_ID:
 		me->pixelgen.pixelgen_id = PIXELGEN2_ID;
@@ -398,42 +354,36 @@ static bool create_input_system_input_port(
 	/* for metadata */
 	me->metadata.packet_type = CSI_MIPI_PACKET_TYPE_UNDEFINED;
 	if (rc && cfg->metadata.enable) {
-		me->metadata.packet_type = get_csi_mipi_packet_type(
-					       cfg->metadata.fmt_type);
-		rc = acquire_be_lut_entry(
-			 me->csi_rx.backend_id,
-			 me->metadata.packet_type,
-			 &me->metadata.backend_lut_entry);
+		me->metadata.packet_type =
+			get_csi_mipi_packet_type(cfg->metadata.fmt_type);
+		rc = acquire_be_lut_entry(me->csi_rx.backend_id,
+					  me->metadata.packet_type,
+					  &me->metadata.backend_lut_entry);
 	}
 
 	return rc;
 }
 
-static void destroy_input_system_input_port(
-    input_system_input_port_t	*me)
+static void destroy_input_system_input_port(input_system_input_port_t *me)
 {
 	if (me->source_type == INPUT_SYSTEM_SOURCE_TYPE_SENSOR) {
-		release_be_lut_entry(
-		    me->csi_rx.backend_id,
-		    me->csi_rx.packet_type,
-		    &me->csi_rx.backend_lut_entry);
+		release_be_lut_entry(me->csi_rx.backend_id,
+				     me->csi_rx.packet_type,
+				     &me->csi_rx.backend_lut_entry);
 	}
 
 	if (me->metadata.packet_type != CSI_MIPI_PACKET_TYPE_UNDEFINED) {
 		/*Free the backend lut allocated for metadata*/
-		release_be_lut_entry(
-		    me->csi_rx.backend_id,
-		    me->metadata.packet_type,
-		    &me->metadata.backend_lut_entry);
+		release_be_lut_entry(me->csi_rx.backend_id,
+				     me->metadata.packet_type,
+				     &me->metadata.backend_lut_entry);
 	}
 }
 
 static bool calculate_input_system_channel_cfg(
-    input_system_channel_t		*channel,
-    input_system_input_port_t	*input_port,
-    isp2401_input_system_cfg_t		*isys_cfg,
-    input_system_channel_cfg_t	*channel_cfg,
-    bool metadata)
+	input_system_channel_t *channel, input_system_input_port_t *input_port,
+	isp2401_input_system_cfg_t *isys_cfg,
+	input_system_channel_cfg_t *channel_cfg, bool metadata)
 {
 	bool rc;
 
@@ -442,37 +392,27 @@ static bool calculate_input_system_channel_cfg(
 	if (!rc)
 		return false;
 
-	rc = calculate_ibuf_ctrl_cfg(
-		 channel,
-		 input_port,
-		 isys_cfg,
-		 &channel_cfg->ibuf_ctrl_cfg);
+	rc = calculate_ibuf_ctrl_cfg(channel, input_port, isys_cfg,
+				     &channel_cfg->ibuf_ctrl_cfg);
 	if (!rc)
 		return false;
 	if (metadata)
 		channel_cfg->ibuf_ctrl_cfg.stores_per_frame =
-		    isys_cfg->metadata.lines_per_frame;
+			isys_cfg->metadata.lines_per_frame;
 
-	rc = calculate_isys2401_dma_cfg(
-		 channel,
-		 isys_cfg,
-		 &channel_cfg->dma_cfg);
+	rc = calculate_isys2401_dma_cfg(channel, isys_cfg,
+					&channel_cfg->dma_cfg);
 	if (!rc)
 		return false;
 
-	rc = calculate_isys2401_dma_port_cfg(
-		 isys_cfg,
-		 false,
-		 metadata,
-		 &channel_cfg->dma_src_port_cfg);
+	rc = calculate_isys2401_dma_port_cfg(isys_cfg, false, metadata,
+					     &channel_cfg->dma_src_port_cfg);
 	if (!rc)
 		return false;
 
-	rc = calculate_isys2401_dma_port_cfg(
-		 isys_cfg,
-		 isys_cfg->raw_packed,
-		 metadata,
-		 &channel_cfg->dma_dest_port_cfg);
+	rc = calculate_isys2401_dma_port_cfg(isys_cfg, isys_cfg->raw_packed,
+					     metadata,
+					     &channel_cfg->dma_dest_port_cfg);
 	if (!rc)
 		return false;
 
@@ -480,35 +420,28 @@ static bool calculate_input_system_channel_cfg(
 }
 
 static bool calculate_input_system_input_port_cfg(
-    input_system_channel_t		*channel,
-    input_system_input_port_t	*input_port,
-    isp2401_input_system_cfg_t		*isys_cfg,
-    input_system_input_port_cfg_t	*input_port_cfg)
+	input_system_channel_t *channel, input_system_input_port_t *input_port,
+	isp2401_input_system_cfg_t *isys_cfg,
+	input_system_input_port_cfg_t *input_port_cfg)
 {
 	bool rc;
 
 	switch (input_port->source_type) {
 	case INPUT_SYSTEM_SOURCE_TYPE_SENSOR:
-		rc  = calculate_fe_cfg(
-			  isys_cfg,
-			  &input_port_cfg->csi_rx_cfg.frontend_cfg);
+		rc = calculate_fe_cfg(isys_cfg,
+				      &input_port_cfg->csi_rx_cfg.frontend_cfg);
 
-		rc &= calculate_be_cfg(
-			  input_port,
-			  isys_cfg,
-			  false,
-			  &input_port_cfg->csi_rx_cfg.backend_cfg);
+		rc &= calculate_be_cfg(input_port, isys_cfg, false,
+				       &input_port_cfg->csi_rx_cfg.backend_cfg);
 
 		if (rc && isys_cfg->metadata.enable)
-			rc &= calculate_be_cfg(input_port, isys_cfg, true,
-					       &input_port_cfg->csi_rx_cfg.md_backend_cfg);
+			rc &= calculate_be_cfg(
+				input_port, isys_cfg, true,
+				&input_port_cfg->csi_rx_cfg.md_backend_cfg);
 		break;
 	case INPUT_SYSTEM_SOURCE_TYPE_PRBS:
-		rc = calculate_prbs_cfg(
-			 channel,
-			 input_port,
-			 isys_cfg,
-			 &input_port_cfg->pixelgen_cfg.prbs_cfg);
+		rc = calculate_prbs_cfg(channel, input_port, isys_cfg,
+					&input_port_cfg->pixelgen_cfg.prbs_cfg);
 		break;
 	default:
 		rc = false;
@@ -518,26 +451,19 @@ static bool calculate_input_system_input_port_cfg(
 	return rc;
 }
 
-static bool acquire_sid(
-    stream2mmio_ID_t	stream2mmio,
-    stream2mmio_sid_ID_t	*sid)
+static bool acquire_sid(stream2mmio_ID_t stream2mmio, stream2mmio_sid_ID_t *sid)
 {
 	return ia_css_isys_stream2mmio_sid_rmgr_acquire(stream2mmio, sid);
 }
 
-static void release_sid(
-    stream2mmio_ID_t	stream2mmio,
-    stream2mmio_sid_ID_t	*sid)
+static void release_sid(stream2mmio_ID_t stream2mmio, stream2mmio_sid_ID_t *sid)
 {
 	ia_css_isys_stream2mmio_sid_rmgr_release(stream2mmio, sid);
 }
 
 /* See also: ia_css_dma_configure_from_info() */
-static int32_t calculate_stride(
-    s32 bits_per_pixel,
-    s32 pixels_per_line,
-    bool	raw_packed,
-    int32_t align_in_bytes)
+static int32_t calculate_stride(s32 bits_per_pixel, s32 pixels_per_line,
+				bool raw_packed, int32_t align_in_bytes)
 {
 	s32 bytes_per_line;
 	s32 pixels_per_word;
@@ -550,19 +476,15 @@ static int32_t calculate_stride(
 		bits_per_pixel = CEIL_MUL(bits_per_pixel, 8);
 
 	pixels_per_word = HIVE_ISP_DDR_WORD_BITS / bits_per_pixel;
-	words_per_line  = DIV_ROUND_UP(pixels_per_line_padded, pixels_per_word);
-	bytes_per_line  = HIVE_ISP_DDR_WORD_BYTES * words_per_line;
+	words_per_line = DIV_ROUND_UP(pixels_per_line_padded, pixels_per_word);
+	bytes_per_line = HIVE_ISP_DDR_WORD_BYTES * words_per_line;
 
 	return bytes_per_line;
 }
 
-static bool acquire_ib_buffer(
-    s32 bits_per_pixel,
-    s32 pixels_per_line,
-    s32 lines_per_frame,
-    s32 align_in_bytes,
-    bool online,
-    isp2401_ib_buffer_t *buf)
+static bool acquire_ib_buffer(s32 bits_per_pixel, s32 pixels_per_line,
+			      s32 lines_per_frame, s32 align_in_bytes,
+			      bool online, isp2401_ib_buffer_t *buf)
 {
 	buf->stride = calculate_stride(bits_per_pixel, pixels_per_line, false,
 				       align_in_bytes);
@@ -576,111 +498,103 @@ static bool acquire_ib_buffer(
 					     &buf->start_addr);
 }
 
-static void release_ib_buffer(
-    isp2401_ib_buffer_t *buf)
+static void release_ib_buffer(isp2401_ib_buffer_t *buf)
 {
 	ia_css_isys_ibuf_rmgr_release(&buf->start_addr);
 }
 
-static bool acquire_dma_channel(
-    isys2401_dma_ID_t	dma_id,
-    isys2401_dma_channel	*channel)
+static bool acquire_dma_channel(isys2401_dma_ID_t dma_id,
+				isys2401_dma_channel *channel)
 {
 	return ia_css_isys_dma_channel_rmgr_acquire(dma_id, channel);
 }
 
-static void release_dma_channel(
-    isys2401_dma_ID_t	dma_id,
-    isys2401_dma_channel	*channel)
+static void release_dma_channel(isys2401_dma_ID_t dma_id,
+				isys2401_dma_channel *channel)
 {
 	ia_css_isys_dma_channel_rmgr_release(dma_id, channel);
 }
 
-static bool acquire_be_lut_entry(
-    csi_rx_backend_ID_t		backend,
-    csi_mipi_packet_type_t		packet_type,
-    csi_rx_backend_lut_entry_t	*entry)
+static bool acquire_be_lut_entry(csi_rx_backend_ID_t backend,
+				 csi_mipi_packet_type_t packet_type,
+				 csi_rx_backend_lut_entry_t *entry)
 {
 	return ia_css_isys_csi_rx_lut_rmgr_acquire(backend, packet_type, entry);
 }
 
-static void release_be_lut_entry(
-    csi_rx_backend_ID_t		backend,
-    csi_mipi_packet_type_t		packet_type,
-    csi_rx_backend_lut_entry_t	*entry)
+static void release_be_lut_entry(csi_rx_backend_ID_t backend,
+				 csi_mipi_packet_type_t packet_type,
+				 csi_rx_backend_lut_entry_t *entry)
 {
 	ia_css_isys_csi_rx_lut_rmgr_release(backend, packet_type, entry);
 }
 
-static bool calculate_prbs_cfg(
-    input_system_channel_t		*channel,
-    input_system_input_port_t	*input_port,
-    isp2401_input_system_cfg_t		*isys_cfg,
-    pixelgen_prbs_cfg_t		*cfg)
+static bool calculate_prbs_cfg(input_system_channel_t *channel,
+			       input_system_input_port_t *input_port,
+			       isp2401_input_system_cfg_t *isys_cfg,
+			       pixelgen_prbs_cfg_t *cfg)
 {
 	memcpy(cfg, &isys_cfg->prbs_port_attr, sizeof(pixelgen_prbs_cfg_t));
 
 	return true;
 }
 
-static bool calculate_fe_cfg(
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    csi_rx_frontend_cfg_t		*cfg)
+static bool calculate_fe_cfg(const isp2401_input_system_cfg_t *isys_cfg,
+			     csi_rx_frontend_cfg_t *cfg)
 {
 	cfg->active_lanes = isys_cfg->csi_port_attr.active_lanes;
 	return true;
 }
 
-static bool calculate_be_cfg(
-    const input_system_input_port_t	*input_port,
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    bool				metadata,
-    csi_rx_backend_cfg_t		*cfg)
+static bool calculate_be_cfg(const input_system_input_port_t *input_port,
+			     const isp2401_input_system_cfg_t *isys_cfg,
+			     bool metadata, csi_rx_backend_cfg_t *cfg)
 {
 	memcpy(&cfg->lut_entry,
-	      metadata ? &input_port->metadata.backend_lut_entry :
-			 &input_port->csi_rx.backend_lut_entry,
-	      sizeof(csi_rx_backend_lut_entry_t));
+	       metadata ? &input_port->metadata.backend_lut_entry :
+			  &input_port->csi_rx.backend_lut_entry,
+	       sizeof(csi_rx_backend_lut_entry_t));
 
 	cfg->csi_mipi_cfg.virtual_channel = isys_cfg->csi_port_attr.ch_id;
 	if (metadata) {
-		cfg->csi_mipi_packet_type = get_csi_mipi_packet_type(
-						isys_cfg->metadata.fmt_type);
+		cfg->csi_mipi_packet_type =
+			get_csi_mipi_packet_type(isys_cfg->metadata.fmt_type);
 		cfg->csi_mipi_cfg.comp_enable = false;
 		cfg->csi_mipi_cfg.data_type = isys_cfg->metadata.fmt_type;
 	} else {
 		cfg->csi_mipi_packet_type = get_csi_mipi_packet_type(
-						isys_cfg->csi_port_attr.fmt_type);
+			isys_cfg->csi_port_attr.fmt_type);
 		cfg->csi_mipi_cfg.data_type = isys_cfg->csi_port_attr.fmt_type;
-		cfg->csi_mipi_cfg.comp_enable = isys_cfg->csi_port_attr.comp_enable;
-		cfg->csi_mipi_cfg.comp_scheme = isys_cfg->csi_port_attr.comp_scheme;
-		cfg->csi_mipi_cfg.comp_predictor = isys_cfg->csi_port_attr.comp_predictor;
-		cfg->csi_mipi_cfg.comp_bit_idx = cfg->csi_mipi_cfg.data_type -
-						 MIPI_FORMAT_2401_CUSTOM0;
+		cfg->csi_mipi_cfg.comp_enable =
+			isys_cfg->csi_port_attr.comp_enable;
+		cfg->csi_mipi_cfg.comp_scheme =
+			isys_cfg->csi_port_attr.comp_scheme;
+		cfg->csi_mipi_cfg.comp_predictor =
+			isys_cfg->csi_port_attr.comp_predictor;
+		cfg->csi_mipi_cfg.comp_bit_idx =
+			cfg->csi_mipi_cfg.data_type - MIPI_FORMAT_2401_CUSTOM0;
 	}
 
 	return true;
 }
 
-static bool calculate_stream2mmio_cfg(
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    bool				metadata,
-    stream2mmio_cfg_t		*cfg
-)
+static bool
+calculate_stream2mmio_cfg(const isp2401_input_system_cfg_t *isys_cfg,
+			  bool metadata, stream2mmio_cfg_t *cfg)
 {
-	cfg->bits_per_pixel = metadata ? isys_cfg->metadata.bits_per_pixel :
-			      isys_cfg->input_port_resolution.bits_per_pixel;
+	cfg->bits_per_pixel =
+		metadata ? isys_cfg->metadata.bits_per_pixel :
+			   isys_cfg->input_port_resolution.bits_per_pixel;
 
 	cfg->enable_blocking = isys_cfg->mode == INPUT_SYSTEM_SOURCE_TYPE_PRBS;
 
 	return true;
 }
 
-static bool calculate_ibuf_ctrl_cfg(
-    const input_system_channel_t	*channel,
-    const input_system_input_port_t	*input_port,
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    ibuf_ctrl_cfg_t			*cfg)
+static bool calculate_ibuf_ctrl_cfg(const input_system_channel_t *channel,
+				    const input_system_input_port_t *input_port,
+				    const isp2401_input_system_cfg_t *isys_cfg,
+				    ibuf_ctrl_cfg_t *cfg)
 {
 	s32 bits_per_pixel;
 	s32 bytes_per_pixel;
@@ -691,21 +605,22 @@ static bool calculate_ibuf_ctrl_cfg(
 	bits_per_pixel = isys_cfg->input_port_resolution.bits_per_pixel;
 	bytes_per_pixel = BITS_TO_BYTES(bits_per_pixel);
 
-	left_padding = CEIL_MUL(isys_cfg->output_port_attr.left_padding, ISP_VEC_NELEMS)
-		       * bytes_per_pixel;
+	left_padding = CEIL_MUL(isys_cfg->output_port_attr.left_padding,
+				ISP_VEC_NELEMS) *
+		       bytes_per_pixel;
 
-	cfg->online	= isys_cfg->online;
+	cfg->online = isys_cfg->online;
 
-	cfg->dma_cfg.channel	= channel->dma_channel;
-	cfg->dma_cfg.cmd	= _DMA_V2_MOVE_A2B_NO_SYNC_CHK_COMMAND;
+	cfg->dma_cfg.channel = channel->dma_channel;
+	cfg->dma_cfg.cmd = _DMA_V2_MOVE_A2B_NO_SYNC_CHK_COMMAND;
 
-	cfg->dma_cfg.shift_returned_items	= 0;
-	cfg->dma_cfg.elems_per_word_in_ibuf	= 0;
-	cfg->dma_cfg.elems_per_word_in_dest	= 0;
+	cfg->dma_cfg.shift_returned_items = 0;
+	cfg->dma_cfg.elems_per_word_in_ibuf = 0;
+	cfg->dma_cfg.elems_per_word_in_dest = 0;
 
-	cfg->ib_buffer.start_addr		= channel->ib_buffer.start_addr;
-	cfg->ib_buffer.stride			= channel->ib_buffer.stride;
-	cfg->ib_buffer.lines			= channel->ib_buffer.lines;
+	cfg->ib_buffer.start_addr = channel->ib_buffer.start_addr;
+	cfg->ib_buffer.stride = channel->ib_buffer.stride;
+	cfg->ib_buffer.lines = channel->ib_buffer.lines;
 
 	/*
 	#ifndef ISP2401
@@ -722,17 +637,20 @@ static bool calculate_ibuf_ctrl_cfg(
 	   this buffer is allocated in isp, crun mode addr
 	   can be passed by after ISP allocation */
 	if (cfg->online) {
-		cfg->dest_buf_cfg.start_addr	= ISP_INPUT_BUF_START_ADDR + left_padding;
-		cfg->dest_buf_cfg.stride	= bytes_per_pixel
-					      * isys_cfg->output_port_attr.max_isp_input_width;
-		cfg->dest_buf_cfg.lines		= LINES_OF_ISP_INPUT_BUF;
+		cfg->dest_buf_cfg.start_addr =
+			ISP_INPUT_BUF_START_ADDR + left_padding;
+		cfg->dest_buf_cfg.stride =
+			bytes_per_pixel *
+			isys_cfg->output_port_attr.max_isp_input_width;
+		cfg->dest_buf_cfg.lines = LINES_OF_ISP_INPUT_BUF;
 	} else if (isys_cfg->raw_packed) {
-		cfg->dest_buf_cfg.stride	= calculate_stride(bits_per_pixel,
-					      isys_cfg->input_port_resolution.pixels_per_line,
-					      isys_cfg->raw_packed,
-					      isys_cfg->input_port_resolution.align_req_in_bytes);
+		cfg->dest_buf_cfg.stride = calculate_stride(
+			bits_per_pixel,
+			isys_cfg->input_port_resolution.pixels_per_line,
+			isys_cfg->raw_packed,
+			isys_cfg->input_port_resolution.align_req_in_bytes);
 	} else {
-		cfg->dest_buf_cfg.stride	= channel->ib_buffer.stride;
+		cfg->dest_buf_cfg.stride = channel->ib_buffer.stride;
 	}
 
 	/*
@@ -746,24 +664,24 @@ static bool calculate_ibuf_ctrl_cfg(
 	 * configure "items_per_store" so that it can also handle the CSI-MIPI
 	 * short packet.
 	 */
-	cfg->items_per_store		= 1;
+	cfg->items_per_store = 1;
 
-	cfg->stores_per_frame		= isys_cfg->input_port_resolution.lines_per_frame;
+	cfg->stores_per_frame = isys_cfg->input_port_resolution.lines_per_frame;
 
-	cfg->stream2mmio_cfg.sync_cmd	= _STREAM2MMIO_CMD_TOKEN_SYNC_FRAME;
+	cfg->stream2mmio_cfg.sync_cmd = _STREAM2MMIO_CMD_TOKEN_SYNC_FRAME;
 
 	/* TODO: Define conditions as when to use store words vs store packets */
-	cfg->stream2mmio_cfg.store_cmd	= _STREAM2MMIO_CMD_TOKEN_STORE_PACKETS;
+	cfg->stream2mmio_cfg.store_cmd = _STREAM2MMIO_CMD_TOKEN_STORE_PACKETS;
 
 	return true;
 }
 
-static bool calculate_isys2401_dma_cfg(
-    const input_system_channel_t	*channel,
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    isys2401_dma_cfg_t		*cfg)
+static bool
+calculate_isys2401_dma_cfg(const input_system_channel_t *channel,
+			   const isp2401_input_system_cfg_t *isys_cfg,
+			   isys2401_dma_cfg_t *cfg)
 {
-	cfg->channel	= channel->dma_channel;
+	cfg->channel = channel->dma_channel;
 
 	/* only online/sensor mode goto vmem
 	   offline/buffered_sensor, tpg and prbs will go to ddr */
@@ -772,18 +690,17 @@ static bool calculate_isys2401_dma_cfg(
 	else
 		cfg->connection = isys2401_dma_ibuf_to_ddr_connection;
 
-	cfg->extension	= isys2401_dma_zero_extension;
-	cfg->height	= 1;
+	cfg->extension = isys2401_dma_zero_extension;
+	cfg->height = 1;
 
 	return true;
 }
 
 /* See also: ia_css_dma_configure_from_info() */
-static bool calculate_isys2401_dma_port_cfg(
-    const isp2401_input_system_cfg_t	*isys_cfg,
-    bool				raw_packed,
-    bool				metadata,
-    isys2401_dma_port_cfg_t		*cfg)
+static bool
+calculate_isys2401_dma_port_cfg(const isp2401_input_system_cfg_t *isys_cfg,
+				bool raw_packed, bool metadata,
+				isys2401_dma_port_cfg_t *cfg)
 {
 	s32 bits_per_pixel;
 	s32 pixels_per_line;
@@ -796,25 +713,26 @@ static bool calculate_isys2401_dma_port_cfg(
 		align_req_in_bytes = isys_cfg->metadata.align_req_in_bytes;
 	} else {
 		bits_per_pixel = isys_cfg->input_port_resolution.bits_per_pixel;
-		pixels_per_line = isys_cfg->input_port_resolution.pixels_per_line;
-		align_req_in_bytes = isys_cfg->input_port_resolution.align_req_in_bytes;
+		pixels_per_line =
+			isys_cfg->input_port_resolution.pixels_per_line;
+		align_req_in_bytes =
+			isys_cfg->input_port_resolution.align_req_in_bytes;
 	}
 
-	cfg->stride	= calculate_stride(bits_per_pixel, pixels_per_line, raw_packed,
-				       align_req_in_bytes);
+	cfg->stride = calculate_stride(bits_per_pixel, pixels_per_line,
+				       raw_packed, align_req_in_bytes);
 
 	if (!raw_packed)
 		bits_per_pixel = CEIL_MUL(bits_per_pixel, 8);
 
-	cfg->elements	= HIVE_ISP_DDR_WORD_BITS / bits_per_pixel;
-	cfg->cropping	= 0;
-	cfg->width	= CEIL_DIV(cfg->stride, HIVE_ISP_DDR_WORD_BYTES);
+	cfg->elements = HIVE_ISP_DDR_WORD_BITS / bits_per_pixel;
+	cfg->cropping = 0;
+	cfg->width = CEIL_DIV(cfg->stride, HIVE_ISP_DDR_WORD_BYTES);
 
 	return true;
 }
 
-static csi_mipi_packet_type_t get_csi_mipi_packet_type(
-    int32_t data_type)
+static csi_mipi_packet_type_t get_csi_mipi_packet_type(int32_t data_type)
 {
 	csi_mipi_packet_type_t packet_type;
 
@@ -823,7 +741,8 @@ static csi_mipi_packet_type_t get_csi_mipi_packet_type(
 	if (data_type >= 0 && data_type <= MIPI_FORMAT_2401_SHORT8)
 		packet_type = CSI_MIPI_PACKET_TYPE_SHORT;
 
-	if (data_type > MIPI_FORMAT_2401_SHORT8 && data_type <= N_MIPI_FORMAT_2401)
+	if (data_type > MIPI_FORMAT_2401_SHORT8 &&
+	    data_type <= N_MIPI_FORMAT_2401)
 		packet_type = CSI_MIPI_PACKET_TYPE_LONG;
 
 	return packet_type;
diff --git a/drivers/staging/media/atomisp/pci/runtime/isys/src/virtual_isys.h b/drivers/staging/media/atomisp/pci/runtime/isys/src/virtual_isys.h
index a911766b7d490995b45b66d8dafcf65c28b6edf7..b51ec7ee4a893b8f4b2fb55c6f71247385888608 100644
--- a/drivers/staging/media/atomisp/pci/runtime/isys/src/virtual_isys.h
+++ b/drivers/staging/media/atomisp/pci/runtime/isys/src/virtual_isys.h
@@ -8,9 +8,9 @@
 #define __VIRTUAL_ISYS_H_INCLUDED__
 
 /* cmd for storing a number of packets indicated by reg _STREAM2MMIO_NUM_ITEMS*/
-#define _STREAM2MMIO_CMD_TOKEN_STORE_PACKETS	1
+#define _STREAM2MMIO_CMD_TOKEN_STORE_PACKETS 1
 
 /* command for waiting for a frame start */
-#define _STREAM2MMIO_CMD_TOKEN_SYNC_FRAME	2
+#define _STREAM2MMIO_CMD_TOKEN_SYNC_FRAME 2
 
 #endif /* __VIRTUAL_ISYS_H_INCLUDED__ */
diff --git a/drivers/staging/media/atomisp/pci/runtime/pipeline/interface/ia_css_pipeline.h b/drivers/staging/media/atomisp/pci/runtime/pipeline/interface/ia_css_pipeline.h
index 316eaa2070ea79cae88f3e22b492d2e9de39d721..d6006577c98b4c7a73bd0e420c90b2f02c647bf7 100644
--- a/drivers/staging/media/atomisp/pci/runtime/pipeline/interface/ia_css_pipeline.h
+++ b/drivers/staging/media/atomisp/pci/runtime/pipeline/interface/ia_css_pipeline.h
@@ -11,17 +11,17 @@
 #include "ia_css_pipe_public.h"
 #include "ia_css_pipeline_common.h"
 
-#define IA_CSS_PIPELINE_NUM_MAX		(20)
+#define IA_CSS_PIPELINE_NUM_MAX (20)
 
 /* Pipeline stage to be executed on SP/ISP */
 struct ia_css_pipeline_stage {
 	unsigned int stage_num;
-	struct ia_css_binary *binary;	/* built-in binary */
+	struct ia_css_binary *binary; /* built-in binary */
 	struct ia_css_binary_info *binary_info;
-	const struct ia_css_fw_info *firmware;	/* acceleration binary */
+	const struct ia_css_fw_info *firmware; /* acceleration binary */
 	/* SP function for SP stage */
 	enum ia_css_pipeline_stage_sp_func sp_func;
-	unsigned int max_input_width;	/* For SP raw copy */
+	unsigned int max_input_width; /* For SP raw copy */
 	struct sh_css_binary_args args;
 	int mode;
 	bool out_frame_allocated[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -47,15 +47,13 @@ struct ia_css_pipeline {
 	bool acquire_isp_each_stage;
 };
 
-#define DEFAULT_PIPELINE { \
-	.pipe_id		= IA_CSS_PIPE_ID_PREVIEW, \
-	.in_frame		= DEFAULT_FRAME, \
-	.out_frame		= {DEFAULT_FRAME}, \
-	.vf_frame		= {DEFAULT_FRAME}, \
-	.dvs_frame_delay	= IA_CSS_FRAME_DELAY_1, \
-	.num_execs		= -1, \
-	.acquire_isp_each_stage	= true, \
-}
+#define DEFAULT_PIPELINE                                                       \
+	{                                                                      \
+		.pipe_id = IA_CSS_PIPE_ID_PREVIEW, .in_frame = DEFAULT_FRAME,  \
+		.out_frame = { DEFAULT_FRAME }, .vf_frame = { DEFAULT_FRAME }, \
+		.dvs_frame_delay = IA_CSS_FRAME_DELAY_1, .num_execs = -1,      \
+		.acquire_isp_each_stage = true,                                \
+	}
 
 /* Stage descriptor used to create a new stage in the pipeline */
 struct ia_css_pipeline_stage_desc {
@@ -89,11 +87,9 @@ void ia_css_pipeline_init(void);
  * This API is expected to be used when a pipeline structure is allocated
  * externally and needs sane defaults
  */
-int ia_css_pipeline_create(
-    struct ia_css_pipeline *pipeline,
-    enum ia_css_pipe_id pipe_id,
-    unsigned int pipe_num,
-    unsigned int dvs_frame_delay);
+int ia_css_pipeline_create(struct ia_css_pipeline *pipeline,
+			   enum ia_css_pipe_id pipe_id, unsigned int pipe_num,
+			   unsigned int dvs_frame_delay);
 
 /* @brief destroy a pipeline
  *
@@ -149,9 +145,9 @@ void ia_css_pipeline_clean(struct ia_css_pipeline *pipeline);
  * arguments.
 */
 int ia_css_pipeline_create_and_add_stage(
-    struct ia_css_pipeline *pipeline,
-    struct ia_css_pipeline_stage_desc *stage_desc,
-    struct ia_css_pipeline_stage **stage);
+	struct ia_css_pipeline *pipeline,
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_pipeline_stage **stage);
 
 /* @brief Finalize the stages in a pipeline
  *
@@ -169,9 +165,8 @@ void ia_css_pipeline_finalize_stages(struct ia_css_pipeline *pipeline,
  * @return                     0 or error code upon error.
  *
  */
-int ia_css_pipeline_get_stage(struct ia_css_pipeline *pipeline,
-	int mode,
-	struct ia_css_pipeline_stage **stage);
+int ia_css_pipeline_get_stage(struct ia_css_pipeline *pipeline, int mode,
+			      struct ia_css_pipeline_stage **stage);
 
 /* @brief Gets a pipeline stage corresponding Firmware handle from the pipeline
  *
@@ -182,10 +177,9 @@ int ia_css_pipeline_get_stage(struct ia_css_pipeline *pipeline,
  * @return   0 or error code upon error.
  *
  */
-int ia_css_pipeline_get_stage_from_fw(struct ia_css_pipeline
-	*pipeline,
-	u32 fw_handle,
-	struct ia_css_pipeline_stage **stage);
+int ia_css_pipeline_get_stage_from_fw(struct ia_css_pipeline *pipeline,
+				      u32 fw_handle,
+				      struct ia_css_pipeline_stage **stage);
 
 /* @brief Gets the Firmware handle corresponding the stage num from the pipeline
  *
@@ -196,10 +190,8 @@ int ia_css_pipeline_get_stage_from_fw(struct ia_css_pipeline
  * @return   0 or error code upon error.
  *
  */
-int ia_css_pipeline_get_fw_from_stage(struct ia_css_pipeline
-	*pipeline,
-	u32 stage_num,
-	uint32_t *fw_handle);
+int ia_css_pipeline_get_fw_from_stage(struct ia_css_pipeline *pipeline,
+				      u32 stage_num, uint32_t *fw_handle);
 
 /* @brief gets the output stage from the pipeline
  *
@@ -207,10 +199,8 @@ int ia_css_pipeline_get_fw_from_stage(struct ia_css_pipeline
  * @return                     0 or error code upon error.
  *
  */
-int ia_css_pipeline_get_output_stage(
-    struct ia_css_pipeline *pipeline,
-    int mode,
-    struct ia_css_pipeline_stage **stage);
+int ia_css_pipeline_get_output_stage(struct ia_css_pipeline *pipeline, int mode,
+				     struct ia_css_pipeline_stage **stage);
 
 /* @brief Checks whether the pipeline uses params
  *
diff --git a/drivers/staging/media/atomisp/pci/runtime/pipeline/src/pipeline.c b/drivers/staging/media/atomisp/pci/runtime/pipeline/src/pipeline.c
index aabebe61ec779ecd4c902b81c1fb1c7ed3d69169..38ca315da9641c5fe8e75fe5ba2999f4a59ae404 100644
--- a/drivers/staging/media/atomisp/pci/runtime/pipeline/src/pipeline.c
+++ b/drivers/staging/media/atomisp/pci/runtime/pipeline/src/pipeline.c
@@ -7,17 +7,17 @@
 #include "hmm.h"
 
 #include "ia_css_debug.h"
-#include "sw_event_global.h"		/* encode_sw_event */
-#include "sp.h"			/* cnd_sp_irq_enable() */
+#include "sw_event_global.h" /* encode_sw_event */
+#include "sp.h" /* cnd_sp_irq_enable() */
 #include "assert_support.h"
 #include "sh_css_sp.h"
 #include "ia_css_pipeline.h"
 #include "ia_css_isp_param.h"
 #include "ia_css_bufq.h"
 
-#define PIPELINE_NUM_UNMAPPED                   (~0U)
-#define PIPELINE_SP_THREAD_EMPTY_TOKEN          (0x0)
-#define PIPELINE_SP_THREAD_RESERVED_TOKEN       (0x1)
+#define PIPELINE_NUM_UNMAPPED (~0U)
+#define PIPELINE_SP_THREAD_EMPTY_TOKEN (0x0)
+#define PIPELINE_SP_THREAD_RESERVED_TOKEN (0x1)
 
 /*******************************************************
 *** Static variables
@@ -31,19 +31,17 @@ static unsigned int pipeline_sp_thread_list[SH_CSS_MAX_SP_THREADS];
 static void pipeline_init_sp_thread_map(void);
 static void pipeline_map_num_to_sp_thread(unsigned int pipe_num);
 static void pipeline_unmap_num_to_sp_thread(unsigned int pipe_num);
-static void pipeline_init_defaults(
-    struct ia_css_pipeline *pipeline,
-    enum ia_css_pipe_id pipe_id,
-    unsigned int pipe_num,
-    unsigned int dvs_frame_delay);
+static void pipeline_init_defaults(struct ia_css_pipeline *pipeline,
+				   enum ia_css_pipe_id pipe_id,
+				   unsigned int pipe_num,
+				   unsigned int dvs_frame_delay);
 
 static void pipeline_stage_destroy(struct ia_css_pipeline_stage *stage);
-static int pipeline_stage_create(
-    struct ia_css_pipeline_stage_desc *stage_desc,
-    struct ia_css_pipeline_stage **new_stage);
+static int pipeline_stage_create(struct ia_css_pipeline_stage_desc *stage_desc,
+				 struct ia_css_pipeline_stage **new_stage);
 static void ia_css_pipeline_set_zoom_stage(struct ia_css_pipeline *pipeline);
 static void ia_css_pipeline_configure_inout_port(struct ia_css_pipeline *me,
-	bool continuous);
+						 bool continuous);
 
 /*******************************************************
 *** Public functions
@@ -53,15 +51,14 @@ void ia_css_pipeline_init(void)
 	pipeline_init_sp_thread_map();
 }
 
-int ia_css_pipeline_create(
-    struct ia_css_pipeline *pipeline,
-    enum ia_css_pipe_id pipe_id,
-    unsigned int pipe_num,
-    unsigned int dvs_frame_delay)
+int ia_css_pipeline_create(struct ia_css_pipeline *pipeline,
+			   enum ia_css_pipe_id pipe_id, unsigned int pipe_num,
+			   unsigned int dvs_frame_delay)
 {
 	assert(pipeline);
-	IA_CSS_ENTER_PRIVATE("pipeline = %p, pipe_id = %d, pipe_num = %d, dvs_frame_delay = %d",
-			     pipeline, pipe_id, pipe_num, dvs_frame_delay);
+	IA_CSS_ENTER_PRIVATE(
+		"pipeline = %p, pipe_id = %d, pipe_num = %d, dvs_frame_delay = %d",
+		pipeline, pipe_id, pipe_num, dvs_frame_delay);
 	if (!pipeline) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
 		return -EINVAL;
@@ -123,12 +120,13 @@ void ia_css_pipeline_start(enum ia_css_pipe_id pipe_id,
 	unsigned int thread_id;
 
 	assert(pipeline);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_pipeline_start() enter: pipe_id=%d, pipeline=%p\n",
-			    pipe_id, pipeline);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_start() enter: pipe_id=%d, pipeline=%p\n",
+		pipe_id, pipeline);
 	pipeline->pipe_id = pipe_id;
-	sh_css_sp_init_pipeline(pipeline, pipe_id, pipe_num,
-				false, false, false, true, SH_CSS_BDS_FACTOR_1_00,
+	sh_css_sp_init_pipeline(pipeline, pipe_id, pipe_num, false, false,
+				false, true, SH_CSS_BDS_FACTOR_1_00,
 				SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD,
 				IA_CSS_INPUT_MODE_MEMORY, NULL, NULL,
 				(enum mipi_port_id)0);
@@ -141,9 +139,7 @@ void ia_css_pipeline_start(enum ia_css_pipe_id pipe_id,
 		return;
 	}
 	ia_css_bufq_enqueue_psys_event(IA_CSS_PSYS_SW_EVENT_START_STREAM,
-				       (uint8_t)thread_id,
-				       0,
-				       0);
+				       (uint8_t)thread_id, 0, 0);
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
 			    "ia_css_pipeline_start() leave: return_void\n");
@@ -157,7 +153,8 @@ bool ia_css_pipeline_get_sp_thread_id(unsigned int key, unsigned int *val)
 {
 	IA_CSS_ENTER("key=%d, val=%p", key, val);
 
-	if ((!val) || (key >= IA_CSS_PIPELINE_NUM_MAX) || (key >= IA_CSS_PIPE_ID_NUM)) {
+	if ((!val) || (key >= IA_CSS_PIPELINE_NUM_MAX) ||
+	    (key >= IA_CSS_PIPE_ID_NUM)) {
 		IA_CSS_LEAVE("return value = false");
 		return false;
 	}
@@ -181,7 +178,8 @@ void ia_css_pipeline_dump_thread_map_info(void)
 			    "pipeline_num_to_sp_thread_map:\n");
 	for (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "pipe_num: %u, tid: 0x%x\n", i, pipeline_num_to_sp_thread_map[i]);
+				    "pipe_num: %u, tid: 0x%x\n", i,
+				    pipeline_num_to_sp_thread_map[i]);
 	}
 }
 
@@ -195,9 +193,10 @@ int ia_css_pipeline_request_stop(struct ia_css_pipeline *pipeline)
 	if (!pipeline)
 		return -EINVAL;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_pipeline_request_stop() enter: pipeline=%p\n",
-			    pipeline);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_request_stop() enter: pipeline=%p\n",
+		pipeline);
 	pipeline->stop_requested = true;
 
 	/* Send stop event to the sp*/
@@ -211,14 +210,12 @@ int ia_css_pipeline_request_stop(struct ia_css_pipeline *pipeline)
 		return -EBUSY;
 	}
 	ia_css_bufq_enqueue_psys_event(IA_CSS_PSYS_SW_EVENT_STOP_STREAM,
-				       (uint8_t)thread_id,
-				       0,
-				       0);
+				       (uint8_t)thread_id, 0, 0);
 	sh_css_sp_uninit_pipeline(pipeline->pipe_num);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_pipeline_request_stop() leave: return_err=%d\n",
-			    err);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_request_stop() leave: return_err=%d\n", err);
 	return err;
 }
 
@@ -260,9 +257,9 @@ void ia_css_pipeline_clean(struct ia_css_pipeline *pipeline)
  * output arguments.
 */
 int ia_css_pipeline_create_and_add_stage(
-    struct ia_css_pipeline *pipeline,
-    struct ia_css_pipeline_stage_desc *stage_desc,
-    struct ia_css_pipeline_stage **stage)
+	struct ia_css_pipeline *pipeline,
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_pipeline_stage **stage)
 {
 	struct ia_css_pipeline_stage *last, *new_stage = NULL;
 	int err;
@@ -274,10 +271,11 @@ int ia_css_pipeline_create_and_add_stage(
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
 			    "ia_css_pipeline_create_and_add_stage() enter:\n");
-	if (!stage_desc->binary && !stage_desc->firmware
-	    && (stage_desc->sp_func == IA_CSS_PIPELINE_NO_FUNC)) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "ia_css_pipeline_create_and_add_stage() done: Invalid args\n");
+	if (!stage_desc->binary && !stage_desc->firmware &&
+	    (stage_desc->sp_func == IA_CSS_PIPELINE_NO_FUNC)) {
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE,
+			"ia_css_pipeline_create_and_add_stage() done: Invalid args\n");
 
 		return -EINVAL;
 	}
@@ -289,10 +287,9 @@ int ia_css_pipeline_create_and_add_stage(
 	/* if in_frame is not set, we use the out_frame from the previous
 	 * stage, if no previous stage, it's an error.
 	 */
-	if ((stage_desc->sp_func == IA_CSS_PIPELINE_NO_FUNC)
-	    && (!stage_desc->in_frame)
-	    && (!stage_desc->firmware)
-	    && (!stage_desc->binary->online)) {
+	if ((stage_desc->sp_func == IA_CSS_PIPELINE_NO_FUNC) &&
+	    (!stage_desc->in_frame) && (!stage_desc->firmware) &&
+	    (!stage_desc->binary->online)) {
 		/* Do this only for ISP stages*/
 		if (last && last->args.out_frame[0])
 			stage_desc->in_frame = last->args.out_frame[0];
@@ -304,8 +301,9 @@ int ia_css_pipeline_create_and_add_stage(
 	/* Create the new stage */
 	err = pipeline_stage_create(stage_desc, &new_stage);
 	if (err) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "ia_css_pipeline_create_and_add_stage() done: stage_create_failed\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE,
+			"ia_css_pipeline_create_and_add_stage() done: stage_create_failed\n");
 		return err;
 	}
 
@@ -340,9 +338,8 @@ void ia_css_pipeline_finalize_stages(struct ia_css_pipeline *pipeline,
 	ia_css_pipeline_configure_inout_port(pipeline, continuous);
 }
 
-int ia_css_pipeline_get_stage(struct ia_css_pipeline *pipeline,
-	int mode,
-	struct ia_css_pipeline_stage **stage)
+int ia_css_pipeline_get_stage(struct ia_css_pipeline *pipeline, int mode,
+			      struct ia_css_pipeline_stage **stage)
 {
 	struct ia_css_pipeline_stage *s;
 
@@ -359,10 +356,9 @@ int ia_css_pipeline_get_stage(struct ia_css_pipeline *pipeline,
 	return -EINVAL;
 }
 
-int ia_css_pipeline_get_stage_from_fw(struct ia_css_pipeline
-	*pipeline,
-	u32 fw_handle,
-	struct ia_css_pipeline_stage **stage)
+int ia_css_pipeline_get_stage_from_fw(struct ia_css_pipeline *pipeline,
+				      u32 fw_handle,
+				      struct ia_css_pipeline_stage **stage)
 {
 	struct ia_css_pipeline_stage *s;
 
@@ -378,10 +374,8 @@ int ia_css_pipeline_get_stage_from_fw(struct ia_css_pipeline
 	return -EINVAL;
 }
 
-int ia_css_pipeline_get_fw_from_stage(struct ia_css_pipeline
-	*pipeline,
-	u32 stage_num,
-	uint32_t *fw_handle)
+int ia_css_pipeline_get_fw_from_stage(struct ia_css_pipeline *pipeline,
+				      u32 stage_num, uint32_t *fw_handle)
 {
 	struct ia_css_pipeline_stage *s;
 
@@ -398,10 +392,8 @@ int ia_css_pipeline_get_fw_from_stage(struct ia_css_pipeline
 	return -EINVAL;
 }
 
-int ia_css_pipeline_get_output_stage(
-    struct ia_css_pipeline *pipeline,
-    int mode,
-    struct ia_css_pipeline_stage **stage)
+int ia_css_pipeline_get_output_stage(struct ia_css_pipeline *pipeline, int mode,
+				     struct ia_css_pipeline_stage **stage)
 {
 	struct ia_css_pipeline_stage *s;
 
@@ -439,15 +431,14 @@ bool ia_css_pipeline_has_stopped(struct ia_css_pipeline *pipeline)
 	HIVE_ADDR_sp_group = fw->info.sp.group;
 
 	ia_css_pipeline_get_sp_thread_id(pipeline->pipe_num, &thread_id);
-	sp_dmem_load(SP0_ID,
-		     (unsigned int)sp_address_of(sp_group),
-		     &sp_group, sizeof(struct sh_css_sp_group));
+	sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(sp_group), &sp_group,
+		     sizeof(struct sh_css_sp_group));
 	return sp_group.pipe[thread_id].num_stages == 0;
 }
 
 struct sh_css_sp_pipeline_io_status *ia_css_pipeline_get_pipe_io_status(void)
 {
-	return(&sh_css_sp_group.pipe_io_status);
+	return &sh_css_sp_group.pipe_io_status;
 }
 
 bool ia_css_pipeline_is_mapped(unsigned int key)
@@ -462,8 +453,8 @@ bool ia_css_pipeline_is_mapped(unsigned int key)
 		return false;
 	}
 
-	ret = (bool)(pipeline_num_to_sp_thread_map[key] != (unsigned int)
-		     PIPELINE_NUM_UNMAPPED);
+	ret = (bool)(pipeline_num_to_sp_thread_map[key] !=
+		     (unsigned int)PIPELINE_NUM_UNMAPPED);
 
 	IA_CSS_LEAVE_PRIVATE("return = %d", ret);
 	return ret;
@@ -519,14 +510,14 @@ static void pipeline_map_num_to_sp_thread(unsigned int pipe_num)
 	bool found_sp_thread = false;
 
 	/* pipe is not mapped to any thread */
-	assert(pipeline_num_to_sp_thread_map[pipe_num]
-	       == (unsigned int)PIPELINE_NUM_UNMAPPED);
+	assert(pipeline_num_to_sp_thread_map[pipe_num] ==
+	       (unsigned int)PIPELINE_NUM_UNMAPPED);
 
 	for (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {
 		if (pipeline_sp_thread_list[i] ==
 		    PIPELINE_SP_THREAD_EMPTY_TOKEN) {
 			pipeline_sp_thread_list[i] =
-			    PIPELINE_SP_THREAD_RESERVED_TOKEN;
+				PIPELINE_SP_THREAD_RESERVED_TOKEN;
 			pipeline_num_to_sp_thread_map[pipe_num] = i;
 			found_sp_thread = true;
 			break;
@@ -546,17 +537,16 @@ static void pipeline_unmap_num_to_sp_thread(unsigned int pipe_num)
 {
 	unsigned int thread_id;
 
-	assert(pipeline_num_to_sp_thread_map[pipe_num]
-	       != (unsigned int)PIPELINE_NUM_UNMAPPED);
+	assert(pipeline_num_to_sp_thread_map[pipe_num] !=
+	       (unsigned int)PIPELINE_NUM_UNMAPPED);
 
 	thread_id = pipeline_num_to_sp_thread_map[pipe_num];
 	pipeline_num_to_sp_thread_map[pipe_num] = PIPELINE_NUM_UNMAPPED;
 	pipeline_sp_thread_list[thread_id] = PIPELINE_SP_THREAD_EMPTY_TOKEN;
 }
 
-static int pipeline_stage_create(
-    struct ia_css_pipeline_stage_desc *stage_desc,
-    struct ia_css_pipeline_stage **new_stage)
+static int pipeline_stage_create(struct ia_css_pipeline_stage_desc *stage_desc,
+				 struct ia_css_pipeline_stage **new_stage)
 {
 	int err = 0;
 	struct ia_css_pipeline_stage *stage = NULL;
@@ -567,8 +557,8 @@ static int pipeline_stage_create(
 	unsigned int i;
 
 	/* Verify input parameters*/
-	if (!(stage_desc->in_frame) && !(stage_desc->firmware)
-	    && (stage_desc->binary) && !(stage_desc->binary->online)) {
+	if (!(stage_desc->in_frame) && !(stage_desc->firmware) &&
+	    (stage_desc->binary) && !(stage_desc->binary->online)) {
 		err = -EINVAL;
 		goto ERR;
 	}
@@ -589,12 +579,12 @@ static int pipeline_stage_create(
 	if (firmware) {
 		stage->binary = NULL;
 		stage->binary_info =
-		    (struct ia_css_binary_info *)&firmware->info.isp;
+			(struct ia_css_binary_info *)&firmware->info.isp;
 	} else {
 		stage->binary = binary;
 		if (binary)
 			stage->binary_info =
-			    (struct ia_css_binary_info *)binary->info;
+				(struct ia_css_binary_info *)binary->info;
 		else
 			stage->binary_info = NULL;
 	}
@@ -610,10 +600,10 @@ static int pipeline_stage_create(
 	sh_css_binary_args_reset(&stage->args);
 
 	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
-		if (!(out_frame[i]) && (binary)
-		    && (binary->out_frame_info[i].res.width)) {
-			err = ia_css_frame_allocate_from_info(&out_frame[i],
-							      &binary->out_frame_info[i]);
+		if (!(out_frame[i]) && (binary) &&
+		    (binary->out_frame_info[i].res.width)) {
+			err = ia_css_frame_allocate_from_info(
+				&out_frame[i], &binary->out_frame_info[i]);
 			if (err)
 				goto ERR;
 			stage->out_frame_allocated[i] = true;
@@ -624,16 +614,15 @@ static int pipeline_stage_create(
 	 */
 	if (!vf_frame) {
 		if ((binary && binary->vf_frame_info.res.width) ||
-		    (firmware && firmware->info.isp.sp.enable.vf_veceven)
-		   ) {
-			err = ia_css_frame_allocate_from_info(&vf_frame,
-							      &binary->vf_frame_info);
+		    (firmware && firmware->info.isp.sp.enable.vf_veceven)) {
+			err = ia_css_frame_allocate_from_info(
+				&vf_frame, &binary->vf_frame_info);
 			if (err)
 				goto ERR;
 			stage->vf_frame_allocated = true;
 		}
-	} else if (vf_frame && binary && binary->vf_frame_info.res.width
-		   && !firmware) {
+	} else if (vf_frame && binary && binary->vf_frame_info.res.width &&
+		   !firmware) {
 		/* only mark as allocated if buffer pointer available */
 		if (vf_frame->data != mmgr_NULL)
 			stage->vf_frame_allocated = true;
@@ -653,11 +642,10 @@ static int pipeline_stage_create(
 
 static const struct ia_css_frame ia_css_default_frame = DEFAULT_FRAME;
 
-static void pipeline_init_defaults(
-    struct ia_css_pipeline *pipeline,
-    enum ia_css_pipe_id pipe_id,
-    unsigned int pipe_num,
-    unsigned int dvs_frame_delay)
+static void pipeline_init_defaults(struct ia_css_pipeline *pipeline,
+				   enum ia_css_pipe_id pipe_id,
+				   unsigned int pipe_num,
+				   unsigned int dvs_frame_delay)
 {
 	unsigned int i;
 
@@ -689,42 +677,46 @@ static void ia_css_pipeline_set_zoom_stage(struct ia_css_pipeline *pipeline)
 	assert(pipeline);
 	if (pipeline->pipe_id == IA_CSS_PIPE_ID_PREVIEW) {
 		/* in preview pipeline, vf_pp stage should do zoom */
-		err = ia_css_pipeline_get_stage(pipeline, IA_CSS_BINARY_MODE_VF_PP, &stage);
+		err = ia_css_pipeline_get_stage(
+			pipeline, IA_CSS_BINARY_MODE_VF_PP, &stage);
 		if (!err)
 			stage->enable_zoom = true;
 	} else if (pipeline->pipe_id == IA_CSS_PIPE_ID_CAPTURE) {
 		/* in capture pipeline, capture_pp stage should do zoom */
-		err = ia_css_pipeline_get_stage(pipeline, IA_CSS_BINARY_MODE_CAPTURE_PP,
-						&stage);
+		err = ia_css_pipeline_get_stage(
+			pipeline, IA_CSS_BINARY_MODE_CAPTURE_PP, &stage);
 		if (!err)
 			stage->enable_zoom = true;
 	} else if (pipeline->pipe_id == IA_CSS_PIPE_ID_VIDEO) {
 		/* in video pipeline, video stage should do zoom */
-		err = ia_css_pipeline_get_stage(pipeline, IA_CSS_BINARY_MODE_VIDEO, &stage);
+		err = ia_css_pipeline_get_stage(
+			pipeline, IA_CSS_BINARY_MODE_VIDEO, &stage);
 		if (!err)
 			stage->enable_zoom = true;
 	} else if (pipeline->pipe_id == IA_CSS_PIPE_ID_YUVPP) {
 		/* in yuvpp pipeline, first yuv_scaler stage should do zoom */
-		err = ia_css_pipeline_get_stage(pipeline, IA_CSS_BINARY_MODE_CAPTURE_PP,
-						&stage);
+		err = ia_css_pipeline_get_stage(
+			pipeline, IA_CSS_BINARY_MODE_CAPTURE_PP, &stage);
 		if (!err)
 			stage->enable_zoom = true;
 	}
 }
 
-static void
-ia_css_pipeline_configure_inout_port(struct ia_css_pipeline *me,
-				     bool continuous)
+static void ia_css_pipeline_configure_inout_port(struct ia_css_pipeline *me,
+						 bool continuous)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_pipeline_configure_inout_port() enter: pipe_id(%d) continuous(%d)\n",
-			    me->pipe_id, continuous);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_pipeline_configure_inout_port() enter: pipe_id(%d) continuous(%d)\n",
+		me->pipe_id, continuous);
 	switch (me->pipe_id) {
 	case IA_CSS_PIPE_ID_PREVIEW:
 	case IA_CSS_PIPE_ID_VIDEO:
-		SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
-					    (uint8_t)SH_CSS_PORT_INPUT,
-					    (uint8_t)(continuous ? SH_CSS_COPYSINK_TYPE : SH_CSS_HOST_TYPE), 1);
+		SH_CSS_PIPE_PORT_CONFIG_SET(
+			me->inout_port_config, (uint8_t)SH_CSS_PORT_INPUT,
+			(uint8_t)(continuous ? SH_CSS_COPYSINK_TYPE :
+					       SH_CSS_HOST_TYPE),
+			1);
 		SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
 					    (uint8_t)SH_CSS_PORT_OUTPUT,
 					    (uint8_t)SH_CSS_HOST_TYPE, 1);
@@ -734,23 +726,27 @@ ia_css_pipeline_configure_inout_port(struct ia_css_pipeline *me,
 					    (uint8_t)SH_CSS_PORT_INPUT,
 					    (uint8_t)SH_CSS_HOST_TYPE, 1);
 		if (continuous) {
-			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
-						    (uint8_t)SH_CSS_PORT_OUTPUT,
-						    (uint8_t)SH_CSS_COPYSINK_TYPE, 1);
-			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
-						    (uint8_t)SH_CSS_PORT_OUTPUT,
-						    (uint8_t)SH_CSS_TAGGERSINK_TYPE, 1);
+			SH_CSS_PIPE_PORT_CONFIG_SET(
+				me->inout_port_config,
+				(uint8_t)SH_CSS_PORT_OUTPUT,
+				(uint8_t)SH_CSS_COPYSINK_TYPE, 1);
+			SH_CSS_PIPE_PORT_CONFIG_SET(
+				me->inout_port_config,
+				(uint8_t)SH_CSS_PORT_OUTPUT,
+				(uint8_t)SH_CSS_TAGGERSINK_TYPE, 1);
 		} else {
 			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
 						    (uint8_t)SH_CSS_PORT_OUTPUT,
-						    (uint8_t)SH_CSS_HOST_TYPE, 1);
+						    (uint8_t)SH_CSS_HOST_TYPE,
+						    1);
 		}
 		break;
 	case IA_CSS_PIPE_ID_CAPTURE:
-		SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
-					    (uint8_t)SH_CSS_PORT_INPUT,
-					    (uint8_t)(continuous ? SH_CSS_TAGGERSINK_TYPE : SH_CSS_HOST_TYPE),
-					    1);
+		SH_CSS_PIPE_PORT_CONFIG_SET(
+			me->inout_port_config, (uint8_t)SH_CSS_PORT_INPUT,
+			(uint8_t)(continuous ? SH_CSS_TAGGERSINK_TYPE :
+					       SH_CSS_HOST_TYPE),
+			1);
 		SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
 					    (uint8_t)SH_CSS_PORT_OUTPUT,
 					    (uint8_t)SH_CSS_HOST_TYPE, 1);
@@ -766,7 +762,8 @@ ia_css_pipeline_configure_inout_port(struct ia_css_pipeline *me,
 	default:
 		break;
 	}
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_pipeline_configure_inout_port() leave: inout_port_config(%x)\n",
-			    me->inout_port_config);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_pipeline_configure_inout_port() leave: inout_port_config(%x)\n",
+		me->inout_port_config);
 }
diff --git a/drivers/staging/media/atomisp/pci/runtime/queue/interface/ia_css_queue.h b/drivers/staging/media/atomisp/pci/runtime/queue/interface/ia_css_queue.h
index c097d912d87f89693916d90af128643442a24c55..ddacb843bd96433c34c11db2b8b80cb0ec43666b 100644
--- a/drivers/staging/media/atomisp/pci/runtime/queue/interface/ia_css_queue.h
+++ b/drivers/staging/media/atomisp/pci/runtime/queue/interface/ia_css_queue.h
@@ -35,9 +35,8 @@ typedef struct ia_css_queue ia_css_queue_t;
  * @return     -EINVAL - Invalid argument.
  *
  */
-int ia_css_queue_local_init(
-    ia_css_queue_t *qhandle,
-    ia_css_queue_local_t *desc);
+int ia_css_queue_local_init(ia_css_queue_t *qhandle,
+			    ia_css_queue_local_t *desc);
 
 /* @brief Initialize a remote queue instance
  *
@@ -46,9 +45,8 @@ int ia_css_queue_local_init(
  * @return     0      - Successful init of remote queue instance.
  * @return     -EINVAL - Invalid argument.
  */
-int ia_css_queue_remote_init(
-    ia_css_queue_t *qhandle,
-    ia_css_queue_remote_t *desc);
+int ia_css_queue_remote_init(ia_css_queue_t *qhandle,
+			     ia_css_queue_remote_t *desc);
 
 /* @brief Uninitialize a queue instance
  *
@@ -56,8 +54,7 @@ int ia_css_queue_remote_init(
  * @return     0 - Successful uninit.
  *
  */
-int ia_css_queue_uninit(
-    ia_css_queue_t *qhandle);
+int ia_css_queue_uninit(ia_css_queue_t *qhandle);
 
 /* @brief Enqueue an item in the queue instance
  *
@@ -68,9 +65,7 @@ int ia_css_queue_uninit(
  * @return     -ENOBUFS - Queue is full.
  *
  */
-int ia_css_queue_enqueue(
-    ia_css_queue_t *qhandle,
-    uint32_t item);
+int ia_css_queue_enqueue(ia_css_queue_t *qhandle, uint32_t item);
 
 /* @brief Dequeue an item from the queue instance
  *
@@ -82,9 +77,7 @@ int ia_css_queue_enqueue(
  * @return     -ENODATA - Queue is empty.
  *
  */
-int ia_css_queue_dequeue(
-    ia_css_queue_t *qhandle,
-    uint32_t *item);
+int ia_css_queue_dequeue(ia_css_queue_t *qhandle, uint32_t *item);
 
 /* @brief Check if the queue is empty
  *
@@ -95,9 +88,7 @@ int ia_css_queue_dequeue(
  * @return     -ENOSYS  - Function not implemented.
  *
  */
-int ia_css_queue_is_empty(
-    ia_css_queue_t *qhandle,
-    bool *is_empty);
+int ia_css_queue_is_empty(ia_css_queue_t *qhandle, bool *is_empty);
 
 /* @brief Check if the queue is full
  *
@@ -108,9 +99,7 @@ int ia_css_queue_is_empty(
  * @return     -ENOSYS  - Function not implemented.
  *
  */
-int ia_css_queue_is_full(
-    ia_css_queue_t *qhandle,
-    bool *is_full);
+int ia_css_queue_is_full(ia_css_queue_t *qhandle, bool *is_full);
 
 /* @brief Get used space in the queue
  *
@@ -120,9 +109,7 @@ int ia_css_queue_is_full(
  * @return     -EINVAL  - Invalid argument.
  *
  */
-int ia_css_queue_get_used_space(
-    ia_css_queue_t *qhandle,
-    uint32_t *size);
+int ia_css_queue_get_used_space(ia_css_queue_t *qhandle, uint32_t *size);
 
 /* @brief Get free space in the queue
  *
@@ -132,9 +119,7 @@ int ia_css_queue_get_used_space(
  * @return     -EINVAL  - Invalid argument.
  *
  */
-int ia_css_queue_get_free_space(
-    ia_css_queue_t *qhandle,
-    uint32_t *size);
+int ia_css_queue_get_free_space(ia_css_queue_t *qhandle, uint32_t *size);
 
 /* @brief Peek at an element in the queue
  *
@@ -146,10 +131,7 @@ int ia_css_queue_get_free_space(
  * @return     -EINVAL  - Invalid argument.
  *
  */
-int ia_css_queue_peek(
-    ia_css_queue_t *qhandle,
-    u32 offset,
-    uint32_t *element);
+int ia_css_queue_peek(ia_css_queue_t *qhandle, u32 offset, uint32_t *element);
 
 /* @brief Get the usable size for the queue
  *
@@ -160,8 +142,6 @@ int ia_css_queue_peek(
  * @return     -ENOSYS  - Function not implemented.
  *
  */
-int ia_css_queue_get_size(
-    ia_css_queue_t *qhandle,
-    uint32_t *size);
+int ia_css_queue_get_size(ia_css_queue_t *qhandle, uint32_t *size);
 
 #endif /* __IA_CSS_QUEUE_H */
diff --git a/drivers/staging/media/atomisp/pci/runtime/queue/interface/ia_css_queue_comm.h b/drivers/staging/media/atomisp/pci/runtime/queue/interface/ia_css_queue_comm.h
index 0bed6425a07f02bf0e82b9b34d9376e57a6fab83..fa28223a98d92d455f996c912d3c76cc964b553a 100644
--- a/drivers/staging/media/atomisp/pci/runtime/queue/interface/ia_css_queue_comm.h
+++ b/drivers/staging/media/atomisp/pci/runtime/queue/interface/ia_css_queue_comm.h
@@ -16,12 +16,12 @@
 /* Queue location specifier */
 /* Avoiding enums to save space */
 #define IA_CSS_QUEUE_LOC_HOST 0
-#define IA_CSS_QUEUE_LOC_SP   1
-#define IA_CSS_QUEUE_LOC_ISP  2
+#define IA_CSS_QUEUE_LOC_SP 1
+#define IA_CSS_QUEUE_LOC_ISP 2
 
 /* Queue type specifier */
 /* Avoiding enums to save space */
-#define IA_CSS_QUEUE_TYPE_LOCAL  0
+#define IA_CSS_QUEUE_TYPE_LOCAL 0
 #define IA_CSS_QUEUE_TYPE_REMOTE 1
 
 /* for DDR Allocated queues,
@@ -29,15 +29,15 @@ allocate minimum these many elements.
 DDR->SP' DMEM DMA transfer needs 32byte aligned address.
 Since each element size is 4 bytes, 8 elements need to be
 DMAed to access single element.*/
-#define IA_CSS_MIN_ELEM_COUNT    8
+#define IA_CSS_MIN_ELEM_COUNT 8
 #define IA_CSS_DMA_XFER_MASK (IA_CSS_MIN_ELEM_COUNT - 1)
 
 /* Remote Queue object descriptor */
 struct ia_css_queue_remote {
 	u32 cb_desc_addr; /*Circbuf desc address for remote queues*/
 	u32 cb_elems_addr; /*Circbuf elements addr for remote queue*/
-	u8 location;    /* Cell location for queue */
-	u8 proc_id;     /* Processor id for queue access */
+	u8 location; /* Cell location for queue */
+	u8 proc_id; /* Processor id for queue access */
 };
 
 typedef struct ia_css_queue_remote ia_css_queue_remote_t;
diff --git a/drivers/staging/media/atomisp/pci/runtime/queue/src/queue.c b/drivers/staging/media/atomisp/pci/runtime/queue/src/queue.c
index afe77d4373f8dda6da572a496b4e1c11e59a44f7..857ab71ed9b75424cce0caa23d8a4d239b4f738b 100644
--- a/drivers/staging/media/atomisp/pci/runtime/queue/src/queue.c
+++ b/drivers/staging/media/atomisp/pci/runtime/queue/src/queue.c
@@ -15,8 +15,8 @@
  *****************************************************************************/
 int ia_css_queue_local_init(ia_css_queue_t *qhandle, ia_css_queue_local_t *desc)
 {
-	if (NULL == qhandle || NULL == desc
-	    || NULL == desc->cb_elems || NULL == desc->cb_desc) {
+	if (NULL == qhandle || NULL == desc || NULL == desc->cb_elems ||
+	    NULL == desc->cb_desc) {
 		/* Invalid parameters, return error*/
 		return -EINVAL;
 	}
@@ -25,14 +25,14 @@ int ia_css_queue_local_init(ia_css_queue_t *qhandle, ia_css_queue_local_t *desc)
 	qhandle->type = IA_CSS_QUEUE_TYPE_LOCAL;
 
 	/* Create a local circular buffer queue*/
-	ia_css_circbuf_create(&qhandle->desc.cb_local,
-			      desc->cb_elems,
+	ia_css_circbuf_create(&qhandle->desc.cb_local, desc->cb_elems,
 			      desc->cb_desc);
 
 	return 0;
 }
 
-int ia_css_queue_remote_init(ia_css_queue_t *qhandle, ia_css_queue_remote_t *desc)
+int ia_css_queue_remote_init(ia_css_queue_t *qhandle,
+			     ia_css_queue_remote_t *desc)
 {
 	if (NULL == qhandle || NULL == desc) {
 		/* Invalid parameters, return error*/
@@ -119,7 +119,8 @@ int ia_css_queue_enqueue(ia_css_queue_t *qhandle, uint32_t item)
 		 */
 		ignore_desc_flags = QUEUE_IGNORE_SIZE_START_STEP_FLAGS;
 
-		error = ia_css_queue_store(qhandle, &cb_desc, ignore_desc_flags);
+		error = ia_css_queue_store(qhandle, &cb_desc,
+					   ignore_desc_flags);
 		if (error != 0)
 			return error;
 	}
@@ -161,7 +162,8 @@ int ia_css_queue_dequeue(ia_css_queue_t *qhandle, uint32_t *item)
 		if (ia_css_circbuf_desc_is_empty(&cb_desc))
 			return -ENODATA;
 
-		error = ia_css_queue_item_load(qhandle, cb_desc.start, &cb_elem);
+		error = ia_css_queue_item_load(qhandle, cb_desc.start,
+					       &cb_elem);
 		if (error != 0)
 			return error;
 
@@ -175,7 +177,8 @@ int ia_css_queue_dequeue(ia_css_queue_t *qhandle, uint32_t *item)
 		 * to load/store functions
 		 */
 		ignore_desc_flags = QUEUE_IGNORE_SIZE_END_STEP_FLAGS;
-		error = ia_css_queue_store(qhandle, &cb_desc, ignore_desc_flags);
+		error = ia_css_queue_store(qhandle, &cb_desc,
+					   ignore_desc_flags);
 		if (error != 0)
 			return error;
 	}
@@ -292,11 +295,13 @@ int ia_css_queue_peek(ia_css_queue_t *qhandle, u32 offset, uint32_t *element)
 		 * operate on the queue
 		 */
 		/* Check if offset is valid */
-		num_elems = ia_css_circbuf_get_num_elems(&qhandle->desc.cb_local);
+		num_elems =
+			ia_css_circbuf_get_num_elems(&qhandle->desc.cb_local);
 		if (offset > num_elems)
 			return -EINVAL;
 
-		*element = ia_css_circbuf_peek_from_start(&qhandle->desc.cb_local, (int)offset);
+		*element = ia_css_circbuf_peek_from_start(
+			&qhandle->desc.cb_local, (int)offset);
 		return 0;
 	} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {
 		/* a. Load the queue from remote */
@@ -306,7 +311,7 @@ int ia_css_queue_peek(ia_css_queue_t *qhandle, u32 offset, uint32_t *element)
 
 		QUEUE_CB_DESC_INIT(&cb_desc);
 
-		error =  ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);
+		error = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);
 		if (error != 0)
 			return error;
 
@@ -316,7 +321,8 @@ int ia_css_queue_peek(ia_css_queue_t *qhandle, u32 offset, uint32_t *element)
 			return -EINVAL;
 
 		offset = OP_std_modadd(cb_desc.start, offset, cb_desc.size);
-		error = ia_css_queue_item_load(qhandle, (uint8_t)offset, &cb_elem);
+		error = ia_css_queue_item_load(qhandle, (uint8_t)offset,
+					       &cb_elem);
 		if (error != 0)
 			return error;
 
diff --git a/drivers/staging/media/atomisp/pci/runtime/queue/src/queue_access.c b/drivers/staging/media/atomisp/pci/runtime/queue/src/queue_access.c
index 2591d157870ce54d2363e7a7fd05fe7fb8bd432c..bb7fbc9ae1bcab67abfc38679f55f256a1c47838 100644
--- a/drivers/staging/media/atomisp/pci/runtime/queue/src/queue_access.c
+++ b/drivers/staging/media/atomisp/pci/runtime/queue/src/queue_access.c
@@ -12,10 +12,9 @@
 #include "sp.h"
 #include "assert_support.h"
 
-int ia_css_queue_load(
-    struct ia_css_queue *rdesc,
-    ia_css_circbuf_desc_t *cb_desc,
-    uint32_t ignore_desc_flags)
+int ia_css_queue_load(struct ia_css_queue *rdesc,
+		      ia_css_circbuf_desc_t *cb_desc,
+		      uint32_t ignore_desc_flags)
 {
 	if (!rdesc || !cb_desc)
 		return -EINVAL;
@@ -24,9 +23,10 @@ int ia_css_queue_load(
 		assert(ignore_desc_flags <= QUEUE_IGNORE_DESC_FLAGS_MAX);
 
 		if (0 == (ignore_desc_flags & QUEUE_IGNORE_SIZE_FLAG)) {
-			cb_desc->size = sp_dmem_load_uint8(rdesc->proc_id,
-							   rdesc->desc.remote.cb_desc_addr
-							   + offsetof(ia_css_circbuf_desc_t, size));
+			cb_desc->size = sp_dmem_load_uint8(
+				rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr +
+					offsetof(ia_css_circbuf_desc_t, size));
 
 			if (cb_desc->size == 0) {
 				/* Adding back the workaround which was removed
@@ -40,25 +40,27 @@ int ia_css_queue_load(
 		}
 
 		if (0 == (ignore_desc_flags & QUEUE_IGNORE_START_FLAG))
-			cb_desc->start = sp_dmem_load_uint8(rdesc->proc_id,
-							    rdesc->desc.remote.cb_desc_addr
-							    + offsetof(ia_css_circbuf_desc_t, start));
+			cb_desc->start = sp_dmem_load_uint8(
+				rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr +
+					offsetof(ia_css_circbuf_desc_t, start));
 
 		if (0 == (ignore_desc_flags & QUEUE_IGNORE_END_FLAG))
-			cb_desc->end = sp_dmem_load_uint8(rdesc->proc_id,
-							  rdesc->desc.remote.cb_desc_addr
-							  + offsetof(ia_css_circbuf_desc_t, end));
+			cb_desc->end = sp_dmem_load_uint8(
+				rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr +
+					offsetof(ia_css_circbuf_desc_t, end));
 
 		if (0 == (ignore_desc_flags & QUEUE_IGNORE_STEP_FLAG))
-			cb_desc->step = sp_dmem_load_uint8(rdesc->proc_id,
-							   rdesc->desc.remote.cb_desc_addr
-							   + offsetof(ia_css_circbuf_desc_t, step));
+			cb_desc->step = sp_dmem_load_uint8(
+				rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr +
+					offsetof(ia_css_circbuf_desc_t, step));
 
 	} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {
 		/* doing DMA transfer of entire structure */
-		hmm_load(rdesc->desc.remote.cb_desc_addr,
-			  (void *)cb_desc,
-			  sizeof(ia_css_circbuf_desc_t));
+		hmm_load(rdesc->desc.remote.cb_desc_addr, (void *)cb_desc,
+			 sizeof(ia_css_circbuf_desc_t));
 	} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {
 		/* Not supported yet */
 		return -ENOTSUPP;
@@ -67,10 +69,9 @@ int ia_css_queue_load(
 	return 0;
 }
 
-int ia_css_queue_store(
-    struct ia_css_queue *rdesc,
-    ia_css_circbuf_desc_t *cb_desc,
-    uint32_t ignore_desc_flags)
+int ia_css_queue_store(struct ia_css_queue *rdesc,
+		       ia_css_circbuf_desc_t *cb_desc,
+		       uint32_t ignore_desc_flags)
 {
 	if (!rdesc || !cb_desc)
 		return -EINVAL;
@@ -79,33 +80,36 @@ int ia_css_queue_store(
 		assert(ignore_desc_flags <= QUEUE_IGNORE_DESC_FLAGS_MAX);
 
 		if (0 == (ignore_desc_flags & QUEUE_IGNORE_SIZE_FLAG))
-			sp_dmem_store_uint8(rdesc->proc_id,
-					    rdesc->desc.remote.cb_desc_addr
-					    + offsetof(ia_css_circbuf_desc_t, size),
-					    cb_desc->size);
+			sp_dmem_store_uint8(
+				rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr +
+					offsetof(ia_css_circbuf_desc_t, size),
+				cb_desc->size);
 
 		if (0 == (ignore_desc_flags & QUEUE_IGNORE_START_FLAG))
-			sp_dmem_store_uint8(rdesc->proc_id,
-					    rdesc->desc.remote.cb_desc_addr
-					    + offsetof(ia_css_circbuf_desc_t, start),
-					    cb_desc->start);
+			sp_dmem_store_uint8(
+				rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr +
+					offsetof(ia_css_circbuf_desc_t, start),
+				cb_desc->start);
 
 		if (0 == (ignore_desc_flags & QUEUE_IGNORE_END_FLAG))
-			sp_dmem_store_uint8(rdesc->proc_id,
-					    rdesc->desc.remote.cb_desc_addr
-					    + offsetof(ia_css_circbuf_desc_t, end),
-					    cb_desc->end);
+			sp_dmem_store_uint8(
+				rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr +
+					offsetof(ia_css_circbuf_desc_t, end),
+				cb_desc->end);
 
 		if (0 == (ignore_desc_flags & QUEUE_IGNORE_STEP_FLAG))
-			sp_dmem_store_uint8(rdesc->proc_id,
-					    rdesc->desc.remote.cb_desc_addr
-					    + offsetof(ia_css_circbuf_desc_t, step),
-					    cb_desc->step);
+			sp_dmem_store_uint8(
+				rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr +
+					offsetof(ia_css_circbuf_desc_t, step),
+				cb_desc->step);
 	} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {
 		/* doing DMA transfer of entire structure */
-		hmm_store(rdesc->desc.remote.cb_desc_addr,
-			   (void *)cb_desc,
-			   sizeof(ia_css_circbuf_desc_t));
+		hmm_store(rdesc->desc.remote.cb_desc_addr, (void *)cb_desc,
+			  sizeof(ia_css_circbuf_desc_t));
 	} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {
 		/* Not supported yet */
 		return -ENOTSUPP;
@@ -114,25 +118,21 @@ int ia_css_queue_store(
 	return 0;
 }
 
-int ia_css_queue_item_load(
-    struct ia_css_queue *rdesc,
-    u8 position,
-    ia_css_circbuf_elem_t *item)
+int ia_css_queue_item_load(struct ia_css_queue *rdesc, u8 position,
+			   ia_css_circbuf_elem_t *item)
 {
 	if (!rdesc || !item)
 		return -EINVAL;
 
 	if (rdesc->location == IA_CSS_QUEUE_LOC_SP) {
 		sp_dmem_load(rdesc->proc_id,
-			     rdesc->desc.remote.cb_elems_addr
-			     + position * sizeof(ia_css_circbuf_elem_t),
-			     item,
-			     sizeof(ia_css_circbuf_elem_t));
+			     rdesc->desc.remote.cb_elems_addr +
+				     position * sizeof(ia_css_circbuf_elem_t),
+			     item, sizeof(ia_css_circbuf_elem_t));
 	} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {
-		hmm_load(rdesc->desc.remote.cb_elems_addr
-			  + position * sizeof(ia_css_circbuf_elem_t),
-			  (void *)item,
-			  sizeof(ia_css_circbuf_elem_t));
+		hmm_load(rdesc->desc.remote.cb_elems_addr +
+				 position * sizeof(ia_css_circbuf_elem_t),
+			 (void *)item, sizeof(ia_css_circbuf_elem_t));
 	} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {
 		/* Not supported yet */
 		return -ENOTSUPP;
@@ -141,25 +141,21 @@ int ia_css_queue_item_load(
 	return 0;
 }
 
-int ia_css_queue_item_store(
-    struct ia_css_queue *rdesc,
-    u8 position,
-    ia_css_circbuf_elem_t *item)
+int ia_css_queue_item_store(struct ia_css_queue *rdesc, u8 position,
+			    ia_css_circbuf_elem_t *item)
 {
 	if (!rdesc || !item)
 		return -EINVAL;
 
 	if (rdesc->location == IA_CSS_QUEUE_LOC_SP) {
 		sp_dmem_store(rdesc->proc_id,
-			      rdesc->desc.remote.cb_elems_addr
-			      + position * sizeof(ia_css_circbuf_elem_t),
-			      item,
-			      sizeof(ia_css_circbuf_elem_t));
+			      rdesc->desc.remote.cb_elems_addr +
+				      position * sizeof(ia_css_circbuf_elem_t),
+			      item, sizeof(ia_css_circbuf_elem_t));
 	} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {
-		hmm_store(rdesc->desc.remote.cb_elems_addr
-			   + position * sizeof(ia_css_circbuf_elem_t),
-			   (void *)item,
-			   sizeof(ia_css_circbuf_elem_t));
+		hmm_store(rdesc->desc.remote.cb_elems_addr +
+				  position * sizeof(ia_css_circbuf_elem_t),
+			  (void *)item, sizeof(ia_css_circbuf_elem_t));
 	} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {
 		/* Not supported yet */
 		return -ENOTSUPP;
diff --git a/drivers/staging/media/atomisp/pci/runtime/queue/src/queue_access.h b/drivers/staging/media/atomisp/pci/runtime/queue/src/queue_access.h
index d62133a8fe6f86a56dd2838fc1ee74123014aaba..9651e51c46779f70ebb7dfc52f3cace7162ae1a3 100644
--- a/drivers/staging/media/atomisp/pci/runtime/queue/src/queue_access.h
+++ b/drivers/staging/media/atomisp/pci/runtime/queue/src/queue_access.h
@@ -13,66 +13,57 @@
 #include <ia_css_queue_comm.h>
 #include <ia_css_circbuf.h>
 
-#define QUEUE_IGNORE_START_FLAG	0x0001
-#define QUEUE_IGNORE_END_FLAG	0x0002
-#define QUEUE_IGNORE_SIZE_FLAG	0x0004
-#define QUEUE_IGNORE_STEP_FLAG	0x0008
+#define QUEUE_IGNORE_START_FLAG 0x0001
+#define QUEUE_IGNORE_END_FLAG 0x0002
+#define QUEUE_IGNORE_SIZE_FLAG 0x0004
+#define QUEUE_IGNORE_STEP_FLAG 0x0008
 #define QUEUE_IGNORE_DESC_FLAGS_MAX 0x000f
 
-#define QUEUE_IGNORE_SIZE_START_STEP_FLAGS \
-	(QUEUE_IGNORE_SIZE_FLAG | \
-	QUEUE_IGNORE_START_FLAG | \
-	QUEUE_IGNORE_STEP_FLAG)
+#define QUEUE_IGNORE_SIZE_START_STEP_FLAGS                  \
+	(QUEUE_IGNORE_SIZE_FLAG | QUEUE_IGNORE_START_FLAG | \
+	 QUEUE_IGNORE_STEP_FLAG)
 
-#define QUEUE_IGNORE_SIZE_END_STEP_FLAGS \
-	(QUEUE_IGNORE_SIZE_FLAG | \
-	QUEUE_IGNORE_END_FLAG   | \
-	QUEUE_IGNORE_STEP_FLAG)
+#define QUEUE_IGNORE_SIZE_END_STEP_FLAGS                  \
+	(QUEUE_IGNORE_SIZE_FLAG | QUEUE_IGNORE_END_FLAG | \
+	 QUEUE_IGNORE_STEP_FLAG)
 
-#define QUEUE_IGNORE_START_END_STEP_FLAGS \
-	(QUEUE_IGNORE_START_FLAG | \
-	QUEUE_IGNORE_END_FLAG	  | \
-	QUEUE_IGNORE_STEP_FLAG)
+#define QUEUE_IGNORE_START_END_STEP_FLAGS                  \
+	(QUEUE_IGNORE_START_FLAG | QUEUE_IGNORE_END_FLAG | \
+	 QUEUE_IGNORE_STEP_FLAG)
 
-#define QUEUE_CB_DESC_INIT(cb_desc)	\
-	do {				\
-		(cb_desc)->size  = 0;	\
-		(cb_desc)->step  = 0;	\
-		(cb_desc)->start = 0;	\
-		(cb_desc)->end   = 0;	\
+#define QUEUE_CB_DESC_INIT(cb_desc)   \
+	do {                          \
+		(cb_desc)->size = 0;  \
+		(cb_desc)->step = 0;  \
+		(cb_desc)->start = 0; \
+		(cb_desc)->end = 0;   \
 	} while (0)
 
 struct ia_css_queue {
-	u8 type;        /* Specify remote/local type of access */
-	u8 location;    /* Cell location for queue */
-	u8 proc_id;     /* Processor id for queue access */
+	u8 type; /* Specify remote/local type of access */
+	u8 location; /* Cell location for queue */
+	u8 proc_id; /* Processor id for queue access */
 	union {
 		ia_css_circbuf_t cb_local;
 		struct {
 			u32 cb_desc_addr; /*Circbuf desc address for remote queues*/
 			u32 cb_elems_addr; /*Circbuf elements addr for remote queue*/
-		}	remote;
+		} remote;
 	} desc;
 };
 
-int ia_css_queue_load(
-    struct ia_css_queue *rdesc,
-    ia_css_circbuf_desc_t *cb_desc,
-    uint32_t ignore_desc_flags);
+int ia_css_queue_load(struct ia_css_queue *rdesc,
+		      ia_css_circbuf_desc_t *cb_desc,
+		      uint32_t ignore_desc_flags);
 
-int ia_css_queue_store(
-    struct ia_css_queue *rdesc,
-    ia_css_circbuf_desc_t *cb_desc,
-    uint32_t ignore_desc_flags);
+int ia_css_queue_store(struct ia_css_queue *rdesc,
+		       ia_css_circbuf_desc_t *cb_desc,
+		       uint32_t ignore_desc_flags);
 
-int ia_css_queue_item_load(
-    struct ia_css_queue *rdesc,
-    u8 position,
-    ia_css_circbuf_elem_t *item);
+int ia_css_queue_item_load(struct ia_css_queue *rdesc, u8 position,
+			   ia_css_circbuf_elem_t *item);
 
-int ia_css_queue_item_store(
-    struct ia_css_queue *rdesc,
-    u8 position,
-    ia_css_circbuf_elem_t *item);
+int ia_css_queue_item_store(struct ia_css_queue *rdesc, u8 position,
+			    ia_css_circbuf_elem_t *item);
 
 #endif /* __QUEUE_ACCESS_H */
diff --git a/drivers/staging/media/atomisp/pci/runtime/rmgr/interface/ia_css_rmgr.h b/drivers/staging/media/atomisp/pci/runtime/rmgr/interface/ia_css_rmgr.h
index 00b903d950df78e8e0606dcb6b5499c11ea76102..2336efa2e9f5fcc5e646c306b772e611c5db7502 100644
--- a/drivers/staging/media/atomisp/pci/runtime/rmgr/interface/ia_css_rmgr.h
+++ b/drivers/staging/media/atomisp/pci/runtime/rmgr/interface/ia_css_rmgr.h
@@ -12,10 +12,10 @@
 #ifndef __INLINE_RMGR__
 #define STORAGE_CLASS_RMGR_H extern
 #define STORAGE_CLASS_RMGR_C
-#else				/* __INLINE_RMGR__ */
-#define STORAGE_CLASS_RMGR_H static inline
-#define STORAGE_CLASS_RMGR_C static inline
-#endif				/* __INLINE_RMGR__ */
+#else /* __INLINE_RMGR__ */
+#define STORAGE_CLASS_RMGR_H (static inline)
+#define STORAGE_CLASS_RMGR_C (static inline)
+#endif /* __INLINE_RMGR__ */
 
 /**
  * @brief Initialize resource manager (host/common)
@@ -61,4 +61,4 @@ void ia_css_rmgr_uninit(void);
 
 #include "ia_css_rmgr_vbuf.h"
 
-#endif	/* _IA_CSS_RMGR_H */
+#endif /* _IA_CSS_RMGR_H */
diff --git a/drivers/staging/media/atomisp/pci/runtime/rmgr/interface/ia_css_rmgr_vbuf.h b/drivers/staging/media/atomisp/pci/runtime/rmgr/interface/ia_css_rmgr_vbuf.h
index 6820bfc7743224a4fd9b10bb67255fee9c32e6a6..fe0d9d6a7aa0be00f5058379e06b744f8fd89094 100644
--- a/drivers/staging/media/atomisp/pci/runtime/rmgr/interface/ia_css_rmgr_vbuf.h
+++ b/drivers/staging/media/atomisp/pci/runtime/rmgr/interface/ia_css_rmgr_vbuf.h
@@ -44,16 +44,16 @@ extern struct ia_css_rmgr_vbuf_pool *hmm_buffer_pool;
  *
  * @param pool	The pointer to the pool
  */
-STORAGE_CLASS_RMGR_H int ia_css_rmgr_init_vbuf(
-    struct ia_css_rmgr_vbuf_pool *pool);
+STORAGE_CLASS_RMGR_H int
+ia_css_rmgr_init_vbuf(struct ia_css_rmgr_vbuf_pool *pool);
 
 /**
  * @brief Uninitialize the resource pool (host, vbuf)
  *
  * @param pool	The pointer to the pool
  */
-STORAGE_CLASS_RMGR_H void ia_css_rmgr_uninit_vbuf(
-    struct ia_css_rmgr_vbuf_pool *pool);
+STORAGE_CLASS_RMGR_H void
+ia_css_rmgr_uninit_vbuf(struct ia_css_rmgr_vbuf_pool *pool);
 
 /**
  * @brief Acquire a handle from the pool (host, vbuf)
@@ -61,9 +61,9 @@ STORAGE_CLASS_RMGR_H void ia_css_rmgr_uninit_vbuf(
  * @param pool		The pointer to the pool
  * @param handle	The pointer to the handle
  */
-STORAGE_CLASS_RMGR_H void ia_css_rmgr_acq_vbuf(
-    struct ia_css_rmgr_vbuf_pool *pool,
-    struct ia_css_rmgr_vbuf_handle **handle);
+STORAGE_CLASS_RMGR_H void
+ia_css_rmgr_acq_vbuf(struct ia_css_rmgr_vbuf_pool *pool,
+		     struct ia_css_rmgr_vbuf_handle **handle);
 
 /**
  * @brief Release a handle to the pool (host, vbuf)
@@ -71,9 +71,9 @@ STORAGE_CLASS_RMGR_H void ia_css_rmgr_acq_vbuf(
  * @param pool		The pointer to the pool
  * @param handle	The pointer to the handle
  */
-STORAGE_CLASS_RMGR_H void ia_css_rmgr_rel_vbuf(
-    struct ia_css_rmgr_vbuf_pool *pool,
-    struct ia_css_rmgr_vbuf_handle **handle);
+STORAGE_CLASS_RMGR_H void
+ia_css_rmgr_rel_vbuf(struct ia_css_rmgr_vbuf_pool *pool,
+		     struct ia_css_rmgr_vbuf_handle **handle);
 
 /**
  * @brief Retain the reference count for a handle (host, vbuf)
@@ -89,4 +89,4 @@ void ia_css_rmgr_refcount_retain_vbuf(struct ia_css_rmgr_vbuf_handle **handle);
  */
 void ia_css_rmgr_refcount_release_vbuf(struct ia_css_rmgr_vbuf_handle **handle);
 
-#endif	/* _IA_CSS_RMGR_VBUF_H */
+#endif /* _IA_CSS_RMGR_VBUF_H */
diff --git a/drivers/staging/media/atomisp/pci/runtime/rmgr/src/rmgr_vbuf.c b/drivers/staging/media/atomisp/pci/runtime/rmgr/src/rmgr_vbuf.c
index 940b28c66e99752e8309ee872dde413f8ad3147d..2f33e0b6fc348dc3190ed45786bb4e6ad5b5ca5c 100644
--- a/drivers/staging/media/atomisp/pci/runtime/rmgr/src/rmgr_vbuf.c
+++ b/drivers/staging/media/atomisp/pci/runtime/rmgr/src/rmgr_vbuf.c
@@ -27,16 +27,16 @@ static struct ia_css_rmgr_vbuf_pool refpool;
  * @brief VBUF resource pool - writepool
  */
 static struct ia_css_rmgr_vbuf_pool writepool = {
-	.copy_on_write	= true,
+	.copy_on_write = true,
 };
 
 /*
  * @brief VBUF resource pool - hmmbufferpool
  */
 static struct ia_css_rmgr_vbuf_pool hmmbufferpool = {
-	.copy_on_write	= true,
-	.recycle	= true,
-	.size		= 32,
+	.copy_on_write = true,
+	.recycle = true,
+	.size = 32,
 };
 
 struct ia_css_rmgr_vbuf_pool *vbuf_ref = &refpool;
@@ -80,8 +80,9 @@ void ia_css_rmgr_refcount_retain_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
 		 * this is an error handle and report it.
 		 */
 		if (!*handle) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
-					    "ia_css_i_host_refcount_retain_vbuf() failed to find empty slot!\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_ERROR,
+				"ia_css_i_host_refcount_retain_vbuf() failed to find empty slot!\n");
 			return;
 		}
 		(*handle)->vptr = h->vptr;
@@ -98,7 +99,8 @@ void ia_css_rmgr_refcount_retain_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
 void ia_css_rmgr_refcount_release_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
 {
 	if ((!handle) || ((*handle) == NULL) || (((*handle)->count) == 0)) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "%s invalid arguments!\n", __func__);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "%s invalid arguments!\n", __func__);
 		return;
 	}
 	/* decrease reference count */
@@ -128,9 +130,7 @@ int ia_css_rmgr_init_vbuf(struct ia_css_rmgr_vbuf_pool *pool)
 	/* initialize the recycle pool if used */
 	if (pool->recycle && pool->size) {
 		/* allocate memory for storing the handles */
-		bytes_needed =
-		    sizeof(void *) *
-		    pool->size;
+		bytes_needed = sizeof(void *) * pool->size;
 		pool->handles = kvmalloc(bytes_needed, GFP_KERNEL);
 		if (pool->handles)
 			memset(pool->handles, 0, bytes_needed);
@@ -155,21 +155,24 @@ void ia_css_rmgr_uninit_vbuf(struct ia_css_rmgr_vbuf_pool *pool)
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s\n", __func__);
 	if (!pool) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "%s NULL argument\n", __func__);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "%s NULL argument\n",
+				    __func__);
 		return;
 	}
 	if (pool->handles) {
 		/* free the hmm buffers */
 		for (i = 0; i < pool->size; i++) {
 			if (pool->handles[i]) {
-				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-						    "   freeing/releasing %x (count=%d)\n",
-						    pool->handles[i]->vptr,
-						    pool->handles[i]->count);
+				ia_css_debug_dtrace(
+					IA_CSS_DEBUG_TRACE,
+					"   freeing/releasing %x (count=%d)\n",
+					pool->handles[i]->vptr,
+					pool->handles[i]->count);
 				/* free memory */
 				hmm_free(pool->handles[i]->vptr);
 				/* remove from refcount admin */
-				ia_css_rmgr_refcount_release_vbuf(&pool->handles[i]);
+				ia_css_rmgr_refcount_release_vbuf(
+					&pool->handles[i]);
 			}
 		}
 		/* now free the pool handles list */
@@ -184,9 +187,8 @@ void ia_css_rmgr_uninit_vbuf(struct ia_css_rmgr_vbuf_pool *pool)
  * @param pool		The pointer to the pool
  * @param handle	The pointer to the handle
  */
-static
-void rmgr_push_handle(struct ia_css_rmgr_vbuf_pool *pool,
-		      struct ia_css_rmgr_vbuf_handle **handle)
+static void rmgr_push_handle(struct ia_css_rmgr_vbuf_pool *pool,
+			     struct ia_css_rmgr_vbuf_handle **handle)
 {
 	u32 i;
 	bool success = false;
@@ -212,9 +214,8 @@ void rmgr_push_handle(struct ia_css_rmgr_vbuf_pool *pool,
  * @param pool		The pointer to the pool
  * @param handle	The pointer to the handle
  */
-static
-void rmgr_pop_handle(struct ia_css_rmgr_vbuf_pool *pool,
-		     struct ia_css_rmgr_vbuf_handle **handle)
+static void rmgr_pop_handle(struct ia_css_rmgr_vbuf_pool *pool,
+			    struct ia_css_rmgr_vbuf_handle **handle)
 {
 	u32 i;
 
diff --git a/drivers/staging/media/atomisp/pci/runtime/spctrl/interface/ia_css_spctrl.h b/drivers/staging/media/atomisp/pci/runtime/spctrl/interface/ia_css_spctrl.h
index 3cd69284f4b4fbdca538f0ff0adce97b4f97e143..0542b37e62e641183cc896ce03e0b6ca0c3ad176 100644
--- a/drivers/staging/media/atomisp/pci/runtime/spctrl/interface/ia_css_spctrl.h
+++ b/drivers/staging/media/atomisp/pci/runtime/spctrl/interface/ia_css_spctrl.h
@@ -12,26 +12,25 @@
 #include "ia_css_spctrl_comm.h"
 
 typedef struct {
-	u32        ddr_data_offset;       /**  posistion of data in DDR */
-	u32        dmem_data_addr;        /** data segment address in dmem */
-	u32        dmem_bss_addr;         /** bss segment address in dmem  */
-	u32        data_size;             /** data segment size            */
-	u32        bss_size;              /** bss segment size             */
-	u32        spctrl_config_dmem_addr; /* <location of dmem_cfg  in SP dmem */
-	u32        spctrl_state_dmem_addr;  /* < location of state  in SP dmem */
-	unsigned int    sp_entry;                /* < entry function ptr on SP */
-	const void      *code;                   /** location of firmware */
-	u32         code_size;
-	char      *program_name;    /** not used on hardware, only for simulation */
+	u32 ddr_data_offset; /**  posistion of data in DDR */
+	u32 dmem_data_addr; /** data segment address in dmem */
+	u32 dmem_bss_addr; /** bss segment address in dmem  */
+	u32 data_size; /** data segment size            */
+	u32 bss_size; /** bss segment size             */
+	u32 spctrl_config_dmem_addr; /* <location of dmem_cfg  in SP dmem */
+	u32 spctrl_state_dmem_addr; /* < location of state  in SP dmem */
+	unsigned int sp_entry; /* < entry function ptr on SP */
+	const void *code; /** location of firmware */
+	u32 code_size;
+	char *program_name; /** not used on hardware, only for simulation */
 } ia_css_spctrl_cfg;
 
 /* Get the code addr in DDR of SP */
-ia_css_ptr get_sp_code_addr(sp_ID_t  sp_id);
+ia_css_ptr get_sp_code_addr(sp_ID_t sp_id);
 
 /* ! Load firmware on to specfied SP
 */
-int ia_css_spctrl_load_fw(sp_ID_t sp_id,
-				      ia_css_spctrl_cfg *spctrl_cfg);
+int ia_css_spctrl_load_fw(sp_ID_t sp_id, ia_css_spctrl_cfg *spctrl_cfg);
 
 /* ISP2401 */
 /*! Setup registers for reloading FW */
diff --git a/drivers/staging/media/atomisp/pci/runtime/spctrl/interface/ia_css_spctrl_comm.h b/drivers/staging/media/atomisp/pci/runtime/spctrl/interface/ia_css_spctrl_comm.h
index f358785fa5b6b596bf54c39dd6463851b1a7ecf5..1cb781db82de9f6f18fa39047da7617e92192811 100644
--- a/drivers/staging/media/atomisp/pci/runtime/spctrl/interface/ia_css_spctrl_comm.h
+++ b/drivers/staging/media/atomisp/pci/runtime/spctrl/interface/ia_css_spctrl_comm.h
@@ -23,19 +23,19 @@ typedef enum {
  * initialization of SP DMEM using the SP itself
  */
 struct ia_css_sp_init_dmem_cfg {
-	ia_css_ptr      ddr_data_addr;  /** data segment address in ddr  */
-	u32        dmem_data_addr; /** data segment address in dmem */
-	u32        dmem_bss_addr;  /** bss segment address in dmem  */
-	u32        data_size;      /** data segment size            */
-	u32        bss_size;       /** bss segment size             */
-	sp_ID_t         sp_id;          /* <sp Id */
+	ia_css_ptr ddr_data_addr; /** data segment address in ddr  */
+	u32 dmem_data_addr; /** data segment address in dmem */
+	u32 dmem_bss_addr; /** bss segment address in dmem  */
+	u32 data_size; /** data segment size            */
+	u32 bss_size; /** bss segment size             */
+	sp_ID_t sp_id; /* <sp Id */
 };
 
-#define SIZE_OF_IA_CSS_SP_INIT_DMEM_CFG_STRUCT	\
-	(1 * SIZE_OF_IA_CSS_PTR) +		\
-	(4 * sizeof(uint32_t)) +		\
-	(1 * sizeof(sp_ID_t))
+#define SIZE_OF_IA_CSS_SP_INIT_DMEM_CFG_STRUCT             ( \
+	(1 * SIZE_OF_IA_CSS_PTR) + (4 * sizeof(uint32_t)) + \
+		(1 * sizeof(sp_ID_t)))
 
-static_assert(sizeof(struct ia_css_sp_init_dmem_cfg) == SIZE_OF_IA_CSS_SP_INIT_DMEM_CFG_STRUCT);
+static_assert(sizeof(struct ia_css_sp_init_dmem_cfg) ==
+	      SIZE_OF_IA_CSS_SP_INIT_DMEM_CFG_STRUCT);
 
 #endif /* __IA_CSS_SPCTRL_COMM_H__ */
diff --git a/drivers/staging/media/atomisp/pci/runtime/spctrl/src/spctrl.c b/drivers/staging/media/atomisp/pci/runtime/spctrl/src/spctrl.c
index 78f00f07baaa755e26f8720fb4073ffc6a4e9188..bbd454c26c5bab74d7f4e35a2c3639e050d66b22 100644
--- a/drivers/staging/media/atomisp/pci/runtime/spctrl/src/spctrl.c
+++ b/drivers/staging/media/atomisp/pci/runtime/spctrl/src/spctrl.c
@@ -16,16 +16,16 @@
 
 struct spctrl_context_info {
 	struct ia_css_sp_init_dmem_cfg dmem_config;
-	u32        spctrl_config_dmem_addr; /* location of dmem_cfg  in SP dmem */
-	u32        spctrl_state_dmem_addr;
-	unsigned int    sp_entry;           /* entry function ptr on SP */
-	ia_css_ptr    code_addr;          /* sp firmware location in host mem-DDR*/
-	u32        code_size;
-	char           *program_name;       /* used in case of PLATFORM_SIM */
+	u32 spctrl_config_dmem_addr; /* location of dmem_cfg  in SP dmem */
+	u32 spctrl_state_dmem_addr;
+	unsigned int sp_entry; /* entry function ptr on SP */
+	ia_css_ptr code_addr; /* sp firmware location in host mem-DDR*/
+	u32 code_size;
+	char *program_name; /* used in case of PLATFORM_SIM */
 };
 
 static struct spctrl_context_info spctrl_cofig_info[N_SP_ID];
-static bool spctrl_loaded[N_SP_ID] = {0};
+static bool spctrl_loaded[N_SP_ID] = { 0 };
 
 /* Load firmware */
 int ia_css_spctrl_load_fw(sp_ID_t sp_id, ia_css_spctrl_cfg *spctrl_cfg)
@@ -40,15 +40,15 @@ int ia_css_spctrl_load_fw(sp_ID_t sp_id, ia_css_spctrl_cfg *spctrl_cfg)
 
 	init_dmem_cfg = &spctrl_cofig_info[sp_id].dmem_config;
 	init_dmem_cfg->dmem_data_addr = spctrl_cfg->dmem_data_addr;
-	init_dmem_cfg->dmem_bss_addr  = spctrl_cfg->dmem_bss_addr;
-	init_dmem_cfg->data_size      = spctrl_cfg->data_size;
-	init_dmem_cfg->bss_size       = spctrl_cfg->bss_size;
-	init_dmem_cfg->sp_id          = sp_id;
+	init_dmem_cfg->dmem_bss_addr = spctrl_cfg->dmem_bss_addr;
+	init_dmem_cfg->data_size = spctrl_cfg->data_size;
+	init_dmem_cfg->bss_size = spctrl_cfg->bss_size;
+	init_dmem_cfg->sp_id = sp_id;
 
 	spctrl_cofig_info[sp_id].spctrl_config_dmem_addr =
-	    spctrl_cfg->spctrl_config_dmem_addr;
+		spctrl_cfg->spctrl_config_dmem_addr;
 	spctrl_cofig_info[sp_id].spctrl_state_dmem_addr =
-	    spctrl_cfg->spctrl_state_dmem_addr;
+		spctrl_cfg->spctrl_state_dmem_addr;
 
 	/* store code (text + icache) and data to DDR
 	 *
@@ -61,17 +61,19 @@ int ia_css_spctrl_load_fw(sp_ID_t sp_id, ia_css_spctrl_cfg *spctrl_cfg)
 	hmm_store(code_addr, spctrl_cfg->code, spctrl_cfg->code_size);
 
 	if (sizeof(ia_css_ptr) > sizeof(hrt_data)) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
-				    "size of ia_css_ptr can not be greater than hrt_data\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_ERROR,
+			"size of ia_css_ptr can not be greater than hrt_data\n");
 		hmm_free(code_addr);
 		code_addr = mmgr_NULL;
 		return -EINVAL;
 	}
 
-	init_dmem_cfg->ddr_data_addr  = code_addr + spctrl_cfg->ddr_data_offset;
+	init_dmem_cfg->ddr_data_addr = code_addr + spctrl_cfg->ddr_data_offset;
 	if ((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) != 0) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
-				    "DDR address pointer is not properly aligned for DMA transfer\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_ERROR,
+			"DDR address pointer is not properly aligned for DMA transfer\n");
 		hmm_free(code_addr);
 		code_addr = mmgr_NULL;
 		return -EINVAL;
@@ -104,14 +106,15 @@ void sh_css_spctrl_reload_fw(sp_ID_t sp_id)
 	spctrl_loaded[sp_id] = true;
 }
 
-ia_css_ptr get_sp_code_addr(sp_ID_t  sp_id)
+ia_css_ptr get_sp_code_addr(sp_ID_t sp_id)
 {
 	return spctrl_cofig_info[sp_id].code_addr;
 }
 
 int ia_css_spctrl_unload_fw(sp_ID_t sp_id)
 {
-	if ((sp_id >= N_SP_ID) || ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))
+	if ((sp_id >= N_SP_ID) ||
+	    ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))
 		return -EINVAL;
 
 	/*  freeup the resource */
@@ -126,7 +129,8 @@ int ia_css_spctrl_unload_fw(sp_ID_t sp_id)
 /* Initialize dmem_cfg in SP dmem  and  start SP program*/
 int ia_css_spctrl_start(sp_ID_t sp_id)
 {
-	if ((sp_id >= N_SP_ID) || ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))
+	if ((sp_id >= N_SP_ID) ||
+	    ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))
 		return -EINVAL;
 
 	/* Set descr in the SP to initialize the SP DMEM */
@@ -137,8 +141,7 @@ int ia_css_spctrl_start(sp_ID_t sp_id)
 	 */
 	assert(sizeof(unsigned int) <= sizeof(hrt_data));
 
-	sp_dmem_store(sp_id,
-		      spctrl_cofig_info[sp_id].spctrl_config_dmem_addr,
+	sp_dmem_store(sp_id, spctrl_cofig_info[sp_id].spctrl_config_dmem_addr,
 		      &spctrl_cofig_info[sp_id].dmem_config,
 		      sizeof(spctrl_cofig_info[sp_id].dmem_config));
 	/* set the start address */
@@ -161,7 +164,8 @@ ia_css_spctrl_sp_sw_state ia_css_spctrl_get_state(sp_ID_t sp_id)
 	HIVE_ADDR_sp_sw_state = spctrl_cofig_info[sp_id].spctrl_state_dmem_addr;
 	(void)HIVE_ADDR_sp_sw_state; /* Suppres warnings in CRUN */
 	if (sp_id == SP0_ID)
-		state = sp_dmem_load_uint32(sp_id, (unsigned int)sp_address_of(sp_sw_state));
+		state = sp_dmem_load_uint32(
+			sp_id, (unsigned int)sp_address_of(sp_sw_state));
 	return state;
 }
 
diff --git a/drivers/staging/media/atomisp/pci/runtime/tagger/interface/ia_css_tagger_common.h b/drivers/staging/media/atomisp/pci/runtime/tagger/interface/ia_css_tagger_common.h
index 79006c325de60e9e263c71b0beb239b5cc70c35d..66147e63fc0d3b521af27bb8c30dea5af1b29676 100644
--- a/drivers/staging/media/atomisp/pci/runtime/tagger/interface/ia_css_tagger_common.h
+++ b/drivers/staging/media/atomisp/pci/runtime/tagger/interface/ia_css_tagger_common.h
@@ -21,10 +21,10 @@
  * @brief Data structure for the tagger buffer element.
  */
 typedef struct {
-	u32 frame;	/* the frame value stored in the element */
-	u32 param;	/* the param value stored in the element */
-	u8 mark;	/* the mark on the element */
-	u8 lock;	/* the lock on the element */
+	u32 frame; /* the frame value stored in the element */
+	u32 param; /* the param value stored in the element */
+	u8 mark; /* the mark on the element */
+	u8 lock; /* the lock on the element */
 	u8 exp_id; /* exp_id of frame, for debugging only */
 } ia_css_tagger_buf_sp_elem_t;
 
diff --git a/drivers/staging/media/atomisp/pci/runtime/timer/src/timer.c b/drivers/staging/media/atomisp/pci/runtime/timer/src/timer.c
index 391308e563cb035247f768530be90b6406b7c980..5b6ae36d42ffd77dd44bb1ce43e3b39b856841f5 100644
--- a/drivers/staging/media/atomisp/pci/runtime/timer/src/timer.c
+++ b/drivers/staging/media/atomisp/pci/runtime/timer/src/timer.c
@@ -4,7 +4,7 @@
  * Copyright (c) 2015, Intel Corporation.
  */
 
-#include <type_support.h>		/* for uint32_t */
+#include <type_support.h> /* for uint32_t */
 #include "ia_css_timer.h" /*struct ia_css_clock_tick */
 #include "sh_css_legacy.h" /* IA_CSS_PIPE_ID_NUM*/
 #include "gp_timer.h" /*gp_timer_read()*/
diff --git a/drivers/staging/media/atomisp/pci/sh_css.c b/drivers/staging/media/atomisp/pci/sh_css.c
index 5a8e8e67aa1389dd10b9c9d75ffe6ca887776393..8a2130bdbe8ca8ce4d768043af5af72a91d94bf5 100644
--- a/drivers/staging/media/atomisp/pci/sh_css.c
+++ b/drivers/staging/media/atomisp/pci/sh_css.c
@@ -14,12 +14,12 @@
 #include "atomisp_internal.h"
 
 #include "ia_css.h"
-#include "sh_css_hrt.h"		/* only for file 2 MIPI */
+#include "sh_css_hrt.h" /* only for file 2 MIPI */
 #include "ia_css_buffer.h"
 #include "ia_css_binary.h"
 #include "sh_css_internal.h"
 #include "sh_css_mipi.h"
-#include "sh_css_sp.h"		/* sh_css_sp_group */
+#include "sh_css_sp.h" /* sh_css_sp_group */
 #include "ia_css_isys.h"
 #include "ia_css_frame.h"
 #include "sh_css_defs.h"
@@ -46,26 +46,25 @@
 #include "tag.h"
 #include "assert_support.h"
 #include "math_support.h"
-#include "sw_event_global.h"			/* Event IDs.*/
+#include "sw_event_global.h" /* Event IDs.*/
 #include "ia_css_ifmtr.h"
 #include "input_system.h"
-#include "mmu_device.h"		/* mmu_set_page_table_base_index(), ... */
+#include "mmu_device.h" /* mmu_set_page_table_base_index(), ... */
 #include "ia_css_mmu_private.h" /* sh_css_mmu_set_page_table_base_index() */
-#include "gdc_device.h"		/* HRT_GDC_N */
-#include "dma.h"		/* dma_set_max_burst_size() */
-#include "irq.h"		/* virq */
-#include "sp.h"			/* cnd_sp_irq_enable() */
-#include "isp.h"		/* cnd_isp_irq_enable, ISP_VEC_NELEMS */
-#include "gp_device.h"		/* gp_device_reg_store() */
+#include "gdc_device.h" /* HRT_GDC_N */
+#include "dma.h" /* dma_set_max_burst_size() */
+#include "irq.h" /* virq */
+#include "sp.h" /* cnd_sp_irq_enable() */
+#include "isp.h" /* cnd_isp_irq_enable, ISP_VEC_NELEMS */
+#include "gp_device.h" /* gp_device_reg_store() */
 #include <gpio_global.h>
 #include <gpio_private.h>
 #include "timed_ctrl.h"
 #include "ia_css_inputfifo.h"
-#define WITH_PC_MONITORING  0
+#define WITH_PC_MONITORING 0
 
 #define SH_CSS_VIDEO_BUFFER_ALIGNMENT 0
 
-
 #include "ia_css_spctrl.h"
 #include "ia_css_version_data.h"
 #include "sh_css_struct.h"
@@ -88,7 +87,7 @@
 
 struct sh_css my_css;
 
-int  __printf(1, 0) (*sh_css_printf)(const char *fmt, va_list args) = NULL;
+int __printf(1, 0) (*sh_css_printf)(const char *fmt, va_list args) = NULL;
 
 /*
  * modes of work: stream_create and stream_destroy will update the save/restore
@@ -117,31 +116,31 @@ enum ia_sh_css_modes {
  * after it was closed.
 */
 struct sh_css_stream_seed {
-	struct ia_css_stream		**orig_stream;
-	struct ia_css_stream		*stream;
-	struct ia_css_stream_config	stream_config;
-	int				num_pipes;
-	struct ia_css_pipe		*pipes[IA_CSS_PIPE_ID_NUM];
-	struct ia_css_pipe		**orig_pipes[IA_CSS_PIPE_ID_NUM];
-	struct ia_css_pipe_config	pipe_config[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_stream **orig_stream;
+	struct ia_css_stream *stream;
+	struct ia_css_stream_config stream_config;
+	int num_pipes;
+	struct ia_css_pipe *pipes[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_pipe **orig_pipes[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_pipe_config pipe_config[IA_CSS_PIPE_ID_NUM];
 };
 
-#define MAX_ACTIVE_STREAMS	5
+#define MAX_ACTIVE_STREAMS 5
 /*
  * A global struct for save/restore to hold all the data that should
  * sustain power-down: MMU base, IRQ type, env for routines, binary loaded FW
  * and the stream seeds.
  */
 struct sh_css_save {
-	enum ia_sh_css_modes		mode;
-	u32		       mmu_base;		/* the last mmu_base */
-	enum ia_css_irq_type           irq_type;
-	struct sh_css_stream_seed      stream_seeds[MAX_ACTIVE_STREAMS];
-	struct ia_css_fw	       *loaded_fw;	/* fw struct previously loaded */
-	struct ia_css_env	       driver_env;	/* driver-supplied env copy */
+	enum ia_sh_css_modes mode;
+	u32 mmu_base; /* the last mmu_base */
+	enum ia_css_irq_type irq_type;
+	struct sh_css_stream_seed stream_seeds[MAX_ACTIVE_STREAMS];
+	struct ia_css_fw *loaded_fw; /* fw struct previously loaded */
+	struct ia_css_env driver_env; /* driver-supplied env copy */
 };
 
-static bool my_css_save_initialized;	/* if my_css_save was initialized */
+static bool my_css_save_initialized; /* if my_css_save was initialized */
 static struct sh_css_save my_css_save;
 
 /*
@@ -151,7 +150,7 @@ static struct sh_css_save my_css_save;
  */
 
 /* Taking the biggest Size for number of Elements */
-#define MAX_HMM_BUFFER_NUM	\
+#define MAX_HMM_BUFFER_NUM \
 	(SH_CSS_MAX_NUM_QUEUES * (IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE + 2))
 
 struct sh_css_hmm_buffer_record {
@@ -169,11 +168,9 @@ static struct sh_css_hmm_buffer_record hmm_buffer_record[MAX_HMM_BUFFER_NUM];
  * Local prototypes
  */
 
-static int
-allocate_delay_frames(struct ia_css_pipe *pipe);
+static int allocate_delay_frames(struct ia_css_pipe *pipe);
 
-static int
-sh_css_pipe_start(struct ia_css_stream *stream);
+static int sh_css_pipe_start(struct ia_css_stream *stream);
 
 /*
  * @brief Check if all "ia_css_pipe" instances in the target
@@ -188,125 +185,98 @@ sh_css_pipe_start(struct ia_css_stream *stream);
  */
 
 /* ISP 2401 */
-static int
-ia_css_pipe_check_format(struct ia_css_pipe *pipe,
-			 enum ia_css_frame_format format);
+static int ia_css_pipe_check_format(struct ia_css_pipe *pipe,
+				    enum ia_css_frame_format format);
 
 /* ISP 2401 */
-static void
-ia_css_reset_defaults(struct sh_css *css);
+static void ia_css_reset_defaults(struct sh_css *css);
 
-static void
-sh_css_init_host_sp_control_vars(void);
+static void sh_css_init_host_sp_control_vars(void);
 
-static int
-set_num_primary_stages(unsigned int *num, enum ia_css_pipe_version version);
+static int set_num_primary_stages(unsigned int *num,
+				  enum ia_css_pipe_version version);
 
-static bool
-need_capture_pp(const struct ia_css_pipe *pipe);
+static bool need_capture_pp(const struct ia_css_pipe *pipe);
 
-static bool
-need_yuv_scaler_stage(const struct ia_css_pipe *pipe);
+static bool need_yuv_scaler_stage(const struct ia_css_pipe *pipe);
 
 static int ia_css_pipe_create_cas_scaler_desc_single_output(
-    struct ia_css_frame_info *cas_scaler_in_info,
-    struct ia_css_frame_info *cas_scaler_out_info,
-    struct ia_css_frame_info *cas_scaler_vf_info,
-    struct ia_css_cas_binary_descr *descr);
+	struct ia_css_frame_info *cas_scaler_in_info,
+	struct ia_css_frame_info *cas_scaler_out_info,
+	struct ia_css_frame_info *cas_scaler_vf_info,
+	struct ia_css_cas_binary_descr *descr);
 
-static void ia_css_pipe_destroy_cas_scaler_desc(struct ia_css_cas_binary_descr
-	*descr);
+static void
+ia_css_pipe_destroy_cas_scaler_desc(struct ia_css_cas_binary_descr *descr);
 
-static bool
-need_downscaling(const struct ia_css_resolution in_res,
-		 const struct ia_css_resolution out_res);
+static bool need_downscaling(const struct ia_css_resolution in_res,
+			     const struct ia_css_resolution out_res);
 
 static bool need_capt_ldc(const struct ia_css_pipe *pipe);
 
-static int
-sh_css_pipe_load_binaries(struct ia_css_pipe *pipe);
+static int sh_css_pipe_load_binaries(struct ia_css_pipe *pipe);
 
-static
-int sh_css_pipe_get_viewfinder_frame_info(
-    struct ia_css_pipe *pipe,
-    struct ia_css_frame_info *info,
-    unsigned int idx);
+static int sh_css_pipe_get_viewfinder_frame_info(struct ia_css_pipe *pipe,
+						 struct ia_css_frame_info *info,
+						 unsigned int idx);
 
-static int
-sh_css_pipe_get_output_frame_info(struct ia_css_pipe *pipe,
-				  struct ia_css_frame_info *info,
-				  unsigned int idx);
+static int sh_css_pipe_get_output_frame_info(struct ia_css_pipe *pipe,
+					     struct ia_css_frame_info *info,
+					     unsigned int idx);
 
-static int
-capture_start(struct ia_css_pipe *pipe);
+static int capture_start(struct ia_css_pipe *pipe);
 
-static int
-video_start(struct ia_css_pipe *pipe);
+static int video_start(struct ia_css_pipe *pipe);
 
-static int
-preview_start(struct ia_css_pipe *pipe);
+static int preview_start(struct ia_css_pipe *pipe);
 
-static int
-yuvpp_start(struct ia_css_pipe *pipe);
+static int yuvpp_start(struct ia_css_pipe *pipe);
 
 static bool copy_on_sp(struct ia_css_pipe *pipe);
 
-static int
-init_vf_frameinfo_defaults(struct ia_css_pipe *pipe,
-			   struct ia_css_frame *vf_frame, unsigned int idx);
+static int init_vf_frameinfo_defaults(struct ia_css_pipe *pipe,
+				      struct ia_css_frame *vf_frame,
+				      unsigned int idx);
 
-static int
-init_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,
-				  struct ia_css_frame *frame, enum ia_css_frame_format format);
+static int init_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,
+					     struct ia_css_frame *frame,
+					     enum ia_css_frame_format format);
 
-static int
-init_out_frameinfo_defaults(struct ia_css_pipe *pipe,
-			    struct ia_css_frame *out_frame, unsigned int idx);
+static int init_out_frameinfo_defaults(struct ia_css_pipe *pipe,
+				       struct ia_css_frame *out_frame,
+				       unsigned int idx);
 
-static int
-alloc_continuous_frames(struct ia_css_pipe *pipe, bool init_time);
+static int alloc_continuous_frames(struct ia_css_pipe *pipe, bool init_time);
 
-static void
-pipe_global_init(void);
+static void pipe_global_init(void);
 
-static int
-pipe_generate_pipe_num(const struct ia_css_pipe *pipe,
-		       unsigned int *pipe_number);
+static int pipe_generate_pipe_num(const struct ia_css_pipe *pipe,
+				  unsigned int *pipe_number);
 
-static void
-pipe_release_pipe_num(unsigned int pipe_num);
+static void pipe_release_pipe_num(unsigned int pipe_num);
 
-static int
-create_host_pipeline_structure(struct ia_css_stream *stream);
+static int create_host_pipeline_structure(struct ia_css_stream *stream);
 
-static int
-create_host_pipeline(struct ia_css_stream *stream);
+static int create_host_pipeline(struct ia_css_stream *stream);
 
-static int
-create_host_preview_pipeline(struct ia_css_pipe *pipe);
+static int create_host_preview_pipeline(struct ia_css_pipe *pipe);
 
-static int
-create_host_video_pipeline(struct ia_css_pipe *pipe);
+static int create_host_video_pipeline(struct ia_css_pipe *pipe);
 
-static int
-create_host_copy_pipeline(struct ia_css_pipe *pipe,
-			  unsigned int max_input_width,
-			  struct ia_css_frame *out_frame);
+static int create_host_copy_pipeline(struct ia_css_pipe *pipe,
+				     unsigned int max_input_width,
+				     struct ia_css_frame *out_frame);
 
-static int
-create_host_isyscopy_capture_pipeline(struct ia_css_pipe *pipe);
+static int create_host_isyscopy_capture_pipeline(struct ia_css_pipe *pipe);
 
-static int
-create_host_capture_pipeline(struct ia_css_pipe *pipe);
+static int create_host_capture_pipeline(struct ia_css_pipe *pipe);
 
-static int
-create_host_yuvpp_pipeline(struct ia_css_pipe *pipe);
+static int create_host_yuvpp_pipeline(struct ia_css_pipe *pipe);
 
-static unsigned int
-sh_css_get_sw_interrupt_value(unsigned int irq);
+static unsigned int sh_css_get_sw_interrupt_value(unsigned int irq);
 
-static struct ia_css_binary *ia_css_pipe_get_shading_correction_binary(
-    const struct ia_css_pipe *pipe);
+static struct ia_css_binary *
+ia_css_pipe_get_shading_correction_binary(const struct ia_css_pipe *pipe);
 
 static struct ia_css_binary *
 ia_css_pipe_get_s3a_binary(const struct ia_css_pipe *pipe);
@@ -314,33 +284,31 @@ ia_css_pipe_get_s3a_binary(const struct ia_css_pipe *pipe);
 static struct ia_css_binary *
 ia_css_pipe_get_sdis_binary(const struct ia_css_pipe *pipe);
 
-static void
-sh_css_hmm_buffer_record_init(void);
+static void sh_css_hmm_buffer_record_init(void);
 
-static void
-sh_css_hmm_buffer_record_uninit(void);
+static void sh_css_hmm_buffer_record_uninit(void);
 
 static void
 sh_css_hmm_buffer_record_reset(struct sh_css_hmm_buffer_record *buffer_record);
 
-static struct sh_css_hmm_buffer_record
-*sh_css_hmm_buffer_record_acquire(struct ia_css_rmgr_vbuf_handle *h_vbuf,
-				  enum ia_css_buffer_type type,
-				  hrt_address kernel_ptr);
+static struct sh_css_hmm_buffer_record *
+sh_css_hmm_buffer_record_acquire(struct ia_css_rmgr_vbuf_handle *h_vbuf,
+				 enum ia_css_buffer_type type,
+				 hrt_address kernel_ptr);
 
-static struct sh_css_hmm_buffer_record
-*sh_css_hmm_buffer_record_validate(ia_css_ptr ddr_buffer_addr,
-				   enum ia_css_buffer_type type);
+static struct sh_css_hmm_buffer_record *
+sh_css_hmm_buffer_record_validate(ia_css_ptr ddr_buffer_addr,
+				  enum ia_css_buffer_type type);
 
-static unsigned int get_crop_lines_for_bayer_order(const struct
-	ia_css_stream_config *config);
-static unsigned int get_crop_columns_for_bayer_order(const struct
-	ia_css_stream_config *config);
+static unsigned int
+get_crop_lines_for_bayer_order(const struct ia_css_stream_config *config);
+static unsigned int
+get_crop_columns_for_bayer_order(const struct ia_css_stream_config *config);
 static void get_pipe_extra_pixel(struct ia_css_pipe *pipe,
-				 unsigned int *extra_row, unsigned int *extra_column);
+				 unsigned int *extra_row,
+				 unsigned int *extra_column);
 
-static void
-sh_css_pipe_free_shading_table(struct ia_css_pipe *pipe)
+static void sh_css_pipe_free_shading_table(struct ia_css_pipe *pipe)
 {
 	if (!pipe) {
 		IA_CSS_ERROR("NULL input parameter");
@@ -363,26 +331,19 @@ static enum ia_css_frame_format yuv420_copy_formats[] = {
 };
 
 static enum ia_css_frame_format yuv422_copy_formats[] = {
-	IA_CSS_FRAME_FORMAT_NV12,
-	IA_CSS_FRAME_FORMAT_NV16,
-	IA_CSS_FRAME_FORMAT_NV21,
-	IA_CSS_FRAME_FORMAT_NV61,
-	IA_CSS_FRAME_FORMAT_YV12,
-	IA_CSS_FRAME_FORMAT_YV16,
-	IA_CSS_FRAME_FORMAT_YUV420,
-	IA_CSS_FRAME_FORMAT_YUV420_16,
-	IA_CSS_FRAME_FORMAT_YUV422,
-	IA_CSS_FRAME_FORMAT_YUV422_16,
-	IA_CSS_FRAME_FORMAT_UYVY,
-	IA_CSS_FRAME_FORMAT_YUYV
+	IA_CSS_FRAME_FORMAT_NV12,   IA_CSS_FRAME_FORMAT_NV16,
+	IA_CSS_FRAME_FORMAT_NV21,   IA_CSS_FRAME_FORMAT_NV61,
+	IA_CSS_FRAME_FORMAT_YV12,   IA_CSS_FRAME_FORMAT_YV16,
+	IA_CSS_FRAME_FORMAT_YUV420, IA_CSS_FRAME_FORMAT_YUV420_16,
+	IA_CSS_FRAME_FORMAT_YUV422, IA_CSS_FRAME_FORMAT_YUV422_16,
+	IA_CSS_FRAME_FORMAT_UYVY,   IA_CSS_FRAME_FORMAT_YUYV
 };
 
 /*
  * Verify whether the selected output format is can be produced
  * by the copy binary given the stream format.
  */
-static int
-verify_copy_out_frame_format(struct ia_css_pipe *pipe)
+static int verify_copy_out_frame_format(struct ia_css_pipe *pipe)
 {
 	enum ia_css_frame_format out_fmt = pipe->output_info[0].format;
 	unsigned int i, found = 0;
@@ -428,7 +389,7 @@ verify_copy_out_frame_format(struct ia_css_pipe *pipe)
 	case ATOMISP_INPUT_FORMAT_RAW_14:
 	case ATOMISP_INPUT_FORMAT_RAW_16:
 		found = (out_fmt == IA_CSS_FRAME_FORMAT_RAW) ||
-		(out_fmt == IA_CSS_FRAME_FORMAT_RAW_PACKED);
+			(out_fmt == IA_CSS_FRAME_FORMAT_RAW_PACKED);
 		break;
 	case ATOMISP_INPUT_FORMAT_BINARY_8:
 		found = (out_fmt == IA_CSS_FRAME_FORMAT_BINARY_8);
@@ -447,14 +408,14 @@ ia_css_stream_input_format_bits_per_pixel(struct ia_css_stream *stream)
 	int bpp = 0;
 
 	if (stream)
-		bpp = ia_css_util_input_format_bpp(stream->config.input_config.format,
-						   stream->config.pixels_per_clock == 2);
+		bpp = ia_css_util_input_format_bpp(
+			stream->config.input_config.format,
+			stream->config.pixels_per_clock == 2);
 
 	return bpp;
 }
 
-static int
-sh_css_config_input_network_2400(struct ia_css_stream *stream)
+static int sh_css_config_input_network_2400(struct ia_css_stream *stream)
 {
 	unsigned int fmt_type;
 	struct ia_css_pipe *pipe = stream->last_pipe;
@@ -471,19 +432,16 @@ sh_css_config_input_network_2400(struct ia_css_stream *stream)
 		binary = pipe->pipeline.stages->binary;
 
 	err = ia_css_isys_convert_stream_format_to_mipi_format(
-	    stream->config.input_config.format,
-	    stream->csi_rx_config.comp,
-	    &fmt_type);
+		stream->config.input_config.format, stream->csi_rx_config.comp,
+		&fmt_type);
 	if (err)
 		return err;
-	sh_css_sp_program_input_circuit(fmt_type,
-					stream->config.channel_id,
+	sh_css_sp_program_input_circuit(fmt_type, stream->config.channel_id,
 					stream->config.mode);
 
 	if ((binary && (binary->online || stream->config.continuous)) ||
 	    pipe->config.mode == IA_CSS_PIPE_MODE_COPY) {
-		err = ia_css_ifmtr_configure(&stream->config,
-					     binary);
+		err = ia_css_ifmtr_configure(&stream->config, binary);
 		if (err)
 			return err;
 	}
@@ -497,16 +455,17 @@ sh_css_config_input_network_2400(struct ia_css_stream *stream)
 			(1 + (stream->config.pixels_per_clock == 2));
 		height = stream->config.input_config.input_res.height;
 		vblank_cycles = vblank_lines * (width + hblank_cycles);
-		sh_css_sp_configure_sync_gen(width, height, hblank_cycles, vblank_cycles);
+		sh_css_sp_configure_sync_gen(width, height, hblank_cycles,
+					     vblank_cycles);
 	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "sh_css_config_input_network() leave:\n");
 	return 0;
 }
 
-static unsigned int csi2_protocol_calculate_max_subpixels_per_line(
-    enum atomisp_input_format	format,
-    unsigned int			pixels_per_line)
+static unsigned int
+csi2_protocol_calculate_max_subpixels_per_line(enum atomisp_input_format format,
+					       unsigned int pixels_per_line)
 {
 	unsigned int rval;
 
@@ -630,8 +589,8 @@ static unsigned int csi2_protocol_calculate_max_subpixels_per_line(
 }
 
 static bool sh_css_translate_stream_cfg_to_input_system_input_port_id(
-    struct ia_css_stream_config *stream_cfg,
-    ia_css_isys_descr_t	*isys_stream_descr)
+	struct ia_css_stream_config *stream_cfg,
+	ia_css_isys_descr_t *isys_stream_descr)
 {
 	bool rc;
 
@@ -640,21 +599,27 @@ static bool sh_css_translate_stream_cfg_to_input_system_input_port_id(
 	case IA_CSS_INPUT_MODE_PRBS:
 
 		if (stream_cfg->source.prbs.id == IA_CSS_PRBS_ID0)
-			isys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT0_ID;
+			isys_stream_descr->input_port_id =
+				INPUT_SYSTEM_PIXELGEN_PORT0_ID;
 		else if (stream_cfg->source.prbs.id == IA_CSS_PRBS_ID1)
-			isys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT1_ID;
+			isys_stream_descr->input_port_id =
+				INPUT_SYSTEM_PIXELGEN_PORT1_ID;
 		else if (stream_cfg->source.prbs.id == IA_CSS_PRBS_ID2)
-			isys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT2_ID;
+			isys_stream_descr->input_port_id =
+				INPUT_SYSTEM_PIXELGEN_PORT2_ID;
 
 		break;
 	case IA_CSS_INPUT_MODE_BUFFERED_SENSOR:
 
 		if (stream_cfg->source.port.port == MIPI_PORT0_ID)
-			isys_stream_descr->input_port_id = INPUT_SYSTEM_CSI_PORT0_ID;
+			isys_stream_descr->input_port_id =
+				INPUT_SYSTEM_CSI_PORT0_ID;
 		else if (stream_cfg->source.port.port == MIPI_PORT1_ID)
-			isys_stream_descr->input_port_id = INPUT_SYSTEM_CSI_PORT1_ID;
+			isys_stream_descr->input_port_id =
+				INPUT_SYSTEM_CSI_PORT1_ID;
 		else if (stream_cfg->source.port.port == MIPI_PORT2_ID)
-			isys_stream_descr->input_port_id = INPUT_SYSTEM_CSI_PORT2_ID;
+			isys_stream_descr->input_port_id =
+				INPUT_SYSTEM_CSI_PORT2_ID;
 
 		break;
 	default:
@@ -666,8 +631,8 @@ static bool sh_css_translate_stream_cfg_to_input_system_input_port_id(
 }
 
 static bool sh_css_translate_stream_cfg_to_input_system_input_port_type(
-    struct ia_css_stream_config *stream_cfg,
-    ia_css_isys_descr_t	*isys_stream_descr)
+	struct ia_css_stream_config *stream_cfg,
+	ia_css_isys_descr_t *isys_stream_descr)
 {
 	bool rc;
 
@@ -693,9 +658,8 @@ static bool sh_css_translate_stream_cfg_to_input_system_input_port_type(
 }
 
 static bool sh_css_translate_stream_cfg_to_input_system_input_port_attr(
-    struct ia_css_stream_config *stream_cfg,
-    ia_css_isys_descr_t	*isys_stream_descr,
-    int isys_stream_idx)
+	struct ia_css_stream_config *stream_cfg,
+	ia_css_isys_descr_t *isys_stream_descr, int isys_stream_idx)
 {
 	bool rc;
 
@@ -703,22 +667,33 @@ static bool sh_css_translate_stream_cfg_to_input_system_input_port_attr(
 	switch (stream_cfg->mode) {
 	case IA_CSS_INPUT_MODE_PRBS:
 
-		isys_stream_descr->prbs_port_attr.seed0 = stream_cfg->source.prbs.seed;
-		isys_stream_descr->prbs_port_attr.seed1 = stream_cfg->source.prbs.seed1;
+		isys_stream_descr->prbs_port_attr.seed0 =
+			stream_cfg->source.prbs.seed;
+		isys_stream_descr->prbs_port_attr.seed1 =
+			stream_cfg->source.prbs.seed1;
 
 		/*
 		 * TODO
 		 * - Make "sync_gen_cfg" as part of "ia_css_prbs_config".
 		 */
-		isys_stream_descr->prbs_port_attr.sync_gen_cfg.hblank_cycles = 100;
-		isys_stream_descr->prbs_port_attr.sync_gen_cfg.vblank_cycles = 100;
+		isys_stream_descr->prbs_port_attr.sync_gen_cfg.hblank_cycles =
+			100;
+		isys_stream_descr->prbs_port_attr.sync_gen_cfg.vblank_cycles =
+			100;
 		isys_stream_descr->prbs_port_attr.sync_gen_cfg.pixels_per_clock =
-		    stream_cfg->pixels_per_clock;
-		isys_stream_descr->prbs_port_attr.sync_gen_cfg.nr_of_frames = (uint32_t)~(0x0);
+			stream_cfg->pixels_per_clock;
+		isys_stream_descr->prbs_port_attr.sync_gen_cfg.nr_of_frames =
+			(uint32_t) ~(0x0);
 		isys_stream_descr->prbs_port_attr.sync_gen_cfg.pixels_per_line =
-		    stream_cfg->isys_config[IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX].input_res.width;
+			stream_cfg
+				->isys_config
+					[IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX]
+				.input_res.width;
 		isys_stream_descr->prbs_port_attr.sync_gen_cfg.lines_per_frame =
-		    stream_cfg->isys_config[IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX].input_res.height;
+			stream_cfg
+				->isys_config
+					[IA_CSS_STREAM_DEFAULT_ISYS_STREAM_IDX]
+				.input_res.height;
 
 		break;
 	case IA_CSS_INPUT_MODE_BUFFERED_SENSOR: {
@@ -726,14 +701,13 @@ static bool sh_css_translate_stream_cfg_to_input_system_input_port_attr(
 		unsigned int fmt_type;
 
 		err = ia_css_isys_convert_stream_format_to_mipi_format(
-			  stream_cfg->isys_config[isys_stream_idx].format,
-			  MIPI_PREDICTOR_NONE,
-			  &fmt_type);
+			stream_cfg->isys_config[isys_stream_idx].format,
+			MIPI_PREDICTOR_NONE, &fmt_type);
 		if (err)
 			rc = false;
 
 		isys_stream_descr->csi_port_attr.active_lanes =
-		    stream_cfg->source.port.num_lanes;
+			stream_cfg->source.port.num_lanes;
 		isys_stream_descr->csi_port_attr.fmt_type = fmt_type;
 		isys_stream_descr->csi_port_attr.ch_id = stream_cfg->channel_id;
 
@@ -741,8 +715,8 @@ static bool sh_css_translate_stream_cfg_to_input_system_input_port_attr(
 			isys_stream_descr->online = stream_cfg->online;
 
 		err |= ia_css_isys_convert_compressed_format(
-			   &stream_cfg->source.port.compression,
-			   isys_stream_descr);
+			&stream_cfg->source.port.compression,
+			isys_stream_descr);
 		if (err)
 			rc = false;
 
@@ -750,30 +724,34 @@ static bool sh_css_translate_stream_cfg_to_input_system_input_port_attr(
 		isys_stream_descr->metadata.enable = false;
 		if (stream_cfg->metadata_config.resolution.height > 0) {
 			err = ia_css_isys_convert_stream_format_to_mipi_format(
-				  stream_cfg->metadata_config.data_type,
-				  MIPI_PREDICTOR_NONE,
-				  &fmt_type);
+				stream_cfg->metadata_config.data_type,
+				MIPI_PREDICTOR_NONE, &fmt_type);
 			if (err)
 				rc = false;
 			isys_stream_descr->metadata.fmt_type = fmt_type;
 			isys_stream_descr->metadata.bits_per_pixel =
-			    ia_css_util_input_format_bpp(stream_cfg->metadata_config.data_type, true);
+				ia_css_util_input_format_bpp(
+					stream_cfg->metadata_config.data_type,
+					true);
 			isys_stream_descr->metadata.pixels_per_line =
-			    stream_cfg->metadata_config.resolution.width;
+				stream_cfg->metadata_config.resolution.width;
 			isys_stream_descr->metadata.lines_per_frame =
-			    stream_cfg->metadata_config.resolution.height;
+				stream_cfg->metadata_config.resolution.height;
 
 			/*
 			 * For new input system, number of str2mmio requests must be even.
 			 * So we round up number of metadata lines to be even.
 			 */
-			if (IS_ISP2401 && isys_stream_descr->metadata.lines_per_frame > 0)
+			if (IS_ISP2401 &&
+			    isys_stream_descr->metadata.lines_per_frame > 0)
 				isys_stream_descr->metadata.lines_per_frame +=
-				    (isys_stream_descr->metadata.lines_per_frame & 1);
+					(isys_stream_descr->metadata
+						 .lines_per_frame &
+					 1);
 
 			isys_stream_descr->metadata.align_req_in_bytes =
-			    ia_css_csi2_calculate_input_system_alignment(
-				stream_cfg->metadata_config.data_type);
+				ia_css_csi2_calculate_input_system_alignment(
+					stream_cfg->metadata_config.data_type);
 			isys_stream_descr->metadata.enable = true;
 		}
 
@@ -788,9 +766,8 @@ static bool sh_css_translate_stream_cfg_to_input_system_input_port_attr(
 }
 
 static bool sh_css_translate_stream_cfg_to_input_system_input_port_resolution(
-    struct ia_css_stream_config *stream_cfg,
-    ia_css_isys_descr_t	*isys_stream_descr,
-    int isys_stream_idx)
+	struct ia_css_stream_config *stream_cfg,
+	ia_css_isys_descr_t *isys_stream_descr, int isys_stream_idx)
 {
 	unsigned int bits_per_subpixel;
 	unsigned int max_subpixels_per_line;
@@ -801,96 +778,101 @@ static bool sh_css_translate_stream_cfg_to_input_system_input_port_resolution(
 	fmt_type = stream_cfg->isys_config[isys_stream_idx].format;
 	if ((stream_cfg->mode == IA_CSS_INPUT_MODE_SENSOR ||
 	     stream_cfg->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) &&
-	    stream_cfg->source.port.compression.type != IA_CSS_CSI2_COMPRESSION_TYPE_NONE) {
-		if (stream_cfg->source.port.compression.uncompressed_bits_per_pixel ==
+	    stream_cfg->source.port.compression.type !=
+		    IA_CSS_CSI2_COMPRESSION_TYPE_NONE) {
+		if (stream_cfg->source.port.compression
+			    .uncompressed_bits_per_pixel ==
 		    UNCOMPRESSED_BITS_PER_PIXEL_10)
 			fmt_type = ATOMISP_INPUT_FORMAT_RAW_10;
-		else if (stream_cfg->source.port.compression.uncompressed_bits_per_pixel ==
-			   UNCOMPRESSED_BITS_PER_PIXEL_12)
+		else if (stream_cfg->source.port.compression
+				 .uncompressed_bits_per_pixel ==
+			 UNCOMPRESSED_BITS_PER_PIXEL_12)
 			fmt_type = ATOMISP_INPUT_FORMAT_RAW_12;
 		else
 			return false;
 	}
 
-	bits_per_subpixel =
-	    sh_css_stream_format_2_bits_per_subpixel(fmt_type);
+	bits_per_subpixel = sh_css_stream_format_2_bits_per_subpixel(fmt_type);
 	if (bits_per_subpixel == 0)
 		return false;
 
-	max_subpixels_per_line =
-	    csi2_protocol_calculate_max_subpixels_per_line(fmt_type,
-		    stream_cfg->isys_config[isys_stream_idx].input_res.width);
+	max_subpixels_per_line = csi2_protocol_calculate_max_subpixels_per_line(
+		fmt_type,
+		stream_cfg->isys_config[isys_stream_idx].input_res.width);
 	if (max_subpixels_per_line == 0)
 		return false;
 
-	lines_per_frame = stream_cfg->isys_config[isys_stream_idx].input_res.height;
+	lines_per_frame =
+		stream_cfg->isys_config[isys_stream_idx].input_res.height;
 	if (lines_per_frame == 0)
 		return false;
 
-	align_req_in_bytes = ia_css_csi2_calculate_input_system_alignment(fmt_type);
+	align_req_in_bytes =
+		ia_css_csi2_calculate_input_system_alignment(fmt_type);
 
 	/* HW needs subpixel info for their settings */
-	isys_stream_descr->input_port_resolution.bits_per_pixel = bits_per_subpixel;
+	isys_stream_descr->input_port_resolution.bits_per_pixel =
+		bits_per_subpixel;
 	isys_stream_descr->input_port_resolution.pixels_per_line =
-	    max_subpixels_per_line;
-	isys_stream_descr->input_port_resolution.lines_per_frame = lines_per_frame;
+		max_subpixels_per_line;
+	isys_stream_descr->input_port_resolution.lines_per_frame =
+		lines_per_frame;
 	isys_stream_descr->input_port_resolution.align_req_in_bytes =
-	    align_req_in_bytes;
+		align_req_in_bytes;
 
 	return true;
 }
 
 static bool sh_css_translate_stream_cfg_to_isys_stream_descr(
-    struct ia_css_stream_config *stream_cfg,
-    bool early_polling,
-    ia_css_isys_descr_t	*isys_stream_descr,
-    int isys_stream_idx)
+	struct ia_css_stream_config *stream_cfg, bool early_polling,
+	ia_css_isys_descr_t *isys_stream_descr, int isys_stream_idx)
 {
 	bool rc;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "sh_css_translate_stream_cfg_to_isys_stream_descr() enter:\n");
-	rc  = sh_css_translate_stream_cfg_to_input_system_input_port_id(stream_cfg,
-		isys_stream_descr);
-	rc &= sh_css_translate_stream_cfg_to_input_system_input_port_type(stream_cfg,
-		isys_stream_descr);
-	rc &= sh_css_translate_stream_cfg_to_input_system_input_port_attr(stream_cfg,
-		isys_stream_descr, isys_stream_idx);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_translate_stream_cfg_to_isys_stream_descr() enter:\n");
+	rc = sh_css_translate_stream_cfg_to_input_system_input_port_id(
+		stream_cfg, isys_stream_descr);
+	rc &= sh_css_translate_stream_cfg_to_input_system_input_port_type(
+		stream_cfg, isys_stream_descr);
+	rc &= sh_css_translate_stream_cfg_to_input_system_input_port_attr(
+		stream_cfg, isys_stream_descr, isys_stream_idx);
 	rc &= sh_css_translate_stream_cfg_to_input_system_input_port_resolution(
-		  stream_cfg, isys_stream_descr, isys_stream_idx);
+		stream_cfg, isys_stream_descr, isys_stream_idx);
 
 	isys_stream_descr->raw_packed = stream_cfg->pack_raw_pixels;
-	isys_stream_descr->linked_isys_stream_id = (int8_t)
-		stream_cfg->isys_config[isys_stream_idx].linked_isys_stream_id;
+	isys_stream_descr->linked_isys_stream_id =
+		(int8_t)stream_cfg->isys_config[isys_stream_idx]
+			.linked_isys_stream_id;
 
 	if (IS_ISP2401)
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "sh_css_translate_stream_cfg_to_isys_stream_descr() leave:\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"sh_css_translate_stream_cfg_to_isys_stream_descr() leave:\n");
 
 	return rc;
 }
 
 static bool sh_css_translate_binary_info_to_input_system_output_port_attr(
-    struct ia_css_binary *binary,
-    ia_css_isys_descr_t     *isys_stream_descr)
+	struct ia_css_binary *binary, ia_css_isys_descr_t *isys_stream_descr)
 {
 	if (!binary)
 		return false;
 
 	isys_stream_descr->output_port_attr.left_padding = binary->left_padding;
 	isys_stream_descr->output_port_attr.max_isp_input_width =
-	    binary->info->sp.input.max_width;
+		binary->info->sp.input.max_width;
 
 	return true;
 }
 
-static int
-sh_css_config_input_network_2401(struct ia_css_stream *stream)
+static int sh_css_config_input_network_2401(struct ia_css_stream *stream)
 {
-	bool					rc;
-	ia_css_isys_descr_t			isys_stream_descr;
-	unsigned int				sp_thread_id;
-	struct sh_css_sp_pipeline_terminal	*sp_pipeline_input_terminal;
+	bool rc;
+	ia_css_isys_descr_t isys_stream_descr;
+	unsigned int sp_thread_id;
+	struct sh_css_sp_pipeline_terminal *sp_pipeline_input_terminal;
 	struct ia_css_pipe *pipe = NULL;
 	struct ia_css_binary *binary = NULL;
 	int i;
@@ -899,16 +881,21 @@ sh_css_config_input_network_2401(struct ia_css_stream *stream)
 
 	assert(stream);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "sh_css_config_input_network() enter 0x%p:\n", stream);
+			    "sh_css_config_input_network() enter 0x%p:\n",
+			    stream);
 
 	if (stream->config.continuous) {
 		if (stream->last_pipe->config.mode == IA_CSS_PIPE_MODE_CAPTURE)
 			pipe = stream->last_pipe;
-		else if (stream->last_pipe->config.mode == IA_CSS_PIPE_MODE_YUVPP)
+		else if (stream->last_pipe->config.mode ==
+			 IA_CSS_PIPE_MODE_YUVPP)
 			pipe = stream->last_pipe;
-		else if (stream->last_pipe->config.mode == IA_CSS_PIPE_MODE_PREVIEW)
-			pipe = stream->last_pipe->pipe_settings.preview.copy_pipe;
-		else if (stream->last_pipe->config.mode == IA_CSS_PIPE_MODE_VIDEO)
+		else if (stream->last_pipe->config.mode ==
+			 IA_CSS_PIPE_MODE_PREVIEW)
+			pipe = stream->last_pipe->pipe_settings.preview
+				       .copy_pipe;
+		else if (stream->last_pipe->config.mode ==
+			 IA_CSS_PIPE_MODE_VIDEO)
 			pipe = stream->last_pipe->pipe_settings.video.copy_pipe;
 	} else {
 		pipe = stream->last_pipe;
@@ -931,54 +918,64 @@ sh_css_config_input_network_2401(struct ia_css_stream *stream)
 	}
 
 	/* get the SP thread id */
-	rc = ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &sp_thread_id);
+	rc = ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe),
+					      &sp_thread_id);
 	if (!rc)
 		return -EINVAL;
 	/* get the target input terminal */
-	sp_pipeline_input_terminal = &sh_css_sp_group.pipe_io[sp_thread_id].input;
+	sp_pipeline_input_terminal =
+		&sh_css_sp_group.pipe_io[sp_thread_id].input;
 
 	for (i = 0; i < IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH; i++) {
 		/* initialization */
-		memset((void *)(&isys_stream_descr), 0, sizeof(ia_css_isys_descr_t));
-		sp_pipeline_input_terminal->context.virtual_input_system_stream[i].valid = 0;
-		sp_pipeline_input_terminal->ctrl.virtual_input_system_stream_cfg[i].valid = 0;
+		memset((void *)(&isys_stream_descr), 0,
+		       sizeof(ia_css_isys_descr_t));
+		sp_pipeline_input_terminal->context
+			.virtual_input_system_stream[i]
+			.valid = 0;
+		sp_pipeline_input_terminal->ctrl
+			.virtual_input_system_stream_cfg[i]
+			.valid = 0;
 
 		if (!stream->config.isys_config[i].valid)
 			continue;
 
 		/* translate the stream configuration to the Input System (2401) configuration */
 		rc = sh_css_translate_stream_cfg_to_isys_stream_descr(
-			 &stream->config,
-			 early_polling,
-			 &(isys_stream_descr), i);
+			&stream->config, early_polling, &(isys_stream_descr),
+			i);
 
 		if (stream->config.online) {
 			rc &= sh_css_translate_binary_info_to_input_system_output_port_attr(
-				  binary,
-				  &(isys_stream_descr));
+				binary, &(isys_stream_descr));
 		}
 
 		if (!rc)
 			return -EINVAL;
 
-		isys_stream_id = ia_css_isys_generate_stream_id(sp_thread_id, i);
+		isys_stream_id =
+			ia_css_isys_generate_stream_id(sp_thread_id, i);
 
 		/* create the virtual Input System (2401) */
-		rc =  ia_css_isys_stream_create(
-			  &(isys_stream_descr),
-			  &sp_pipeline_input_terminal->context.virtual_input_system_stream[i],
-			  isys_stream_id);
+		rc = ia_css_isys_stream_create(
+			&(isys_stream_descr),
+			&sp_pipeline_input_terminal->context
+				 .virtual_input_system_stream[i],
+			isys_stream_id);
 		if (!rc)
 			return -EINVAL;
 
 		/* calculate the configuration of the virtual Input System (2401) */
 		rc = ia_css_isys_stream_calculate_cfg(
-			 &sp_pipeline_input_terminal->context.virtual_input_system_stream[i],
-			 &(isys_stream_descr),
-			 &sp_pipeline_input_terminal->ctrl.virtual_input_system_stream_cfg[i]);
+			&sp_pipeline_input_terminal->context
+				 .virtual_input_system_stream[i],
+			&(isys_stream_descr),
+			&sp_pipeline_input_terminal->ctrl
+				 .virtual_input_system_stream_cfg[i]);
 		if (!rc) {
 			ia_css_isys_stream_destroy(
-			    &sp_pipeline_input_terminal->context.virtual_input_system_stream[i]);
+				&sp_pipeline_input_terminal->context
+					 .virtual_input_system_stream[i]);
 			return -EINVAL;
 		}
 	}
@@ -989,8 +986,8 @@ sh_css_config_input_network_2401(struct ia_css_stream *stream)
 	return 0;
 }
 
-static inline struct ia_css_pipe *stream_get_last_pipe(
-    struct ia_css_stream *stream)
+static inline struct ia_css_pipe *
+stream_get_last_pipe(struct ia_css_stream *stream)
 {
 	struct ia_css_pipe *last_pipe = NULL;
 
@@ -1000,8 +997,8 @@ static inline struct ia_css_pipe *stream_get_last_pipe(
 	return last_pipe;
 }
 
-static inline struct ia_css_pipe *stream_get_copy_pipe(
-    struct ia_css_stream *stream)
+static inline struct ia_css_pipe *
+stream_get_copy_pipe(struct ia_css_stream *stream)
 {
 	struct ia_css_pipe *copy_pipe = NULL;
 	struct ia_css_pipe *last_pipe = NULL;
@@ -1009,9 +1006,7 @@ static inline struct ia_css_pipe *stream_get_copy_pipe(
 
 	last_pipe = stream_get_last_pipe(stream);
 
-	if ((stream) &&
-	    (last_pipe) &&
-	    (stream->config.continuous)) {
+	if ((stream) && (last_pipe) && (stream->config.continuous)) {
 		pipe_id = last_pipe->mode;
 		switch (pipe_id) {
 		case IA_CSS_PIPE_ID_PREVIEW:
@@ -1029,8 +1024,8 @@ static inline struct ia_css_pipe *stream_get_copy_pipe(
 	return copy_pipe;
 }
 
-static inline struct ia_css_pipe *stream_get_target_pipe(
-    struct ia_css_stream *stream)
+static inline struct ia_css_pipe *
+stream_get_target_pipe(struct ia_css_stream *stream)
 {
 	struct ia_css_pipe *target_pipe;
 
@@ -1043,16 +1038,16 @@ static inline struct ia_css_pipe *stream_get_target_pipe(
 	return target_pipe;
 }
 
-static int stream_csi_rx_helper(
-    struct ia_css_stream *stream,
-    int (*func)(enum mipi_port_id, uint32_t))
+static int stream_csi_rx_helper(struct ia_css_stream *stream,
+				int (*func)(enum mipi_port_id, uint32_t))
 {
 	int retval = -EINVAL;
 	u32 sp_thread_id, stream_id;
 	bool rc;
 	struct ia_css_pipe *target_pipe = NULL;
 
-	if ((!stream) || (stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR))
+	if ((!stream) ||
+	    (stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR))
 		goto exit;
 
 	target_pipe = stream_get_target_pipe(stream);
@@ -1061,8 +1056,7 @@ static int stream_csi_rx_helper(
 		goto exit;
 
 	rc = ia_css_pipeline_get_sp_thread_id(
-		 ia_css_pipe_get_pipe_num(target_pipe),
-		 &sp_thread_id);
+		ia_css_pipe_get_pipe_num(target_pipe), &sp_thread_id);
 
 	if (!rc)
 		goto exit;
@@ -1071,9 +1065,11 @@ static int stream_csi_rx_helper(
 	stream_id = 0;
 	do {
 		if (stream->config.isys_config[stream_id].valid) {
-			u32 isys_stream_id = ia_css_isys_generate_stream_id(sp_thread_id, stream_id);
+			u32 isys_stream_id = ia_css_isys_generate_stream_id(
+				sp_thread_id, stream_id);
 
-			retval = func(stream->config.source.port.port, isys_stream_id);
+			retval = func(stream->config.source.port.port,
+				      isys_stream_id);
 		}
 		stream_id++;
 	} while ((retval == 0) &&
@@ -1083,22 +1079,18 @@ static int stream_csi_rx_helper(
 	return retval;
 }
 
-static inline int stream_register_with_csi_rx(
-    struct ia_css_stream *stream)
+static inline int stream_register_with_csi_rx(struct ia_css_stream *stream)
 {
 	return stream_csi_rx_helper(stream, ia_css_isys_csi_rx_register_stream);
 }
 
-static inline int stream_unregister_with_csi_rx(
-    struct ia_css_stream *stream)
+static inline int stream_unregister_with_csi_rx(struct ia_css_stream *stream)
 {
-	return stream_csi_rx_helper(stream, ia_css_isys_csi_rx_unregister_stream);
+	return stream_csi_rx_helper(stream,
+				    ia_css_isys_csi_rx_unregister_stream);
 }
 
-
-static void
-start_binary(struct ia_css_pipe *pipe,
-	     struct ia_css_binary *binary)
+static void start_binary(struct ia_css_pipe *pipe, struct ia_css_binary *binary)
 {
 	assert(pipe);
 	/* Acceleration uses firmware, the binary thus can be NULL */
@@ -1114,9 +1106,8 @@ start_binary(struct ia_css_pipe *pipe,
 }
 
 /* start the copy function on the SP */
-static int
-start_copy_on_sp(struct ia_css_pipe *pipe,
-		 struct ia_css_frame *out_frame)
+static int start_copy_on_sp(struct ia_css_pipe *pipe,
+			    struct ia_css_frame *out_frame)
 {
 	(void)out_frame;
 
@@ -1126,9 +1117,11 @@ start_copy_on_sp(struct ia_css_pipe *pipe,
 	if (!IS_ISP2401 && pipe->stream->reconfigure_css_rx)
 		ia_css_isys_rx_disable();
 
-	if (pipe->stream->config.input_config.format != ATOMISP_INPUT_FORMAT_BINARY_8)
+	if (pipe->stream->config.input_config.format !=
+	    ATOMISP_INPUT_FORMAT_BINARY_8)
 		return -EINVAL;
-	sh_css_sp_start_binary_copy(ia_css_pipe_get_pipe_num(pipe), out_frame, pipe->stream->config.pixels_per_clock == 2);
+	sh_css_sp_start_binary_copy(ia_css_pipe_get_pipe_num(pipe), out_frame,
+				    pipe->stream->config.pixels_per_clock == 2);
 
 	if (!IS_ISP2401 && pipe->stream->reconfigure_css_rx) {
 		ia_css_isys_rx_configure(&pipe->stream->csi_rx_config,
@@ -1147,40 +1140,34 @@ void sh_css_binary_args_reset(struct sh_css_binary_args *args)
 		args->tnr_frames[i] = NULL;
 	for (i = 0; i < MAX_NUM_VIDEO_DELAY_FRAMES; i++)
 		args->delay_frames[i] = NULL;
-	args->in_frame      = NULL;
+	args->in_frame = NULL;
 	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
 		args->out_frame[i] = NULL;
-	args->out_vf_frame  = NULL;
-	args->copy_vf       = false;
-	args->copy_output   = true;
+	args->out_vf_frame = NULL;
+	args->copy_vf = false;
+	args->copy_output = true;
 	args->vf_downscale_log2 = 0;
 }
 
-static void start_pipe(
-    struct ia_css_pipe *me,
-    enum sh_css_pipe_config_override copy_ovrd,
-    enum ia_css_input_mode input_mode)
+static void start_pipe(struct ia_css_pipe *me,
+		       enum sh_css_pipe_config_override copy_ovrd,
+		       enum ia_css_input_mode input_mode)
 {
-	IA_CSS_ENTER_PRIVATE("me = %p, copy_ovrd = %d, input_mode = %d",
-			     me, copy_ovrd, input_mode);
+	IA_CSS_ENTER_PRIVATE("me = %p, copy_ovrd = %d, input_mode = %d", me,
+			     copy_ovrd, input_mode);
 
 	assert(me); /* all callers are in this file and call with non null argument */
 
-	sh_css_sp_init_pipeline(&me->pipeline,
-				me->mode,
-				(uint8_t)ia_css_pipe_get_pipe_num(me),
-				me->config.default_capture_config.enable_xnr != 0,
-				me->stream->config.pixels_per_clock == 2,
-				me->stream->config.continuous,
-				false,
-				me->required_bds_factor,
-				copy_ovrd,
-				input_mode,
-				&me->stream->config.metadata_config,
-				&me->stream->info.metadata_info
-				, (input_mode == IA_CSS_INPUT_MODE_MEMORY) ?
-				(enum mipi_port_id)0 :
-				me->stream->config.source.port.port);
+	sh_css_sp_init_pipeline(
+		&me->pipeline, me->mode, (uint8_t)ia_css_pipe_get_pipe_num(me),
+		me->config.default_capture_config.enable_xnr != 0,
+		me->stream->config.pixels_per_clock == 2,
+		me->stream->config.continuous, false, me->required_bds_factor,
+		copy_ovrd, input_mode, &me->stream->config.metadata_config,
+		&me->stream->info.metadata_info,
+		(input_mode == IA_CSS_INPUT_MODE_MEMORY) ?
+			(enum mipi_port_id)0 :
+			me->stream->config.source.port.port);
 
 	if (me->config.mode != IA_CSS_PIPE_MODE_COPY) {
 		struct ia_css_pipeline_stage *stage;
@@ -1194,8 +1181,7 @@ static void start_pipe(
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-void
-sh_css_invalidate_shading_tables(struct ia_css_stream *stream)
+void sh_css_invalidate_shading_tables(struct ia_css_stream *stream)
 {
 	int i;
 
@@ -1209,12 +1195,12 @@ sh_css_invalidate_shading_tables(struct ia_css_stream *stream)
 		sh_css_pipe_free_shading_table(stream->pipes[i]);
 	}
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "sh_css_invalidate_shading_tables() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"sh_css_invalidate_shading_tables() leave: return_void\n");
 }
 
-static void
-enable_interrupts(enum ia_css_irq_type irq_type)
+static void enable_interrupts(enum ia_css_irq_type irq_type)
 {
 	enum mipi_port_id port;
 	bool enable_pulse = irq_type != IA_CSS_IRQ_TYPE_EDGE;
@@ -1230,12 +1216,12 @@ enable_interrupts(enum ia_css_irq_type irq_type)
 
 	/* Enable SW interrupt 0, this is used to signal ISYS events */
 	cnd_virq_enable_channel(
-	    (enum virq_id)(IRQ_SW_CHANNEL0_ID + IRQ_SW_CHANNEL_OFFSET),
-	    true);
+		(enum virq_id)(IRQ_SW_CHANNEL0_ID + IRQ_SW_CHANNEL_OFFSET),
+		true);
 	/* Enable SW interrupt 1, this is used to signal PSYS events */
 	cnd_virq_enable_channel(
-	    (enum virq_id)(IRQ_SW_CHANNEL1_ID + IRQ_SW_CHANNEL_OFFSET),
-	    true);
+		(enum virq_id)(IRQ_SW_CHANNEL1_ID + IRQ_SW_CHANNEL_OFFSET),
+		true);
 
 	if (!IS_ISP2401) {
 		for (port = 0; port < N_MIPI_PORT_ID; port++)
@@ -1247,14 +1233,14 @@ enable_interrupts(enum ia_css_irq_type irq_type)
 
 static bool sh_css_setup_spctrl_config(const struct ia_css_fw_info *fw,
 				       const char *program,
-				       ia_css_spctrl_cfg  *spctrl_cfg)
+				       ia_css_spctrl_cfg *spctrl_cfg)
 {
 	if ((!fw) || (!spctrl_cfg))
 		return false;
 	spctrl_cfg->sp_entry = 0;
 	spctrl_cfg->program_name = (char *)(program);
 
-	spctrl_cfg->ddr_data_offset =  fw->blob.data_source;
+	spctrl_cfg->ddr_data_offset = fw->blob.data_source;
 	spctrl_cfg->dmem_data_addr = fw->blob.data_target;
 	spctrl_cfg->dmem_bss_addr = fw->blob.bss_target;
 	spctrl_cfg->data_size = fw->blob.data_size;
@@ -1264,14 +1250,14 @@ static bool sh_css_setup_spctrl_config(const struct ia_css_fw_info *fw,
 	spctrl_cfg->spctrl_state_dmem_addr = fw->info.sp.sw_state;
 
 	spctrl_cfg->code_size = fw->blob.size;
-	spctrl_cfg->code      = fw->blob.code;
-	spctrl_cfg->sp_entry  = fw->info.sp.sp_entry; /* entry function ptr on SP */
+	spctrl_cfg->code = fw->blob.code;
+	spctrl_cfg->sp_entry =
+		fw->info.sp.sp_entry; /* entry function ptr on SP */
 
 	return true;
 }
 
-void
-ia_css_unload_firmware(void)
+void ia_css_unload_firmware(void)
 {
 	if (sh_css_num_binaries) {
 		/* we have already loaded before so get rid of the old stuff */
@@ -1280,8 +1266,7 @@ ia_css_unload_firmware(void)
 	}
 }
 
-static void
-ia_css_reset_defaults(struct sh_css *css)
+static void ia_css_reset_defaults(struct sh_css *css)
 {
 	struct sh_css default_css;
 
@@ -1303,9 +1288,8 @@ ia_css_reset_defaults(struct sh_css *css)
 	*css = default_css;
 }
 
-int
-ia_css_load_firmware(struct device *dev, const struct ia_css_env *env,
-		     const struct ia_css_fw  *fw)
+int ia_css_load_firmware(struct device *dev, const struct ia_css_env *env,
+			 const struct ia_css_fw *fw)
 {
 	int err;
 
@@ -1314,7 +1298,8 @@ ia_css_load_firmware(struct device *dev, const struct ia_css_env *env,
 	if (!fw)
 		return -EINVAL;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_load_firmware() enter\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_load_firmware() enter\n");
 
 	/* make sure we initialize my_css */
 	if (my_css.flush != env->cpu_mem_env.flush) {
@@ -1326,13 +1311,13 @@ ia_css_load_firmware(struct device *dev, const struct ia_css_env *env,
 	if (!err)
 		err = ia_css_binary_init_infos();
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_load_firmware() leave\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_load_firmware() leave\n");
 	return err;
 }
 
-int
-ia_css_init(struct device *dev, const struct ia_css_env *env,
-	    u32 mmu_l1_base, enum ia_css_irq_type irq_type)
+int ia_css_init(struct device *dev, const struct ia_css_env *env,
+		u32 mmu_l1_base, enum ia_css_irq_type irq_type)
 {
 	int err;
 	ia_css_spctrl_cfg spctrl_cfg;
@@ -1346,7 +1331,7 @@ ia_css_init(struct device *dev, const struct ia_css_env *env,
 
 	IA_CSS_ENTER("void");
 
-	flush_func     = env->cpu_mem_env.flush;
+	flush_func = env->cpu_mem_env.flush;
 
 	pipe_global_init();
 	ia_css_pipeline_init();
@@ -1354,8 +1339,10 @@ ia_css_init(struct device *dev, const struct ia_css_env *env,
 
 	ia_css_device_access_init(&env->hw_access_env);
 
-	select = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_select) & ~GPIO_FLASH_PIN_MASK;
-	enable = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_e) | GPIO_FLASH_PIN_MASK;
+	select = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_select) &
+		 ~GPIO_FLASH_PIN_MASK;
+	enable = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_e) |
+		 GPIO_FLASH_PIN_MASK;
 	sh_css_mmu_set_page_table_base_index(mmu_l1_base);
 
 	my_css_save.mmu_base = mmu_l1_base;
@@ -1363,7 +1350,7 @@ ia_css_init(struct device *dev, const struct ia_css_env *env,
 	ia_css_reset_defaults(&my_css);
 
 	my_css_save.driver_env = *env;
-	my_css.flush     = flush_func;
+	my_css.flush = flush_func;
 
 	err = ia_css_rmgr_init();
 	if (err) {
@@ -1378,7 +1365,8 @@ ia_css_init(struct device *dev, const struct ia_css_env *env,
 		my_css_save.mode = sh_css_mode_working;
 		memset(my_css_save.stream_seeds, 0,
 		       sizeof(struct sh_css_stream_seed) * MAX_ACTIVE_STREAMS);
-		IA_CSS_LOG("init: %d mode=%d", my_css_save_initialized, my_css_save.mode);
+		IA_CSS_LOG("init: %d mode=%d", my_css_save_initialized,
+			   my_css_save.mode);
 	}
 
 	mipi_init();
@@ -1389,7 +1377,8 @@ ia_css_init(struct device *dev, const struct ia_css_env *env,
 	 * DEPRECATED
 	 */
 	if (!IS_ISP2401)
-		my_css.page_table_base_index = mmu_get_page_table_base_index(MMU0_ID);
+		my_css.page_table_base_index =
+			mmu_get_page_table_base_index(MMU0_ID);
 
 	my_css.irq_type = irq_type;
 
@@ -1413,7 +1402,8 @@ ia_css_init(struct device *dev, const struct ia_css_env *env,
 		return err;
 	}
 
-	if (!sh_css_setup_spctrl_config(&sh_css_sp_fw, SP_PROG_NAME, &spctrl_cfg))
+	if (!sh_css_setup_spctrl_config(&sh_css_sp_fw, SP_PROG_NAME,
+					&spctrl_cfg))
 		return -EINVAL;
 
 	err = ia_css_spctrl_load_fw(SP0_ID, &spctrl_cfg);
@@ -1435,7 +1425,8 @@ ia_css_init(struct device *dev, const struct ia_css_env *env,
 	 */
 
 	if (IS_ISP2401)
-		gp_device_reg_store(GP_DEVICE0_ID, _REG_GP_SWITCH_ISYS2401_ADDR, 1);
+		gp_device_reg_store(GP_DEVICE0_ID, _REG_GP_SWITCH_ISYS2401_ADDR,
+				    1);
 
 	if (!IS_ISP2401)
 		dma_set_max_burst_size(DMA0_ID, HIVE_DMA_BUS_DDR_CONN,
@@ -1453,8 +1444,7 @@ ia_css_init(struct device *dev, const struct ia_css_env *env,
 	return err;
 }
 
-int
-ia_css_enable_isys_event_queue(bool enable)
+int ia_css_enable_isys_event_queue(bool enable)
 {
 	if (sh_css_sp_is_running())
 		return -EBUSY;
@@ -1468,8 +1458,7 @@ ia_css_enable_isys_event_queue(bool enable)
  * doing it from stream_create since we could run out of sp threads due to
  * allocation on inactive pipelines.
  */
-static int
-map_sp_threads(struct ia_css_stream *stream, bool map)
+static int map_sp_threads(struct ia_css_stream *stream, bool map)
 {
 	struct ia_css_pipe *main_pipe = NULL;
 	struct ia_css_pipe *copy_pipe = NULL;
@@ -1477,8 +1466,8 @@ map_sp_threads(struct ia_css_stream *stream, bool map)
 	int err = 0;
 	enum ia_css_pipe_id pipe_id;
 
-	IA_CSS_ENTER_PRIVATE("stream = %p, map = %s",
-			     stream, map ? "true" : "false");
+	IA_CSS_ENTER_PRIVATE("stream = %p, map = %s", stream,
+			     map ? "true" : "false");
 
 	if (!stream) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
@@ -1486,18 +1475,18 @@ map_sp_threads(struct ia_css_stream *stream, bool map)
 	}
 
 	main_pipe = stream->last_pipe;
-	pipe_id	= main_pipe->mode;
+	pipe_id = main_pipe->mode;
 
 	ia_css_pipeline_map(main_pipe->pipe_num, map);
 
 	switch (pipe_id) {
 	case IA_CSS_PIPE_ID_PREVIEW:
-		copy_pipe    = main_pipe->pipe_settings.preview.copy_pipe;
+		copy_pipe = main_pipe->pipe_settings.preview.copy_pipe;
 		capture_pipe = main_pipe->pipe_settings.preview.capture_pipe;
 		break;
 
 	case IA_CSS_PIPE_ID_VIDEO:
-		copy_pipe    = main_pipe->pipe_settings.video.copy_pipe;
+		copy_pipe = main_pipe->pipe_settings.video.copy_pipe;
 		capture_pipe = main_pipe->pipe_settings.video.capture_pipe;
 		break;
 
@@ -1529,15 +1518,13 @@ map_sp_threads(struct ia_css_stream *stream, bool map)
  * creates a host pipeline skeleton for all pipes in a stream. Called during
  * stream_create.
  */
-static int
-create_host_pipeline_structure(struct ia_css_stream *stream)
+static int create_host_pipeline_structure(struct ia_css_stream *stream)
 {
 	struct ia_css_pipe *copy_pipe = NULL, *capture_pipe = NULL;
 	enum ia_css_pipe_id pipe_id;
 	struct ia_css_pipe *main_pipe = NULL;
 	int err = 0;
-	unsigned int copy_pipe_delay = 0,
-	capture_pipe_delay = 0;
+	unsigned int copy_pipe_delay = 0, capture_pipe_delay = 0;
 
 	IA_CSS_ENTER_PRIVATE("stream = %p", stream);
 
@@ -1546,31 +1533,35 @@ create_host_pipeline_structure(struct ia_css_stream *stream)
 		return -EINVAL;
 	}
 
-	main_pipe	= stream->last_pipe;
+	main_pipe = stream->last_pipe;
 	if (!main_pipe) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
 		return -EINVAL;
 	}
 
-	pipe_id	= main_pipe->mode;
+	pipe_id = main_pipe->mode;
 
 	switch (pipe_id) {
 	case IA_CSS_PIPE_ID_PREVIEW:
-		copy_pipe    = main_pipe->pipe_settings.preview.copy_pipe;
+		copy_pipe = main_pipe->pipe_settings.preview.copy_pipe;
 		copy_pipe_delay = main_pipe->dvs_frame_delay;
 		capture_pipe = main_pipe->pipe_settings.preview.capture_pipe;
 		capture_pipe_delay = IA_CSS_FRAME_DELAY_0;
-		err = ia_css_pipeline_create(&main_pipe->pipeline, main_pipe->mode,
-					     main_pipe->pipe_num, main_pipe->dvs_frame_delay);
+		err = ia_css_pipeline_create(&main_pipe->pipeline,
+					     main_pipe->mode,
+					     main_pipe->pipe_num,
+					     main_pipe->dvs_frame_delay);
 		break;
 
 	case IA_CSS_PIPE_ID_VIDEO:
-		copy_pipe    = main_pipe->pipe_settings.video.copy_pipe;
+		copy_pipe = main_pipe->pipe_settings.video.copy_pipe;
 		copy_pipe_delay = main_pipe->dvs_frame_delay;
 		capture_pipe = main_pipe->pipe_settings.video.capture_pipe;
 		capture_pipe_delay = IA_CSS_FRAME_DELAY_0;
-		err = ia_css_pipeline_create(&main_pipe->pipeline, main_pipe->mode,
-					     main_pipe->pipe_num, main_pipe->dvs_frame_delay);
+		err = ia_css_pipeline_create(&main_pipe->pipeline,
+					     main_pipe->mode,
+					     main_pipe->pipe_num,
+					     main_pipe->dvs_frame_delay);
 		break;
 
 	case IA_CSS_PIPE_ID_CAPTURE:
@@ -1579,8 +1570,10 @@ create_host_pipeline_structure(struct ia_css_stream *stream)
 		break;
 
 	case IA_CSS_PIPE_ID_YUVPP:
-		err = ia_css_pipeline_create(&main_pipe->pipeline, main_pipe->mode,
-					     main_pipe->pipe_num, main_pipe->dvs_frame_delay);
+		err = ia_css_pipeline_create(&main_pipe->pipeline,
+					     main_pipe->mode,
+					     main_pipe->pipe_num,
+					     main_pipe->dvs_frame_delay);
 		break;
 
 	default:
@@ -1605,10 +1598,10 @@ create_host_pipeline_structure(struct ia_css_stream *stream)
 
 		for (i = 1; i < stream->num_pipes && 0 == err; i++) {
 			main_pipe = stream->pipes[i];
-			err = ia_css_pipeline_create(&main_pipe->pipeline,
-						     main_pipe->mode,
-						     main_pipe->pipe_num,
-						     main_pipe->dvs_frame_delay);
+			err = ia_css_pipeline_create(
+				&main_pipe->pipeline, main_pipe->mode,
+				main_pipe->pipe_num,
+				main_pipe->dvs_frame_delay);
 		}
 	}
 
@@ -1620,8 +1613,7 @@ create_host_pipeline_structure(struct ia_css_stream *stream)
  * creates a host pipeline for all pipes in a stream. Called during
  * stream_start.
  */
-static int
-create_host_pipeline(struct ia_css_stream *stream)
+static int create_host_pipeline(struct ia_css_stream *stream)
 {
 	struct ia_css_pipe *copy_pipe = NULL, *capture_pipe = NULL;
 	enum ia_css_pipe_id pipe_id;
@@ -1635,8 +1627,8 @@ create_host_pipeline(struct ia_css_stream *stream)
 		return -EINVAL;
 	}
 
-	main_pipe	= stream->last_pipe;
-	pipe_id	= main_pipe->mode;
+	main_pipe = stream->last_pipe;
+	pipe_id = main_pipe->mode;
 
 	/*
 	 * No continuous frame allocation for capture pipe. It uses the
@@ -1676,10 +1668,11 @@ create_host_pipeline(struct ia_css_stream *stream)
 
 	switch (pipe_id) {
 	case IA_CSS_PIPE_ID_PREVIEW:
-		copy_pipe    = main_pipe->pipe_settings.preview.copy_pipe;
+		copy_pipe = main_pipe->pipe_settings.preview.copy_pipe;
 		capture_pipe = main_pipe->pipe_settings.preview.capture_pipe;
 		max_input_width =
-		    main_pipe->pipe_settings.preview.preview_binary.info->sp.input.max_width;
+			main_pipe->pipe_settings.preview.preview_binary.info->sp
+				.input.max_width;
 
 		err = create_host_preview_pipeline(main_pipe);
 		if (err)
@@ -1688,10 +1681,10 @@ create_host_pipeline(struct ia_css_stream *stream)
 		break;
 
 	case IA_CSS_PIPE_ID_VIDEO:
-		copy_pipe    = main_pipe->pipe_settings.video.copy_pipe;
+		copy_pipe = main_pipe->pipe_settings.video.copy_pipe;
 		capture_pipe = main_pipe->pipe_settings.video.capture_pipe;
-		max_input_width =
-		    main_pipe->pipe_settings.video.video_binary.info->sp.input.max_width;
+		max_input_width = main_pipe->pipe_settings.video.video_binary
+					  .info->sp.input.max_width;
 
 		err = create_host_video_pipeline(main_pipe);
 		if (err)
@@ -1718,8 +1711,9 @@ create_host_pipeline(struct ia_css_stream *stream)
 		goto ERR;
 
 	if (copy_pipe) {
-		err = create_host_copy_pipeline(copy_pipe, max_input_width,
-						main_pipe->continuous_frames[0]);
+		err = create_host_copy_pipeline(
+			copy_pipe, max_input_width,
+			main_pipe->continuous_frames[0]);
 		if (err)
 			goto ERR;
 	}
@@ -1737,16 +1731,20 @@ create_host_pipeline(struct ia_css_stream *stream)
 		for (i = 1; i < stream->num_pipes && 0 == err; i++) {
 			switch (stream->pipes[i]->mode) {
 			case IA_CSS_PIPE_ID_PREVIEW:
-				err = create_host_preview_pipeline(stream->pipes[i]);
+				err = create_host_preview_pipeline(
+					stream->pipes[i]);
 				break;
 			case IA_CSS_PIPE_ID_VIDEO:
-				err = create_host_video_pipeline(stream->pipes[i]);
+				err = create_host_video_pipeline(
+					stream->pipes[i]);
 				break;
 			case IA_CSS_PIPE_ID_CAPTURE:
-				err = create_host_capture_pipeline(stream->pipes[i]);
+				err = create_host_capture_pipeline(
+					stream->pipes[i]);
 				break;
 			case IA_CSS_PIPE_ID_YUVPP:
-				err = create_host_yuvpp_pipeline(stream->pipes[i]);
+				err = create_host_yuvpp_pipeline(
+					stream->pipes[i]);
 				break;
 			default:
 				err = -EINVAL;
@@ -1762,15 +1760,15 @@ create_host_pipeline(struct ia_css_stream *stream)
 }
 
 static const struct ia_css_pipe default_pipe = IA_CSS_DEFAULT_PIPE;
-static const struct ia_css_preview_settings preview = IA_CSS_DEFAULT_PREVIEW_SETTINGS;
-static const struct ia_css_capture_settings capture = IA_CSS_DEFAULT_CAPTURE_SETTINGS;
+static const struct ia_css_preview_settings preview =
+	IA_CSS_DEFAULT_PREVIEW_SETTINGS;
+static const struct ia_css_capture_settings capture =
+	IA_CSS_DEFAULT_CAPTURE_SETTINGS;
 static const struct ia_css_video_settings video = IA_CSS_DEFAULT_VIDEO_SETTINGS;
 static const struct ia_css_yuvpp_settings yuvpp = IA_CSS_DEFAULT_YUVPP_SETTINGS;
 
-static int
-init_pipe_defaults(enum ia_css_pipe_mode mode,
-		   struct ia_css_pipe *pipe,
-		   bool copy_pipe)
+static int init_pipe_defaults(enum ia_css_pipe_mode mode,
+			      struct ia_css_pipe *pipe, bool copy_pipe)
 {
 	if (!pipe) {
 		IA_CSS_ERROR("NULL pipe parameter");
@@ -1812,8 +1810,7 @@ init_pipe_defaults(enum ia_css_pipe_mode mode,
 	return 0;
 }
 
-static void
-pipe_global_init(void)
+static void pipe_global_init(void)
 {
 	u8 i;
 
@@ -1822,11 +1819,10 @@ pipe_global_init(void)
 		my_css.all_pipes[i] = NULL;
 }
 
-static int
-pipe_generate_pipe_num(const struct ia_css_pipe *pipe,
-		       unsigned int *pipe_number)
+static int pipe_generate_pipe_num(const struct ia_css_pipe *pipe,
+				  unsigned int *pipe_number)
 {
-	const u8 INVALID_PIPE_NUM = (uint8_t)~(0);
+	const u8 INVALID_PIPE_NUM = (uint8_t) ~(0);
 	u8 pipe_num = INVALID_PIPE_NUM;
 	u8 i;
 
@@ -1858,19 +1854,16 @@ pipe_generate_pipe_num(const struct ia_css_pipe *pipe,
 	return 0;
 }
 
-static void
-pipe_release_pipe_num(unsigned int pipe_num)
+static void pipe_release_pipe_num(unsigned int pipe_num)
 {
 	my_css.all_pipes[pipe_num] = NULL;
 	my_css.pipe_counter--;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "pipe_release_pipe_num (%d)\n", pipe_num);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "pipe_release_pipe_num (%d)\n",
+			    pipe_num);
 }
 
-static int
-create_pipe(enum ia_css_pipe_mode mode,
-	    struct ia_css_pipe **pipe,
-	    bool copy_pipe)
+static int create_pipe(enum ia_css_pipe_mode mode, struct ia_css_pipe **pipe,
+		       bool copy_pipe)
 {
 	int err = 0;
 	struct ia_css_pipe *me;
@@ -1900,8 +1893,7 @@ create_pipe(enum ia_css_pipe_mode mode,
 	return 0;
 }
 
-struct ia_css_pipe *
-find_pipe_by_num(uint32_t pipe_num)
+struct ia_css_pipe *find_pipe_by_num(uint32_t pipe_num)
 {
 	unsigned int i;
 
@@ -1914,8 +1906,7 @@ find_pipe_by_num(uint32_t pipe_num)
 	return NULL;
 }
 
-int
-ia_css_pipe_destroy(struct ia_css_pipe *pipe)
+int ia_css_pipe_destroy(struct ia_css_pipe *pipe)
 {
 	int err = 0;
 
@@ -1944,10 +1935,12 @@ ia_css_pipe_destroy(struct ia_css_pipe *pipe)
 			ia_css_metadata_free_multiple(NUM_CONTINUOUS_FRAMES,
 						      pipe->cont_md_buffers);
 			if (pipe->pipe_settings.preview.copy_pipe) {
-				err = ia_css_pipe_destroy(pipe->pipe_settings.preview.copy_pipe);
-				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-						    "ia_css_pipe_destroy(): destroyed internal copy pipe err=%d\n",
-						    err);
+				err = ia_css_pipe_destroy(
+					pipe->pipe_settings.preview.copy_pipe);
+				ia_css_debug_dtrace(
+					IA_CSS_DEBUG_TRACE,
+					"ia_css_pipe_destroy(): destroyed internal copy pipe err=%d\n",
+					err);
 			}
 		}
 		break;
@@ -1958,20 +1951,25 @@ ia_css_pipe_destroy(struct ia_css_pipe *pipe)
 			ia_css_metadata_free_multiple(NUM_CONTINUOUS_FRAMES,
 						      pipe->cont_md_buffers);
 			if (pipe->pipe_settings.video.copy_pipe) {
-				err = ia_css_pipe_destroy(pipe->pipe_settings.video.copy_pipe);
-				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-						    "ia_css_pipe_destroy(): destroyed internal copy pipe err=%d\n",
-						    err);
+				err = ia_css_pipe_destroy(
+					pipe->pipe_settings.video.copy_pipe);
+				ia_css_debug_dtrace(
+					IA_CSS_DEBUG_TRACE,
+					"ia_css_pipe_destroy(): destroyed internal copy pipe err=%d\n",
+					err);
 			}
 		}
-		ia_css_frame_free_multiple(NUM_VIDEO_TNR_FRAMES,
-					   pipe->pipe_settings.video.tnr_frames);
-		ia_css_frame_free_multiple(MAX_NUM_VIDEO_DELAY_FRAMES,
-					   pipe->pipe_settings.video.delay_frames);
+		ia_css_frame_free_multiple(
+			NUM_VIDEO_TNR_FRAMES,
+			pipe->pipe_settings.video.tnr_frames);
+		ia_css_frame_free_multiple(
+			MAX_NUM_VIDEO_DELAY_FRAMES,
+			pipe->pipe_settings.video.delay_frames);
 		break;
 	case IA_CSS_PIPE_MODE_CAPTURE:
-		ia_css_frame_free_multiple(MAX_NUM_VIDEO_DELAY_FRAMES,
-					   pipe->pipe_settings.capture.delay_frames);
+		ia_css_frame_free_multiple(
+			MAX_NUM_VIDEO_DELAY_FRAMES,
+			pipe->pipe_settings.capture.delay_frames);
 		break;
 	case IA_CSS_PIPE_MODE_COPY:
 		break;
@@ -1995,10 +1993,10 @@ ia_css_pipe_destroy(struct ia_css_pipe *pipe)
 	return err;
 }
 
-void
-ia_css_uninit(void)
+void ia_css_uninit(void)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_uninit() enter: void\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_uninit() enter: void\n");
 
 	sh_css_params_free_default_gdc_lut();
 
@@ -2026,27 +2024,27 @@ ia_css_uninit(void)
 
 	ia_css_isys_uninit();
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_uninit() leave: return_void\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_uninit() leave: return_void\n");
 }
 
-int ia_css_irq_translate(
-    unsigned int *irq_infos)
+int ia_css_irq_translate(unsigned int *irq_infos)
 {
-	enum virq_id	irq;
+	enum virq_id irq;
 	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_more_irqs;
 	unsigned int infos = 0;
 
 	/* irq_infos can be NULL, but that would make the function useless */
 	/* assert(irq_infos != NULL); */
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_irq_translate() enter: irq_infos=%p\n", irq_infos);
+			    "ia_css_irq_translate() enter: irq_infos=%p\n",
+			    irq_infos);
 
 	while (status == hrt_isp_css_irq_status_more_irqs) {
 		status = virq_get_channel_id(&irq);
 		if (status == hrt_isp_css_irq_status_error)
 			return -EINVAL;
 
-
 		switch (irq) {
 		case virq_sp:
 			/*
@@ -2095,11 +2093,9 @@ int ia_css_irq_translate(
 	return 0;
 }
 
-int ia_css_irq_enable(
-    enum ia_css_irq_info info,
-    bool enable)
+int ia_css_irq_enable(enum ia_css_irq_info info, bool enable)
 {
-	enum virq_id	irq = N_virq_id;
+	enum virq_id irq = N_virq_id;
 
 	IA_CSS_ENTER("info=%d, enable=%d", info, enable);
 
@@ -2152,17 +2148,18 @@ int ia_css_irq_enable(
 	return 0;
 }
 
-
-static unsigned int
-sh_css_get_sw_interrupt_value(unsigned int irq)
+static unsigned int sh_css_get_sw_interrupt_value(unsigned int irq)
 {
 	unsigned int irq_value;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "sh_css_get_sw_interrupt_value() enter: irq=%d\n", irq);
+			    "sh_css_get_sw_interrupt_value() enter: irq=%d\n",
+			    irq);
 	irq_value = sh_css_sp_get_sw_interrupt_value(irq);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "sh_css_get_sw_interrupt_value() leave: irq_value=%d\n", irq_value);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"sh_css_get_sw_interrupt_value() leave: irq_value=%d\n",
+		irq_value);
 	return irq_value;
 }
 
@@ -2170,10 +2167,9 @@ sh_css_get_sw_interrupt_value(unsigned int irq)
  * configure and load the copy binary, the next binary is used to
  * determine whether the copy binary needs to do left padding.
  */
-static int load_copy_binary(
-    struct ia_css_pipe *pipe,
-    struct ia_css_binary *copy_binary,
-    struct ia_css_binary *next_binary)
+static int load_copy_binary(struct ia_css_pipe *pipe,
+			    struct ia_css_binary *copy_binary,
+			    struct ia_css_binary *next_binary)
 {
 	struct ia_css_frame_info copy_out_info, copy_in_info, copy_vf_info;
 	unsigned int left_padding;
@@ -2192,13 +2188,14 @@ static int load_copy_binary(
 	} else {
 		copy_out_info = pipe->output_info[0];
 		copy_vf_info = pipe->vf_output_info[0];
-		ia_css_frame_info_set_format(&copy_vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);
+		ia_css_frame_info_set_format(&copy_vf_info,
+					     IA_CSS_FRAME_FORMAT_YUV_LINE);
 		left_padding = 0;
 	}
 
-	ia_css_pipe_get_copy_binarydesc(pipe, &copy_descr,
-					&copy_in_info, &copy_out_info,
-					(next_binary) ? NULL : NULL/*TODO: &copy_vf_info*/);
+	ia_css_pipe_get_copy_binarydesc(
+		pipe, &copy_descr, &copy_in_info, &copy_out_info,
+		(next_binary) ? NULL : NULL /*TODO: &copy_vf_info*/);
 	err = ia_css_binary_find(&copy_descr, copy_binary);
 	if (err)
 		return err;
@@ -2206,8 +2203,7 @@ static int load_copy_binary(
 	return 0;
 }
 
-static int
-alloc_continuous_frames(struct ia_css_pipe *pipe, bool init_time)
+static int alloc_continuous_frames(struct ia_css_pipe *pipe, bool init_time)
 {
 	int err = 0;
 	struct ia_css_frame_info ref_info;
@@ -2231,14 +2227,16 @@ alloc_continuous_frames(struct ia_css_pipe *pipe, bool init_time)
 			num_frames = pipe->stream->config.init_num_cont_raw_buf;
 			pipe->stream->continuous_pipe = pipe;
 		} else {
-			num_frames = pipe->stream->config.target_num_cont_raw_buf;
+			num_frames =
+				pipe->stream->config.target_num_cont_raw_buf;
 		}
 	} else {
 		num_frames = NUM_ONLINE_INIT_CONTINUOUS_FRAMES;
 	}
 
 	if (pipe_id == IA_CSS_PIPE_ID_PREVIEW) {
-		ref_info = pipe->pipe_settings.preview.preview_binary.in_frame_info;
+		ref_info =
+			pipe->pipe_settings.preview.preview_binary.in_frame_info;
 	} else if (pipe_id == IA_CSS_PIPE_ID_VIDEO) {
 		ref_info = pipe->pipe_settings.video.video_binary.in_frame_info;
 	} else {
@@ -2249,30 +2247,35 @@ alloc_continuous_frames(struct ia_css_pipe *pipe, bool init_time)
 
 	if (IS_ISP2401) {
 		/* For CSI2+, the continuous frame will hold the full input frame */
-		ref_info.res.width = pipe->stream->config.input_config.input_res.width;
-		ref_info.res.height = pipe->stream->config.input_config.input_res.height;
+		ref_info.res.width =
+			pipe->stream->config.input_config.input_res.width;
+		ref_info.res.height =
+			pipe->stream->config.input_config.input_res.height;
 
 		/* Ensure padded width is aligned for 2401 */
-		ref_info.padded_width = CEIL_MUL(ref_info.res.width, 2 * ISP_VEC_NELEMS);
+		ref_info.padded_width =
+			CEIL_MUL(ref_info.res.width, 2 * ISP_VEC_NELEMS);
 	}
 
 	if (pipe->stream->config.pack_raw_pixels) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "alloc_continuous_frames() IA_CSS_FRAME_FORMAT_RAW_PACKED\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"alloc_continuous_frames() IA_CSS_FRAME_FORMAT_RAW_PACKED\n");
 		ref_info.format = IA_CSS_FRAME_FORMAT_RAW_PACKED;
-	} else
-	{
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "alloc_continuous_frames() IA_CSS_FRAME_FORMAT_RAW\n");
+	} else {
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"alloc_continuous_frames() IA_CSS_FRAME_FORMAT_RAW\n");
 		ref_info.format = IA_CSS_FRAME_FORMAT_RAW;
 	}
 
 	/* Write format back to binary */
 	if (pipe_id == IA_CSS_PIPE_ID_PREVIEW) {
 		pipe->pipe_settings.preview.preview_binary.in_frame_info.format =
-		    ref_info.format;
+			ref_info.format;
 	} else if (pipe_id == IA_CSS_PIPE_ID_VIDEO) {
-		pipe->pipe_settings.video.video_binary.in_frame_info.format = ref_info.format;
+		pipe->pipe_settings.video.video_binary.in_frame_info.format =
+			ref_info.format;
 	} else {
 		/* should not happen */
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
@@ -2298,35 +2301,30 @@ alloc_continuous_frames(struct ia_css_pipe *pipe, bool init_time)
 		if (i < num_frames) {
 			/* allocate new frame */
 			err = ia_css_frame_allocate_from_info(
-				  &pipe->continuous_frames[i],
-				  &ref_info);
+				&pipe->continuous_frames[i], &ref_info);
 			if (err) {
 				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
 			}
 			/* allocate metadata buffer */
 			pipe->cont_md_buffers[i] = ia_css_metadata_allocate(
-						       &pipe->stream->info.metadata_info);
+				&pipe->stream->info.metadata_info);
 		}
 	}
 	IA_CSS_LEAVE_ERR_PRIVATE(0);
 	return 0;
 }
 
-int
-ia_css_alloc_continuous_frame_remain(struct ia_css_stream *stream)
+int ia_css_alloc_continuous_frame_remain(struct ia_css_stream *stream)
 {
 	if (!stream)
 		return -EINVAL;
 	return alloc_continuous_frames(stream->continuous_pipe, false);
 }
 
-static int
-load_preview_binaries(struct ia_css_pipe *pipe)
+static int load_preview_binaries(struct ia_css_pipe *pipe)
 {
-	struct ia_css_frame_info prev_in_info,
-		prev_bds_out_info,
-		prev_out_info,
+	struct ia_css_frame_info prev_in_info, prev_bds_out_info, prev_out_info,
 		prev_vf_info;
 	struct ia_css_binary_descr preview_descr;
 	bool online;
@@ -2338,7 +2336,7 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 
 	/* preview only have 1 output pin now */
 	struct ia_css_frame_info *pipe_out_info = &pipe->output_info[0];
-	struct ia_css_preview_settings *mycs  = &pipe->pipe_settings.preview;
+	struct ia_css_preview_settings *mycs = &pipe->pipe_settings.preview;
 
 	IA_CSS_ENTER_PRIVATE("");
 	assert(pipe);
@@ -2376,10 +2374,11 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 	 * can perform the requested YUV downscaling.
 	 */
 	need_vf_pp = pipe->config.enable_dz;
-	need_vf_pp |= pipe_out_info->format != IA_CSS_FRAME_FORMAT_YUV_LINE &&
-	!(pipe_out_info->format == IA_CSS_FRAME_FORMAT_NV12 ||
-	  pipe_out_info->format == IA_CSS_FRAME_FORMAT_NV12_16 ||
-	  pipe_out_info->format == IA_CSS_FRAME_FORMAT_NV12_TILEY);
+	need_vf_pp |=
+		pipe_out_info->format != IA_CSS_FRAME_FORMAT_YUV_LINE &&
+		!(pipe_out_info->format == IA_CSS_FRAME_FORMAT_NV12 ||
+		  pipe_out_info->format == IA_CSS_FRAME_FORMAT_NV12_16 ||
+		  pipe_out_info->format == IA_CSS_FRAME_FORMAT_NV12_TILEY);
 
 	/* Preview step 1 */
 	if (pipe->vf_yuv_ds_input_info.res.width)
@@ -2396,13 +2395,10 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 		ia_css_frame_info_set_format(&prev_vf_info,
 					     IA_CSS_FRAME_FORMAT_YUV_LINE);
 
-	err = ia_css_pipe_get_preview_binarydesc(
-	    pipe,
-	    &preview_descr,
-	    &prev_in_info,
-	    &prev_bds_out_info,
-	    &prev_out_info,
-	    &prev_vf_info);
+	err = ia_css_pipe_get_preview_binarydesc(pipe, &preview_descr,
+						 &prev_in_info,
+						 &prev_bds_out_info,
+						 &prev_out_info, &prev_vf_info);
 	if (err)
 		return err;
 	err = ia_css_binary_find(&preview_descr, &mycs->preview_binary);
@@ -2410,16 +2406,18 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 		return err;
 
 	/* The vf_pp binary is needed when (further) YUV downscaling is required */
-	need_vf_pp |= mycs->preview_binary.out_frame_info[0].res.width != pipe_out_info->res.width;
-	need_vf_pp |= mycs->preview_binary.out_frame_info[0].res.height != pipe_out_info->res.height;
+	need_vf_pp |= mycs->preview_binary.out_frame_info[0].res.width !=
+		      pipe_out_info->res.width;
+	need_vf_pp |= mycs->preview_binary.out_frame_info[0].res.height !=
+		      pipe_out_info->res.height;
 
 	/*
 	 * When vf_pp is needed, then the output format of the selected
 	 * preview binary must be yuv_line. If this is not the case,
 	 * then the preview binary selection is done again.
 	 */
-	if (need_vf_pp &&
-	    (mycs->preview_binary.out_frame_info[0].format != IA_CSS_FRAME_FORMAT_YUV_LINE)) {
+	if (need_vf_pp && (mycs->preview_binary.out_frame_info[0].format !=
+			   IA_CSS_FRAME_FORMAT_YUV_LINE)) {
 		/* Preview step 2 */
 		if (pipe->vf_yuv_ds_input_info.res.width)
 			prev_vf_info = pipe->vf_yuv_ds_input_info;
@@ -2430,16 +2428,11 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 					     IA_CSS_FRAME_FORMAT_YUV_LINE);
 
 		err = ia_css_pipe_get_preview_binarydesc(
-		    pipe,
-		    &preview_descr,
-		    &prev_in_info,
-		    &prev_bds_out_info,
-		    &prev_out_info,
-		    &prev_vf_info);
+			pipe, &preview_descr, &prev_in_info, &prev_bds_out_info,
+			&prev_out_info, &prev_vf_info);
 		if (err)
 			return err;
-		err = ia_css_binary_find(&preview_descr,
-					 &mycs->preview_binary);
+		err = ia_css_binary_find(&preview_descr, &mycs->preview_binary);
 		if (err)
 			return err;
 	}
@@ -2448,11 +2441,10 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 		struct ia_css_binary_descr vf_pp_descr;
 
 		/* Viewfinder post-processing */
-		ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
-						&mycs->preview_binary.out_frame_info[0],
-						pipe_out_info);
-		err = ia_css_binary_find(&vf_pp_descr,
-					 &mycs->vf_pp_binary);
+		ia_css_pipe_get_vfpp_binarydesc(
+			pipe, &vf_pp_descr,
+			&mycs->preview_binary.out_frame_info[0], pipe_out_info);
+		err = ia_css_binary_find(&vf_pp_descr, &mycs->vf_pp_binary);
 		if (err)
 			return err;
 	}
@@ -2476,8 +2468,7 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 
 	/* Copy */
 	if (need_isp_copy_binary) {
-		err = load_copy_binary(pipe,
-				       &mycs->copy_binary,
+		err = load_copy_binary(pipe, &mycs->copy_binary,
 				       &mycs->preview_binary);
 		if (err)
 			return err;
@@ -2491,14 +2482,12 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 	return 0;
 }
 
-static void
-ia_css_binary_unload(struct ia_css_binary *binary)
+static void ia_css_binary_unload(struct ia_css_binary *binary)
 {
 	ia_css_binary_destroy_isp_parameters(binary);
 }
 
-static int
-unload_preview_binaries(struct ia_css_pipe *pipe)
+static int unload_preview_binaries(struct ia_css_pipe *pipe)
 {
 	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
 
@@ -2514,8 +2503,8 @@ unload_preview_binaries(struct ia_css_pipe *pipe)
 	return 0;
 }
 
-static const struct ia_css_fw_info *last_output_firmware(
-    const struct ia_css_fw_info *fw)
+static const struct ia_css_fw_info *
+last_output_firmware(const struct ia_css_fw_info *fw)
 {
 	const struct ia_css_fw_info *last_fw = NULL;
 	/* fw can be NULL */
@@ -2530,17 +2519,14 @@ static const struct ia_css_fw_info *last_output_firmware(
 	return last_fw;
 }
 
-static int add_firmwares(
-    struct ia_css_pipeline *me,
-    struct ia_css_binary *binary,
-    const struct ia_css_fw_info *fw,
-    const struct ia_css_fw_info *last_fw,
-    unsigned int binary_mode,
-    struct ia_css_frame *in_frame,
-    struct ia_css_frame *out_frame,
-    struct ia_css_frame *vf_frame,
-    struct ia_css_pipeline_stage **my_stage,
-    struct ia_css_pipeline_stage **vf_stage)
+static int
+add_firmwares(struct ia_css_pipeline *me, struct ia_css_binary *binary,
+	      const struct ia_css_fw_info *fw,
+	      const struct ia_css_fw_info *last_fw, unsigned int binary_mode,
+	      struct ia_css_frame *in_frame, struct ia_css_frame *out_frame,
+	      struct ia_css_frame *vf_frame,
+	      struct ia_css_pipeline_stage **my_stage,
+	      struct ia_css_pipeline_stage **vf_stage)
 {
 	int err = 0;
 	struct ia_css_pipeline_stage *extra_stage = NULL;
@@ -2551,11 +2537,13 @@ static int add_firmwares(
 			    "add_firmwares() enter:\n");
 
 	for (; fw; fw = fw->next) {
-		struct ia_css_frame *out[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {NULL};
+		struct ia_css_frame *out[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {
+			NULL
+		};
 		struct ia_css_frame *in = NULL;
 		struct ia_css_frame *vf = NULL;
 
-		if ((fw == last_fw) && (fw->info.isp.sp.enable.out_frame  != 0))
+		if ((fw == last_fw) && (fw->info.isp.sp.enable.out_frame != 0))
 			out[0] = out_frame;
 
 		if (fw->info.isp.sp.enable.in_frame != 0)
@@ -2564,8 +2552,8 @@ static int add_firmwares(
 		if (fw->info.isp.sp.enable.out_frame != 0)
 			vf = vf_frame;
 
-		ia_css_pipe_get_firmwares_stage_desc(&stage_desc, binary,
-						     out, in, vf, fw, binary_mode);
+		ia_css_pipe_get_firmwares_stage_desc(&stage_desc, binary, out,
+						     in, vf, fw, binary_mode);
 		err = ia_css_pipeline_create_and_add_stage(me, &stage_desc,
 							   &extra_stage);
 		if (err)
@@ -2581,12 +2569,11 @@ static int add_firmwares(
 	return err;
 }
 
-static int add_vf_pp_stage(
-    struct ia_css_pipe *pipe,
-    struct ia_css_frame *in_frame,
-    struct ia_css_frame *out_frame,
-    struct ia_css_binary *vf_pp_binary,
-    struct ia_css_pipeline_stage **vf_pp_stage)
+static int add_vf_pp_stage(struct ia_css_pipe *pipe,
+			   struct ia_css_frame *in_frame,
+			   struct ia_css_frame *out_frame,
+			   struct ia_css_binary *vf_pp_binary,
+			   struct ia_css_pipeline_stage **vf_pp_stage)
 {
 	struct ia_css_pipeline *me = NULL;
 	const struct ia_css_fw_info *last_fw = NULL;
@@ -2617,33 +2604,37 @@ static int add_vf_pp_stage(
 	if (!pipe->extra_config.disable_vf_pp) {
 		if (last_fw) {
 			ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
-			ia_css_pipe_get_generic_stage_desc(&stage_desc, vf_pp_binary,
-							   out_frames, in_frame, NULL);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc,
+							   vf_pp_binary,
+							   out_frames, in_frame,
+							   NULL);
 		} else {
-			ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
-			ia_css_pipe_get_generic_stage_desc(&stage_desc, vf_pp_binary,
-							   out_frames, in_frame, NULL);
+			ia_css_pipe_util_set_output_frames(out_frames, 0,
+							   out_frame);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc,
+							   vf_pp_binary,
+							   out_frames, in_frame,
+							   NULL);
 		}
-		err = ia_css_pipeline_create_and_add_stage(me, &stage_desc, vf_pp_stage);
+		err = ia_css_pipeline_create_and_add_stage(me, &stage_desc,
+							   vf_pp_stage);
 		if (err)
 			return err;
 		in_frame = (*vf_pp_stage)->args.out_frame[0];
 	}
 	err = add_firmwares(me, vf_pp_binary, pipe->vf_stage, last_fw,
-			    IA_CSS_BINARY_MODE_VF_PP,
-			    in_frame, out_frame, NULL,
+			    IA_CSS_BINARY_MODE_VF_PP, in_frame, out_frame, NULL,
 			    vf_pp_stage, NULL);
 	return err;
 }
 
-static int add_yuv_scaler_stage(
-    struct ia_css_pipe *pipe,
-    struct ia_css_pipeline *me,
-    struct ia_css_frame *in_frame,
-    struct ia_css_frame *out_frame,
-    struct ia_css_frame *internal_out_frame,
-    struct ia_css_binary *yuv_scaler_binary,
-    struct ia_css_pipeline_stage **pre_vf_pp_stage)
+static int add_yuv_scaler_stage(struct ia_css_pipe *pipe,
+				struct ia_css_pipeline *me,
+				struct ia_css_frame *in_frame,
+				struct ia_css_frame *out_frame,
+				struct ia_css_frame *internal_out_frame,
+				struct ia_css_binary *yuv_scaler_binary,
+				struct ia_css_pipeline_stage **pre_vf_pp_stage)
 {
 	const struct ia_css_fw_info *last_fw;
 	int err = 0;
@@ -2668,12 +2659,17 @@ static int add_yuv_scaler_stage(
 	if (last_fw) {
 		ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
 		ia_css_pipe_get_generic_stage_desc(&stage_desc,
-						   yuv_scaler_binary, out_frames, in_frame, vf_frame);
+						   yuv_scaler_binary,
+						   out_frames, in_frame,
+						   vf_frame);
 	} else {
 		ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
-		ia_css_pipe_util_set_output_frames(out_frames, 1, internal_out_frame);
+		ia_css_pipe_util_set_output_frames(out_frames, 1,
+						   internal_out_frame);
 		ia_css_pipe_get_generic_stage_desc(&stage_desc,
-						   yuv_scaler_binary, out_frames, in_frame, vf_frame);
+						   yuv_scaler_binary,
+						   out_frames, in_frame,
+						   vf_frame);
 	}
 	err = ia_css_pipeline_create_and_add_stage(me, &stage_desc,
 						   pre_vf_pp_stage);
@@ -2682,25 +2678,23 @@ static int add_yuv_scaler_stage(
 	in_frame = (*pre_vf_pp_stage)->args.out_frame[0];
 
 	err = add_firmwares(me, yuv_scaler_binary, pipe->output_stage, last_fw,
-			    IA_CSS_BINARY_MODE_CAPTURE_PP,
-			    in_frame, out_frame, vf_frame,
-			    NULL, pre_vf_pp_stage);
+			    IA_CSS_BINARY_MODE_CAPTURE_PP, in_frame, out_frame,
+			    vf_frame, NULL, pre_vf_pp_stage);
 	/* If a firmware produce vf_pp output, we set that as vf_pp input */
 	(*pre_vf_pp_stage)->args.vf_downscale_log2 =
-	    yuv_scaler_binary->vf_downscale_log2;
+		yuv_scaler_binary->vf_downscale_log2;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "add_yuv_scaler_stage() leave:\n");
 	return err;
 }
 
-static int add_capture_pp_stage(
-    struct ia_css_pipe *pipe,
-    struct ia_css_pipeline *me,
-    struct ia_css_frame *in_frame,
-    struct ia_css_frame *out_frame,
-    struct ia_css_binary *capture_pp_binary,
-    struct ia_css_pipeline_stage **capture_pp_stage)
+static int add_capture_pp_stage(struct ia_css_pipe *pipe,
+				struct ia_css_pipeline *me,
+				struct ia_css_frame *in_frame,
+				struct ia_css_frame *out_frame,
+				struct ia_css_binary *capture_pp_binary,
+				struct ia_css_pipeline_stage **capture_pp_stage)
 {
 	const struct ia_css_fw_info *last_fw = NULL;
 	int err = 0;
@@ -2721,31 +2715,32 @@ static int add_capture_pp_stage(
 	ia_css_pipe_util_create_output_frames(out_frames);
 
 	last_fw = last_output_firmware(pipe->output_stage);
-	err = ia_css_frame_allocate_from_info(&vf_frame,
-					      &capture_pp_binary->vf_frame_info);
+	err = ia_css_frame_allocate_from_info(
+		&vf_frame, &capture_pp_binary->vf_frame_info);
 	if (err)
 		return err;
-	if (last_fw)	{
+	if (last_fw) {
 		ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
 		ia_css_pipe_get_generic_stage_desc(&stage_desc,
-						   capture_pp_binary, out_frames, NULL, vf_frame);
+						   capture_pp_binary,
+						   out_frames, NULL, vf_frame);
 	} else {
 		ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
 		ia_css_pipe_get_generic_stage_desc(&stage_desc,
-						   capture_pp_binary, out_frames, NULL, vf_frame);
+						   capture_pp_binary,
+						   out_frames, NULL, vf_frame);
 	}
 	err = ia_css_pipeline_create_and_add_stage(me, &stage_desc,
 						   capture_pp_stage);
 	if (err)
 		return err;
 	err = add_firmwares(me, capture_pp_binary, pipe->output_stage, last_fw,
-			    IA_CSS_BINARY_MODE_CAPTURE_PP,
-			    in_frame, out_frame, vf_frame,
-			    NULL, capture_pp_stage);
+			    IA_CSS_BINARY_MODE_CAPTURE_PP, in_frame, out_frame,
+			    vf_frame, NULL, capture_pp_stage);
 	/* If a firmware produce vf_pp output, we set that as vf_pp input */
 	if (*capture_pp_stage) {
 		(*capture_pp_stage)->args.vf_downscale_log2 =
-		    capture_pp_binary->vf_downscale_log2;
+			capture_pp_binary->vf_downscale_log2;
 	}
 	return err;
 }
@@ -2761,20 +2756,21 @@ static void sh_css_setup_queues(void)
 
 	fw = &sh_css_sp_fw;
 	HIVE_ADDR_host_sp_queues_initialized =
-	    fw->info.sp.host_sp_queues_initialized;
+		fw->info.sp.host_sp_queues_initialized;
 
 	ia_css_bufq_init();
 
 	/* set "host_sp_queues_initialized" to "true" */
-	sp_dmem_store_uint32(SP0_ID,
-			     (unsigned int)sp_address_of(host_sp_queues_initialized),
-			     (uint32_t)(1));
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_setup_queues() leave:\n");
+	sp_dmem_store_uint32(
+		SP0_ID, (unsigned int)sp_address_of(host_sp_queues_initialized),
+		(uint32_t)(1));
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "sh_css_setup_queues() leave:\n");
 }
 
-static int
-init_vf_frameinfo_defaults(struct ia_css_pipe *pipe,
-			   struct ia_css_frame *vf_frame, unsigned int idx)
+static int init_vf_frameinfo_defaults(struct ia_css_pipe *pipe,
+				      struct ia_css_frame *vf_frame,
+				      unsigned int idx)
 {
 	int err = 0;
 	unsigned int thread_id;
@@ -2783,8 +2779,10 @@ init_vf_frameinfo_defaults(struct ia_css_pipe *pipe,
 	assert(vf_frame);
 
 	sh_css_pipe_get_viewfinder_frame_info(pipe, &vf_frame->frame_info, idx);
-	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
-	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME + idx, thread_id, &queue_id);
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe),
+					 &thread_id);
+	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME + idx,
+				       thread_id, &queue_id);
 	vf_frame->dynamic_queue_id = queue_id;
 	vf_frame->buf_type = IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME + idx;
 
@@ -2819,7 +2817,8 @@ get_crop_columns_for_bayer_order(const struct ia_css_stream_config *config)
  * input, it includes dvs envelop and filter run-in
  */
 static void get_pipe_extra_pixel(struct ia_css_pipe *pipe,
-				 unsigned int *extra_row, unsigned int *extra_column)
+				 unsigned int *extra_row,
+				 unsigned int *extra_column)
 {
 	enum ia_css_pipe_id pipe_id = pipe->mode;
 	unsigned int left_cropping = 0, top_cropping = 0;
@@ -2835,33 +2834,44 @@ static void get_pipe_extra_pixel(struct ia_css_pipe *pipe,
 	case IA_CSS_PIPE_ID_PREVIEW:
 		if (pipe->pipe_settings.preview.preview_binary.info) {
 			left_cropping =
-			    pipe->pipe_settings.preview.preview_binary.info->sp.pipeline.left_cropping;
+				pipe->pipe_settings.preview.preview_binary.info
+					->sp.pipeline.left_cropping;
 			top_cropping =
-			    pipe->pipe_settings.preview.preview_binary.info->sp.pipeline.top_cropping;
+				pipe->pipe_settings.preview.preview_binary.info
+					->sp.pipeline.top_cropping;
 		}
-		dvs_env = pipe->pipe_settings.preview.preview_binary.dvs_envelope;
+		dvs_env =
+			pipe->pipe_settings.preview.preview_binary.dvs_envelope;
 		break;
 	case IA_CSS_PIPE_ID_VIDEO:
 		if (pipe->pipe_settings.video.video_binary.info) {
 			left_cropping =
-			    pipe->pipe_settings.video.video_binary.info->sp.pipeline.left_cropping;
-			top_cropping =
-			    pipe->pipe_settings.video.video_binary.info->sp.pipeline.top_cropping;
+				pipe->pipe_settings.video.video_binary.info->sp
+					.pipeline.left_cropping;
+			top_cropping = pipe->pipe_settings.video.video_binary
+					       .info->sp.pipeline.top_cropping;
 		}
 		dvs_env = pipe->pipe_settings.video.video_binary.dvs_envelope;
 		break;
 	case IA_CSS_PIPE_ID_CAPTURE:
-		for (i = 0; i < pipe->pipe_settings.capture.num_primary_stage; i++) {
+		for (i = 0; i < pipe->pipe_settings.capture.num_primary_stage;
+		     i++) {
 			if (pipe->pipe_settings.capture.primary_binary[i].info) {
 				left_cropping +=
-				    pipe->pipe_settings.capture.primary_binary[i].info->sp.pipeline.left_cropping;
+					pipe->pipe_settings.capture
+						.primary_binary[i]
+						.info->sp.pipeline.left_cropping;
 				top_cropping +=
-				    pipe->pipe_settings.capture.primary_binary[i].info->sp.pipeline.top_cropping;
+					pipe->pipe_settings.capture
+						.primary_binary[i]
+						.info->sp.pipeline.top_cropping;
 			}
 			dvs_env.width +=
-			    pipe->pipe_settings.capture.primary_binary[i].dvs_envelope.width;
+				pipe->pipe_settings.capture.primary_binary[i]
+					.dvs_envelope.width;
 			dvs_env.height +=
-			    pipe->pipe_settings.capture.primary_binary[i].dvs_envelope.height;
+				pipe->pipe_settings.capture.primary_binary[i]
+					.dvs_envelope.height;
 		}
 		break;
 	default:
@@ -2872,10 +2882,8 @@ static void get_pipe_extra_pixel(struct ia_css_pipe *pipe,
 	*extra_column = left_cropping + dvs_env.width;
 }
 
-void
-ia_css_get_crop_offsets(
-    struct ia_css_pipe *pipe,
-    struct ia_css_frame_info *in_frame)
+void ia_css_get_crop_offsets(struct ia_css_pipe *pipe,
+			     struct ia_css_frame_info *in_frame)
 {
 	unsigned int row = 0;
 	unsigned int column = 0;
@@ -2897,11 +2905,13 @@ ia_css_get_crop_offsets(
 	if (IS_ISP2401)
 		effective_res = &pipe->config.input_effective_res;
 	else
-		effective_res = &pipe->stream->config.input_config.effective_res;
+		effective_res =
+			&pipe->stream->config.input_config.effective_res;
 
 	get_pipe_extra_pixel(pipe, &extra_row, &extra_col);
 
-	in_frame->raw_bayer_order = pipe->stream->config.input_config.bayer_order;
+	in_frame->raw_bayer_order =
+		pipe->stream->config.input_config.bayer_order;
 
 	min_reqd_height = effective_res->height + extra_row;
 	min_reqd_width = effective_res->width + extra_col;
@@ -2936,9 +2946,9 @@ ia_css_get_crop_offsets(
 	return;
 }
 
-static int
-init_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,
-				  struct ia_css_frame *frame, enum ia_css_frame_format format)
+static int init_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,
+					     struct ia_css_frame *frame,
+					     enum ia_css_frame_format format)
 {
 	struct ia_css_frame *in_frame;
 	int err = 0;
@@ -2951,17 +2961,25 @@ init_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,
 	in_frame->frame_info.format = format;
 
 	if (IS_ISP2401 && format == IA_CSS_FRAME_FORMAT_RAW) {
-		in_frame->frame_info.format = (pipe->stream->config.pack_raw_pixels) ?
-		IA_CSS_FRAME_FORMAT_RAW_PACKED : IA_CSS_FRAME_FORMAT_RAW;
+		in_frame->frame_info.format =
+			(pipe->stream->config.pack_raw_pixels) ?
+				IA_CSS_FRAME_FORMAT_RAW_PACKED :
+				IA_CSS_FRAME_FORMAT_RAW;
 	}
 
-	in_frame->frame_info.res.width = pipe->stream->config.input_config.input_res.width;
-	in_frame->frame_info.res.height = pipe->stream->config.input_config.input_res.height;
-	in_frame->frame_info.raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);
-	ia_css_frame_info_set_width(&in_frame->frame_info,
-				    pipe->stream->config.input_config.input_res.width, 0);
-	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
-	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_INPUT_FRAME, thread_id, &queue_id);
+	in_frame->frame_info.res.width =
+		pipe->stream->config.input_config.input_res.width;
+	in_frame->frame_info.res.height =
+		pipe->stream->config.input_config.input_res.height;
+	in_frame->frame_info.raw_bit_depth =
+		ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	ia_css_frame_info_set_width(
+		&in_frame->frame_info,
+		pipe->stream->config.input_config.input_res.width, 0);
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe),
+					 &thread_id);
+	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_INPUT_FRAME,
+				       thread_id, &queue_id);
 	in_frame->dynamic_queue_id = queue_id;
 	in_frame->buf_type = IA_CSS_BUFFER_TYPE_INPUT_FRAME;
 
@@ -2970,15 +2988,16 @@ init_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,
 
 	err = ia_css_frame_init_planes(in_frame);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "%s() bayer_order = %d\n",
-			    __func__, in_frame->frame_info.raw_bayer_order);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "%s() bayer_order = %d\n", __func__,
+			    in_frame->frame_info.raw_bayer_order);
 
 	return err;
 }
 
-static int
-init_out_frameinfo_defaults(struct ia_css_pipe *pipe,
-			    struct ia_css_frame *out_frame, unsigned int idx)
+static int init_out_frameinfo_defaults(struct ia_css_pipe *pipe,
+				       struct ia_css_frame *out_frame,
+				       unsigned int idx)
 {
 	int err = 0;
 	unsigned int thread_id;
@@ -2987,8 +3006,10 @@ init_out_frameinfo_defaults(struct ia_css_pipe *pipe,
 	assert(out_frame);
 
 	sh_css_pipe_get_output_frame_info(pipe, &out_frame->frame_info, idx);
-	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
-	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx, thread_id, &queue_id);
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe),
+					 &thread_id);
+	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx,
+				       thread_id, &queue_id);
 	out_frame->dynamic_queue_id = queue_id;
 	out_frame->buf_type = IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx;
 	err = ia_css_frame_init_planes(out_frame);
@@ -3000,11 +3021,11 @@ init_out_frameinfo_defaults(struct ia_css_pipe *pipe,
 static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 {
 	struct ia_css_pipeline_stage_desc stage_desc;
-	struct ia_css_binary *copy_binary, *video_binary,
-		       *yuv_scaler_binary, *vf_pp_binary;
-	struct ia_css_pipeline_stage *copy_stage  = NULL;
+	struct ia_css_binary *copy_binary, *video_binary, *yuv_scaler_binary,
+		*vf_pp_binary;
+	struct ia_css_pipeline_stage *copy_stage = NULL;
 	struct ia_css_pipeline_stage *video_stage = NULL;
-	struct ia_css_pipeline_stage *yuv_scaler_stage  = NULL;
+	struct ia_css_pipeline_stage *yuv_scaler_stage = NULL;
 	struct ia_css_pipeline_stage *vf_pp_stage = NULL;
 	struct ia_css_pipeline *me;
 	struct ia_css_frame *in_frame = NULL;
@@ -3012,8 +3033,8 @@ static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 	struct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
 	struct ia_css_frame *vf_frame = NULL;
 	int err = 0;
-	bool need_copy   = false;
-	bool need_vf_pp  = false;
+	bool need_copy = false;
+	bool need_vf_pp = false;
 	bool need_yuv_pp = false;
 	bool need_in_frameinfo_memory = false;
 
@@ -3021,7 +3042,8 @@ static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 	bool *is_output_stage = NULL;
 
 	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
-	if ((!pipe) || (!pipe->stream) || (pipe->mode != IA_CSS_PIPE_ID_VIDEO)) {
+	if ((!pipe) || (!pipe->stream) ||
+	    (pipe->mode != IA_CSS_PIPE_ID_VIDEO)) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
 		return -EINVAL;
 	}
@@ -3050,8 +3072,8 @@ static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 	/* Construct in_frame info (only in case we have dynamic input */
 	if (need_in_frameinfo_memory) {
 		in_frame = &pipe->in_frame_struct;
-		err = init_in_frameinfo_memory_defaults(pipe, in_frame,
-							IA_CSS_FRAME_FORMAT_RAW);
+		err = init_in_frameinfo_memory_defaults(
+			pipe, in_frame, IA_CSS_FRAME_FORMAT_RAW);
 		if (err)
 			goto ERR;
 	}
@@ -3069,16 +3091,16 @@ static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 			goto ERR;
 	}
 
-	copy_binary  = &pipe->pipe_settings.video.copy_binary;
+	copy_binary = &pipe->pipe_settings.video.copy_binary;
 	video_binary = &pipe->pipe_settings.video.video_binary;
 	vf_pp_binary = &pipe->pipe_settings.video.vf_pp_binary;
 
 	yuv_scaler_binary = pipe->pipe_settings.video.yuv_scaler_binary;
-	num_yuv_scaler  = pipe->pipe_settings.video.num_yuv_scaler;
+	num_yuv_scaler = pipe->pipe_settings.video.num_yuv_scaler;
 	is_output_stage = pipe->pipe_settings.video.is_output_stage;
 
-	need_copy   = (copy_binary && copy_binary->info);
-	need_vf_pp  = (vf_pp_binary && vf_pp_binary->info);
+	need_copy = (copy_binary && copy_binary->info);
+	need_vf_pp = (vf_pp_binary && vf_pp_binary->info);
 	need_yuv_pp = (yuv_scaler_binary && yuv_scaler_binary->info);
 
 	if (need_copy) {
@@ -3096,7 +3118,8 @@ static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 			 * When continuous is enabled, configure in_frame with the
 			 * last pipe, which is the copy pipe.
 			 */
-			in_frame = pipe->stream->last_pipe->continuous_frames[0];
+			in_frame =
+				pipe->stream->last_pipe->continuous_frames[0];
 		else
 			in_frame = pipe->continuous_frames[0];
 	}
@@ -3113,7 +3136,8 @@ static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 						   out_frames, in_frame, NULL);
 	} else {
 		ia_css_pipe_get_generic_stage_desc(&stage_desc, video_binary,
-						   out_frames, in_frame, vf_frame);
+						   out_frames, in_frame,
+						   vf_frame);
 	}
 	err = ia_css_pipeline_create_and_add_stage(me, &stage_desc,
 						   &video_stage);
@@ -3123,7 +3147,8 @@ static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 	/* If we use copy iso video, the input must be yuv iso raw */
 	if (video_stage) {
 		video_stage->args.copy_vf =
-		    video_binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_COPY;
+			video_binary->info->sp.pipeline.mode ==
+			IA_CSS_BINARY_MODE_COPY;
 		video_stage->args.copy_output = video_stage->args.copy_vf;
 	}
 
@@ -3141,16 +3166,17 @@ static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 
 		for (frm = 0; frm < NUM_VIDEO_TNR_FRAMES; frm++) {
 			video_stage->args.tnr_frames[frm] =
-			    pipe->pipe_settings.video.tnr_frames[frm];
+				pipe->pipe_settings.video.tnr_frames[frm];
 		}
 		for (frm = 0; frm < MAX_NUM_VIDEO_DELAY_FRAMES; frm++) {
 			video_stage->args.delay_frames[frm] =
-			    pipe->pipe_settings.video.delay_frames[frm];
+				pipe->pipe_settings.video.delay_frames[frm];
 		}
 	}
 
 	if (need_yuv_pp && video_stage) {
-		struct ia_css_frame *tmp_in_frame = video_stage->args.out_frame[0];
+		struct ia_css_frame *tmp_in_frame =
+			video_stage->args.out_frame[0];
 		struct ia_css_frame *tmp_out_frame = NULL;
 
 		for (i = 0; i < num_yuv_scaler; i++) {
@@ -3167,7 +3193,8 @@ static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 			}
 			/* we use output port 1 as internal output port */
 			if (yuv_scaler_stage)
-				tmp_in_frame = yuv_scaler_stage->args.out_frame[1];
+				tmp_in_frame =
+					yuv_scaler_stage->args.out_frame[1];
 		}
 	}
 
@@ -3181,15 +3208,15 @@ static int create_host_video_pipeline(struct ia_css_pipe *pipe)
 }
 
 /* Create stages for preview */
-static int
-create_host_preview_pipeline(struct ia_css_pipe *pipe)
+static int create_host_preview_pipeline(struct ia_css_pipe *pipe)
 {
 	struct ia_css_pipeline_stage *copy_stage = NULL;
 	struct ia_css_pipeline_stage *preview_stage = NULL;
 	struct ia_css_pipeline_stage *vf_pp_stage = NULL;
 	struct ia_css_pipeline_stage_desc stage_desc;
 	struct ia_css_pipeline *me = NULL;
-	struct ia_css_binary *copy_binary, *preview_binary, *vf_pp_binary = NULL;
+	struct ia_css_binary *copy_binary, *preview_binary,
+		*vf_pp_binary = NULL;
 	struct ia_css_frame *in_frame = NULL;
 	int err = 0;
 	struct ia_css_frame *out_frame;
@@ -3201,7 +3228,8 @@ create_host_preview_pipeline(struct ia_css_pipe *pipe)
 	bool continuous = false;
 
 	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
-	if ((!pipe) || (!pipe->stream) || (pipe->mode != IA_CSS_PIPE_ID_PREVIEW)) {
+	if ((!pipe) || (!pipe->stream) ||
+	    (pipe->mode != IA_CSS_PIPE_ID_PREVIEW)) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
 		return -EINVAL;
 	}
@@ -3220,20 +3248,23 @@ create_host_preview_pipeline(struct ia_css_pipe *pipe)
 		 * - Direct Sensor Mode Continuous Preview
 		 * - Buffered Sensor Mode Continuous Preview
 		 */
-		sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR);
-		buffered_sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR);
+		sensor =
+			(pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR);
+		buffered_sensor = (pipe->stream->config.mode ==
+				   IA_CSS_INPUT_MODE_BUFFERED_SENSOR);
 		online = pipe->stream->config.online;
 		continuous = pipe->stream->config.continuous;
 		need_in_frameinfo_memory =
-		!((sensor && (online || continuous)) || (buffered_sensor &&
-							(online || continuous)));
+			!((sensor && (online || continuous)) ||
+			  (buffered_sensor && (online || continuous)));
 	} else {
 		/* Construct in_frame info (only in case we have dynamic input */
-		need_in_frameinfo_memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;
+		need_in_frameinfo_memory = pipe->stream->config.mode ==
+					   IA_CSS_INPUT_MODE_MEMORY;
 	}
 	if (need_in_frameinfo_memory) {
-		err = init_in_frameinfo_memory_defaults(pipe, &me->in_frame,
-							IA_CSS_FRAME_FORMAT_RAW);
+		err = init_in_frameinfo_memory_defaults(
+			pipe, &me->in_frame, IA_CSS_FRAME_FORMAT_RAW);
 		if (err)
 			goto ERR;
 
@@ -3246,7 +3277,7 @@ create_host_preview_pipeline(struct ia_css_pipe *pipe)
 		goto ERR;
 	out_frame = &me->out_frame[0];
 
-	copy_binary    = &pipe->pipe_settings.preview.copy_binary;
+	copy_binary = &pipe->pipe_settings.preview.copy_binary;
 	preview_binary = &pipe->pipe_settings.preview.preview_binary;
 	if (pipe->pipe_settings.preview.vf_pp_binary.info)
 		vf_pp_binary = &pipe->pipe_settings.preview.vf_pp_binary;
@@ -3267,7 +3298,8 @@ create_host_preview_pipeline(struct ia_css_pipe *pipe)
 			 * last pipe, which is the copy pipe.
 			 */
 			if (continuous || !online)
-				in_frame = pipe->stream->last_pipe->continuous_frames[0];
+				in_frame = pipe->stream->last_pipe
+						   ->continuous_frames[0];
 		} else {
 			in_frame = pipe->continuous_frames[0];
 		}
@@ -3287,16 +3319,17 @@ create_host_preview_pipeline(struct ia_css_pipe *pipe)
 	if (err)
 		goto ERR;
 	/* If we use copy iso preview, the input must be yuv iso raw */
-	preview_stage->args.copy_vf =
-	    preview_binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_COPY;
+	preview_stage->args.copy_vf = preview_binary->info->sp.pipeline.mode ==
+				      IA_CSS_BINARY_MODE_COPY;
 	preview_stage->args.copy_output = !preview_stage->args.copy_vf;
 	if (preview_stage->args.copy_vf && !preview_stage->args.out_vf_frame) {
 		/* in case of copy, use the vf frame as output frame */
 		preview_stage->args.out_vf_frame =
-		    preview_stage->args.out_frame[0];
+			preview_stage->args.out_frame[0];
 	}
 	if (vf_pp_binary) {
-		if (preview_binary->info->sp.pipeline.mode == IA_CSS_BINARY_MODE_COPY)
+		if (preview_binary->info->sp.pipeline.mode ==
+		    IA_CSS_BINARY_MODE_COPY)
 			in_frame = preview_stage->args.out_vf_frame;
 		else
 			in_frame = preview_stage->args.out_frame[0];
@@ -3307,7 +3340,8 @@ create_host_preview_pipeline(struct ia_css_pipe *pipe)
 	}
 
 	pipe->pipeline.acquire_isp_each_stage = false;
-	ia_css_pipeline_finalize_stages(&pipe->pipeline, pipe->stream->config.continuous);
+	ia_css_pipeline_finalize_stages(&pipe->pipeline,
+					pipe->stream->config.continuous);
 
 ERR:
 	IA_CSS_LEAVE_ERR_PRIVATE(err);
@@ -3319,23 +3353,24 @@ static void send_raw_frames(struct ia_css_pipe *pipe)
 	if (pipe->stream->config.continuous) {
 		unsigned int i;
 
-		sh_css_update_host2sp_cont_num_raw_frames
-		(pipe->stream->config.init_num_cont_raw_buf, true);
-		sh_css_update_host2sp_cont_num_raw_frames
-		(pipe->stream->config.target_num_cont_raw_buf, false);
+		sh_css_update_host2sp_cont_num_raw_frames(
+			pipe->stream->config.init_num_cont_raw_buf, true);
+		sh_css_update_host2sp_cont_num_raw_frames(
+			pipe->stream->config.target_num_cont_raw_buf, false);
 
 		/* Hand-over all the SP-internal buffers */
-		for (i = 0; i < pipe->stream->config.init_num_cont_raw_buf; i++) {
-			sh_css_update_host2sp_offline_frame(i,
-							    pipe->continuous_frames[i], pipe->cont_md_buffers[i]);
+		for (i = 0; i < pipe->stream->config.init_num_cont_raw_buf;
+		     i++) {
+			sh_css_update_host2sp_offline_frame(
+				i, pipe->continuous_frames[i],
+				pipe->cont_md_buffers[i]);
 		}
 	}
 
 	return;
 }
 
-static int
-preview_start(struct ia_css_pipe *pipe)
+static int preview_start(struct ia_css_pipe *pipe)
 {
 	int err = 0;
 	struct ia_css_pipe *copy_pipe, *capture_pipe;
@@ -3344,14 +3379,15 @@ preview_start(struct ia_css_pipe *pipe)
 	unsigned int thread_id;
 
 	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
-	if ((!pipe) || (!pipe->stream) || (pipe->mode != IA_CSS_PIPE_ID_PREVIEW)) {
+	if ((!pipe) || (!pipe->stream) ||
+	    (pipe->mode != IA_CSS_PIPE_ID_PREVIEW)) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
 		return -EINVAL;
 	}
 
 	preview_pipe_input_mode = pipe->stream->config.mode;
 
-	copy_pipe    = pipe->pipe_settings.preview.copy_pipe;
+	copy_pipe = pipe->pipe_settings.preview.copy_pipe;
 	capture_pipe = pipe->pipe_settings.preview.capture_pipe;
 
 	sh_css_metrics_start_frame();
@@ -3364,28 +3400,27 @@ preview_start(struct ia_css_pipe *pipe)
 	}
 	send_raw_frames(pipe);
 
-	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe),
+					 &thread_id);
 	copy_ovrd = 1 << thread_id;
 
 	if (pipe->stream->cont_capt) {
-		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(capture_pipe),
-						 &thread_id);
+		ia_css_pipeline_get_sp_thread_id(
+			ia_css_pipe_get_pipe_num(capture_pipe), &thread_id);
 		copy_ovrd |= 1 << thread_id;
 	}
 
 	/* Construct and load the copy pipe */
 	if (pipe->stream->config.continuous) {
-		sh_css_sp_init_pipeline(&copy_pipe->pipeline,
-					IA_CSS_PIPE_ID_COPY,
-					(uint8_t)ia_css_pipe_get_pipe_num(copy_pipe),
-					false,
-					pipe->stream->config.pixels_per_clock == 2, false,
-					false, pipe->required_bds_factor,
-					copy_ovrd,
-					pipe->stream->config.mode,
-					&pipe->stream->config.metadata_config,
-					&pipe->stream->info.metadata_info,
-					pipe->stream->config.source.port.port);
+		sh_css_sp_init_pipeline(
+			&copy_pipe->pipeline, IA_CSS_PIPE_ID_COPY,
+			(uint8_t)ia_css_pipe_get_pipe_num(copy_pipe), false,
+			pipe->stream->config.pixels_per_clock == 2, false,
+			false, pipe->required_bds_factor, copy_ovrd,
+			pipe->stream->config.mode,
+			&pipe->stream->config.metadata_config,
+			&pipe->stream->info.metadata_info,
+			pipe->stream->config.source.port.port);
 
 		/*
 		 * make the preview pipe start with mem mode input, copy handles
@@ -3396,19 +3431,19 @@ preview_start(struct ia_css_pipe *pipe)
 
 	/* Construct and load the capture pipe */
 	if (pipe->stream->cont_capt) {
-		sh_css_sp_init_pipeline(&capture_pipe->pipeline,
-					IA_CSS_PIPE_ID_CAPTURE,
-					(uint8_t)ia_css_pipe_get_pipe_num(capture_pipe),
-					capture_pipe->config.default_capture_config.enable_xnr != 0,
-					capture_pipe->stream->config.pixels_per_clock == 2,
-					true, /* continuous */
-					false, /* offline */
-					capture_pipe->required_bds_factor,
-					0,
-					IA_CSS_INPUT_MODE_MEMORY,
-					&pipe->stream->config.metadata_config,
-					&pipe->stream->info.metadata_info,
-					(enum mipi_port_id)0);
+		sh_css_sp_init_pipeline(
+			&capture_pipe->pipeline, IA_CSS_PIPE_ID_CAPTURE,
+			(uint8_t)ia_css_pipe_get_pipe_num(capture_pipe),
+			capture_pipe->config.default_capture_config.enable_xnr !=
+				0,
+			capture_pipe->stream->config.pixels_per_clock == 2,
+			true, /* continuous */
+			false, /* offline */
+			capture_pipe->required_bds_factor, 0,
+			IA_CSS_INPUT_MODE_MEMORY,
+			&pipe->stream->config.metadata_config,
+			&pipe->stream->info.metadata_info,
+			(enum mipi_port_id)0);
 	}
 
 	start_pipe(pipe, copy_ovrd, preview_pipe_input_mode);
@@ -3417,9 +3452,8 @@ preview_start(struct ia_css_pipe *pipe)
 	return err;
 }
 
-int
-ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
-			   const struct ia_css_buffer *buffer)
+int ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
+			       const struct ia_css_buffer *buffer)
 {
 	int return_err = 0;
 	unsigned int thread_id;
@@ -3455,19 +3489,22 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
 		return -EINVAL;
 	}
 
-	ret_err = ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ret_err = ia_css_pipeline_get_sp_thread_id(
+		ia_css_pipe_get_pipe_num(pipe), &thread_id);
 	if (!ret_err) {
 		IA_CSS_LEAVE_ERR(-EINVAL);
 		return -EINVAL;
 	}
 
-	ret_err = ia_css_query_internal_queue_id(buf_type, thread_id, &queue_id);
+	ret_err =
+		ia_css_query_internal_queue_id(buf_type, thread_id, &queue_id);
 	if (!ret_err) {
 		IA_CSS_LEAVE_ERR(-EINVAL);
 		return -EINVAL;
 	}
 
-	if ((queue_id <= SH_CSS_INVALID_QUEUE_ID) || (queue_id >= SH_CSS_MAX_NUM_QUEUES)) {
+	if ((queue_id <= SH_CSS_INVALID_QUEUE_ID) ||
+	    (queue_id >= SH_CSS_MAX_NUM_QUEUES)) {
 		IA_CSS_LEAVE_ERR(-EINVAL);
 		return -EINVAL;
 	}
@@ -3522,10 +3559,10 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
 		ddr_buffer.payload.frame.frame_data = buffer->data.frame->data;
 		ddr_buffer.payload.frame.flashed = 0;
 
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "ia_css_pipe_enqueue_buffer() buf_type=%d, data(DDR address)=0x%x\n",
-				    buf_type, buffer->data.frame->data);
-
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE,
+			"ia_css_pipe_enqueue_buffer() buf_type=%d, data(DDR address)=0x%x\n",
+			buf_type, buffer->data.frame->data);
 	}
 
 	/* start of test for using rmgr for acq/rel memory */
@@ -3541,8 +3578,7 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
 		return -EINVAL;
 	}
 
-	hmm_store(h_vbuf->vptr,
-		  (void *)(&ddr_buffer),
+	hmm_store(h_vbuf->vptr, (void *)(&ddr_buffer),
 		  sizeof(struct sh_css_hmm_buffer));
 	if (buf_type == IA_CSS_BUFFER_TYPE_3A_STATISTICS ||
 	    buf_type == IA_CSS_BUFFER_TYPE_DIS_STATISTICS ||
@@ -3563,9 +3599,9 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
 			    (stage->binary->info->sp.enable.s3a ||
 			     stage->binary->info->sp.enable.dis)) {
 				/* there is a stage that needs it */
-				return_err = ia_css_bufq_enqueue_buffer(thread_id,
-									queue_id,
-									(uint32_t)h_vbuf->vptr);
+				return_err = ia_css_bufq_enqueue_buffer(
+					thread_id, queue_id,
+					(uint32_t)h_vbuf->vptr);
 			}
 		}
 	} else if (buf_type == IA_CSS_BUFFER_TYPE_INPUT_FRAME ||
@@ -3574,8 +3610,7 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
 		   buf_type == IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME ||
 		   buf_type == IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME ||
 		   buf_type == IA_CSS_BUFFER_TYPE_METADATA) {
-		return_err = ia_css_bufq_enqueue_buffer(thread_id,
-							queue_id,
+		return_err = ia_css_bufq_enqueue_buffer(thread_id, queue_id,
 							(uint32_t)h_vbuf->vptr);
 		if (!return_err &&
 		    buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME) {
@@ -3587,12 +3622,13 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
 
 	if (!return_err) {
 		if (sh_css_hmm_buffer_record_acquire(
-			h_vbuf, buf_type,
-			HOST_ADDRESS(ddr_buffer.kernel_ptr))) {
+			    h_vbuf, buf_type,
+			    HOST_ADDRESS(ddr_buffer.kernel_ptr))) {
 			IA_CSS_LOG("send vbuf=%p", h_vbuf);
 		} else {
 			return_err = -EINVAL;
-			IA_CSS_ERROR("hmm_buffer_record[]: no available slots\n");
+			IA_CSS_ERROR(
+				"hmm_buffer_record[]: no available slots\n");
 		}
 	}
 
@@ -3608,10 +3644,8 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
 			return -EBUSY;
 		}
 		return_err = ia_css_bufq_enqueue_psys_event(
-				 IA_CSS_PSYS_SW_EVENT_BUFFER_ENQUEUED,
-				 (uint8_t)thread_id,
-				 queue_id,
-				 0);
+			IA_CSS_PSYS_SW_EVENT_BUFFER_ENQUEUED,
+			(uint8_t)thread_id, queue_id, 0);
 	} else {
 		ia_css_rmgr_rel_vbuf(hmm_buffer_pool, &h_vbuf);
 		IA_CSS_ERROR("buffer not enqueued");
@@ -3625,9 +3659,8 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
 /*
  * TODO: Free up the hmm memory space.
  */
-int
-ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
-			   struct ia_css_buffer *buffer)
+int ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
+			       struct ia_css_buffer *buffer)
 {
 	int return_err;
 	enum sh_css_queue_id queue_id;
@@ -3654,19 +3687,22 @@ ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
 
 	ddr_buffer.kernel_ptr = 0;
 
-	ret_err = ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ret_err = ia_css_pipeline_get_sp_thread_id(
+		ia_css_pipe_get_pipe_num(pipe), &thread_id);
 	if (!ret_err) {
 		IA_CSS_LEAVE_ERR(-EINVAL);
 		return -EINVAL;
 	}
 
-	ret_err = ia_css_query_internal_queue_id(buf_type, thread_id, &queue_id);
+	ret_err =
+		ia_css_query_internal_queue_id(buf_type, thread_id, &queue_id);
 	if (!ret_err) {
 		IA_CSS_LEAVE_ERR(-EINVAL);
 		return -EINVAL;
 	}
 
-	if ((queue_id <= SH_CSS_INVALID_QUEUE_ID) || (queue_id >= SH_CSS_MAX_NUM_QUEUES)) {
+	if ((queue_id <= SH_CSS_INVALID_QUEUE_ID) ||
+	    (queue_id >= SH_CSS_MAX_NUM_QUEUES)) {
 		IA_CSS_LEAVE_ERR(-EINVAL);
 		return -EINVAL;
 	}
@@ -3689,7 +3725,7 @@ ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
 
 		/* Validate the ddr_buffer_addr and buf_type */
 		hmm_buffer_record = sh_css_hmm_buffer_record_validate(
-		    ddr_buffer_addr, buf_type);
+			ddr_buffer_addr, buf_type);
 		if (hmm_buffer_record) {
 			/*
 			 * valid hmm_buffer_record found. Save the kernel_ptr
@@ -3697,17 +3733,18 @@ ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
 			 * vbuf handle and buffer_record can be released.
 			 */
 			kernel_ptr = hmm_buffer_record->kernel_ptr;
-			ia_css_rmgr_rel_vbuf(hmm_buffer_pool, &hmm_buffer_record->h_vbuf);
+			ia_css_rmgr_rel_vbuf(hmm_buffer_pool,
+					     &hmm_buffer_record->h_vbuf);
 			sh_css_hmm_buffer_record_reset(hmm_buffer_record);
 		} else {
-			IA_CSS_ERROR("hmm_buffer_record not found (0x%x) buf_type(%d)",
-				     ddr_buffer_addr, buf_type);
+			IA_CSS_ERROR(
+				"hmm_buffer_record not found (0x%x) buf_type(%d)",
+				ddr_buffer_addr, buf_type);
 			IA_CSS_LEAVE_ERR(-EINVAL);
 			return -EINVAL;
 		}
 
-		hmm_load(ddr_buffer_addr,
-			 &ddr_buffer,
+		hmm_load(ddr_buffer_addr, &ddr_buffer,
 			 sizeof(struct sh_css_hmm_buffer));
 
 		/*
@@ -3718,7 +3755,8 @@ ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
 		    (kernel_ptr != HOST_ADDRESS(ddr_buffer.kernel_ptr))) {
 			IA_CSS_ERROR("kernel_ptr invalid");
 			IA_CSS_ERROR("expected: (0x%llx)", (u64)kernel_ptr);
-			IA_CSS_ERROR("actual: (0x%llx)", (u64)HOST_ADDRESS(ddr_buffer.kernel_ptr));
+			IA_CSS_ERROR("actual: (0x%llx)",
+				     (u64)HOST_ADDRESS(ddr_buffer.kernel_ptr));
 			IA_CSS_ERROR("buf_type: %d\n", buf_type);
 			IA_CSS_LEAVE_ERR(-EINVAL);
 			return -EINVAL;
@@ -3736,7 +3774,8 @@ ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
 
 			if (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME ||
 			    buf_type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME) {
-				buffer->isys_eof_clock_tick.ticks = ddr_buffer.isys_eof_clock_tick;
+				buffer->isys_eof_clock_tick.ticks =
+					ddr_buffer.isys_eof_clock_tick;
 			}
 
 			switch (buf_type) {
@@ -3750,10 +3789,13 @@ ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
 						 * system for 2401 it is done in
 						 * ia_css_stream_destroy call
 						 */
-						return_err = free_mipi_frames(pipe);
+						return_err =
+							free_mipi_frames(pipe);
 						if (return_err) {
-							IA_CSS_LOG("free_mipi_frames() failed");
-							IA_CSS_LEAVE_ERR(return_err);
+							IA_CSS_LOG(
+								"free_mipi_frames() failed");
+							IA_CSS_LEAVE_ERR(
+								return_err);
 							return return_err;
 						}
 					}
@@ -3762,53 +3804,73 @@ ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
 				fallthrough;
 			case IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
 			case IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME:
-				frame = (struct ia_css_frame *)HOST_ADDRESS(ddr_buffer.kernel_ptr);
+				frame = (struct ia_css_frame *)HOST_ADDRESS(
+					ddr_buffer.kernel_ptr);
 				buffer->data.frame = frame;
-				buffer->exp_id = ddr_buffer.payload.frame.exp_id;
+				buffer->exp_id =
+					ddr_buffer.payload.frame.exp_id;
 				frame->exp_id = ddr_buffer.payload.frame.exp_id;
-				frame->isp_config_id = ddr_buffer.payload.frame.isp_parameters_id;
+				frame->isp_config_id =
+					ddr_buffer.payload.frame
+						.isp_parameters_id;
 				frame->valid = pipe->num_invalid_frames == 0;
 				if (!frame->valid)
 					pipe->num_invalid_frames--;
 
-				if (frame->frame_info.format == IA_CSS_FRAME_FORMAT_BINARY_8) {
+				if (frame->frame_info.format ==
+				    IA_CSS_FRAME_FORMAT_BINARY_8) {
 					if (IS_ISP2401)
-						frame->planes.binary.size = frame->data_bytes;
+						frame->planes.binary.size =
+							frame->data_bytes;
 					else
 						frame->planes.binary.size =
-						    sh_css_sp_get_binary_copy_size();
+							sh_css_sp_get_binary_copy_size();
 				}
-				if (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME) {
-					IA_CSS_LOG("pfp: dequeued OF %d with config id %d thread %d",
-						   frame->data, frame->isp_config_id, thread_id);
+				if (buf_type ==
+				    IA_CSS_BUFFER_TYPE_OUTPUT_FRAME) {
+					IA_CSS_LOG(
+						"pfp: dequeued OF %d with config id %d thread %d",
+						frame->data,
+						frame->isp_config_id,
+						thread_id);
 				}
 
-				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-						    "ia_css_pipe_dequeue_buffer() buf_type=%d, data(DDR address)=0x%x\n",
-						    buf_type, buffer->data.frame->data);
+				ia_css_debug_dtrace(
+					IA_CSS_DEBUG_TRACE,
+					"ia_css_pipe_dequeue_buffer() buf_type=%d, data(DDR address)=0x%x\n",
+					buf_type, buffer->data.frame->data);
 
 				break;
 			case IA_CSS_BUFFER_TYPE_3A_STATISTICS:
 				buffer->data.stats_3a =
-				    (struct ia_css_isp_3a_statistics *)HOST_ADDRESS(ddr_buffer.kernel_ptr);
+					(struct ia_css_isp_3a_statistics *)
+						HOST_ADDRESS(
+							ddr_buffer.kernel_ptr);
 				buffer->exp_id = ddr_buffer.payload.s3a.exp_id;
-				buffer->data.stats_3a->exp_id = ddr_buffer.payload.s3a.exp_id;
-				buffer->data.stats_3a->isp_config_id = ddr_buffer.payload.s3a.isp_config_id;
+				buffer->data.stats_3a->exp_id =
+					ddr_buffer.payload.s3a.exp_id;
+				buffer->data.stats_3a->isp_config_id =
+					ddr_buffer.payload.s3a.isp_config_id;
 				break;
 			case IA_CSS_BUFFER_TYPE_DIS_STATISTICS:
 				buffer->data.stats_dvs =
-				    (struct ia_css_isp_dvs_statistics *)
-				    HOST_ADDRESS(ddr_buffer.kernel_ptr);
+					(struct ia_css_isp_dvs_statistics *)
+						HOST_ADDRESS(
+							ddr_buffer.kernel_ptr);
 				buffer->exp_id = ddr_buffer.payload.dis.exp_id;
-				buffer->data.stats_dvs->exp_id = ddr_buffer.payload.dis.exp_id;
+				buffer->data.stats_dvs->exp_id =
+					ddr_buffer.payload.dis.exp_id;
 				break;
 			case IA_CSS_BUFFER_TYPE_LACE_STATISTICS:
 				break;
 			case IA_CSS_BUFFER_TYPE_METADATA:
 				buffer->data.metadata =
-				    (struct ia_css_metadata *)HOST_ADDRESS(ddr_buffer.kernel_ptr);
-				buffer->exp_id = ddr_buffer.payload.metadata.exp_id;
-				buffer->data.metadata->exp_id = ddr_buffer.payload.metadata.exp_id;
+					(struct ia_css_metadata *)HOST_ADDRESS(
+						ddr_buffer.kernel_ptr);
+				buffer->exp_id =
+					ddr_buffer.payload.metadata.exp_id;
+				buffer->data.metadata->exp_id =
+					ddr_buffer.payload.metadata.exp_id;
 				break;
 			default:
 				return_err = -EINVAL;
@@ -3829,10 +3891,7 @@ ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
 			return -EBUSY;
 		}
 		ia_css_bufq_enqueue_psys_event(
-		    IA_CSS_PSYS_SW_EVENT_BUFFER_DEQUEUED,
-		    0,
-		    queue_id,
-		    0);
+			IA_CSS_PSYS_SW_EVENT_BUFFER_DEQUEUED, 0, queue_id, 0);
 	}
 	IA_CSS_LEAVE("buffer=%p", buffer);
 
@@ -3850,30 +3909,29 @@ ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
  * 4) "enum ia_css_event_type convert_event_sp_to_host_domain"	(sh_css.c)
  */
 static enum ia_css_event_type convert_event_sp_to_host_domain[] = {
-	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE,	/* Output frame ready. */
-	IA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE,	/* Second output frame ready. */
-	IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE,	/* Viewfinder Output frame ready. */
-	IA_CSS_EVENT_TYPE_SECOND_VF_OUTPUT_FRAME_DONE,	/* Second viewfinder Output frame ready. */
-	IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE,	/* Indication that 3A statistics are available. */
-	IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE,	/* Indication that DIS statistics are available. */
-	IA_CSS_EVENT_TYPE_PIPELINE_DONE,	/* Pipeline Done event, sent after last pipeline stage. */
-	IA_CSS_EVENT_TYPE_FRAME_TAGGED,		/* Frame tagged. */
-	IA_CSS_EVENT_TYPE_INPUT_FRAME_DONE,	/* Input frame ready. */
-	IA_CSS_EVENT_TYPE_METADATA_DONE,	/* Metadata ready. */
-	IA_CSS_EVENT_TYPE_LACE_STATISTICS_DONE,	/* Indication that LACE statistics are available. */
-	IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE,	/* Extension stage executed. */
-	IA_CSS_EVENT_TYPE_TIMER,		/* Timing measurement data. */
-	IA_CSS_EVENT_TYPE_PORT_EOF,		/* End Of Frame event, sent when in buffered sensor mode. */
-	IA_CSS_EVENT_TYPE_FW_WARNING,		/* Performance warning encountered by FW */
-	IA_CSS_EVENT_TYPE_FW_ASSERT,		/* Assertion hit by FW */
-	0,					/* error if sp passes  SH_CSS_SP_EVENT_NR_OF_TYPES as a valid event. */
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE, /* Output frame ready. */
+	IA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE, /* Second output frame ready. */
+	IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE, /* Viewfinder Output frame ready. */
+	IA_CSS_EVENT_TYPE_SECOND_VF_OUTPUT_FRAME_DONE, /* Second viewfinder Output frame ready. */
+	IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE, /* Indication that 3A statistics are available. */
+	IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE, /* Indication that DIS statistics are available. */
+	IA_CSS_EVENT_TYPE_PIPELINE_DONE, /* Pipeline Done event, sent after last pipeline stage. */
+	IA_CSS_EVENT_TYPE_FRAME_TAGGED, /* Frame tagged. */
+	IA_CSS_EVENT_TYPE_INPUT_FRAME_DONE, /* Input frame ready. */
+	IA_CSS_EVENT_TYPE_METADATA_DONE, /* Metadata ready. */
+	IA_CSS_EVENT_TYPE_LACE_STATISTICS_DONE, /* Indication that LACE statistics are available. */
+	IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE, /* Extension stage executed. */
+	IA_CSS_EVENT_TYPE_TIMER, /* Timing measurement data. */
+	IA_CSS_EVENT_TYPE_PORT_EOF, /* End Of Frame event, sent when in buffered sensor mode. */
+	IA_CSS_EVENT_TYPE_FW_WARNING, /* Performance warning encountered by FW */
+	IA_CSS_EVENT_TYPE_FW_ASSERT, /* Assertion hit by FW */
+	0, /* error if sp passes  SH_CSS_SP_EVENT_NR_OF_TYPES as a valid event. */
 };
 
-int
-ia_css_dequeue_psys_event(struct ia_css_event *event)
+int ia_css_dequeue_psys_event(struct ia_css_event *event)
 {
 	enum ia_css_pipe_id pipe_id = 0;
-	u8 payload[4] = {0, 0, 0, 0};
+	u8 payload[4] = { 0, 0, 0, 0 };
 	int ret_err;
 
 	/*
@@ -3900,8 +3958,8 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 	IA_CSS_LOG("event dequeued from psys event queue");
 
 	/* Tell the SP that we dequeued an event from the event queue. */
-	ia_css_bufq_enqueue_psys_event(
-	    IA_CSS_PSYS_SW_EVENT_EVENT_DEQUEUED, 0, 0, 0);
+	ia_css_bufq_enqueue_psys_event(IA_CSS_PSYS_SW_EVENT_EVENT_DEQUEUED, 0,
+				       0, 0);
 
 	/*
 	 * Events are decoded into 4 bytes of payload, the first byte
@@ -3926,7 +3984,8 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 		 */
 		u32 tmp_data;
 		/* 1st event: LSB 16-bit timer data and code */
-		event->timer_data = ((payload[1] & 0xFF) | ((payload[3] & 0xFF) << 8));
+		event->timer_data =
+			((payload[1] & 0xFF) | ((payload[3] & 0xFF) << 8));
 		event->timer_code = payload[2];
 		payload[0] = payload[1] = payload[2] = payload[3] = 0;
 		ret_err = ia_css_bufq_dequeue_psys_event(payload);
@@ -3936,16 +3995,18 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 			 * Putting IA_CSS_ERROR is resulting in failures in
 			 * Merrifield smoke testing
 			 */
-			IA_CSS_WARNING("Timer: Error de-queuing the 2nd TIMER event!!!\n");
+			IA_CSS_WARNING(
+				"Timer: Error de-queuing the 2nd TIMER event!!!\n");
 			return ret_err;
 		}
 		ia_css_bufq_enqueue_psys_event(
-		    IA_CSS_PSYS_SW_EVENT_EVENT_DEQUEUED, 0, 0, 0);
+			IA_CSS_PSYS_SW_EVENT_EVENT_DEQUEUED, 0, 0, 0);
 		event->type = convert_event_sp_to_host_domain[payload[0]];
 		/* It's a timer */
 		if (event->type == IA_CSS_EVENT_TYPE_TIMER) {
 			/* 2nd event data: MSB 16-bit timer and subcode */
-			tmp_data = ((payload[1] & 0xFF) | ((payload[3] & 0xFF) << 8));
+			tmp_data = ((payload[1] & 0xFF) |
+				    ((payload[3] & 0xFF) << 8));
 			event->timer_data |= (tmp_data << 16);
 			event->timer_subcode = payload[2];
 		} else {
@@ -3961,7 +4022,8 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 			event->timer_data = 0;
 			event->timer_code = 0;
 			event->timer_subcode = 0;
-			IA_CSS_ERROR("Missing 2nd timer event. Timer event discarded");
+			IA_CSS_ERROR(
+				"Missing 2nd timer event. Timer event discarded");
 		}
 	}
 	if (event->type == IA_CSS_EVENT_TYPE_PORT_EOF) {
@@ -3996,8 +4058,9 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 			n = event->pipe->stream->num_pipes;
 			for (i = 0; i < n; i++) {
 				struct ia_css_pipe *p =
-					    event->pipe->stream->pipes[i];
-				if (p->config.mode == IA_CSS_PIPE_MODE_CAPTURE) {
+					event->pipe->stream->pipes[i];
+				if (p->config.mode ==
+				    IA_CSS_PIPE_MODE_CAPTURE) {
 					event->pipe = p;
 					break;
 				}
@@ -4009,12 +4072,12 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 			u32 stage_num = (uint32_t)payload[3];
 
 			ret_err = ia_css_pipeline_get_fw_from_stage(
-				      &event->pipe->pipeline,
-				      stage_num,
-				      &event->fw_handle);
+				&event->pipe->pipeline, stage_num,
+				&event->fw_handle);
 			if (ret_err) {
-				IA_CSS_ERROR("Invalid stage num received for ACC event. stage_num:%u",
-					     stage_num);
+				IA_CSS_ERROR(
+					"Invalid stage num received for ACC event. stage_num:%u",
+					stage_num);
 				return ret_err;
 			}
 		}
@@ -4028,10 +4091,9 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 	return 0;
 }
 
-int
-ia_css_dequeue_isys_event(struct ia_css_event *event)
+int ia_css_dequeue_isys_event(struct ia_css_event *event)
 {
-	u8 payload[4] = {0, 0, 0, 0};
+	u8 payload[4] = { 0, 0, 0, 0 };
 	int err = 0;
 
 	/*
@@ -4066,8 +4128,7 @@ ia_css_dequeue_isys_event(struct ia_css_event *event)
 	return err;
 }
 
-static int
-sh_css_pipe_start(struct ia_css_stream *stream)
+static int sh_css_pipe_start(struct ia_css_stream *stream)
 {
 	int err = 0;
 
@@ -4117,7 +4178,7 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 	if (!stream->config.continuous) {
 		int i;
 
-		for (i = 1; i < stream->num_pipes && 0 == err ; i++) {
+		for (i = 1; i < stream->num_pipes && 0 == err; i++) {
 			switch (stream->pipes[i]->mode) {
 			case IA_CSS_PIPE_ID_PREVIEW:
 				stream->pipes[i]->stop_requested = false;
@@ -4153,8 +4214,8 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 	 */
 	if (!copy_on_sp(pipe)) {
 		sh_css_invalidate_params(stream);
-		err = sh_css_param_update_isp_params(pipe,
-						     stream->isp_params_configs, true, NULL);
+		err = sh_css_param_update_isp_params(
+			pipe, stream->isp_params_configs, true, NULL);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
@@ -4163,7 +4224,8 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 
 	ia_css_debug_pipe_graph_dump_epilogue();
 
-	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe),
+					 &thread_id);
 
 	if (!sh_css_sp_is_running()) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EBUSY);
@@ -4179,11 +4241,11 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 
 		for (i = 1; i < stream->num_pipes; i++) {
 			ia_css_pipeline_get_sp_thread_id(
-			    ia_css_pipe_get_pipe_num(stream->pipes[i]),
-			    &thread_id);
+				ia_css_pipe_get_pipe_num(stream->pipes[i]),
+				&thread_id);
 			ia_css_bufq_enqueue_psys_event(
-			    IA_CSS_PSYS_SW_EVENT_START_STREAM,
-			    (uint8_t)thread_id, 0, 0);
+				IA_CSS_PSYS_SW_EVENT_START_STREAM,
+				(uint8_t)thread_id, 0, 0);
 		}
 	}
 
@@ -4200,12 +4262,12 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 			IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
 			return -EINVAL;
 		}
-		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(copy_pipe),
-						 &thread_id);
+		ia_css_pipeline_get_sp_thread_id(
+			ia_css_pipe_get_pipe_num(copy_pipe), &thread_id);
 		/* by the time we reach here q is initialized and handle is available.*/
 		ia_css_bufq_enqueue_psys_event(
-		    IA_CSS_PSYS_SW_EVENT_START_STREAM,
-		    (uint8_t)thread_id, 0,  0);
+			IA_CSS_PSYS_SW_EVENT_START_STREAM, (uint8_t)thread_id,
+			0, 0);
 	}
 	if (pipe->stream->cont_capt) {
 		struct ia_css_pipe *capture_pipe = NULL;
@@ -4219,12 +4281,12 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 			IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
 			return -EINVAL;
 		}
-		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(capture_pipe),
-						 &thread_id);
+		ia_css_pipeline_get_sp_thread_id(
+			ia_css_pipe_get_pipe_num(capture_pipe), &thread_id);
 		/* by the time we reach here q is initialized and handle is available.*/
 		ia_css_bufq_enqueue_psys_event(
-		    IA_CSS_PSYS_SW_EVENT_START_STREAM,
-		    (uint8_t)thread_id, 0,  0);
+			IA_CSS_PSYS_SW_EVENT_START_STREAM, (uint8_t)thread_id,
+			0, 0);
 	}
 
 	stream->started = true;
@@ -4234,23 +4296,24 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 }
 
 /* ISP2400 */
-void
-sh_css_enable_cont_capt(bool enable, bool stop_copy_preview)
+void sh_css_enable_cont_capt(bool enable, bool stop_copy_preview)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "sh_css_enable_cont_capt() enter: enable=%d\n", enable);
-//my_css.cont_capt = enable;
+			    "sh_css_enable_cont_capt() enter: enable=%d\n",
+			    enable);
+	//my_css.cont_capt = enable;
 	my_css.stop_copy_preview = stop_copy_preview;
 }
 
-bool
-sh_css_continuous_is_enabled(uint8_t pipe_num)
+bool sh_css_continuous_is_enabled(uint8_t pipe_num)
 {
 	struct ia_css_pipe *pipe;
 	bool continuous;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "sh_css_continuous_is_enabled() enter: pipe_num=%d\n", pipe_num);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"sh_css_continuous_is_enabled() enter: pipe_num=%d\n",
+		pipe_num);
 
 	pipe = find_pipe_by_num(pipe_num);
 	continuous = pipe && pipe->stream->config.continuous;
@@ -4261,22 +4324,26 @@ sh_css_continuous_is_enabled(uint8_t pipe_num)
 }
 
 /* ISP2400 */
-int
-ia_css_stream_get_max_buffer_depth(struct ia_css_stream *stream,
-				   int *buffer_depth)
+int ia_css_stream_get_max_buffer_depth(struct ia_css_stream *stream,
+				       int *buffer_depth)
 {
 	if (!buffer_depth)
 		return -EINVAL;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_get_max_buffer_depth() enter: void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_get_max_buffer_depth() enter: void\n");
 	(void)stream;
 	*buffer_depth = NUM_CONTINUOUS_FRAMES;
 	return 0;
 }
 
-int
-ia_css_stream_set_buffer_depth(struct ia_css_stream *stream, int buffer_depth)
+int ia_css_stream_set_buffer_depth(struct ia_css_stream *stream,
+				   int buffer_depth)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_set_buffer_depth() enter: num_frames=%d\n", buffer_depth);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_set_buffer_depth() enter: num_frames=%d\n",
+		buffer_depth);
 	(void)stream;
 	if (buffer_depth > NUM_CONTINUOUS_FRAMES || buffer_depth < 1)
 		return -EINVAL;
@@ -4287,41 +4354,41 @@ ia_css_stream_set_buffer_depth(struct ia_css_stream *stream, int buffer_depth)
 }
 
 /* ISP2401 */
-int
-ia_css_stream_get_buffer_depth(struct ia_css_stream *stream,
-			       int *buffer_depth)
+int ia_css_stream_get_buffer_depth(struct ia_css_stream *stream,
+				   int *buffer_depth)
 {
 	if (!buffer_depth)
 		return -EINVAL;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_get_buffer_depth() enter: void\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_stream_get_buffer_depth() enter: void\n");
 	(void)stream;
 	*buffer_depth = stream->config.target_num_cont_raw_buf;
 	return 0;
 }
 
-unsigned int
-sh_css_get_mipi_sizes_for_check(const unsigned int port, const unsigned int idx)
+unsigned int sh_css_get_mipi_sizes_for_check(const unsigned int port,
+					     const unsigned int idx)
 {
 	OP___assert(port < N_CSI_PORTS);
-	OP___assert(idx  < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "sh_css_get_mipi_sizes_for_check(port %d, idx %d): %d\n",
-			    port, idx, my_css.mipi_sizes_for_check[port][idx]);
+	OP___assert(idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_get_mipi_sizes_for_check(port %d, idx %d): %d\n", port,
+		idx, my_css.mipi_sizes_for_check[port][idx]);
 	return my_css.mipi_sizes_for_check[port][idx];
 }
 
-static int sh_css_pipe_configure_output(
-    struct ia_css_pipe *pipe,
-    unsigned int width,
-    unsigned int height,
-    unsigned int padded_width,
-    enum ia_css_frame_format format,
-    unsigned int idx)
+static int sh_css_pipe_configure_output(struct ia_css_pipe *pipe,
+					unsigned int width, unsigned int height,
+					unsigned int padded_width,
+					enum ia_css_frame_format format,
+					unsigned int idx)
 {
 	int err = 0;
 
-	IA_CSS_ENTER_PRIVATE("pipe = %p, width = %d, height = %d, padded width = %d, format = %d, idx = %d",
-			     pipe, width, height, padded_width, format, idx);
+	IA_CSS_ENTER_PRIVATE(
+		"pipe = %p, width = %d, height = %d, padded width = %d, format = %d, idx = %d",
+		pipe, width, height, padded_width, format, idx);
 	if (!pipe) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
 		return -EINVAL;
@@ -4335,12 +4402,8 @@ static int sh_css_pipe_configure_output(
 	if (pipe->output_info[idx].res.width != width ||
 	    pipe->output_info[idx].res.height != height ||
 	    pipe->output_info[idx].format != format) {
-		ia_css_frame_info_init(
-		    &pipe->output_info[idx],
-		    width,
-		    height,
-		    format,
-		    padded_width);
+		ia_css_frame_info_init(&pipe->output_info[idx], width, height,
+				       format, padded_width);
 	}
 	IA_CSS_LEAVE_ERR_PRIVATE(0);
 	return 0;
@@ -4360,11 +4423,12 @@ sh_css_pipe_get_shading_info(struct ia_css_pipe *pipe,
 	binary = ia_css_pipe_get_shading_correction_binary(pipe);
 
 	if (binary) {
-		err = ia_css_binary_get_shading_info(binary,
-						     IA_CSS_SHADING_CORRECTION_TYPE_1,
-						     pipe->required_bds_factor,
-						     (const struct ia_css_stream_config *)&pipe->stream->config,
-						     shading_info, pipe_config);
+		err = ia_css_binary_get_shading_info(
+			binary, IA_CSS_SHADING_CORRECTION_TYPE_1,
+			pipe->required_bds_factor,
+			(const struct ia_css_stream_config *)&pipe->stream
+				->config,
+			shading_info, pipe_config);
 
 		/*
 		 * Other function calls can be added here when other shading
@@ -4382,9 +4446,8 @@ sh_css_pipe_get_shading_info(struct ia_css_pipe *pipe,
 	return err;
 }
 
-static int
-sh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,
-			  struct ia_css_grid_info *info)
+static int sh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,
+				     struct ia_css_grid_info *info)
 {
 	int err = 0;
 	struct ia_css_binary *binary = NULL;
@@ -4412,7 +4475,7 @@ sh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,
 	} else {
 		memset(&info->dvs_grid, 0, sizeof(info->dvs_grid));
 		memset(&info->dvs_grid.dvs_stat_grid_info, 0,
-			   sizeof(info->dvs_grid.dvs_stat_grid_info));
+		       sizeof(info->dvs_grid.dvs_stat_grid_info));
 	}
 
 	if (binary) {
@@ -4433,9 +4496,8 @@ sh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,
  * @brief Check if a format is supported by the pipe.
  *
  */
-static int
-ia_css_pipe_check_format(struct ia_css_pipe *pipe,
-			 enum ia_css_frame_format format)
+static int ia_css_pipe_check_format(struct ia_css_pipe *pipe,
+				    enum ia_css_frame_format format)
 {
 	const enum ia_css_frame_format *supported_formats;
 	int number_of_formats;
@@ -4444,14 +4506,18 @@ ia_css_pipe_check_format(struct ia_css_pipe *pipe,
 
 	IA_CSS_ENTER_PRIVATE("");
 
-	if (NULL == pipe || NULL == pipe->pipe_settings.video.video_binary.info) {
+	if (NULL == pipe ||
+	    NULL == pipe->pipe_settings.video.video_binary.info) {
 		IA_CSS_ERROR("Pipe or binary info is not set");
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
 		return -EINVAL;
 	}
 
-	supported_formats = pipe->pipe_settings.video.video_binary.info->output_formats;
-	number_of_formats = sizeof(pipe->pipe_settings.video.video_binary.info->output_formats) / sizeof(enum ia_css_frame_format);
+	supported_formats =
+		pipe->pipe_settings.video.video_binary.info->output_formats;
+	number_of_formats = sizeof(pipe->pipe_settings.video.video_binary.info
+					   ->output_formats) /
+			    sizeof(enum ia_css_frame_format);
 
 	for (i = 0; i < number_of_formats && !found; i++) {
 		if (supported_formats[i] == format) {
@@ -4470,8 +4536,8 @@ ia_css_pipe_check_format(struct ia_css_pipe *pipe,
 
 static int load_video_binaries(struct ia_css_pipe *pipe)
 {
-	struct ia_css_frame_info video_in_info, tnr_info,
-		       *video_vf_info, video_bds_out_info, *pipe_out_info, *pipe_vf_out_info;
+	struct ia_css_frame_info video_in_info, tnr_info, *video_vf_info,
+		video_bds_out_info, *pipe_out_info, *pipe_vf_out_info;
 	bool online;
 	int err = 0;
 	bool continuous = pipe->stream->config.continuous;
@@ -4482,7 +4548,7 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 	bool vf_res_different_than_output = false;
 	bool need_vf_pp = false;
 	int vf_ds_log2;
-	struct ia_css_video_settings *mycs  = &pipe->pipe_settings.video;
+	struct ia_css_video_settings *mycs = &pipe->pipe_settings.video;
 
 	IA_CSS_ENTER_PRIVATE("");
 	assert(pipe);
@@ -4533,27 +4599,27 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 		video_vf_info = pipe_vf_out_info;
 		vf_res_different_than_output = (video_vf_info->res.width !=
 						video_bin_out_info.res.width) ||
-					       (video_vf_info->res.height != video_bin_out_info.res.height);
+					       (video_vf_info->res.height !=
+						video_bin_out_info.res.height);
 	} else {
 		video_vf_info = NULL;
 	}
 
-	need_scaler = need_downscaling(video_bin_out_info.res, pipe_out_info->res);
+	need_scaler =
+		need_downscaling(video_bin_out_info.res, pipe_out_info->res);
 
 	/* we build up the pipeline starting at the end */
 	/* YUV post-processing if needed */
 	if (need_scaler) {
-		struct ia_css_cas_binary_descr cas_scaler_descr = { };
+		struct ia_css_cas_binary_descr cas_scaler_descr = {};
 
 		/* NV12 is the common format that is supported by both */
 		/* yuv_scaler and the video_xx_isp2_min binaries. */
 		video_bin_out_info.format = IA_CSS_FRAME_FORMAT_NV12;
 
 		err = ia_css_pipe_create_cas_scaler_desc_single_output(
-			  &video_bin_out_info,
-			  pipe_out_info,
-			  NULL,
-			  &cas_scaler_descr);
+			&video_bin_out_info, pipe_out_info, NULL,
+			&cas_scaler_descr);
 		if (err)
 			return err;
 		mycs->num_yuv_scaler = cas_scaler_descr.num_stage;
@@ -4574,12 +4640,14 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 		for (i = 0; i < cas_scaler_descr.num_stage; i++) {
 			struct ia_css_binary_descr yuv_scaler_descr;
 
-			mycs->is_output_stage[i] = cas_scaler_descr.is_output_stage[i];
-			ia_css_pipe_get_yuvscaler_binarydesc(pipe,
-							     &yuv_scaler_descr, &cas_scaler_descr.in_info[i],
-							     &cas_scaler_descr.out_info[i],
-							     &cas_scaler_descr.internal_out_info[i],
-							     &cas_scaler_descr.vf_info[i]);
+			mycs->is_output_stage[i] =
+				cas_scaler_descr.is_output_stage[i];
+			ia_css_pipe_get_yuvscaler_binarydesc(
+				pipe, &yuv_scaler_descr,
+				&cas_scaler_descr.in_info[i],
+				&cas_scaler_descr.out_info[i],
+				&cas_scaler_descr.internal_out_info[i],
+				&cas_scaler_descr.vf_info[i]);
 			err = ia_css_binary_find(&yuv_scaler_descr,
 						 &mycs->yuv_scaler_binary[i]);
 			if (err) {
@@ -4595,10 +4663,10 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 		struct ia_css_binary_descr video_descr;
 		enum ia_css_frame_format vf_info_format;
 
-		err = ia_css_pipe_get_video_binarydesc(pipe,
-						       &video_descr, &video_in_info, &video_bds_out_info, &video_bin_out_info,
-						       video_vf_info,
-						       pipe->stream->config.left_padding);
+		err = ia_css_pipe_get_video_binarydesc(
+			pipe, &video_descr, &video_in_info, &video_bds_out_info,
+			&video_bin_out_info, video_vf_info,
+			pipe->stream->config.left_padding);
 		if (err)
 			return err;
 
@@ -4608,8 +4676,7 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 		 * If success, no vf_pp binary is needed.
 		 * If failed, we will look up video binary with YUV_LINE vf format
 		 */
-		err = ia_css_binary_find(&video_descr,
-					 &mycs->video_binary);
+		err = ia_css_binary_find(&video_descr, &mycs->video_binary);
 
 		if (err) {
 			/* This will do another video binary lookup later for YUV_LINE format*/
@@ -4622,36 +4689,44 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 			 * The first video binary lookup is successful, but we
 			 * may still need vf_pp binary based on additional check
 			 */
-			num_output_pins = mycs->video_binary.info->num_output_pins;
+			num_output_pins =
+				mycs->video_binary.info->num_output_pins;
 			vf_ds_log2 = mycs->video_binary.vf_downscale_log2;
 
 			/*
 			 * If the binary has dual output pins, we need vf_pp
 			 * if the resolution is different.
 			 */
-			need_vf_pp |= ((num_output_pins == 2) && vf_res_different_than_output);
+			need_vf_pp |= ((num_output_pins == 2) &&
+				       vf_res_different_than_output);
 
 			/*
 			 * If the binary has single output pin, we need vf_pp
 			 * if additional scaling is needed for vf
 			 */
-			need_vf_pp |= ((num_output_pins == 1) &&
-				       ((video_vf_info->res.width << vf_ds_log2 != pipe_out_info->res.width) ||
-					(video_vf_info->res.height << vf_ds_log2 != pipe_out_info->res.height)));
+			need_vf_pp |=
+				((num_output_pins == 1) &&
+				 ((video_vf_info->res.width << vf_ds_log2 !=
+				   pipe_out_info->res.width) ||
+				  (video_vf_info->res.height << vf_ds_log2 !=
+				   pipe_out_info->res.height)));
 		}
 
 		if (need_vf_pp) {
 			/* save the current vf_info format for restoration later */
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-					    "load_video_binaries() need_vf_pp; find video binary with YUV_LINE again\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE,
+				"load_video_binaries() need_vf_pp; find video binary with YUV_LINE again\n");
 
 			vf_info_format = video_vf_info->format;
 
 			if (!pipe->config.enable_vfpp_bci)
-				ia_css_frame_info_set_format(video_vf_info,
-							     IA_CSS_FRAME_FORMAT_YUV_LINE);
+				ia_css_frame_info_set_format(
+					video_vf_info,
+					IA_CSS_FRAME_FORMAT_YUV_LINE);
 
-			ia_css_binary_destroy_isp_parameters(&mycs->video_binary);
+			ia_css_binary_destroy_isp_parameters(
+				&mycs->video_binary);
 
 			err = ia_css_binary_find(&video_descr,
 						 &mycs->video_binary);
@@ -4686,9 +4761,10 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 	if (video_vf_info)
 		pipe->num_invalid_frames *= 2;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "load_video_binaries() num_invalid_frames=%d dvs_frame_delay=%d\n",
-			    pipe->num_invalid_frames, pipe->dvs_frame_delay);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"load_video_binaries() num_invalid_frames=%d dvs_frame_delay=%d\n",
+		pipe->num_invalid_frames, pipe->dvs_frame_delay);
 
 	/* pqiao TODO: temp hack for PO, should be removed after offline YUVPP is enabled */
 	if (!IS_ISP2401) {
@@ -4698,8 +4774,7 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 			 * TODO: what exactly needs doing, prepend the copy binary to
 			 *	 video base this only on !online?
 			 */
-			err = load_copy_binary(pipe,
-					       &mycs->copy_binary,
+			err = load_copy_binary(pipe, &mycs->copy_binary,
 					       &mycs->video_binary);
 			if (err)
 				return err;
@@ -4709,11 +4784,12 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] && need_vf_pp) {
 		struct ia_css_binary_descr vf_pp_descr;
 
-		if (mycs->video_binary.vf_frame_info.format
-		    == IA_CSS_FRAME_FORMAT_YUV_LINE) {
-			ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
-							&mycs->video_binary.vf_frame_info,
-							pipe_vf_out_info);
+		if (mycs->video_binary.vf_frame_info.format ==
+		    IA_CSS_FRAME_FORMAT_YUV_LINE) {
+			ia_css_pipe_get_vfpp_binarydesc(
+				pipe, &vf_pp_descr,
+				&mycs->video_binary.vf_frame_info,
+				pipe_vf_out_info);
 		} else {
 			/*
 			 * output from main binary is not yuv line. currently
@@ -4721,13 +4797,13 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 			 * output
 			 */
 			assert(pipe->config.enable_vfpp_bci);
-			ia_css_pipe_get_yuvscaler_binarydesc(pipe, &vf_pp_descr,
-							     &mycs->video_binary.vf_frame_info,
-							     pipe_vf_out_info, NULL, NULL);
+			ia_css_pipe_get_yuvscaler_binarydesc(
+				pipe, &vf_pp_descr,
+				&mycs->video_binary.vf_frame_info,
+				pipe_vf_out_info, NULL, NULL);
 		}
 
-		err = ia_css_binary_find(&vf_pp_descr,
-					 &mycs->vf_pp_binary);
+		err = ia_css_binary_find(&vf_pp_descr, &mycs->vf_pp_binary);
 		if (err)
 			return err;
 	}
@@ -4741,8 +4817,9 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 		tnr_info = mycs->video_binary.out_frame_info[0];
 
 		/* Make tnr reference buffers output block height align */
-		tnr_info.res.height = CEIL_MUL(tnr_info.res.height,
-					       mycs->video_binary.info->sp.block.output_block_height);
+		tnr_info.res.height = CEIL_MUL(
+			tnr_info.res.height,
+			mycs->video_binary.info->sp.block.output_block_height);
 	} else {
 		tnr_info = mycs->video_binary.internal_frame_info;
 	}
@@ -4754,9 +4831,8 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 			ia_css_frame_free(mycs->tnr_frames[i]);
 			mycs->tnr_frames[i] = NULL;
 		}
-		err = ia_css_frame_allocate_from_info(
-			  &mycs->tnr_frames[i],
-			  &tnr_info);
+		err = ia_css_frame_allocate_from_info(&mycs->tnr_frames[i],
+						      &tnr_info);
 		if (err)
 			return err;
 	}
@@ -4764,8 +4840,7 @@ static int load_video_binaries(struct ia_css_pipe *pipe)
 	return 0;
 }
 
-static int
-unload_video_binaries(struct ia_css_pipe *pipe)
+static int unload_video_binaries(struct ia_css_pipe *pipe)
 {
 	unsigned int i;
 
@@ -4780,7 +4855,8 @@ unload_video_binaries(struct ia_css_pipe *pipe)
 	ia_css_binary_unload(&pipe->pipe_settings.video.vf_pp_binary);
 
 	for (i = 0; i < pipe->pipe_settings.video.num_yuv_scaler; i++)
-		ia_css_binary_unload(&pipe->pipe_settings.video.yuv_scaler_binary[i]);
+		ia_css_binary_unload(
+			&pipe->pipe_settings.video.yuv_scaler_binary[i]);
 
 	kfree(pipe->pipe_settings.video.is_output_stage);
 	pipe->pipe_settings.video.is_output_stage = NULL;
@@ -4807,7 +4883,7 @@ static int video_start(struct ia_css_pipe *pipe)
 
 	video_pipe_input_mode = pipe->stream->config.mode;
 
-	copy_pipe    = pipe->pipe_settings.video.copy_pipe;
+	copy_pipe = pipe->pipe_settings.video.copy_pipe;
 	capture_pipe = pipe->pipe_settings.video.capture_pipe;
 
 	sh_css_metrics_start_frame();
@@ -4820,28 +4896,27 @@ static int video_start(struct ia_css_pipe *pipe)
 
 	send_raw_frames(pipe);
 
-	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe),
+					 &thread_id);
 	copy_ovrd = 1 << thread_id;
 
 	if (pipe->stream->cont_capt) {
-		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(capture_pipe),
-						    &thread_id);
+		ia_css_pipeline_get_sp_thread_id(
+			ia_css_pipe_get_pipe_num(capture_pipe), &thread_id);
 		copy_ovrd |= 1 << thread_id;
 	}
 
 	/* Construct and load the copy pipe */
 	if (pipe->stream->config.continuous) {
-		sh_css_sp_init_pipeline(&copy_pipe->pipeline,
-					IA_CSS_PIPE_ID_COPY,
-					(uint8_t)ia_css_pipe_get_pipe_num(copy_pipe),
-					false,
-					pipe->stream->config.pixels_per_clock == 2, false,
-					false, pipe->required_bds_factor,
-					copy_ovrd,
-					pipe->stream->config.mode,
-					&pipe->stream->config.metadata_config,
-					&pipe->stream->info.metadata_info,
-					pipe->stream->config.source.port.port);
+		sh_css_sp_init_pipeline(
+			&copy_pipe->pipeline, IA_CSS_PIPE_ID_COPY,
+			(uint8_t)ia_css_pipe_get_pipe_num(copy_pipe), false,
+			pipe->stream->config.pixels_per_clock == 2, false,
+			false, pipe->required_bds_factor, copy_ovrd,
+			pipe->stream->config.mode,
+			&pipe->stream->config.metadata_config,
+			&pipe->stream->info.metadata_info,
+			pipe->stream->config.source.port.port);
 
 		/*
 		 * make the video pipe start with mem mode input, copy handles
@@ -4852,19 +4927,19 @@ static int video_start(struct ia_css_pipe *pipe)
 
 	/* Construct and load the capture pipe */
 	if (pipe->stream->cont_capt) {
-		sh_css_sp_init_pipeline(&capture_pipe->pipeline,
-					IA_CSS_PIPE_ID_CAPTURE,
-					(uint8_t)ia_css_pipe_get_pipe_num(capture_pipe),
-					capture_pipe->config.default_capture_config.enable_xnr != 0,
-					capture_pipe->stream->config.pixels_per_clock == 2,
-					true, /* continuous */
-					false, /* offline */
-					capture_pipe->required_bds_factor,
-					0,
-					IA_CSS_INPUT_MODE_MEMORY,
-					&pipe->stream->config.metadata_config,
-					&pipe->stream->info.metadata_info,
-					(enum mipi_port_id)0);
+		sh_css_sp_init_pipeline(
+			&capture_pipe->pipeline, IA_CSS_PIPE_ID_CAPTURE,
+			(uint8_t)ia_css_pipe_get_pipe_num(capture_pipe),
+			capture_pipe->config.default_capture_config.enable_xnr !=
+				0,
+			capture_pipe->stream->config.pixels_per_clock == 2,
+			true, /* continuous */
+			false, /* offline */
+			capture_pipe->required_bds_factor, 0,
+			IA_CSS_INPUT_MODE_MEMORY,
+			&pipe->stream->config.metadata_config,
+			&pipe->stream->info.metadata_info,
+			(enum mipi_port_id)0);
 	}
 
 	start_pipe(pipe, copy_ovrd, video_pipe_input_mode);
@@ -4873,22 +4948,23 @@ static int video_start(struct ia_css_pipe *pipe)
 	return err;
 }
 
-static
-int sh_css_pipe_get_viewfinder_frame_info(
-    struct ia_css_pipe *pipe,
-    struct ia_css_frame_info *info,
-    unsigned int idx)
+static int sh_css_pipe_get_viewfinder_frame_info(struct ia_css_pipe *pipe,
+						 struct ia_css_frame_info *info,
+						 unsigned int idx)
 {
 	assert(pipe);
 	assert(info);
 
 	/* We could print the pointer as input arg, and the values as output */
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "sh_css_pipe_get_viewfinder_frame_info() enter: void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_pipe_get_viewfinder_frame_info() enter: void\n");
 
 	if (pipe->mode == IA_CSS_PIPE_ID_CAPTURE &&
-	    (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW ||
-	     pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER))
+	    (pipe->config.default_capture_config.mode ==
+		     IA_CSS_CAPTURE_MODE_RAW ||
+	     pipe->config.default_capture_config.mode ==
+		     IA_CSS_CAPTURE_MODE_BAYER))
 		return -EINVAL;
 	/* offline video does not generate viewfinder output */
 	*info = pipe->vf_output_info[idx];
@@ -4905,16 +4981,18 @@ int sh_css_pipe_get_viewfinder_frame_info(
 	return 0;
 }
 
-static int
-sh_css_pipe_configure_viewfinder(struct ia_css_pipe *pipe, unsigned int width,
-				 unsigned int height, unsigned int min_width,
-				 enum ia_css_frame_format format,
-				 unsigned int idx)
+static int sh_css_pipe_configure_viewfinder(struct ia_css_pipe *pipe,
+					    unsigned int width,
+					    unsigned int height,
+					    unsigned int min_width,
+					    enum ia_css_frame_format format,
+					    unsigned int idx)
 {
 	int err = 0;
 
-	IA_CSS_ENTER_PRIVATE("pipe = %p, width = %d, height = %d, min_width = %d, format = %d, idx = %d\n",
-			     pipe, width, height, min_width, format, idx);
+	IA_CSS_ENTER_PRIVATE(
+		"pipe = %p, width = %d, height = %d, min_width = %d, format = %d, idx = %d\n",
+		pipe, width, height, min_width, format, idx);
 
 	if (!pipe) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
@@ -4929,8 +5007,8 @@ sh_css_pipe_configure_viewfinder(struct ia_css_pipe *pipe, unsigned int width,
 	if (pipe->vf_output_info[idx].res.width != width ||
 	    pipe->vf_output_info[idx].res.height != height ||
 	    pipe->vf_output_info[idx].format != format)
-		ia_css_frame_info_init(&pipe->vf_output_info[idx], width, height,
-				       format, min_width);
+		ia_css_frame_info_init(&pipe->vf_output_info[idx], width,
+				       height, format, min_width);
 
 	IA_CSS_LEAVE_ERR_PRIVATE(0);
 	return 0;
@@ -4956,8 +5034,7 @@ static int load_copy_binaries(struct ia_css_pipe *pipe)
 	if (err)
 		goto ERR;
 
-	err = load_copy_binary(pipe,
-			       &pipe->pipe_settings.capture.copy_binary,
+	err = load_copy_binary(pipe, &pipe->pipe_settings.capture.copy_binary,
 			       NULL);
 
 ERR:
@@ -4965,8 +5042,7 @@ static int load_copy_binaries(struct ia_css_pipe *pipe)
 	return err;
 }
 
-static bool need_capture_pp(
-    const struct ia_css_pipe *pipe)
+static bool need_capture_pp(const struct ia_css_pipe *pipe)
 {
 	const struct ia_css_frame_info *out_info = &pipe->output_info[0];
 
@@ -4996,8 +5072,7 @@ static bool need_capture_pp(
 	return false;
 }
 
-static bool need_capt_ldc(
-    const struct ia_css_pipe *pipe)
+static bool need_capt_ldc(const struct ia_css_pipe *pipe)
 {
 	IA_CSS_ENTER_LEAVE_PRIVATE("");
 	assert(pipe);
@@ -5029,8 +5104,7 @@ static int set_num_primary_stages(unsigned int *num,
 	return err;
 }
 
-static int load_primary_binaries(
-    struct ia_css_pipe *pipe)
+static int load_primary_binaries(struct ia_css_pipe *pipe)
 {
 	bool online = false;
 	bool need_pp = false;
@@ -5038,12 +5112,9 @@ static int load_primary_binaries(
 	bool need_ldc = false;
 	bool sensor = false;
 	bool memory, continuous;
-	struct ia_css_frame_info prim_in_info,
-		       prim_out_info,
-		       capt_pp_out_info, vf_info,
-		       *vf_pp_in_info, *pipe_out_info,
-		       *pipe_vf_out_info, *capt_pp_in_info,
-		       capt_ldc_out_info;
+	struct ia_css_frame_info prim_in_info, prim_out_info, capt_pp_out_info,
+		vf_info, *vf_pp_in_info, *pipe_out_info, *pipe_vf_out_info,
+		*capt_pp_in_info, capt_ldc_out_info;
 	int err = 0;
 	struct ia_css_capture_settings *mycs;
 	unsigned int i;
@@ -5076,7 +5147,8 @@ static int load_primary_binaries(
 	}
 
 	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {
-		err = ia_css_util_check_vf_out_info(pipe_out_info, pipe_vf_out_info);
+		err = ia_css_util_check_vf_out_info(pipe_out_info,
+						    pipe_vf_out_info);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
@@ -5117,21 +5189,20 @@ static int load_primary_binaries(
 	 */
 	capt_pp_out_info = pipe->out_yuv_ds_input_info;
 	capt_pp_out_info.format = IA_CSS_FRAME_FORMAT_YUV420;
-	capt_pp_out_info.res.width  /= MAX_PREFERRED_YUV_DS_PER_STEP;
+	capt_pp_out_info.res.width /= MAX_PREFERRED_YUV_DS_PER_STEP;
 	capt_pp_out_info.res.height /= MAX_PREFERRED_YUV_DS_PER_STEP;
-	ia_css_frame_info_set_width(&capt_pp_out_info, capt_pp_out_info.res.width, 0);
+	ia_css_frame_info_set_width(&capt_pp_out_info,
+				    capt_pp_out_info.res.width, 0);
 
-	need_extra_yuv_scaler = need_downscaling(capt_pp_out_info.res,
-						 pipe_out_info->res);
+	need_extra_yuv_scaler =
+		need_downscaling(capt_pp_out_info.res, pipe_out_info->res);
 
 	if (need_extra_yuv_scaler) {
-		struct ia_css_cas_binary_descr cas_scaler_descr = { };
+		struct ia_css_cas_binary_descr cas_scaler_descr = {};
 
 		err = ia_css_pipe_create_cas_scaler_desc_single_output(
-			  &capt_pp_out_info,
-			  pipe_out_info,
-			  NULL,
-			  &cas_scaler_descr);
+			&capt_pp_out_info, pipe_out_info, NULL,
+			&cas_scaler_descr);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
@@ -5155,12 +5226,14 @@ static int load_primary_binaries(
 		for (i = 0; i < cas_scaler_descr.num_stage; i++) {
 			struct ia_css_binary_descr yuv_scaler_descr;
 
-			mycs->is_output_stage[i] = cas_scaler_descr.is_output_stage[i];
-			ia_css_pipe_get_yuvscaler_binarydesc(pipe,
-							     &yuv_scaler_descr, &cas_scaler_descr.in_info[i],
-							     &cas_scaler_descr.out_info[i],
-							     &cas_scaler_descr.internal_out_info[i],
-							     &cas_scaler_descr.vf_info[i]);
+			mycs->is_output_stage[i] =
+				cas_scaler_descr.is_output_stage[i];
+			ia_css_pipe_get_yuvscaler_binarydesc(
+				pipe, &yuv_scaler_descr,
+				&cas_scaler_descr.in_info[i],
+				&cas_scaler_descr.out_info[i],
+				&cas_scaler_descr.internal_out_info[i],
+				&cas_scaler_descr.vf_info[i]);
 			err = ia_css_binary_find(&yuv_scaler_descr,
 						 &mycs->yuv_scaler_binary[i]);
 			if (err) {
@@ -5182,10 +5255,10 @@ static int load_primary_binaries(
 	if (need_pp) {
 		struct ia_css_binary_descr capture_pp_descr;
 
-		capt_pp_in_info = need_ldc ? &capt_ldc_out_info : &prim_out_info;
+		capt_pp_in_info = need_ldc ? &capt_ldc_out_info :
+					     &prim_out_info;
 
-		ia_css_pipe_get_capturepp_binarydesc(pipe,
-						     &capture_pp_descr,
+		ia_css_pipe_get_capturepp_binarydesc(pipe, &capture_pp_descr,
 						     capt_pp_in_info,
 						     &capt_pp_out_info,
 						     &vf_info);
@@ -5200,8 +5273,7 @@ static int load_primary_binaries(
 		if (need_ldc) {
 			struct ia_css_binary_descr capt_ldc_descr;
 
-			ia_css_pipe_get_ldc_binarydesc(pipe,
-						       &capt_ldc_descr,
+			ia_css_pipe_get_ldc_binarydesc(pipe, &capt_ldc_descr,
 						       &prim_out_info,
 						       &capt_ldc_out_info);
 
@@ -5224,9 +5296,11 @@ static int load_primary_binaries(
 		    (i == mycs->num_primary_stage - 1))
 			local_vf_info = &vf_info;
 		ia_css_pipe_get_primary_binarydesc(pipe, &prim_descr[i],
-						   &prim_in_info, &prim_out_info,
+						   &prim_in_info,
+						   &prim_out_info,
 						   local_vf_info, i);
-		err = ia_css_binary_find(&prim_descr[i], &mycs->primary_binary[i]);
+		err = ia_css_binary_find(&prim_descr[i],
+					 &mycs->primary_binary[i]);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
@@ -5237,7 +5311,9 @@ static int load_primary_binaries(
 	if (need_pp)
 		vf_pp_in_info = &mycs->capture_pp_binary.vf_frame_info;
 	else
-		vf_pp_in_info = &mycs->primary_binary[mycs->num_primary_stage - 1].vf_frame_info;
+		vf_pp_in_info =
+			&mycs->primary_binary[mycs->num_primary_stage - 1]
+				 .vf_frame_info;
 
 	/*
 	 * WARNING: The #if def flag has been added below as a
@@ -5252,8 +5328,8 @@ static int load_primary_binaries(
 	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {
 		struct ia_css_binary_descr vf_pp_descr;
 
-		ia_css_pipe_get_vfpp_binarydesc(pipe,
-						&vf_pp_descr, vf_pp_in_info, pipe_vf_out_info);
+		ia_css_pipe_get_vfpp_binarydesc(
+			pipe, &vf_pp_descr, vf_pp_in_info, pipe_vf_out_info);
 		err = ia_css_binary_find(&vf_pp_descr, &mycs->vf_pp_binary);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
@@ -5276,8 +5352,7 @@ static int load_primary_binaries(
 
 	/* ISP Copy */
 	if (need_isp_copy_binary) {
-		err = load_copy_binary(pipe,
-				       &mycs->copy_binary,
+		err = load_copy_binary(pipe, &mycs->copy_binary,
 				       &mycs->primary_binary[0]);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
@@ -5288,8 +5363,7 @@ static int load_primary_binaries(
 	return 0;
 }
 
-static int
-allocate_delay_frames(struct ia_css_pipe *pipe)
+static int allocate_delay_frames(struct ia_css_pipe *pipe)
 {
 	unsigned int num_delay_frames = 0, i = 0;
 	unsigned int dvs_frame_delay = 0;
@@ -5313,13 +5387,14 @@ allocate_delay_frames(struct ia_css_pipe *pipe)
 
 	switch (mode) {
 	case IA_CSS_PIPE_ID_CAPTURE: {
-		struct ia_css_capture_settings *mycs_capture = &pipe->pipe_settings.capture;
+		struct ia_css_capture_settings *mycs_capture =
+			&pipe->pipe_settings.capture;
 		(void)mycs_capture;
 		return err;
-	}
-	break;
+	} break;
 	case IA_CSS_PIPE_ID_VIDEO: {
-		struct ia_css_video_settings *mycs_video = &pipe->pipe_settings.video;
+		struct ia_css_video_settings *mycs_video =
+			&pipe->pipe_settings.video;
 
 		ref_info = mycs_video->video_binary.internal_frame_info;
 
@@ -5335,12 +5410,12 @@ allocate_delay_frames(struct ia_css_pipe *pipe)
 		 *
 		 * TODO: make this ref_frame format as a separate frame format
 		 */
-		ref_info.format        = IA_CSS_FRAME_FORMAT_NV12;
+		ref_info.format = IA_CSS_FRAME_FORMAT_NV12;
 		delay_frames = mycs_video->delay_frames;
-	}
-	break;
+	} break;
 	case IA_CSS_PIPE_ID_PREVIEW: {
-		struct ia_css_preview_settings *mycs_preview = &pipe->pipe_settings.preview;
+		struct ia_css_preview_settings *mycs_preview =
+			&pipe->pipe_settings.preview;
 
 		ref_info = mycs_preview->preview_binary.internal_frame_info;
 
@@ -5356,10 +5431,9 @@ allocate_delay_frames(struct ia_css_pipe *pipe)
 		 *
 		 * TODO: make this ref_frame format as a separate frame format
 		 */
-		ref_info.format        = IA_CSS_FRAME_FORMAT_NV12;
+		ref_info.format = IA_CSS_FRAME_FORMAT_NV12;
 		delay_frames = mycs_preview->delay_frames;
-	}
-	break;
+	} break;
 	default:
 		return -EINVAL;
 	}
@@ -5368,7 +5442,8 @@ allocate_delay_frames(struct ia_css_pipe *pipe)
 
 	assert(num_delay_frames <= MAX_NUM_VIDEO_DELAY_FRAMES);
 	for (i = 0; i < num_delay_frames; i++) {
-		err = ia_css_frame_allocate_from_info(&delay_frames[i],	&ref_info);
+		err = ia_css_frame_allocate_from_info(&delay_frames[i],
+						      &ref_info);
 		if (err)
 			return err;
 	}
@@ -5378,10 +5453,9 @@ allocate_delay_frames(struct ia_css_pipe *pipe)
 
 static int load_advanced_binaries(struct ia_css_pipe *pipe)
 {
-	struct ia_css_frame_info pre_in_info, gdc_in_info,
-			post_in_info, post_out_info,
-			vf_info, *vf_pp_in_info, *pipe_out_info,
-			*pipe_vf_out_info;
+	struct ia_css_frame_info pre_in_info, gdc_in_info, post_in_info,
+		post_out_info, vf_info, *vf_pp_in_info, *pipe_out_info,
+		*pipe_vf_out_info;
 	bool need_pp;
 	bool need_isp_copy = true;
 	int err = 0;
@@ -5402,8 +5476,7 @@ static int load_advanced_binaries(struct ia_css_pipe *pipe)
 		return err;
 	need_pp = need_capture_pp(pipe);
 
-	ia_css_frame_info_set_format(&vf_info,
-				     IA_CSS_FRAME_FORMAT_YUV_LINE);
+	ia_css_frame_info_set_format(&vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);
 
 	/* we build up the pipeline starting at the end */
 	/* Capture post-processing */
@@ -5413,8 +5486,9 @@ static int load_advanced_binaries(struct ia_css_pipe *pipe)
 		ia_css_pipe_get_capturepp_binarydesc(pipe, &capture_pp_descr,
 						     &post_out_info,
 						     pipe_out_info, &vf_info);
-		err = ia_css_binary_find(&capture_pp_descr,
-					 &pipe->pipe_settings.capture.capture_pp_binary);
+		err = ia_css_binary_find(
+			&capture_pp_descr,
+			&pipe->pipe_settings.capture.capture_pp_binary);
 		if (err)
 			return err;
 	} else {
@@ -5428,8 +5502,9 @@ static int load_advanced_binaries(struct ia_css_pipe *pipe)
 		ia_css_pipe_get_post_gdc_binarydesc(pipe, &post_gdc_descr,
 						    &post_in_info,
 						    &post_out_info, &vf_info);
-		err = ia_css_binary_find(&post_gdc_descr,
-					 &pipe->pipe_settings.capture.post_isp_binary);
+		err = ia_css_binary_find(
+			&post_gdc_descr,
+			&pipe->pipe_settings.capture.post_isp_binary);
 		if (err)
 			return err;
 	}
@@ -5438,46 +5513,53 @@ static int load_advanced_binaries(struct ia_css_pipe *pipe)
 	{
 		struct ia_css_binary_descr gdc_descr;
 
-		ia_css_pipe_get_gdc_binarydesc(pipe, &gdc_descr, &gdc_in_info,
-					       &pipe->pipe_settings.capture.post_isp_binary.in_frame_info);
-		err = ia_css_binary_find(&gdc_descr,
-					 &pipe->pipe_settings.capture.anr_gdc_binary);
+		ia_css_pipe_get_gdc_binarydesc(
+			pipe, &gdc_descr, &gdc_in_info,
+			&pipe->pipe_settings.capture.post_isp_binary
+				 .in_frame_info);
+		err = ia_css_binary_find(
+			&gdc_descr,
+			&pipe->pipe_settings.capture.anr_gdc_binary);
 		if (err)
 			return err;
 	}
 	pipe->pipe_settings.capture.anr_gdc_binary.left_padding =
-	    pipe->pipe_settings.capture.post_isp_binary.left_padding;
+		pipe->pipe_settings.capture.post_isp_binary.left_padding;
 
 	/* Pre-gdc */
 	{
 		struct ia_css_binary_descr pre_gdc_descr;
 
-		ia_css_pipe_get_pre_gdc_binarydesc(pipe, &pre_gdc_descr, &pre_in_info,
-						   &pipe->pipe_settings.capture.anr_gdc_binary.in_frame_info);
-		err = ia_css_binary_find(&pre_gdc_descr,
-					 &pipe->pipe_settings.capture.pre_isp_binary);
+		ia_css_pipe_get_pre_gdc_binarydesc(
+			pipe, &pre_gdc_descr, &pre_in_info,
+			&pipe->pipe_settings.capture.anr_gdc_binary
+				 .in_frame_info);
+		err = ia_css_binary_find(
+			&pre_gdc_descr,
+			&pipe->pipe_settings.capture.pre_isp_binary);
 		if (err)
 			return err;
 	}
 	pipe->pipe_settings.capture.pre_isp_binary.left_padding =
-	    pipe->pipe_settings.capture.anr_gdc_binary.left_padding;
+		pipe->pipe_settings.capture.anr_gdc_binary.left_padding;
 
 	/* Viewfinder post-processing */
 	if (need_pp) {
-		vf_pp_in_info =
-		    &pipe->pipe_settings.capture.capture_pp_binary.vf_frame_info;
+		vf_pp_in_info = &pipe->pipe_settings.capture.capture_pp_binary
+					 .vf_frame_info;
 	} else {
-		vf_pp_in_info =
-		    &pipe->pipe_settings.capture.post_isp_binary.vf_frame_info;
+		vf_pp_in_info = &pipe->pipe_settings.capture.post_isp_binary
+					 .vf_frame_info;
 	}
 
 	{
 		struct ia_css_binary_descr vf_pp_descr;
 
-		ia_css_pipe_get_vfpp_binarydesc(pipe,
-						&vf_pp_descr, vf_pp_in_info, pipe_vf_out_info);
-		err = ia_css_binary_find(&vf_pp_descr,
-					 &pipe->pipe_settings.capture.vf_pp_binary);
+		ia_css_pipe_get_vfpp_binarydesc(
+			pipe, &vf_pp_descr, vf_pp_in_info, pipe_vf_out_info);
+		err = ia_css_binary_find(
+			&vf_pp_descr,
+			&pipe->pipe_settings.capture.vf_pp_binary);
 		if (err)
 			return err;
 	}
@@ -5485,11 +5567,11 @@ static int load_advanced_binaries(struct ia_css_pipe *pipe)
 	/* Copy */
 	if (IS_ISP2401)
 		/* For CSI2+, only the direct sensor mode/online requires ISP copy */
-		need_isp_copy = pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR;
+		need_isp_copy = pipe->stream->config.mode ==
+				IA_CSS_INPUT_MODE_SENSOR;
 
 	if (need_isp_copy)
-		load_copy_binary(pipe,
-				 &pipe->pipe_settings.capture.copy_binary,
+		load_copy_binary(pipe, &pipe->pipe_settings.capture.copy_binary,
 				 &pipe->pipe_settings.capture.pre_isp_binary);
 
 	return err;
@@ -5514,8 +5596,7 @@ static int load_bayer_isp_binaries(struct ia_css_pipe *pipe)
 	if (err)
 		return err;
 
-	ia_css_pipe_get_pre_de_binarydesc(pipe, &pre_de_descr,
-					  &pre_isp_in_info,
+	ia_css_pipe_get_pre_de_binarydesc(pipe, &pre_de_descr, &pre_isp_in_info,
 					  pipe_out_info);
 
 	err = ia_css_binary_find(&pre_de_descr,
@@ -5526,10 +5607,9 @@ static int load_bayer_isp_binaries(struct ia_css_pipe *pipe)
 
 static int load_low_light_binaries(struct ia_css_pipe *pipe)
 {
-	struct ia_css_frame_info pre_in_info, anr_in_info,
-			post_in_info, post_out_info,
-			vf_info, *pipe_vf_out_info, *pipe_out_info,
-			*vf_pp_in_info;
+	struct ia_css_frame_info pre_in_info, anr_in_info, post_in_info,
+		post_out_info, vf_info, *pipe_vf_out_info, *pipe_out_info,
+		*vf_pp_in_info;
 	bool need_pp;
 	bool need_isp_copy = true;
 	int err = 0;
@@ -5545,14 +5625,12 @@ static int load_low_light_binaries(struct ia_css_pipe *pipe)
 	pipe_out_info = &pipe->output_info[0];
 
 	vf_info = *pipe_vf_out_info;
-	err = ia_css_util_check_vf_out_info(pipe_out_info,
-					    &vf_info);
+	err = ia_css_util_check_vf_out_info(pipe_out_info, &vf_info);
 	if (err)
 		return err;
 	need_pp = need_capture_pp(pipe);
 
-	ia_css_frame_info_set_format(&vf_info,
-				     IA_CSS_FRAME_FORMAT_YUV_LINE);
+	ia_css_frame_info_set_format(&vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);
 
 	/* we build up the pipeline starting at the end */
 	/* Capture post-processing */
@@ -5562,8 +5640,9 @@ static int load_low_light_binaries(struct ia_css_pipe *pipe)
 		ia_css_pipe_get_capturepp_binarydesc(pipe, &capture_pp_descr,
 						     &post_out_info,
 						     pipe_out_info, &vf_info);
-		err = ia_css_binary_find(&capture_pp_descr,
-					 &pipe->pipe_settings.capture.capture_pp_binary);
+		err = ia_css_binary_find(
+			&capture_pp_descr,
+			&pipe->pipe_settings.capture.capture_pp_binary);
 		if (err)
 			return err;
 	} else {
@@ -5574,10 +5653,12 @@ static int load_low_light_binaries(struct ia_css_pipe *pipe)
 	{
 		struct ia_css_binary_descr post_anr_descr;
 
-		ia_css_pipe_get_post_anr_binarydesc(pipe,
-						    &post_anr_descr, &post_in_info, &post_out_info, &vf_info);
-		err = ia_css_binary_find(&post_anr_descr,
-					 &pipe->pipe_settings.capture.post_isp_binary);
+		ia_css_pipe_get_post_anr_binarydesc(pipe, &post_anr_descr,
+						    &post_in_info,
+						    &post_out_info, &vf_info);
+		err = ia_css_binary_find(
+			&post_anr_descr,
+			&pipe->pipe_settings.capture.post_isp_binary);
 		if (err)
 			return err;
 	}
@@ -5586,46 +5667,53 @@ static int load_low_light_binaries(struct ia_css_pipe *pipe)
 	{
 		struct ia_css_binary_descr anr_descr;
 
-		ia_css_pipe_get_anr_binarydesc(pipe, &anr_descr, &anr_in_info,
-					       &pipe->pipe_settings.capture.post_isp_binary.in_frame_info);
-		err = ia_css_binary_find(&anr_descr,
-					 &pipe->pipe_settings.capture.anr_gdc_binary);
+		ia_css_pipe_get_anr_binarydesc(
+			pipe, &anr_descr, &anr_in_info,
+			&pipe->pipe_settings.capture.post_isp_binary
+				 .in_frame_info);
+		err = ia_css_binary_find(
+			&anr_descr,
+			&pipe->pipe_settings.capture.anr_gdc_binary);
 		if (err)
 			return err;
 	}
 	pipe->pipe_settings.capture.anr_gdc_binary.left_padding =
-	    pipe->pipe_settings.capture.post_isp_binary.left_padding;
+		pipe->pipe_settings.capture.post_isp_binary.left_padding;
 
 	/* Pre-anr */
 	{
 		struct ia_css_binary_descr pre_anr_descr;
 
-		ia_css_pipe_get_pre_anr_binarydesc(pipe, &pre_anr_descr, &pre_in_info,
-						   &pipe->pipe_settings.capture.anr_gdc_binary.in_frame_info);
-		err = ia_css_binary_find(&pre_anr_descr,
-					 &pipe->pipe_settings.capture.pre_isp_binary);
+		ia_css_pipe_get_pre_anr_binarydesc(
+			pipe, &pre_anr_descr, &pre_in_info,
+			&pipe->pipe_settings.capture.anr_gdc_binary
+				 .in_frame_info);
+		err = ia_css_binary_find(
+			&pre_anr_descr,
+			&pipe->pipe_settings.capture.pre_isp_binary);
 		if (err)
 			return err;
 	}
 	pipe->pipe_settings.capture.pre_isp_binary.left_padding =
-	    pipe->pipe_settings.capture.anr_gdc_binary.left_padding;
+		pipe->pipe_settings.capture.anr_gdc_binary.left_padding;
 
 	/* Viewfinder post-processing */
 	if (need_pp) {
-		vf_pp_in_info =
-		    &pipe->pipe_settings.capture.capture_pp_binary.vf_frame_info;
+		vf_pp_in_info = &pipe->pipe_settings.capture.capture_pp_binary
+					 .vf_frame_info;
 	} else {
-		vf_pp_in_info =
-		    &pipe->pipe_settings.capture.post_isp_binary.vf_frame_info;
+		vf_pp_in_info = &pipe->pipe_settings.capture.post_isp_binary
+					 .vf_frame_info;
 	}
 
 	{
 		struct ia_css_binary_descr vf_pp_descr;
 
-		ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
-						vf_pp_in_info, pipe_vf_out_info);
-		err = ia_css_binary_find(&vf_pp_descr,
-					 &pipe->pipe_settings.capture.vf_pp_binary);
+		ia_css_pipe_get_vfpp_binarydesc(
+			pipe, &vf_pp_descr, vf_pp_in_info, pipe_vf_out_info);
+		err = ia_css_binary_find(
+			&vf_pp_descr,
+			&pipe->pipe_settings.capture.vf_pp_binary);
 		if (err)
 			return err;
 	}
@@ -5633,12 +5721,13 @@ static int load_low_light_binaries(struct ia_css_pipe *pipe)
 	/* Copy */
 	if (IS_ISP2401)
 		/* For CSI2+, only the direct sensor mode/online requires ISP copy */
-		need_isp_copy = pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR;
+		need_isp_copy = pipe->stream->config.mode ==
+				IA_CSS_INPUT_MODE_SENSOR;
 
 	if (need_isp_copy)
-		err = load_copy_binary(pipe,
-				       &pipe->pipe_settings.capture.copy_binary,
-				       &pipe->pipe_settings.capture.pre_isp_binary);
+		err = load_copy_binary(
+			pipe, &pipe->pipe_settings.capture.copy_binary,
+			&pipe->pipe_settings.capture.pre_isp_binary);
 
 	return err;
 }
@@ -5648,17 +5737,19 @@ static bool copy_on_sp(struct ia_css_pipe *pipe)
 	bool rval;
 
 	assert(pipe);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "copy_on_sp() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "copy_on_sp() enter:\n");
 
 	rval = true;
 
-	rval &=	(pipe->mode == IA_CSS_PIPE_ID_CAPTURE);
+	rval &= (pipe->mode == IA_CSS_PIPE_ID_CAPTURE);
 
-	rval &= (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW);
+	rval &= (pipe->config.default_capture_config.mode ==
+		 IA_CSS_CAPTURE_MODE_RAW);
 
 	rval &= ((pipe->stream->config.input_config.format ==
-		    ATOMISP_INPUT_FORMAT_BINARY_8) ||
-		    (pipe->config.mode == IA_CSS_PIPE_MODE_COPY));
+		  ATOMISP_INPUT_FORMAT_BINARY_8) ||
+		 (pipe->config.mode == IA_CSS_PIPE_MODE_COPY));
 
 	return rval;
 }
@@ -5680,23 +5771,22 @@ static int load_capture_binaries(struct ia_css_pipe *pipe)
 
 	/* in primary, advanced,low light or bayer,
 						the input format must be raw */
-	must_be_raw =
-	    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_ADVANCED ||
-	    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER ||
-	    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT;
-	err = ia_css_util_check_input(&pipe->stream->config, must_be_raw, false);
+	must_be_raw = pipe->config.default_capture_config.mode ==
+			      IA_CSS_CAPTURE_MODE_ADVANCED ||
+		      pipe->config.default_capture_config.mode ==
+			      IA_CSS_CAPTURE_MODE_BAYER ||
+		      pipe->config.default_capture_config.mode ==
+			      IA_CSS_CAPTURE_MODE_LOW_LIGHT;
+	err = ia_css_util_check_input(&pipe->stream->config, must_be_raw,
+				      false);
 	if (err) {
 		IA_CSS_LEAVE_ERR_PRIVATE(err);
 		return err;
 	}
-	if (copy_on_sp(pipe) &&
-	    pipe->stream->config.input_config.format == ATOMISP_INPUT_FORMAT_BINARY_8) {
-		ia_css_frame_info_init(
-		    &pipe->output_info[0],
-		    JPEG_BYTES,
-		    1,
-		    IA_CSS_FRAME_FORMAT_BINARY_8,
-		    0);
+	if (copy_on_sp(pipe) && pipe->stream->config.input_config.format ==
+					ATOMISP_INPUT_FORMAT_BINARY_8) {
+		ia_css_frame_info_init(&pipe->output_info[0], JPEG_BYTES, 1,
+				       IA_CSS_FRAME_FORMAT_BINARY_8, 0);
 		IA_CSS_LEAVE_ERR_PRIVATE(0);
 		return 0;
 	}
@@ -5705,7 +5795,8 @@ static int load_capture_binaries(struct ia_css_pipe *pipe)
 	case IA_CSS_CAPTURE_MODE_RAW:
 		err = load_copy_binaries(pipe);
 		if (!err && IS_ISP2401)
-			pipe->pipe_settings.capture.copy_binary.online = pipe->stream->config.online;
+			pipe->pipe_settings.capture.copy_binary.online =
+				pipe->stream->config.online;
 
 		break;
 	case IA_CSS_CAPTURE_MODE_BAYER:
@@ -5730,8 +5821,7 @@ static int load_capture_binaries(struct ia_css_pipe *pipe)
 	return err;
 }
 
-static int
-unload_capture_binaries(struct ia_css_pipe *pipe)
+static int unload_capture_binaries(struct ia_css_pipe *pipe)
 {
 	unsigned int i;
 
@@ -5744,7 +5834,8 @@ unload_capture_binaries(struct ia_css_pipe *pipe)
 	}
 	ia_css_binary_unload(&pipe->pipe_settings.capture.copy_binary);
 	for (i = 0; i < MAX_NUM_PRIMARY_STAGES; i++)
-		ia_css_binary_unload(&pipe->pipe_settings.capture.primary_binary[i]);
+		ia_css_binary_unload(
+			&pipe->pipe_settings.capture.primary_binary[i]);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.pre_isp_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.anr_gdc_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.post_isp_binary);
@@ -5753,7 +5844,8 @@ unload_capture_binaries(struct ia_css_pipe *pipe)
 	ia_css_binary_unload(&pipe->pipe_settings.capture.vf_pp_binary);
 
 	for (i = 0; i < pipe->pipe_settings.capture.num_yuv_scaler; i++)
-		ia_css_binary_unload(&pipe->pipe_settings.capture.yuv_scaler_binary[i]);
+		ia_css_binary_unload(
+			&pipe->pipe_settings.capture.yuv_scaler_binary[i]);
 
 	kfree(pipe->pipe_settings.capture.is_output_stage);
 	pipe->pipe_settings.capture.is_output_stage = NULL;
@@ -5764,9 +5856,8 @@ unload_capture_binaries(struct ia_css_pipe *pipe)
 	return 0;
 }
 
-static bool
-need_downscaling(const struct ia_css_resolution in_res,
-		 const struct ia_css_resolution out_res)
+static bool need_downscaling(const struct ia_css_resolution in_res,
+			     const struct ia_css_resolution out_res)
 {
 	if (in_res.width > out_res.width || in_res.height > out_res.height)
 		return true;
@@ -5774,8 +5865,7 @@ need_downscaling(const struct ia_css_resolution in_res,
 	return false;
 }
 
-static bool
-need_yuv_scaler_stage(const struct ia_css_pipe *pipe)
+static bool need_yuv_scaler_stage(const struct ia_css_pipe *pipe)
 {
 	unsigned int i;
 	struct ia_css_resolution in_res, out_res;
@@ -5788,9 +5878,10 @@ need_yuv_scaler_stage(const struct ia_css_pipe *pipe)
 
 	/* TODO: make generic function */
 	need_format_conversion =
-	    ((pipe->stream->config.input_config.format ==
-		ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY) &&
-		(pipe->output_info[0].format != IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8));
+		((pipe->stream->config.input_config.format ==
+		  ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY) &&
+		 (pipe->output_info[0].format !=
+		  IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8));
 
 	in_res = pipe->config.input_effective_res;
 
@@ -5817,10 +5908,9 @@ need_yuv_scaler_stage(const struct ia_css_pipe *pipe)
  * Later, merge this with ia_css_pipe_create_cas_scaler_desc
  */
 static int ia_css_pipe_create_cas_scaler_desc_single_output(
-	    struct ia_css_frame_info *in_info,
-	    struct ia_css_frame_info *out_info,
-	    struct ia_css_frame_info *vf_info,
-	    struct ia_css_cas_binary_descr *descr)
+	struct ia_css_frame_info *in_info, struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info,
+	struct ia_css_cas_binary_descr *descr)
 {
 	unsigned int i;
 	unsigned int hor_ds_factor = 0, ver_ds_factor = 0;
@@ -5848,36 +5938,36 @@ static int ia_css_pipe_create_cas_scaler_desc_single_output(
 		i *= max_scale_factor_per_stage;
 	}
 
-	descr->in_info = kmalloc(descr->num_stage *
-				 sizeof(struct ia_css_frame_info),
-				 GFP_KERNEL);
+	descr->in_info =
+		kmalloc(descr->num_stage * sizeof(struct ia_css_frame_info),
+			GFP_KERNEL);
 	if (!descr->in_info) {
 		err = -ENOMEM;
 		goto ERR;
 	}
-	descr->internal_out_info = kmalloc(descr->num_stage *
-					   sizeof(struct ia_css_frame_info),
-					   GFP_KERNEL);
+	descr->internal_out_info =
+		kmalloc(descr->num_stage * sizeof(struct ia_css_frame_info),
+			GFP_KERNEL);
 	if (!descr->internal_out_info) {
 		err = -ENOMEM;
 		goto ERR;
 	}
-	descr->out_info = kmalloc(descr->num_stage *
-				  sizeof(struct ia_css_frame_info),
-				  GFP_KERNEL);
+	descr->out_info =
+		kmalloc(descr->num_stage * sizeof(struct ia_css_frame_info),
+			GFP_KERNEL);
 	if (!descr->out_info) {
 		err = -ENOMEM;
 		goto ERR;
 	}
-	descr->vf_info = kmalloc(descr->num_stage *
-				 sizeof(struct ia_css_frame_info),
-				 GFP_KERNEL);
+	descr->vf_info =
+		kmalloc(descr->num_stage * sizeof(struct ia_css_frame_info),
+			GFP_KERNEL);
 	if (!descr->vf_info) {
 		err = -ENOMEM;
 		goto ERR;
 	}
-	descr->is_output_stage = kmalloc(descr->num_stage * sizeof(bool),
-					 GFP_KERNEL);
+	descr->is_output_stage =
+		kmalloc(descr->num_stage * sizeof(bool), GFP_KERNEL);
 	if (!descr->is_output_stage) {
 		err = -ENOMEM;
 		goto ERR;
@@ -5886,13 +5976,19 @@ static int ia_css_pipe_create_cas_scaler_desc_single_output(
 	tmp_in_info = *in_info;
 	for (i = 0; i < descr->num_stage; i++) {
 		descr->in_info[i] = tmp_in_info;
-		if ((tmp_in_info.res.width / max_scale_factor_per_stage) <= out_info->res.width) {
+		if ((tmp_in_info.res.width / max_scale_factor_per_stage) <=
+		    out_info->res.width) {
 			descr->is_output_stage[i] = true;
-			if ((descr->num_output_stage > 1) && (i != (descr->num_stage - 1))) {
-				descr->internal_out_info[i].res.width = out_info->res.width;
-				descr->internal_out_info[i].res.height = out_info->res.height;
-				descr->internal_out_info[i].padded_width = out_info->padded_width;
-				descr->internal_out_info[i].format = IA_CSS_FRAME_FORMAT_YUV420;
+			if ((descr->num_output_stage > 1) &&
+			    (i != (descr->num_stage - 1))) {
+				descr->internal_out_info[i].res.width =
+					out_info->res.width;
+				descr->internal_out_info[i].res.height =
+					out_info->res.height;
+				descr->internal_out_info[i].padded_width =
+					out_info->padded_width;
+				descr->internal_out_info[i].format =
+					IA_CSS_FRAME_FORMAT_YUV420;
 			} else {
 				assert(i == (descr->num_stage - 1));
 				descr->internal_out_info[i].res.width = 0;
@@ -5900,13 +5996,19 @@ static int ia_css_pipe_create_cas_scaler_desc_single_output(
 			}
 			descr->out_info[i].res.width = out_info->res.width;
 			descr->out_info[i].res.height = out_info->res.height;
-			descr->out_info[i].padded_width = out_info->padded_width;
+			descr->out_info[i].padded_width =
+				out_info->padded_width;
 			descr->out_info[i].format = out_info->format;
 			if (vf_info) {
-				descr->vf_info[i].res.width = vf_info->res.width;
-				descr->vf_info[i].res.height = vf_info->res.height;
-				descr->vf_info[i].padded_width = vf_info->padded_width;
-				ia_css_frame_info_set_format(&descr->vf_info[i], IA_CSS_FRAME_FORMAT_YUV_LINE);
+				descr->vf_info[i].res.width =
+					vf_info->res.width;
+				descr->vf_info[i].res.height =
+					vf_info->res.height;
+				descr->vf_info[i].padded_width =
+					vf_info->padded_width;
+				ia_css_frame_info_set_format(
+					&descr->vf_info[i],
+					IA_CSS_FRAME_FORMAT_YUV_LINE);
 			} else {
 				descr->vf_info[i].res.width = 0;
 				descr->vf_info[i].res.height = 0;
@@ -5914,15 +6016,21 @@ static int ia_css_pipe_create_cas_scaler_desc_single_output(
 			}
 		} else {
 			descr->is_output_stage[i] = false;
-			descr->internal_out_info[i].res.width = tmp_in_info.res.width /
-								max_scale_factor_per_stage;
-			descr->internal_out_info[i].res.height = tmp_in_info.res.height /
+			descr->internal_out_info[i].res.width =
+				tmp_in_info.res.width /
+				max_scale_factor_per_stage;
+			descr->internal_out_info[i].res.height =
+				tmp_in_info.res.height /
 				max_scale_factor_per_stage;
-			descr->internal_out_info[i].format = IA_CSS_FRAME_FORMAT_YUV420;
-			ia_css_frame_info_init(&descr->internal_out_info[i],
-					       tmp_in_info.res.width / max_scale_factor_per_stage,
-					       tmp_in_info.res.height / max_scale_factor_per_stage,
-					       IA_CSS_FRAME_FORMAT_YUV420, 0);
+			descr->internal_out_info[i].format =
+				IA_CSS_FRAME_FORMAT_YUV420;
+			ia_css_frame_info_init(
+				&descr->internal_out_info[i],
+				tmp_in_info.res.width /
+					max_scale_factor_per_stage,
+				tmp_in_info.res.height /
+					max_scale_factor_per_stage,
+				IA_CSS_FRAME_FORMAT_YUV420, 0);
 			descr->out_info[i].res.width = 0;
 			descr->out_info[i].res.height = 0;
 			descr->vf_info[i].res.width = 0;
@@ -5931,9 +6039,9 @@ static int ia_css_pipe_create_cas_scaler_desc_single_output(
 		tmp_in_info = descr->internal_out_info[i];
 	}
 ERR:
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_pipe_create_cas_scaler_desc() leave, err=%d\n",
-			    err);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_pipe_create_cas_scaler_desc() leave, err=%d\n", err);
 	return err;
 }
 
@@ -5948,8 +6056,8 @@ ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pipe,
 	struct ia_css_frame_info tmp_in_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;
 	unsigned int i, j;
 	unsigned int hor_scale_factor[IA_CSS_PIPE_MAX_OUTPUT_STAGE],
-		    ver_scale_factor[IA_CSS_PIPE_MAX_OUTPUT_STAGE],
-		    scale_factor = 0;
+		ver_scale_factor[IA_CSS_PIPE_MAX_OUTPUT_STAGE],
+		scale_factor = 0;
 	unsigned int num_stages = 0;
 	int err = 0;
 
@@ -5978,8 +6086,10 @@ ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pipe,
 		}
 
 		if (out_info[i]) {
-			hor_scale_factor[i] = CEIL_DIV(in_info.res.width, out_info[i]->res.width);
-			ver_scale_factor[i] = CEIL_DIV(in_info.res.height, out_info[i]->res.height);
+			hor_scale_factor[i] = CEIL_DIV(in_info.res.width,
+						       out_info[i]->res.width);
+			ver_scale_factor[i] = CEIL_DIV(in_info.res.height,
+						       out_info[i]->res.height);
 			/* use the same horizontal and vertical scaling factor for simplicity */
 			assert(hor_scale_factor[i] == ver_scale_factor[i]);
 			scale_factor = 1;
@@ -5997,36 +6107,35 @@ ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pipe,
 
 	descr->num_stage = num_stages;
 
-	descr->in_info = kmalloc_array(descr->num_stage,
-				       sizeof(struct ia_css_frame_info),
-				       GFP_KERNEL);
+	descr->in_info = kmalloc_array(
+		descr->num_stage, sizeof(struct ia_css_frame_info), GFP_KERNEL);
 	if (!descr->in_info) {
 		err = -ENOMEM;
 		goto ERR;
 	}
-	descr->internal_out_info = kmalloc(descr->num_stage *
-					   sizeof(struct ia_css_frame_info),
-					   GFP_KERNEL);
+	descr->internal_out_info =
+		kmalloc(descr->num_stage * sizeof(struct ia_css_frame_info),
+			GFP_KERNEL);
 	if (!descr->internal_out_info) {
 		err = -ENOMEM;
 		goto ERR;
 	}
-	descr->out_info = kmalloc(descr->num_stage *
-				  sizeof(struct ia_css_frame_info),
-				  GFP_KERNEL);
+	descr->out_info =
+		kmalloc(descr->num_stage * sizeof(struct ia_css_frame_info),
+			GFP_KERNEL);
 	if (!descr->out_info) {
 		err = -ENOMEM;
 		goto ERR;
 	}
-	descr->vf_info = kmalloc(descr->num_stage *
-				 sizeof(struct ia_css_frame_info),
-				 GFP_KERNEL);
+	descr->vf_info =
+		kmalloc(descr->num_stage * sizeof(struct ia_css_frame_info),
+			GFP_KERNEL);
 	if (!descr->vf_info) {
 		err = -ENOMEM;
 		goto ERR;
 	}
-	descr->is_output_stage = kmalloc(descr->num_stage * sizeof(bool),
-					 GFP_KERNEL);
+	descr->is_output_stage =
+		kmalloc(descr->num_stage * sizeof(bool), GFP_KERNEL);
 	if (!descr->is_output_stage) {
 		err = -ENOMEM;
 		goto ERR;
@@ -6035,8 +6144,10 @@ ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pipe,
 	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
 		if (out_info[i]) {
 			if (i > 0) {
-				assert((out_info[i - 1]->res.width >= out_info[i]->res.width) &&
-				       (out_info[i - 1]->res.height >= out_info[i]->res.height));
+				assert((out_info[i - 1]->res.width >=
+					out_info[i]->res.width) &&
+				       (out_info[i - 1]->res.height >=
+					out_info[i]->res.height));
 			}
 		}
 	}
@@ -6051,11 +6162,16 @@ ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pipe,
 		if ((tmp_in_info.res.width / max_scale_factor_per_stage) <=
 		    out_info[j]->res.width) {
 			descr->is_output_stage[i] = true;
-			if ((descr->num_output_stage > 1) && (i != (descr->num_stage - 1))) {
-				descr->internal_out_info[i].res.width = out_info[j]->res.width;
-				descr->internal_out_info[i].res.height = out_info[j]->res.height;
-				descr->internal_out_info[i].padded_width = out_info[j]->padded_width;
-				descr->internal_out_info[i].format = IA_CSS_FRAME_FORMAT_YUV420;
+			if ((descr->num_output_stage > 1) &&
+			    (i != (descr->num_stage - 1))) {
+				descr->internal_out_info[i].res.width =
+					out_info[j]->res.width;
+				descr->internal_out_info[i].res.height =
+					out_info[j]->res.height;
+				descr->internal_out_info[i].padded_width =
+					out_info[j]->padded_width;
+				descr->internal_out_info[i].format =
+					IA_CSS_FRAME_FORMAT_YUV420;
 			} else {
 				assert(i == (descr->num_stage - 1));
 				descr->internal_out_info[i].res.width = 0;
@@ -6063,13 +6179,19 @@ ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pipe,
 			}
 			descr->out_info[i].res.width = out_info[j]->res.width;
 			descr->out_info[i].res.height = out_info[j]->res.height;
-			descr->out_info[i].padded_width = out_info[j]->padded_width;
+			descr->out_info[i].padded_width =
+				out_info[j]->padded_width;
 			descr->out_info[i].format = out_info[j]->format;
 			if (vf_out_info[j]) {
-				descr->vf_info[i].res.width = vf_out_info[j]->res.width;
-				descr->vf_info[i].res.height = vf_out_info[j]->res.height;
-				descr->vf_info[i].padded_width = vf_out_info[j]->padded_width;
-				ia_css_frame_info_set_format(&descr->vf_info[i], IA_CSS_FRAME_FORMAT_YUV_LINE);
+				descr->vf_info[i].res.width =
+					vf_out_info[j]->res.width;
+				descr->vf_info[i].res.height =
+					vf_out_info[j]->res.height;
+				descr->vf_info[i].padded_width =
+					vf_out_info[j]->padded_width;
+				ia_css_frame_info_set_format(
+					&descr->vf_info[i],
+					IA_CSS_FRAME_FORMAT_YUV_LINE);
 			} else {
 				descr->vf_info[i].res.width = 0;
 				descr->vf_info[i].res.height = 0;
@@ -6078,15 +6200,21 @@ ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pipe,
 			j++;
 		} else {
 			descr->is_output_stage[i] = false;
-			descr->internal_out_info[i].res.width = tmp_in_info.res.width /
-								max_scale_factor_per_stage;
-			descr->internal_out_info[i].res.height = tmp_in_info.res.height /
+			descr->internal_out_info[i].res.width =
+				tmp_in_info.res.width /
+				max_scale_factor_per_stage;
+			descr->internal_out_info[i].res.height =
+				tmp_in_info.res.height /
 				max_scale_factor_per_stage;
-			descr->internal_out_info[i].format = IA_CSS_FRAME_FORMAT_YUV420;
-			ia_css_frame_info_init(&descr->internal_out_info[i],
-					       tmp_in_info.res.width / max_scale_factor_per_stage,
-					       tmp_in_info.res.height / max_scale_factor_per_stage,
-					       IA_CSS_FRAME_FORMAT_YUV420, 0);
+			descr->internal_out_info[i].format =
+				IA_CSS_FRAME_FORMAT_YUV420;
+			ia_css_frame_info_init(
+				&descr->internal_out_info[i],
+				tmp_in_info.res.width /
+					max_scale_factor_per_stage,
+				tmp_in_info.res.height /
+					max_scale_factor_per_stage,
+				IA_CSS_FRAME_FORMAT_YUV420, 0);
 			descr->out_info[i].res.width = 0;
 			descr->out_info[i].res.height = 0;
 			descr->vf_info[i].res.width = 0;
@@ -6095,14 +6223,14 @@ ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pipe,
 		tmp_in_info = descr->internal_out_info[i];
 	}
 ERR:
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "ia_css_pipe_create_cas_scaler_desc() leave, err=%d\n",
-			    err);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_pipe_create_cas_scaler_desc() leave, err=%d\n", err);
 	return err;
 }
 
-static void ia_css_pipe_destroy_cas_scaler_desc(struct ia_css_cas_binary_descr
-	*descr)
+static void
+ia_css_pipe_destroy_cas_scaler_desc(struct ia_css_cas_binary_descr *descr)
 {
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "ia_css_pipe_destroy_cas_scaler_desc() enter:\n");
@@ -6120,15 +6248,14 @@ static void ia_css_pipe_destroy_cas_scaler_desc(struct ia_css_cas_binary_descr
 			    "ia_css_pipe_destroy_cas_scaler_desc() leave\n");
 }
 
-static int
-load_yuvpp_binaries(struct ia_css_pipe *pipe)
+static int load_yuvpp_binaries(struct ia_css_pipe *pipe)
 {
 	int err = 0;
 	bool need_scaler = false;
 	struct ia_css_frame_info *vf_pp_in_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
 	struct ia_css_yuvpp_settings *mycs;
 	struct ia_css_binary *next_binary;
-	struct ia_css_cas_binary_descr cas_scaler_descr = { };
+	struct ia_css_cas_binary_descr cas_scaler_descr = {};
 	unsigned int i, j;
 	bool need_isp_copy_binary = false;
 
@@ -6149,8 +6276,9 @@ load_yuvpp_binaries(struct ia_css_pipe *pipe)
 
 	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
 		if (pipe->vf_output_info[i].res.width != 0) {
-			err = ia_css_util_check_vf_out_info(&pipe->output_info[i],
-							    &pipe->vf_output_info[i]);
+			err = ia_css_util_check_vf_out_info(
+				&pipe->output_info[i],
+				&pipe->vf_output_info[i]);
 			if (err)
 				goto ERR;
 		}
@@ -6184,13 +6312,14 @@ load_yuvpp_binaries(struct ia_css_pipe *pipe)
 			goto ERR;
 		}
 		for (i = 0; i < cas_scaler_descr.num_stage; i++) {
-			mycs->is_output_stage[i] = cas_scaler_descr.is_output_stage[i];
-			ia_css_pipe_get_yuvscaler_binarydesc(pipe,
-							     &yuv_scaler_descr,
-							     &cas_scaler_descr.in_info[i],
-							     &cas_scaler_descr.out_info[i],
-							     &cas_scaler_descr.internal_out_info[i],
-							     &cas_scaler_descr.vf_info[i]);
+			mycs->is_output_stage[i] =
+				cas_scaler_descr.is_output_stage[i];
+			ia_css_pipe_get_yuvscaler_binarydesc(
+				pipe, &yuv_scaler_descr,
+				&cas_scaler_descr.in_info[i],
+				&cas_scaler_descr.out_info[i],
+				&cas_scaler_descr.internal_out_info[i],
+				&cas_scaler_descr.vf_info[i]);
 			err = ia_css_binary_find(&yuv_scaler_descr,
 						 &mycs->yuv_scaler_binary[i]);
 			if (err)
@@ -6225,14 +6354,13 @@ load_yuvpp_binaries(struct ia_css_pipe *pipe)
 	 */
 	if (IS_ISP2401)
 		need_isp_copy_binary =
-		    (pipe->stream->config.input_config.format == ATOMISP_INPUT_FORMAT_YUV422_8);
+			(pipe->stream->config.input_config.format ==
+			 ATOMISP_INPUT_FORMAT_YUV422_8);
 	else
 		need_isp_copy_binary = true;
 
 	if (need_isp_copy_binary) {
-		err = load_copy_binary(pipe,
-				       &mycs->copy_binary,
-				       next_binary);
+		err = load_copy_binary(pipe, &mycs->copy_binary, next_binary);
 
 		if (err)
 			goto ERR;
@@ -6255,7 +6383,8 @@ load_yuvpp_binaries(struct ia_css_pipe *pipe)
 		 *   input ONLY from the system DDR. So it does not provide the flag "online"
 		 *   to specify where its input is from.
 		 */
-		pipe->pipe_settings.capture.copy_binary.online = pipe->stream->config.online;
+		pipe->pipe_settings.capture.copy_binary.online =
+			pipe->stream->config.online;
 	}
 
 	/* Viewfinder post-processing */
@@ -6263,23 +6392,21 @@ load_yuvpp_binaries(struct ia_css_pipe *pipe)
 		for (i = 0, j = 0; i < mycs->num_yuv_scaler; i++) {
 			if (mycs->is_output_stage[i]) {
 				assert(j < 2);
-				vf_pp_in_info[j] =
-				    &mycs->yuv_scaler_binary[i].vf_frame_info;
+				vf_pp_in_info[j] = &mycs->yuv_scaler_binary[i]
+							    .vf_frame_info;
 				j++;
 			}
 		}
 		mycs->num_vf_pp = j;
 	} else {
-		vf_pp_in_info[0] =
-		    &mycs->copy_binary.vf_frame_info;
+		vf_pp_in_info[0] = &mycs->copy_binary.vf_frame_info;
 		for (i = 1; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++)
 			vf_pp_in_info[i] = NULL;
 
 		mycs->num_vf_pp = 1;
 	}
 	mycs->vf_pp_binary = kcalloc(mycs->num_vf_pp,
-				     sizeof(struct ia_css_binary),
-				     GFP_KERNEL);
+				     sizeof(struct ia_css_binary), GFP_KERNEL);
 	if (!mycs->vf_pp_binary) {
 		err = -ENOMEM;
 		goto ERR;
@@ -6290,9 +6417,11 @@ load_yuvpp_binaries(struct ia_css_pipe *pipe)
 
 		for (i = 0; i < mycs->num_vf_pp; i++) {
 			if (pipe->vf_output_info[i].res.width != 0) {
-				ia_css_pipe_get_vfpp_binarydesc(pipe,
-								&vf_pp_descr, vf_pp_in_info[i], &pipe->vf_output_info[i]);
-				err = ia_css_binary_find(&vf_pp_descr, &mycs->vf_pp_binary[i]);
+				ia_css_pipe_get_vfpp_binarydesc(
+					pipe, &vf_pp_descr, vf_pp_in_info[i],
+					&pipe->vf_output_info[i]);
+				err = ia_css_binary_find(
+					&vf_pp_descr, &mycs->vf_pp_binary[i]);
 				if (err)
 					goto ERR;
 			}
@@ -6303,13 +6432,12 @@ load_yuvpp_binaries(struct ia_css_pipe *pipe)
 	if (need_scaler)
 		ia_css_pipe_destroy_cas_scaler_desc(&cas_scaler_descr);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "load_yuvpp_binaries() leave, err=%d\n",
-			    err);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "load_yuvpp_binaries() leave, err=%d\n", err);
 	return err;
 }
 
-static int
-unload_yuvpp_binaries(struct ia_css_pipe *pipe)
+static int unload_yuvpp_binaries(struct ia_css_pipe *pipe)
 {
 	unsigned int i;
 
@@ -6321,10 +6449,12 @@ unload_yuvpp_binaries(struct ia_css_pipe *pipe)
 	}
 	ia_css_binary_unload(&pipe->pipe_settings.yuvpp.copy_binary);
 	for (i = 0; i < pipe->pipe_settings.yuvpp.num_yuv_scaler; i++)
-		ia_css_binary_unload(&pipe->pipe_settings.yuvpp.yuv_scaler_binary[i]);
+		ia_css_binary_unload(
+			&pipe->pipe_settings.yuvpp.yuv_scaler_binary[i]);
 
 	for (i = 0; i < pipe->pipe_settings.yuvpp.num_vf_pp; i++)
-		ia_css_binary_unload(&pipe->pipe_settings.yuvpp.vf_pp_binary[i]);
+		ia_css_binary_unload(
+			&pipe->pipe_settings.yuvpp.vf_pp_binary[i]);
 
 	kfree(pipe->pipe_settings.yuvpp.is_output_stage);
 	pipe->pipe_settings.yuvpp.is_output_stage = NULL;
@@ -6362,7 +6492,8 @@ static int yuvpp_start(struct ia_css_pipe *pipe)
 		return err;
 	}
 
-	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe),
+					 &thread_id);
 	copy_ovrd = 1 << thread_id;
 
 	start_pipe(pipe, copy_ovrd, yuvpp_pipe_input_mode);
@@ -6371,8 +6502,7 @@ static int yuvpp_start(struct ia_css_pipe *pipe)
 	return err;
 }
 
-static int
-sh_css_pipe_unload_binaries(struct ia_css_pipe *pipe)
+static int sh_css_pipe_unload_binaries(struct ia_css_pipe *pipe)
 {
 	int err = 0;
 
@@ -6408,13 +6538,13 @@ sh_css_pipe_unload_binaries(struct ia_css_pipe *pipe)
 	return err;
 }
 
-static int
-sh_css_pipe_load_binaries(struct ia_css_pipe *pipe)
+static int sh_css_pipe_load_binaries(struct ia_css_pipe *pipe)
 {
 	int err = 0;
 
 	assert(pipe);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_load_binaries() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "sh_css_pipe_load_binaries() enter:\n");
 
 	/* PIPE_MODE_COPY has no binaries, but has output frames to outside*/
 	if (pipe->config.mode == IA_CSS_PIPE_MODE_COPY)
@@ -6450,17 +6580,13 @@ sh_css_pipe_load_binaries(struct ia_css_pipe *pipe)
 	return err;
 }
 
-static int
-create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
+static int create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 {
 	struct ia_css_pipeline *me;
 	int err = 0;
-	struct ia_css_pipeline_stage *vf_pp_stage = NULL,
-		*copy_stage = NULL,
-		*yuv_scaler_stage = NULL;
-	struct ia_css_binary *copy_binary,
-		*vf_pp_binary,
-		*yuv_scaler_binary;
+	struct ia_css_pipeline_stage *vf_pp_stage = NULL, *copy_stage = NULL,
+				     *yuv_scaler_stage = NULL;
+	struct ia_css_binary *copy_binary, *vf_pp_binary, *yuv_scaler_binary;
 	bool need_scaler = false;
 	unsigned int num_stage, num_output_stage;
 	unsigned int i, j;
@@ -6477,7 +6603,8 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 	bool continuous = false;
 
 	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
-	if ((!pipe) || (!pipe->stream) || (pipe->mode != IA_CSS_PIPE_ID_YUVPP)) {
+	if ((!pipe) || (!pipe->stream) ||
+	    (pipe->mode != IA_CSS_PIPE_ID_YUVPP)) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
 		return -EINVAL;
 	}
@@ -6488,8 +6615,8 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 		vf_frame[i] = NULL;
 	}
 	ia_css_pipe_util_create_output_frames(bin_out_frame);
-	num_stage  = pipe->pipe_settings.yuvpp.num_yuv_scaler;
-	num_output_stage   = pipe->pipe_settings.yuvpp.num_output;
+	num_stage = pipe->pipe_settings.yuvpp.num_yuv_scaler;
+	num_output_stage = pipe->pipe_settings.yuvpp.num_output;
 
 	if (IS_ISP2401) {
 		/*
@@ -6500,14 +6627,17 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 		 * - Buffered Sensor Mode Continuous Capture
 		 */
 		sensor = pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR;
-		buffered_sensor = pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
+		buffered_sensor = pipe->stream->config.mode ==
+				  IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
 		online = pipe->stream->config.online;
 		continuous = pipe->stream->config.continuous;
 		need_in_frameinfo_memory =
-		!((sensor && (online || continuous)) || (buffered_sensor && continuous));
+			!((sensor && (online || continuous)) ||
+			  (buffered_sensor && continuous));
 	} else {
 		/* Construct in_frame info (only in case we have dynamic input */
-		need_in_frameinfo_memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;
+		need_in_frameinfo_memory = pipe->stream->config.mode ==
+					   IA_CSS_INPUT_MODE_MEMORY;
 	}
 	/*
 	 * the input frame can come from:
@@ -6530,9 +6660,10 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 
 		if (pipe->stream->config.input_config.format ==
 		    ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY) {
-			in_frame_format = IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8;
+			in_frame_format =
+				IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8;
 		} else if (pipe->stream->config.input_config.format ==
-			    ATOMISP_INPUT_FORMAT_YUV422_8) {
+			   ATOMISP_INPUT_FORMAT_YUV422_8) {
 			/*
 			 * When the sensor output frame format is "ATOMISP_INPUT_FORMAT_YUV422_8",
 			 * the "isp_copy_var" binary is selected as the first stage in the yuvpp
@@ -6555,8 +6686,7 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 			in_frame_format = IA_CSS_FRAME_FORMAT_NV12;
 		}
 
-		err = init_in_frameinfo_memory_defaults(pipe,
-							&me->in_frame,
+		err = init_in_frameinfo_memory_defaults(pipe, &me->in_frame,
 							in_frame_format);
 
 		if (err) {
@@ -6572,7 +6702,8 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 	for (i = 0; i < num_output_stage; i++) {
 		assert(i < IA_CSS_PIPE_MAX_OUTPUT_STAGE);
 		if (pipe->output_info[i].res.width != 0) {
-			err = init_out_frameinfo_defaults(pipe, &me->out_frame[i], i);
+			err = init_out_frameinfo_defaults(pipe,
+							  &me->out_frame[i], i);
 			if (err) {
 				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
@@ -6582,7 +6713,8 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 
 		/* Construct vf_frame info (only in case we have VF) */
 		if (pipe->vf_output_info[i].res.width != 0) {
-			err = init_vf_frameinfo_defaults(pipe, &me->vf_frame[i], i);
+			err = init_vf_frameinfo_defaults(pipe, &me->vf_frame[i],
+							 i);
 			if (err) {
 				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
@@ -6591,8 +6723,8 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 		}
 	}
 
-	copy_binary       = &pipe->pipe_settings.yuvpp.copy_binary;
-	vf_pp_binary      = pipe->pipe_settings.yuvpp.vf_pp_binary;
+	copy_binary = &pipe->pipe_settings.yuvpp.copy_binary;
+	vf_pp_binary = pipe->pipe_settings.yuvpp.vf_pp_binary;
 	yuv_scaler_binary = pipe->pipe_settings.yuvpp.yuv_scaler_binary;
 	need_scaler = need_yuv_scaler_stage(pipe);
 
@@ -6605,25 +6737,20 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 		}
 
 		if (need_scaler) {
-			ia_css_pipe_util_set_output_frames(bin_out_frame,
-							   0, NULL);
-			ia_css_pipe_get_generic_stage_desc(&stage_desc,
-							   copy_binary,
-							   bin_out_frame,
-							   in_frame_local,
+			ia_css_pipe_util_set_output_frames(bin_out_frame, 0,
 							   NULL);
+			ia_css_pipe_get_generic_stage_desc(
+				&stage_desc, copy_binary, bin_out_frame,
+				in_frame_local, NULL);
 		} else {
-			ia_css_pipe_util_set_output_frames(bin_out_frame,
-							   0, out_frame[0]);
-			ia_css_pipe_get_generic_stage_desc(&stage_desc,
-							   copy_binary,
-							   bin_out_frame,
-							   in_frame_local,
-							   NULL);
+			ia_css_pipe_util_set_output_frames(bin_out_frame, 0,
+							   out_frame[0]);
+			ia_css_pipe_get_generic_stage_desc(
+				&stage_desc, copy_binary, bin_out_frame,
+				in_frame_local, NULL);
 		}
 
-		err = ia_css_pipeline_create_and_add_stage(me,
-							   &stage_desc,
+		err = ia_css_pipeline_create_and_add_stage(me, &stage_desc,
 							   &copy_stage);
 
 		if (err) {
@@ -6657,8 +6784,7 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 			}
 
 			err = add_yuv_scaler_stage(pipe, me, tmp_in_frame,
-						   tmp_out_frame,
-						   NULL,
+						   tmp_out_frame, NULL,
 						   &yuv_scaler_binary[i],
 						   &yuv_scaler_stage);
 
@@ -6669,8 +6795,10 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 			/* we use output port 1 as internal output port */
 			tmp_in_frame = yuv_scaler_stage->args.out_frame[1];
 			if (pipe->pipe_settings.yuvpp.is_output_stage[i]) {
-				if (tmp_vf_frame && (tmp_vf_frame->frame_info.res.width != 0)) {
-					in_frame = yuv_scaler_stage->args.out_vf_frame;
+				if (tmp_vf_frame &&
+				    (tmp_vf_frame->frame_info.res.width != 0)) {
+					in_frame = yuv_scaler_stage->args
+							   .out_vf_frame;
 					err = add_vf_pp_stage(pipe, in_frame,
 							      tmp_vf_frame,
 							      &vf_pp_binary[j],
@@ -6704,10 +6832,9 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 	return 0;
 }
 
-static int
-create_host_copy_pipeline(struct ia_css_pipe *pipe,
-			  unsigned int max_input_width,
-			  struct ia_css_frame *out_frame)
+static int create_host_copy_pipeline(struct ia_css_pipe *pipe,
+				     unsigned int max_input_width,
+				     struct ia_css_frame *out_frame)
 {
 	struct ia_css_pipeline *me;
 	int err = 0;
@@ -6721,18 +6848,18 @@ create_host_copy_pipeline(struct ia_css_pipe *pipe,
 	ia_css_pipeline_clean(me);
 
 	/* Construct out_frame info */
-	if (copy_on_sp(pipe) &&
-	    pipe->stream->config.input_config.format == ATOMISP_INPUT_FORMAT_BINARY_8) {
+	if (copy_on_sp(pipe) && pipe->stream->config.input_config.format ==
+					ATOMISP_INPUT_FORMAT_BINARY_8) {
 		ia_css_frame_info_init(&out_frame->frame_info, JPEG_BYTES, 1,
 				       IA_CSS_FRAME_FORMAT_BINARY_8, 0);
 	} else if (out_frame->frame_info.format == IA_CSS_FRAME_FORMAT_RAW) {
 		out_frame->frame_info.raw_bit_depth =
-		ia_css_pipe_util_pipe_input_format_bpp(pipe);
+			ia_css_pipe_util_pipe_input_format_bpp(pipe);
 	}
 
 	me->num_stages = 1;
 	me->pipe_id = IA_CSS_PIPE_ID_COPY;
-	pipe->mode  = IA_CSS_PIPE_ID_COPY;
+	pipe->mode = IA_CSS_PIPE_ID_COPY;
 
 	ia_css_pipe_get_sp_func_stage_desc(&stage_desc, out_frame,
 					   IA_CSS_PIPELINE_RAW_COPY,
@@ -6748,8 +6875,7 @@ create_host_copy_pipeline(struct ia_css_pipe *pipe,
 	return err;
 }
 
-static int
-create_host_isyscopy_capture_pipeline(struct ia_css_pipe *pipe)
+static int create_host_isyscopy_capture_pipeline(struct ia_css_pipe *pipe)
 {
 	struct ia_css_pipeline *me = &pipe->pipeline;
 	int err = 0;
@@ -6758,29 +6884,32 @@ create_host_isyscopy_capture_pipeline(struct ia_css_pipe *pipe)
 	struct ia_css_pipeline_stage *out_stage = NULL;
 	unsigned int thread_id;
 	enum sh_css_queue_id queue_id;
-	unsigned int max_input_width = MAX_VECTORS_PER_INPUT_LINE_CONT * ISP_VEC_NELEMS;
+	unsigned int max_input_width =
+		MAX_VECTORS_PER_INPUT_LINE_CONT * ISP_VEC_NELEMS;
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "create_host_isyscopy_capture_pipeline() enter:\n");
 	ia_css_pipeline_clean(me);
 
 	/* Construct out_frame info */
-	err = sh_css_pipe_get_output_frame_info(pipe, &out_frame->frame_info, 0);
+	err = sh_css_pipe_get_output_frame_info(pipe, &out_frame->frame_info,
+						0);
 	if (err)
 		return err;
-	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
-	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, thread_id, &queue_id);
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe),
+					 &thread_id);
+	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
+				       thread_id, &queue_id);
 	out_frame->dynamic_queue_id = queue_id;
 	out_frame->buf_type = IA_CSS_BUFFER_TYPE_OUTPUT_FRAME;
 
 	me->num_stages = 1;
 	me->pipe_id = IA_CSS_PIPE_ID_CAPTURE;
-	pipe->mode  = IA_CSS_PIPE_ID_CAPTURE;
+	pipe->mode = IA_CSS_PIPE_ID_CAPTURE;
 	ia_css_pipe_get_sp_func_stage_desc(&stage_desc, out_frame,
 					   IA_CSS_PIPELINE_ISYS_COPY,
 					   max_input_width);
-	err = ia_css_pipeline_create_and_add_stage(me,
-						   &stage_desc, &out_stage);
+	err = ia_css_pipeline_create_and_add_stage(me, &stage_desc, &out_stage);
 	if (err)
 		return err;
 
@@ -6792,8 +6921,7 @@ create_host_isyscopy_capture_pipeline(struct ia_css_pipe *pipe)
 	return err;
 }
 
-static int
-create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
+static int create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 {
 	struct ia_css_pipeline *me;
 	int err = 0;
@@ -6801,14 +6929,9 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 	struct ia_css_pipeline_stage *current_stage = NULL;
 	struct ia_css_pipeline_stage *yuv_scaler_stage = NULL;
 	struct ia_css_binary *copy_binary,
-		*primary_binary[MAX_NUM_PRIMARY_STAGES],
-		*vf_pp_binary,
-		*pre_isp_binary,
-		*anr_gdc_binary,
-		*post_isp_binary,
-		*yuv_scaler_binary,
-		*capture_pp_binary,
-		*capture_ldc_binary;
+		*primary_binary[MAX_NUM_PRIMARY_STAGES], *vf_pp_binary,
+		*pre_isp_binary, *anr_gdc_binary, *post_isp_binary,
+		*yuv_scaler_binary, *capture_pp_binary, *capture_ldc_binary;
 	bool need_pp = false;
 	bool raw;
 
@@ -6848,21 +6971,24 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 		 * - Direct Sensor Mode Continuous Capture
 		 * - Buffered Sensor Mode Continuous Capture
 		 */
-		sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR);
-		buffered_sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR);
+		sensor =
+			(pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR);
+		buffered_sensor = (pipe->stream->config.mode ==
+				   IA_CSS_INPUT_MODE_BUFFERED_SENSOR);
 		online = pipe->stream->config.online;
 		continuous = pipe->stream->config.continuous;
 		need_in_frameinfo_memory =
-		!((sensor && (online || continuous)) || (buffered_sensor &&
-							(online || continuous)));
+			!((sensor && (online || continuous)) ||
+			  (buffered_sensor && (online || continuous)));
 	} else {
 		/* Construct in_frame info (only in case we have dynamic input */
-		need_in_frameinfo_memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;
+		need_in_frameinfo_memory = pipe->stream->config.mode ==
+					   IA_CSS_INPUT_MODE_MEMORY;
 	}
 
 	if (need_in_frameinfo_memory) {
-		err = init_in_frameinfo_memory_defaults(pipe, &me->in_frame,
-							IA_CSS_FRAME_FORMAT_RAW);
+		err = init_in_frameinfo_memory_defaults(
+			pipe, &me->in_frame, IA_CSS_FRAME_FORMAT_RAW);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
@@ -6882,7 +7008,8 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 
 	/* Construct vf_frame info (only in case we have VF) */
 	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {
-		if (mode == IA_CSS_CAPTURE_MODE_RAW || mode == IA_CSS_CAPTURE_MODE_BAYER) {
+		if (mode == IA_CSS_CAPTURE_MODE_RAW ||
+		    mode == IA_CSS_CAPTURE_MODE_BAYER) {
 			/* These modes don't support viewfinder output */
 			vf_frame = NULL;
 		} else {
@@ -6893,7 +7020,7 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 		vf_frame = NULL;
 	}
 
-	copy_binary       = &pipe->pipe_settings.capture.copy_binary;
+	copy_binary = &pipe->pipe_settings.capture.copy_binary;
 	num_primary_stage = pipe->pipe_settings.capture.num_primary_stage;
 	if ((num_primary_stage == 0) && (mode == IA_CSS_CAPTURE_MODE_PRIMARY)) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-EINVAL);
@@ -6901,41 +7028,41 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 	}
 
 	for (i = 0; i < num_primary_stage; i++)
-		primary_binary[i] = &pipe->pipe_settings.capture.primary_binary[i];
+		primary_binary[i] =
+			&pipe->pipe_settings.capture.primary_binary[i];
 
-	vf_pp_binary      = &pipe->pipe_settings.capture.vf_pp_binary;
-	pre_isp_binary    = &pipe->pipe_settings.capture.pre_isp_binary;
-	anr_gdc_binary    = &pipe->pipe_settings.capture.anr_gdc_binary;
-	post_isp_binary   = &pipe->pipe_settings.capture.post_isp_binary;
+	vf_pp_binary = &pipe->pipe_settings.capture.vf_pp_binary;
+	pre_isp_binary = &pipe->pipe_settings.capture.pre_isp_binary;
+	anr_gdc_binary = &pipe->pipe_settings.capture.anr_gdc_binary;
+	post_isp_binary = &pipe->pipe_settings.capture.post_isp_binary;
 	capture_pp_binary = &pipe->pipe_settings.capture.capture_pp_binary;
 	yuv_scaler_binary = pipe->pipe_settings.capture.yuv_scaler_binary;
-	num_yuv_scaler	  = pipe->pipe_settings.capture.num_yuv_scaler;
-	is_output_stage   = pipe->pipe_settings.capture.is_output_stage;
+	num_yuv_scaler = pipe->pipe_settings.capture.num_yuv_scaler;
+	is_output_stage = pipe->pipe_settings.capture.is_output_stage;
 	capture_ldc_binary = &pipe->pipe_settings.capture.capture_ldc_binary;
 
 	need_pp = (need_capture_pp(pipe) || pipe->output_stage) &&
-		    mode != IA_CSS_CAPTURE_MODE_RAW &&
-		    mode != IA_CSS_CAPTURE_MODE_BAYER;
+		  mode != IA_CSS_CAPTURE_MODE_RAW &&
+		  mode != IA_CSS_CAPTURE_MODE_BAYER;
 	need_yuv_pp = (yuv_scaler_binary && yuv_scaler_binary->info);
 	need_ldc = (capture_ldc_binary && capture_ldc_binary->info);
 
 	if (pipe->pipe_settings.capture.copy_binary.info) {
 		if (raw) {
-			ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
+			ia_css_pipe_util_set_output_frames(out_frames, 0,
+							   out_frame);
 			if (IS_ISP2401) {
 				if (!continuous) {
-					ia_css_pipe_get_generic_stage_desc(&stage_desc,
-									   copy_binary,
-									   out_frames,
-									   in_frame,
-									   NULL);
+					ia_css_pipe_get_generic_stage_desc(
+						&stage_desc, copy_binary,
+						out_frames, in_frame, NULL);
 				} else {
-					in_frame = pipe->stream->last_pipe->continuous_frames[0];
-					ia_css_pipe_get_generic_stage_desc(&stage_desc,
-									   copy_binary,
-									   out_frames,
-									   in_frame,
-									   NULL);
+					in_frame =
+						pipe->stream->last_pipe
+							->continuous_frames[0];
+					ia_css_pipe_get_generic_stage_desc(
+						&stage_desc, copy_binary,
+						out_frames, in_frame, NULL);
 				}
 			} else {
 				ia_css_pipe_get_generic_stage_desc(&stage_desc,
@@ -6948,12 +7075,11 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 							   in_frame);
 			ia_css_pipe_get_generic_stage_desc(&stage_desc,
 							   copy_binary,
-							   out_frames,
-							   NULL, NULL);
+							   out_frames, NULL,
+							   NULL);
 		}
 
-		err = ia_css_pipeline_create_and_add_stage(me,
-							   &stage_desc,
+		err = ia_css_pipeline_create_and_add_stage(me, &stage_desc,
 							   &current_stage);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
@@ -6972,11 +7098,13 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 				local_in_frame = in_frame;
 			else
 				local_in_frame = NULL;
-			if (!need_pp && (i == num_primary_stage - 1) && (!IS_ISP2401 || !need_ldc))
+			if (!need_pp && (i == num_primary_stage - 1) &&
+			    (!IS_ISP2401 || !need_ldc))
 				local_out_frame = out_frame;
 			else
 				local_out_frame = NULL;
-			ia_css_pipe_util_set_output_frames(out_frames, 0, local_out_frame);
+			ia_css_pipe_util_set_output_frames(out_frames, 0,
+							   local_out_frame);
 			/*
 			 * WARNING: The #if def flag has been added below as a
 			 * temporary solution to solve the problem of enabling the
@@ -6987,14 +7115,11 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 			 * Proper investigation should be done to come up with the clean
 			 * solution.
 			 */
-			ia_css_pipe_get_generic_stage_desc(&stage_desc,
-							   primary_binary[i],
-							   out_frames,
-							   local_in_frame,
-							   NULL);
-			err = ia_css_pipeline_create_and_add_stage(me,
-								   &stage_desc,
-								   &current_stage);
+			ia_css_pipe_get_generic_stage_desc(
+				&stage_desc, primary_binary[i], out_frames,
+				local_in_frame, NULL);
+			err = ia_css_pipeline_create_and_add_stage(
+				me, &stage_desc, &current_stage);
 			if (err) {
 				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
@@ -7002,11 +7127,11 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 		}
 		/* If we use copy iso primary, the input must be yuv iso raw */
 		current_stage->args.copy_vf =
-		    primary_binary[0]->info->sp.pipeline.mode ==
-		    IA_CSS_BINARY_MODE_COPY;
+			primary_binary[0]->info->sp.pipeline.mode ==
+			IA_CSS_BINARY_MODE_COPY;
 		current_stage->args.copy_output = current_stage->args.copy_vf;
 	} else if (mode == IA_CSS_CAPTURE_MODE_ADVANCED ||
-		    mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT) {
+		   mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT) {
 		ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
 		ia_css_pipe_get_generic_stage_desc(&stage_desc, pre_isp_binary,
 						   out_frames, in_frame, NULL);
@@ -7030,15 +7155,15 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 			ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
 			ia_css_pipe_get_generic_stage_desc(&stage_desc,
 							   post_isp_binary,
-							   out_frames,
-							   NULL, NULL);
+							   out_frames, NULL,
+							   NULL);
 		} else {
 			ia_css_pipe_util_set_output_frames(out_frames, 0,
 							   out_frame);
 			ia_css_pipe_get_generic_stage_desc(&stage_desc,
 							   post_isp_binary,
-							   out_frames,
-							   NULL, NULL);
+							   out_frames, NULL,
+							   NULL);
 		}
 
 		err = ia_css_pipeline_create_and_add_stage(me, &stage_desc,
@@ -7066,20 +7191,16 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 
 		if (need_ldc) {
 			ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
-			ia_css_pipe_get_generic_stage_desc(&stage_desc,
-							   capture_ldc_binary,
-							   out_frames,
-							   local_in_frame,
-							   NULL);
-			err = ia_css_pipeline_create_and_add_stage(me,
-								   &stage_desc,
-								   &current_stage);
+			ia_css_pipe_get_generic_stage_desc(
+				&stage_desc, capture_ldc_binary, out_frames,
+				local_in_frame, NULL);
+			err = ia_css_pipeline_create_and_add_stage(
+				me, &stage_desc, &current_stage);
 			local_in_frame = current_stage->args.out_frame[0];
 		}
 		err = add_capture_pp_stage(pipe, me, local_in_frame,
 					   need_yuv_pp ? NULL : out_frame,
-					   capture_pp_binary,
-					   &current_stage);
+					   capture_pp_binary, &current_stage);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
@@ -7087,7 +7208,8 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 	}
 
 	if (need_yuv_pp && current_stage) {
-		struct ia_css_frame *tmp_in_frame = current_stage->args.out_frame[0];
+		struct ia_css_frame *tmp_in_frame =
+			current_stage->args.out_frame[0];
 		struct ia_css_frame *tmp_out_frame = NULL;
 
 		for (i = 0; i < num_yuv_scaler; i++) {
@@ -7119,8 +7241,7 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 	 * investigation should be done to come up with the clean solution.
 	 */
 	if (mode != IA_CSS_CAPTURE_MODE_RAW &&
-	    mode != IA_CSS_CAPTURE_MODE_BAYER &&
-	    current_stage && vf_frame) {
+	    mode != IA_CSS_CAPTURE_MODE_BAYER && current_stage && vf_frame) {
 		in_frame = current_stage->args.out_vf_frame;
 		err = add_vf_pp_stage(pipe, in_frame, vf_frame, vf_pp_binary,
 				      &current_stage);
@@ -7129,7 +7250,8 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 			return err;
 		}
 	}
-	ia_css_pipeline_finalize_stages(&pipe->pipeline, pipe->stream->config.continuous);
+	ia_css_pipeline_finalize_stages(&pipe->pipeline,
+					pipe->stream->config.continuous);
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 			    "create_host_regular_capture_pipeline() leave:\n");
@@ -7137,8 +7259,7 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 	return 0;
 }
 
-static int
-create_host_capture_pipeline(struct ia_css_pipe *pipe)
+static int create_host_capture_pipeline(struct ia_css_pipe *pipe)
 {
 	int err = 0;
 
@@ -7174,8 +7295,10 @@ static int capture_start(struct ia_css_pipe *pipe)
 
 	me = &pipe->pipeline;
 
-	if ((pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW   ||
-	     pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER) &&
+	if ((pipe->config.default_capture_config.mode ==
+		     IA_CSS_CAPTURE_MODE_RAW ||
+	     pipe->config.default_capture_config.mode ==
+		     IA_CSS_CAPTURE_MODE_BAYER) &&
 	    (pipe->config.mode != IA_CSS_PIPE_MODE_COPY)) {
 		if (copy_on_sp(pipe)) {
 			err = start_copy_on_sp(pipe, &me->out_frame[0]);
@@ -7192,7 +7315,8 @@ static int capture_start(struct ia_css_pipe *pipe)
 		}
 	}
 
-	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe),
+					 &thread_id);
 	copy_ovrd = 1 << thread_id;
 
 	start_pipe(pipe, copy_ovrd, pipe->stream->config.mode);
@@ -7202,8 +7326,7 @@ static int capture_start(struct ia_css_pipe *pipe)
 	 * which is currently done in start_binary(); but COPY pipe contains no binary,
 	 * and does not call start_binary(); so we need to configure the rx here.
 	 */
-	if (!IS_ISP2401 &&
-	    pipe->config.mode == IA_CSS_PIPE_MODE_COPY &&
+	if (!IS_ISP2401 && pipe->config.mode == IA_CSS_PIPE_MODE_COPY &&
 	    pipe->stream->reconfigure_css_rx) {
 		ia_css_isys_rx_configure(&pipe->stream->csi_rx_config,
 					 pipe->stream->config.mode);
@@ -7214,10 +7337,9 @@ static int capture_start(struct ia_css_pipe *pipe)
 	return err;
 }
 
-static int
-sh_css_pipe_get_output_frame_info(struct ia_css_pipe *pipe,
-				  struct ia_css_frame_info *info,
-				  unsigned int idx)
+static int sh_css_pipe_get_output_frame_info(struct ia_css_pipe *pipe,
+					     struct ia_css_frame_info *info,
+					     unsigned int idx)
 {
 	assert(pipe);
 	assert(info);
@@ -7226,18 +7348,14 @@ sh_css_pipe_get_output_frame_info(struct ia_css_pipe *pipe,
 			    "sh_css_pipe_get_output_frame_info() enter:\n");
 
 	*info = pipe->output_info[idx];
-	if (copy_on_sp(pipe) &&
-	    pipe->stream->config.input_config.format == ATOMISP_INPUT_FORMAT_BINARY_8) {
-		ia_css_frame_info_init(
-		    info,
-		    JPEG_BYTES,
-		    1,
-		    IA_CSS_FRAME_FORMAT_BINARY_8,
-		    0);
+	if (copy_on_sp(pipe) && pipe->stream->config.input_config.format ==
+					ATOMISP_INPUT_FORMAT_BINARY_8) {
+		ia_css_frame_info_init(info, JPEG_BYTES, 1,
+				       IA_CSS_FRAME_FORMAT_BINARY_8, 0);
 	} else if (info->format == IA_CSS_FRAME_FORMAT_RAW ||
 		   info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED) {
 		info->raw_bit_depth =
-		ia_css_pipe_util_pipe_input_format_bpp(pipe);
+			ia_css_pipe_util_pipe_input_format_bpp(pipe);
 	}
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
@@ -7245,68 +7363,59 @@ sh_css_pipe_get_output_frame_info(struct ia_css_pipe *pipe,
 	return 0;
 }
 
-void
-ia_css_stream_send_input_frame(const struct ia_css_stream *stream,
-			       const unsigned short *data,
-			       unsigned int width,
-			       unsigned int height)
+void ia_css_stream_send_input_frame(const struct ia_css_stream *stream,
+				    const unsigned short *data,
+				    unsigned int width, unsigned int height)
 {
 	assert(stream);
 
-	ia_css_inputfifo_send_input_frame(
-	    data, width, height,
-	    stream->config.channel_id,
-	    stream->config.input_config.format,
-	    stream->config.pixels_per_clock == 2);
+	ia_css_inputfifo_send_input_frame(data, width, height,
+					  stream->config.channel_id,
+					  stream->config.input_config.format,
+					  stream->config.pixels_per_clock == 2);
 }
 
-void
-ia_css_stream_start_input_frame(const struct ia_css_stream *stream)
+void ia_css_stream_start_input_frame(const struct ia_css_stream *stream)
 {
 	assert(stream);
 
-	ia_css_inputfifo_start_frame(
-	    stream->config.channel_id,
-	    stream->config.input_config.format,
-	    stream->config.pixels_per_clock == 2);
+	ia_css_inputfifo_start_frame(stream->config.channel_id,
+				     stream->config.input_config.format,
+				     stream->config.pixels_per_clock == 2);
 }
 
-void
-ia_css_stream_send_input_line(const struct ia_css_stream *stream,
-			      const unsigned short *data,
-			      unsigned int width,
-			      const unsigned short *data2,
-			      unsigned int width2)
+void ia_css_stream_send_input_line(const struct ia_css_stream *stream,
+				   const unsigned short *data,
+				   unsigned int width,
+				   const unsigned short *data2,
+				   unsigned int width2)
 {
 	assert(stream);
 
-	ia_css_inputfifo_send_line(stream->config.channel_id,
-				   data, width, data2, width2);
+	ia_css_inputfifo_send_line(stream->config.channel_id, data, width,
+				   data2, width2);
 }
 
-void
-ia_css_stream_send_input_embedded_line(const struct ia_css_stream *stream,
-				       enum atomisp_input_format format,
-				       const unsigned short *data,
-				       unsigned int width)
+void ia_css_stream_send_input_embedded_line(const struct ia_css_stream *stream,
+					    enum atomisp_input_format format,
+					    const unsigned short *data,
+					    unsigned int width)
 {
 	assert(stream);
 	if (!data || width == 0)
 		return;
-	ia_css_inputfifo_send_embedded_line(stream->config.channel_id,
-					    format, data, width);
+	ia_css_inputfifo_send_embedded_line(stream->config.channel_id, format,
+					    data, width);
 }
 
-void
-ia_css_stream_end_input_frame(const struct ia_css_stream *stream)
+void ia_css_stream_end_input_frame(const struct ia_css_stream *stream)
 {
 	assert(stream);
 
 	ia_css_inputfifo_end_frame(stream->config.channel_id);
 }
 
-bool
-ia_css_pipeline_uses_params(struct ia_css_pipeline *me)
+bool ia_css_pipeline_uses_params(struct ia_css_pipeline *me)
 {
 	struct ia_css_pipeline_stage *stage;
 
@@ -7317,12 +7426,14 @@ ia_css_pipeline_uses_params(struct ia_css_pipeline *me)
 
 	for (stage = me->stages; stage; stage = stage->next)
 		if (stage->binary_info && stage->binary_info->enable.params) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-					    "ia_css_pipeline_uses_params() leave: return_bool=true\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE,
+				"ia_css_pipeline_uses_params() leave: return_bool=true\n");
 			return true;
 		}
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_pipeline_uses_params() leave: return_bool=false\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_uses_params() leave: return_bool=false\n");
 	return false;
 }
 
@@ -7382,15 +7493,17 @@ int ia_css_stream_capture(struct ia_css_stream *stream, int num_captures,
 	if (!stream)
 		return -EINVAL;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_stream_capture() enter: num_captures=%d, skip=%d, offset=%d\n",
-			    num_captures, skip, offset);
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_capture() enter: num_captures=%d, skip=%d, offset=%d\n",
+		num_captures, skip, offset);
 
 	/* Check if the tag descriptor is valid */
 	if (num_captures < SH_CSS_MINIMUM_TAG_ID) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "ia_css_stream_capture() leave: return_err=%d\n",
-				    -EINVAL);
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE,
+			"ia_css_stream_capture() leave: return_err=%d\n",
+			-EINVAL);
 		return -EINVAL;
 	}
 
@@ -7402,8 +7515,9 @@ int ia_css_stream_capture(struct ia_css_stream *stream, int num_captures,
 
 	if (!sh_css_sp_is_running()) {
 		/* SP is not running. The queues are not valid */
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-				    "ia_css_stream_capture() leaving:queues unavailable\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE,
+			"ia_css_stream_capture() leaving:queues unavailable\n");
 		return -EBUSY;
 	}
 
@@ -7422,8 +7536,7 @@ int ia_css_stream_capture(struct ia_css_stream *stream, int num_captures,
 	return return_err;
 }
 
-static void
-sh_css_init_host_sp_control_vars(void)
+static void sh_css_init_host_sp_control_vars(void)
 {
 	const struct ia_css_fw_info *fw;
 	unsigned int HIVE_ADDR_ia_css_ispctrl_sp_isp_started;
@@ -7433,8 +7546,9 @@ sh_css_init_host_sp_control_vars(void)
 	unsigned int HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb;
 	unsigned int HIVE_ADDR_sp_stop_copy_preview;
 	unsigned int HIVE_ADDR_host_sp_com;
-	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
-			    / sizeof(int);
+	unsigned int o =
+		offsetof(struct host_sp_communication, host2sp_command) /
+		sizeof(int);
 
 	unsigned int i;
 
@@ -7445,54 +7559,58 @@ sh_css_init_host_sp_control_vars(void)
 	HIVE_ADDR_ia_css_ispctrl_sp_isp_started = fw->info.sp.isp_started;
 
 	HIVE_ADDR_host_sp_queues_initialized =
-	    fw->info.sp.host_sp_queues_initialized;
+		fw->info.sp.host_sp_queues_initialized;
 	HIVE_ADDR_sp_sleep_mode = fw->info.sp.sleep_mode;
-	HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb = fw->info.sp.invalidate_tlb;
+	HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb =
+		fw->info.sp.invalidate_tlb;
 	HIVE_ADDR_sp_stop_copy_preview = fw->info.sp.stop_copy_preview;
 	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
 
-	sp_dmem_store_uint32(SP0_ID,
-			     (unsigned int)sp_address_of(ia_css_ispctrl_sp_isp_started),
-			     (uint32_t)(0));
+	sp_dmem_store_uint32(
+		SP0_ID,
+		(unsigned int)sp_address_of(ia_css_ispctrl_sp_isp_started),
+		(uint32_t)(0));
 
-	sp_dmem_store_uint32(SP0_ID,
-			     (unsigned int)sp_address_of(host_sp_queues_initialized),
-			     (uint32_t)(0));
-	sp_dmem_store_uint32(SP0_ID,
-			     (unsigned int)sp_address_of(sp_sleep_mode),
+	sp_dmem_store_uint32(
+		SP0_ID, (unsigned int)sp_address_of(host_sp_queues_initialized),
+		(uint32_t)(0));
+	sp_dmem_store_uint32(SP0_ID, (unsigned int)sp_address_of(sp_sleep_mode),
 			     (uint32_t)(0));
-	sp_dmem_store_uint32(SP0_ID,
-			     (unsigned int)sp_address_of(ia_css_dmaproxy_sp_invalidate_tlb),
-			     (uint32_t)(false));
-	sp_dmem_store_uint32(SP0_ID,
-			     (unsigned int)sp_address_of(sp_stop_copy_preview),
-			     my_css.stop_copy_preview ? (uint32_t)(1) : (uint32_t)(0));
+	sp_dmem_store_uint32(
+		SP0_ID,
+		(unsigned int)sp_address_of(ia_css_dmaproxy_sp_invalidate_tlb),
+		(uint32_t)(false));
+	sp_dmem_store_uint32(
+		SP0_ID, (unsigned int)sp_address_of(sp_stop_copy_preview),
+		my_css.stop_copy_preview ? (uint32_t)(1) : (uint32_t)(0));
 	store_sp_array_uint(host_sp_com, o, host2sp_cmd_ready);
 
 	for (i = 0; i < N_CSI_PORTS; i++) {
-		sh_css_update_host2sp_num_mipi_frames
-		(my_css.num_mipi_frames[i]);
+		sh_css_update_host2sp_num_mipi_frames(
+			my_css.num_mipi_frames[i]);
 	}
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-			    "sh_css_init_host_sp_control_vars() leave: return_void\n");
+	ia_css_debug_dtrace(
+		IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_init_host_sp_control_vars() leave: return_void\n");
 }
 
 /*
  * create the internal structures and fill in the configuration data
  */
 
-static const struct
-ia_css_pipe_config ia_css_pipe_default_config = DEFAULT_PIPE_CONFIG;
+static const struct ia_css_pipe_config ia_css_pipe_default_config =
+	DEFAULT_PIPE_CONFIG;
 
 void ia_css_pipe_config_defaults(struct ia_css_pipe_config *pipe_config)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_config_defaults()\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_pipe_config_defaults()\n");
 	memcpy(pipe_config, &ia_css_pipe_default_config, sizeof(*pipe_config));
 }
 
-void
-ia_css_pipe_extra_config_defaults(struct ia_css_pipe_extra_config *extra_config)
+void ia_css_pipe_extra_config_defaults(
+	struct ia_css_pipe_extra_config *extra_config)
 {
 	if (!extra_config) {
 		IA_CSS_ERROR("NULL input parameter");
@@ -7510,7 +7628,8 @@ ia_css_pipe_extra_config_defaults(struct ia_css_pipe_extra_config *extra_config)
 
 void ia_css_stream_config_defaults(struct ia_css_stream_config *stream_config)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_config_defaults()\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_stream_config_defaults()\n");
 	assert(stream_config);
 	memset(stream_config, 0, sizeof(*stream_config));
 	stream_config->online = true;
@@ -7546,16 +7665,16 @@ int ia_css_pipe_create(const struct ia_css_pipe_config *config,
 	return err;
 }
 
-int
-ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
-			 const struct ia_css_pipe_extra_config *extra_config,
-			 struct ia_css_pipe **pipe)
+int ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
+			     const struct ia_css_pipe_extra_config *extra_config,
+			     struct ia_css_pipe **pipe)
 {
 	int err = -EINVAL;
 	struct ia_css_pipe *internal_pipe = NULL;
 	unsigned int i;
 
-	IA_CSS_ENTER_PRIVATE("config = %p, extra_config = %p and pipe = %p", config, extra_config, pipe);
+	IA_CSS_ENTER_PRIVATE("config = %p, extra_config = %p and pipe = %p",
+			     config, extra_config, pipe);
 
 	/* do not allow to create more than the maximum limit */
 	if (my_css.pipe_counter >= IA_CSS_PIPELINE_NUM_MAX) {
@@ -7610,47 +7729,47 @@ ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
 		if (internal_pipe->config.vf_pp_in_res.width) {
 			format = IA_CSS_FRAME_FORMAT_YUV_LINE;
 			ia_css_frame_info_init(
-			    &internal_pipe->vf_yuv_ds_input_info,
-			    internal_pipe->config.vf_pp_in_res.width,
-			    internal_pipe->config.vf_pp_in_res.height,
-			    format, 0);
+				&internal_pipe->vf_yuv_ds_input_info,
+				internal_pipe->config.vf_pp_in_res.width,
+				internal_pipe->config.vf_pp_in_res.height,
+				format, 0);
 		}
 		if (internal_pipe->config.capt_pp_in_res.width) {
 			format = IA_CSS_FRAME_FORMAT_YUV420;
 			ia_css_frame_info_init(
-			    &internal_pipe->out_yuv_ds_input_info,
-			    internal_pipe->config.capt_pp_in_res.width,
-			    internal_pipe->config.capt_pp_in_res.height,
-			    format, 0);
+				&internal_pipe->out_yuv_ds_input_info,
+				internal_pipe->config.capt_pp_in_res.width,
+				internal_pipe->config.capt_pp_in_res.height,
+				format, 0);
 		}
 	}
 	if (internal_pipe->config.vf_pp_in_res.width &&
 	    internal_pipe->config.mode == IA_CSS_PIPE_MODE_PREVIEW) {
 		ia_css_frame_info_init(
-		    &internal_pipe->vf_yuv_ds_input_info,
-		    internal_pipe->config.vf_pp_in_res.width,
-		    internal_pipe->config.vf_pp_in_res.height,
-		    IA_CSS_FRAME_FORMAT_YUV_LINE, 0);
+			&internal_pipe->vf_yuv_ds_input_info,
+			internal_pipe->config.vf_pp_in_res.width,
+			internal_pipe->config.vf_pp_in_res.height,
+			IA_CSS_FRAME_FORMAT_YUV_LINE, 0);
 	}
 	/* handle bayer downscaling output info */
 	if (internal_pipe->config.bayer_ds_out_res.width) {
 		ia_css_frame_info_init(
-		    &internal_pipe->bds_output_info,
-		    internal_pipe->config.bayer_ds_out_res.width,
-		    internal_pipe->config.bayer_ds_out_res.height,
-		    IA_CSS_FRAME_FORMAT_RAW, 0);
+			&internal_pipe->bds_output_info,
+			internal_pipe->config.bayer_ds_out_res.width,
+			internal_pipe->config.bayer_ds_out_res.height,
+			IA_CSS_FRAME_FORMAT_RAW, 0);
 	}
 
 	/* handle output info, assume always needed */
 	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
 		if (internal_pipe->config.output_info[i].res.width) {
 			err = sh_css_pipe_configure_output(
-				    internal_pipe,
-				    internal_pipe->config.output_info[i].res.width,
-				    internal_pipe->config.output_info[i].res.height,
-				    internal_pipe->config.output_info[i].padded_width,
-				    internal_pipe->config.output_info[i].format,
-				    i);
+				internal_pipe,
+				internal_pipe->config.output_info[i].res.width,
+				internal_pipe->config.output_info[i].res.height,
+				internal_pipe->config.output_info[i]
+					.padded_width,
+				internal_pipe->config.output_info[i].format, i);
 			if (err) {
 				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				kvfree(internal_pipe);
@@ -7661,15 +7780,19 @@ ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
 
 		/* handle vf output info, when configured */
 		internal_pipe->enable_viewfinder[i] =
-		    (internal_pipe->config.vf_output_info[i].res.width != 0);
+			(internal_pipe->config.vf_output_info[i].res.width !=
+			 0);
 		if (internal_pipe->config.vf_output_info[i].res.width) {
 			err = sh_css_pipe_configure_viewfinder(
-				    internal_pipe,
-				    internal_pipe->config.vf_output_info[i].res.width,
-				    internal_pipe->config.vf_output_info[i].res.height,
-				    internal_pipe->config.vf_output_info[i].padded_width,
-				    internal_pipe->config.vf_output_info[i].format,
-				    i);
+				internal_pipe,
+				internal_pipe->config.vf_output_info[i]
+					.res.width,
+				internal_pipe->config.vf_output_info[i]
+					.res.height,
+				internal_pipe->config.vf_output_info[i]
+					.padded_width,
+				internal_pipe->config.vf_output_info[i].format,
+				i);
 			if (err) {
 				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				kvfree(internal_pipe);
@@ -7687,25 +7810,26 @@ ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
 	return 0;
 }
 
-int
-ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
-		     struct ia_css_pipe_info *pipe_info)
+int ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
+			 struct ia_css_pipe_info *pipe_info)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			    "ia_css_pipe_get_info()\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_get_info()\n");
 	if (!pipe_info) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
-				    "ia_css_pipe_get_info: pipe_info cannot be NULL\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_ERROR,
+			"ia_css_pipe_get_info: pipe_info cannot be NULL\n");
 		return -EINVAL;
 	}
 	if (!pipe || !pipe->stream) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
-				    "ia_css_pipe_get_info: ia_css_stream_create needs to be called before ia_css_[stream/pipe]_get_info\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_ERROR,
+			"ia_css_pipe_get_info: ia_css_stream_create needs to be called before ia_css_[stream/pipe]_get_info\n");
 		return -EINVAL;
 	}
 	/* we succeeded return the info */
 	*pipe_info = pipe->info;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_get_info() leave\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_pipe_get_info() leave\n");
 	return 0;
 }
 
@@ -7715,7 +7839,9 @@ bool ia_css_pipe_has_dvs_stats(struct ia_css_pipe_info *pipe_info)
 
 	if (pipe_info) {
 		for (i = 0; i < IA_CSS_DVS_STAT_NUM_OF_LEVELS; i++) {
-			if (pipe_info->grid_info.dvs_grid.dvs_stat_grid_info.grd_cfg[i].grd_start.enable)
+			if (pipe_info->grid_info.dvs_grid.dvs_stat_grid_info
+				    .grd_cfg[i]
+				    .grd_start.enable)
 				return true;
 		}
 	}
@@ -7723,14 +7849,13 @@ bool ia_css_pipe_has_dvs_stats(struct ia_css_pipe_info *pipe_info)
 	return false;
 }
 
-int
-ia_css_pipe_override_frame_format(struct ia_css_pipe *pipe,
-				  int pin_index,
-				  enum ia_css_frame_format new_format)
+int ia_css_pipe_override_frame_format(struct ia_css_pipe *pipe, int pin_index,
+				      enum ia_css_frame_format new_format)
 {
 	int err = 0;
 
-	IA_CSS_ENTER_PRIVATE("pipe = %p, pin_index = %d, new_formats = %d", pipe, pin_index, new_format);
+	IA_CSS_ENTER_PRIVATE("pipe = %p, pin_index = %d, new_formats = %d",
+			     pipe, pin_index, new_format);
 
 	if (!pipe) {
 		IA_CSS_ERROR("pipe is not set");
@@ -7763,8 +7888,7 @@ ia_css_pipe_override_frame_format(struct ia_css_pipe *pipe,
 }
 
 /* Configuration of INPUT_SYSTEM_VERSION_2401 is done on SP */
-static int
-ia_css_stream_configure_rx(struct ia_css_stream *stream)
+static int ia_css_stream_configure_rx(struct ia_css_stream *stream)
 {
 	struct ia_css_input_port *config;
 
@@ -7786,11 +7910,11 @@ ia_css_stream_configure_rx(struct ia_css_stream *stream)
 	if (config->port > MIPI_PORT2_ID)
 		return -EINVAL;
 	stream->csi_rx_config.port =
-	ia_css_isys_port_to_mipi_port(config->port);
-	stream->csi_rx_config.timeout    = config->timeout;
-	stream->csi_rx_config.initcount  = 0;
-	stream->csi_rx_config.synccount  = 0x28282828;
-	stream->csi_rx_config.rxcount    = config->rxcount;
+		ia_css_isys_port_to_mipi_port(config->port);
+	stream->csi_rx_config.timeout = config->timeout;
+	stream->csi_rx_config.initcount = 0;
+	stream->csi_rx_config.synccount = 0x28282828;
+	stream->csi_rx_config.rxcount = config->rxcount;
 	if (config->compression.type == IA_CSS_CSI2_COMPRESSION_TYPE_NONE)
 		stream->csi_rx_config.comp = MIPI_PREDICTOR_NONE;
 	else
@@ -7800,14 +7924,15 @@ ia_css_stream_configure_rx(struct ia_css_stream *stream)
 		 */
 		return -EINVAL;
 
-	stream->csi_rx_config.is_two_ppc = (stream->config.pixels_per_clock == 2);
+	stream->csi_rx_config.is_two_ppc =
+		(stream->config.pixels_per_clock == 2);
 	stream->reconfigure_css_rx = true;
 	return 0;
 }
 
-static struct ia_css_pipe *
-find_pipe(struct ia_css_pipe *pipes[], unsigned int num_pipes,
-	  enum ia_css_pipe_mode mode, bool copy_pipe)
+static struct ia_css_pipe *find_pipe(struct ia_css_pipe *pipes[],
+				     unsigned int num_pipes,
+				     enum ia_css_pipe_mode mode, bool copy_pipe)
 {
 	unsigned int i;
 
@@ -7823,9 +7948,8 @@ find_pipe(struct ia_css_pipe *pipes[], unsigned int num_pipes,
 	return NULL;
 }
 
-static int
-metadata_info_init(const struct ia_css_metadata_config *mdc,
-		   struct ia_css_metadata_info *md)
+static int metadata_info_init(const struct ia_css_metadata_config *mdc,
+			      struct ia_css_metadata_info *md)
 {
 	/* Either both width and height should be set or neither */
 	if ((mdc->resolution.height > 0) ^ (mdc->resolution.width > 0))
@@ -7841,11 +7965,9 @@ metadata_info_init(const struct ia_css_metadata_config *mdc,
 	return 0;
 }
 
-int
-ia_css_stream_create(const struct ia_css_stream_config *stream_config,
-		     int num_pipes,
-		     struct ia_css_pipe *pipes[],
-		     struct ia_css_stream **stream)
+int ia_css_stream_create(const struct ia_css_stream_config *stream_config,
+			 int num_pipes, struct ia_css_pipe *pipes[],
+			 struct ia_css_stream **stream)
 {
 	struct ia_css_pipe *curr_pipe;
 	struct ia_css_stream *curr_stream = NULL;
@@ -7860,9 +7982,7 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 	ia_css_debug_dump_stream_config(stream_config, num_pipes);
 
 	/* some checks */
-	if (num_pipes == 0 ||
-	    !stream ||
-	    !pipes) {
+	if (num_pipes == 0 || !stream || !pipes) {
 		err = -EINVAL;
 		IA_CSS_LEAVE_ERR(err);
 		return err;
@@ -7870,7 +7990,8 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 
 	if (!IS_ISP2401) {
 		/* We don't support metadata for JPEG stream, since they both use str2mem */
-		if (stream_config->input_config.format == ATOMISP_INPUT_FORMAT_BINARY_8 &&
+		if (stream_config->input_config.format ==
+			    ATOMISP_INPUT_FORMAT_BINARY_8 &&
 		    stream_config->metadata_config.resolution.height > 0) {
 			err = -EINVAL;
 			IA_CSS_LEAVE_ERR(err);
@@ -7878,7 +7999,8 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 		}
 	} else {
 		if (stream_config->online && stream_config->pack_raw_pixels) {
-			IA_CSS_LOG("online and pack raw is invalid on input system 2401");
+			IA_CSS_LOG(
+				"online and pack raw is invalid on input system 2401");
 			err = -EINVAL;
 			IA_CSS_LEAVE_ERR(err);
 			return err;
@@ -7889,9 +8011,9 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 
 	/* check if mipi size specified */
 	if (stream_config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR)
-		if (!IS_ISP2401 || !stream_config->online)
-		{
-			unsigned int port = (unsigned int)stream_config->source.port.port;
+		if (!IS_ISP2401 || !stream_config->online) {
+			unsigned int port =
+				(unsigned int)stream_config->source.port.port;
 
 			if (port >= N_MIPI_PORT_ID) {
 				err = -EINVAL;
@@ -7900,13 +8022,19 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 			}
 
 			if (my_css.size_mem_words != 0) {
-				my_css.mipi_frame_size[port] = my_css.size_mem_words;
-			} else if (stream_config->mipi_buffer_config.size_mem_words != 0) {
-				my_css.mipi_frame_size[port] = stream_config->mipi_buffer_config.size_mem_words;
+				my_css.mipi_frame_size[port] =
+					my_css.size_mem_words;
+			} else if (stream_config->mipi_buffer_config
+					   .size_mem_words != 0) {
+				my_css.mipi_frame_size[port] =
+					stream_config->mipi_buffer_config
+						.size_mem_words;
 			} else {
-				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-						    "ia_css_stream_create() exit: error, need to set mipi frame size.\n");
-				assert(stream_config->mipi_buffer_config.size_mem_words != 0);
+				ia_css_debug_dtrace(
+					IA_CSS_DEBUG_TRACE,
+					"ia_css_stream_create() exit: error, need to set mipi frame size.\n");
+				assert(stream_config->mipi_buffer_config
+					       .size_mem_words != 0);
 				err = -EINVAL;
 				IA_CSS_LEAVE_ERR(err);
 				return err;
@@ -7914,14 +8042,18 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 
 			if (my_css.size_mem_words != 0) {
 				my_css.num_mipi_frames[port] =
-				    2; /* Temp change: Default for backwards compatibility. */
-			} else if (stream_config->mipi_buffer_config.nof_mipi_buffers != 0) {
+					2; /* Temp change: Default for backwards compatibility. */
+			} else if (stream_config->mipi_buffer_config
+					   .nof_mipi_buffers != 0) {
 				my_css.num_mipi_frames[port] =
-				    stream_config->mipi_buffer_config.nof_mipi_buffers;
+					stream_config->mipi_buffer_config
+						.nof_mipi_buffers;
 			} else {
-				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-						    "ia_css_stream_create() exit: error, need to set number of mipi frames.\n");
-				assert(stream_config->mipi_buffer_config.nof_mipi_buffers != 0);
+				ia_css_debug_dtrace(
+					IA_CSS_DEBUG_TRACE,
+					"ia_css_stream_create() exit: error, need to set number of mipi frames.\n");
+				assert(stream_config->mipi_buffer_config
+					       .nof_mipi_buffers != 0);
 				err = -EINVAL;
 				IA_CSS_LEAVE_ERR(err);
 				return err;
@@ -7947,7 +8079,8 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 
 	/* allocate pipes */
 	curr_stream->num_pipes = num_pipes;
-	curr_stream->pipes = kcalloc(num_pipes, sizeof(struct ia_css_pipe *), GFP_KERNEL);
+	curr_stream->pipes =
+		kcalloc(num_pipes, sizeof(struct ia_css_pipe *), GFP_KERNEL);
 	if (!curr_stream->pipes) {
 		curr_stream->num_pipes = 0;
 		kfree(curr_stream);
@@ -7957,7 +8090,8 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 		return err;
 	}
 	/* store pipes */
-	spcopyonly = (num_pipes == 1) && (pipes[0]->config.mode == IA_CSS_PIPE_MODE_COPY);
+	spcopyonly = (num_pipes == 1) &&
+		     (pipes[0]->config.mode == IA_CSS_PIPE_MODE_COPY);
 	for (i = 0; i < num_pipes; i++)
 		curr_stream->pipes[i] = pipes[i];
 	curr_stream->last_pipe = curr_stream->pipes[0];
@@ -7971,20 +8105,23 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 
 		if (curr_stream->config.online) {
 			curr_stream->config.source.port.num_lanes =
-			    stream_config->source.port.num_lanes;
-			curr_stream->config.mode =  IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
+				stream_config->source.port.num_lanes;
+			curr_stream->config.mode =
+				IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
 		}
 	}
 	/* in case driver doesn't configure init number of raw buffers, configure it here */
 	if (curr_stream->config.target_num_cont_raw_buf == 0)
-		curr_stream->config.target_num_cont_raw_buf = NUM_CONTINUOUS_FRAMES;
+		curr_stream->config.target_num_cont_raw_buf =
+			NUM_CONTINUOUS_FRAMES;
 	if (curr_stream->config.init_num_cont_raw_buf == 0)
-		curr_stream->config.init_num_cont_raw_buf = curr_stream->config.target_num_cont_raw_buf;
+		curr_stream->config.init_num_cont_raw_buf =
+			curr_stream->config.target_num_cont_raw_buf;
 
 	/* Enable locking & unlocking of buffers in RAW buffer pool */
 	if (curr_stream->config.ia_css_enable_raw_buffer_locking)
 		sh_css_sp_configure_enable_raw_pool_locking(
-		    curr_stream->config.lock_all);
+			curr_stream->config.lock_all);
 
 	/* copy mode specific stuff */
 	switch (curr_stream->config.mode) {
@@ -7996,7 +8133,8 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 	case IA_CSS_INPUT_MODE_PRBS:
 		if (!IS_ISP2401) {
 			IA_CSS_LOG("mode prbs");
-			sh_css_sp_configure_prbs(curr_stream->config.source.prbs.seed);
+			sh_css_sp_configure_prbs(
+				curr_stream->config.source.prbs.seed);
 		}
 		break;
 	case IA_CSS_INPUT_MODE_MEMORY:
@@ -8017,12 +8155,12 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 
 		effective_res = curr_pipe->config.input_effective_res;
 		if (effective_res.height == 0 || effective_res.width == 0) {
-			effective_res = curr_pipe->stream->config.input_config.effective_res;
+			effective_res = curr_pipe->stream->config.input_config
+						.effective_res;
 
 			curr_pipe->config.input_effective_res = effective_res;
 		}
-		IA_CSS_LOG("effective_res=%dx%d",
-			   effective_res.width,
+		IA_CSS_LOG("effective_res=%dx%d", effective_res.width,
 			   effective_res.height);
 	}
 
@@ -8033,15 +8171,15 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 
 	/* sensor binning */
 	if (!spcopyonly) {
-		sensor_binning_changed =
-		    sh_css_params_set_binning_factor(curr_stream,
-						     curr_stream->config.sensor_binning_factor);
+		sensor_binning_changed = sh_css_params_set_binning_factor(
+			curr_stream, curr_stream->config.sensor_binning_factor);
 	} else {
 		sensor_binning_changed = false;
 	}
 
 	IA_CSS_LOG("sensor_binning=%d, changed=%d",
-		   curr_stream->config.sensor_binning_factor, sensor_binning_changed);
+		   curr_stream->config.sensor_binning_factor,
+		   sensor_binning_changed);
 	/* loop over pipes */
 	IA_CSS_LOG("num_pipes=%d", num_pipes);
 	curr_stream->cont_capt = false;
@@ -8056,15 +8194,17 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 
 		if (num_pipes >= 2) {
 			curr_stream->cont_capt = true;
-			curr_stream->disable_cont_vf = curr_stream->config.disable_cont_viewfinder;
-			curr_stream->stop_copy_preview = my_css.stop_copy_preview;
+			curr_stream->disable_cont_vf =
+				curr_stream->config.disable_cont_viewfinder;
+			curr_stream->stop_copy_preview =
+				my_css.stop_copy_preview;
 		}
 
 		/* Create copy pipe here, since it may not be exposed to the driver */
 		preview_pipe = find_pipe(pipes, num_pipes,
 					 IA_CSS_PIPE_MODE_PREVIEW, false);
-		video_pipe = find_pipe(pipes, num_pipes,
-				       IA_CSS_PIPE_MODE_VIDEO, false);
+		video_pipe = find_pipe(pipes, num_pipes, IA_CSS_PIPE_MODE_VIDEO,
+				       false);
 
 		if (curr_stream->cont_capt) {
 			capture_pipe = find_pipe(pipes, num_pipes,
@@ -8081,19 +8221,24 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 			goto ERR;
 		}
 
-		if (preview_pipe && !preview_pipe->pipe_settings.preview.copy_pipe) {
-			err = create_pipe(IA_CSS_PIPE_MODE_CAPTURE, &copy_pipe, true);
+		if (preview_pipe &&
+		    !preview_pipe->pipe_settings.preview.copy_pipe) {
+			err = create_pipe(IA_CSS_PIPE_MODE_CAPTURE, &copy_pipe,
+					  true);
 			if (err)
 				goto ERR;
 			ia_css_pipe_config_defaults(&copy_pipe->config);
-			preview_pipe->pipe_settings.preview.copy_pipe = copy_pipe;
+			preview_pipe->pipe_settings.preview.copy_pipe =
+				copy_pipe;
 			copy_pipe->stream = curr_stream;
 		}
 		if (preview_pipe && curr_stream->cont_capt)
-			preview_pipe->pipe_settings.preview.capture_pipe = capture_pipe;
+			preview_pipe->pipe_settings.preview.capture_pipe =
+				capture_pipe;
 
 		if (video_pipe && !video_pipe->pipe_settings.video.copy_pipe) {
-			err = create_pipe(IA_CSS_PIPE_MODE_CAPTURE, &copy_pipe, true);
+			err = create_pipe(IA_CSS_PIPE_MODE_CAPTURE, &copy_pipe,
+					  true);
 			if (err)
 				goto ERR;
 			ia_css_pipe_config_defaults(&copy_pipe->config);
@@ -8101,7 +8246,8 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 			copy_pipe->stream = curr_stream;
 		}
 		if (video_pipe && curr_stream->cont_capt)
-			video_pipe->pipe_settings.video.capture_pipe = capture_pipe;
+			video_pipe->pipe_settings.video.capture_pipe =
+				capture_pipe;
 	}
 	for (i = 0; i < num_pipes; i++) {
 		curr_pipe = pipes[i];
@@ -8111,9 +8257,8 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 		/* take over effective info */
 
 		effective_res = curr_pipe->config.input_effective_res;
-		err = ia_css_util_check_res(
-			effective_res.width,
-			effective_res.height);
+		err = ia_css_util_check_res(effective_res.width,
+					    effective_res.height);
 		if (err)
 			goto ERR;
 
@@ -8135,21 +8280,21 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 		/* handle each pipe */
 		pipe_info = &curr_pipe->info;
 		for (j = 0; j < IA_CSS_PIPE_MAX_OUTPUT_STAGE; j++) {
-			err = sh_css_pipe_get_output_frame_info(curr_pipe,
-								&pipe_info->output_info[j], j);
+			err = sh_css_pipe_get_output_frame_info(
+				curr_pipe, &pipe_info->output_info[j], j);
 			if (err)
 				goto ERR;
 		}
 
 		if (!spcopyonly) {
 			if (!IS_ISP2401)
-				err = sh_css_pipe_get_shading_info(curr_pipe,
-								   &pipe_info->shading_info,
-								   NULL);
+				err = sh_css_pipe_get_shading_info(
+					curr_pipe, &pipe_info->shading_info,
+					NULL);
 			else
-				err = sh_css_pipe_get_shading_info(curr_pipe,
-								   &pipe_info->shading_info,
-								   &curr_pipe->config);
+				err = sh_css_pipe_get_shading_info(
+					curr_pipe, &pipe_info->shading_info,
+					&curr_pipe->config);
 
 			if (err)
 				goto ERR;
@@ -8158,15 +8303,16 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 			if (err)
 				goto ERR;
 			for (j = 0; j < IA_CSS_PIPE_MAX_OUTPUT_STAGE; j++) {
-				sh_css_pipe_get_viewfinder_frame_info(curr_pipe,
-								      &pipe_info->vf_output_info[j],
-								      j);
+				sh_css_pipe_get_viewfinder_frame_info(
+					curr_pipe,
+					&pipe_info->vf_output_info[j], j);
 				if (err)
 					goto ERR;
 			}
 		}
 
-		my_css.active_pipes[ia_css_pipe_get_pipe_num(curr_pipe)] = curr_pipe;
+		my_css.active_pipes[ia_css_pipe_get_pipe_num(curr_pipe)] =
+			curr_pipe;
 	}
 
 	curr_stream->started = false;
@@ -8186,7 +8332,8 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 	/* Create host side pipeline objects without stages */
 	err = create_host_pipeline_structure(curr_stream);
 	if (err) {
-		IA_CSS_LOG("create_host_pipeline_structure: return_err=%d", err);
+		IA_CSS_LOG("create_host_pipeline_structure: return_err=%d",
+			   err);
 		goto ERR;
 	}
 
@@ -8199,15 +8346,25 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 		if (my_css_save.mode == sh_css_mode_working) {
 			for (i = 0; i < MAX_ACTIVE_STREAMS; i++) {
 				if (!my_css_save.stream_seeds[i].stream) {
-					IA_CSS_LOG("entered stream into loc=%d", i);
-					my_css_save.stream_seeds[i].orig_stream = stream;
-					my_css_save.stream_seeds[i].stream = curr_stream;
-					my_css_save.stream_seeds[i].num_pipes = num_pipes;
-					my_css_save.stream_seeds[i].stream_config = *stream_config;
+					IA_CSS_LOG("entered stream into loc=%d",
+						   i);
+					my_css_save.stream_seeds[i].orig_stream =
+						stream;
+					my_css_save.stream_seeds[i].stream =
+						curr_stream;
+					my_css_save.stream_seeds[i].num_pipes =
+						num_pipes;
+					my_css_save.stream_seeds[i]
+						.stream_config = *stream_config;
 					for (j = 0; j < num_pipes; j++) {
-						my_css_save.stream_seeds[i].pipe_config[j] = pipes[j]->config;
-						my_css_save.stream_seeds[i].pipes[j] = pipes[j];
-						my_css_save.stream_seeds[i].orig_pipes[j] = &pipes[j];
+						my_css_save.stream_seeds[i]
+							.pipe_config[j] =
+							pipes[j]->config;
+						my_css_save.stream_seeds[i]
+							.pipes[j] = pipes[j];
+						my_css_save.stream_seeds[i]
+							.orig_pipes[j] =
+							&pipes[j];
 					}
 					break;
 				}
@@ -8222,8 +8379,7 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 	return err;
 }
 
-int
-ia_css_stream_destroy(struct ia_css_stream *stream)
+int ia_css_stream_destroy(struct ia_css_stream *stream)
 {
 	int i;
 	int err = 0;
@@ -8243,31 +8399,48 @@ ia_css_stream_destroy(struct ia_css_stream *stream)
 			for (i = 0; i < stream->num_pipes; i++) {
 				struct ia_css_pipe *entry = stream->pipes[i];
 				unsigned int sp_thread_id;
-				struct sh_css_sp_pipeline_terminal *sp_pipeline_input_terminal;
+				struct sh_css_sp_pipeline_terminal
+					*sp_pipeline_input_terminal;
 
 				assert(entry);
 				if (entry) {
 					/* get the SP thread id */
 					if (!ia_css_pipeline_get_sp_thread_id(
-							ia_css_pipe_get_pipe_num(entry), &sp_thread_id))
+						    ia_css_pipe_get_pipe_num(
+							    entry),
+						    &sp_thread_id))
 						return -EINVAL;
 
 					/* get the target input terminal */
 					sp_pipeline_input_terminal =
-						&sh_css_sp_group.pipe_io[sp_thread_id].input;
-
-					for (i = 0; i < IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH; i++) {
+						&sh_css_sp_group
+							 .pipe_io[sp_thread_id]
+							 .input;
+
+					for (i = 0;
+					     i <
+					     IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH;
+					     i++) {
 						ia_css_isys_stream_h isys_stream =
-							&sp_pipeline_input_terminal->context.virtual_input_system_stream[i];
-						if (stream->config.isys_config[i].valid && isys_stream->valid)
-							ia_css_isys_stream_destroy(isys_stream);
+							&sp_pipeline_input_terminal
+								 ->context
+								 .virtual_input_system_stream
+									 [i];
+						if (stream->config
+							    .isys_config[i]
+							    .valid &&
+						    isys_stream->valid)
+							ia_css_isys_stream_destroy(
+								isys_stream);
 					}
 				}
 			}
 
-			if (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+			if (stream->config.mode ==
+			    IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
 				for (i = 0; i < stream->num_pipes; i++) {
-					struct ia_css_pipe *entry = stream->pipes[i];
+					struct ia_css_pipe *entry =
+						stream->pipes[i];
 					/*
 					 * free any mipi frames that are remaining:
 					 * some test stream create-destroy cycles do
@@ -8307,13 +8480,17 @@ ia_css_stream_destroy(struct ia_css_stream *stream)
 			/* check internal copy pipe */
 			if (entry->mode == IA_CSS_PIPE_ID_PREVIEW &&
 			    entry->pipe_settings.preview.copy_pipe) {
-				IA_CSS_LOG("clearing stream on internal preview copy pipe");
-				entry->pipe_settings.preview.copy_pipe->stream = NULL;
+				IA_CSS_LOG(
+					"clearing stream on internal preview copy pipe");
+				entry->pipe_settings.preview.copy_pipe->stream =
+					NULL;
 			}
 			if (entry->mode == IA_CSS_PIPE_ID_VIDEO &&
 			    entry->pipe_settings.video.copy_pipe) {
-				IA_CSS_LOG("clearing stream on internal video copy pipe");
-				entry->pipe_settings.video.copy_pipe->stream = NULL;
+				IA_CSS_LOG(
+					"clearing stream on internal video copy pipe");
+				entry->pipe_settings.video.copy_pipe->stream =
+					NULL;
 			}
 			err = sh_css_pipe_unload_binaries(entry);
 		}
@@ -8340,11 +8517,11 @@ ia_css_stream_destroy(struct ia_css_stream *stream)
 	return err;
 }
 
-int
-ia_css_stream_get_info(const struct ia_css_stream *stream,
-		       struct ia_css_stream_info *stream_info)
+int ia_css_stream_get_info(const struct ia_css_stream *stream,
+			   struct ia_css_stream_info *stream_info)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_get_info: enter/exit\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_stream_get_info: enter/exit\n");
 	assert(stream);
 	assert(stream_info);
 
@@ -8352,8 +8529,7 @@ ia_css_stream_get_info(const struct ia_css_stream *stream,
 	return 0;
 }
 
-int
-ia_css_stream_start(struct ia_css_stream *stream)
+int ia_css_stream_start(struct ia_css_stream *stream)
 {
 	int err = 0;
 
@@ -8379,13 +8555,17 @@ ia_css_stream_start(struct ia_css_stream *stream)
 		stream_register_with_csi_rx(stream);
 
 	/* Initialize mipi size checks */
-	if (!IS_ISP2401 && stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+	if (!IS_ISP2401 &&
+	    stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
 		unsigned int idx;
-		unsigned int port = (unsigned int)(stream->config.source.port.port);
+		unsigned int port =
+			(unsigned int)(stream->config.source.port.port);
 
-		for (idx = 0; idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT; idx++) {
+		for (idx = 0;
+		     idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT;
+		     idx++) {
 			sh_css_sp_group.config.mipi_sizes_for_check[port][idx] =
-			sh_css_get_mipi_sizes_for_check(port, idx);
+				sh_css_get_mipi_sizes_for_check(port, idx);
 		}
 	}
 
@@ -8403,24 +8583,30 @@ ia_css_stream_start(struct ia_css_stream *stream)
 	return err;
 }
 
-int
-ia_css_stream_stop(struct ia_css_stream *stream)
+int ia_css_stream_stop(struct ia_css_stream *stream)
 {
 	int err = 0;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_stop() enter/exit\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_stream_stop() enter/exit\n");
 	assert(stream);
 	assert(stream->last_pipe);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_stop: stopping %d\n",
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_stream_stop: stopping %d\n",
 			    stream->last_pipe->mode);
 
 	/* De-initialize mipi size checks */
-	if (!IS_ISP2401 && stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+	if (!IS_ISP2401 &&
+	    stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
 		unsigned int idx;
-		unsigned int port = (unsigned int)(stream->config.source.port.port);
+		unsigned int port =
+			(unsigned int)(stream->config.source.port.port);
 
-		for (idx = 0; idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT; idx++)
-			sh_css_sp_group.config.mipi_sizes_for_check[port][idx] = 0;
+		for (idx = 0;
+		     idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT;
+		     idx++)
+			sh_css_sp_group.config.mipi_sizes_for_check[port][idx] =
+				0;
 	}
 
 	err = ia_css_pipeline_request_stop(&stream->last_pipe->pipeline);
@@ -8436,8 +8622,7 @@ ia_css_stream_stop(struct ia_css_stream *stream)
 	return err;
 }
 
-bool
-ia_css_stream_has_stopped(struct ia_css_stream *stream)
+bool ia_css_stream_has_stopped(struct ia_css_stream *stream)
 {
 	bool stopped;
 
@@ -8453,39 +8638,44 @@ ia_css_stream_has_stopped(struct ia_css_stream *stream)
  * Destroy the stream and all the pipes related to it.
  * The stream handle is used to identify the correct entry in the css_save struct
  */
-int
-ia_css_stream_unload(struct ia_css_stream *stream)
+int ia_css_stream_unload(struct ia_css_stream *stream)
 {
 	int i;
 
 	assert(stream);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,	"ia_css_stream_unload() enter,\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_stream_unload() enter,\n");
 	/* some checks */
 	assert(stream);
 	for (i = 0; i < MAX_ACTIVE_STREAMS; i++)
 		if (my_css_save.stream_seeds[i].stream == stream) {
 			int j;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-					    "ia_css_stream_unload(): unloading %d (%p)\n", i,
-					    my_css_save.stream_seeds[i].stream);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE,
+				"ia_css_stream_unload(): unloading %d (%p)\n",
+				i, my_css_save.stream_seeds[i].stream);
 			ia_css_stream_destroy(stream);
-			for (j = 0; j < my_css_save.stream_seeds[i].num_pipes; j++)
-				ia_css_pipe_destroy(my_css_save.stream_seeds[i].pipes[j]);
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-					    "ia_css_stream_unload(): after unloading %d (%p)\n", i,
-					    my_css_save.stream_seeds[i].stream);
+			for (j = 0; j < my_css_save.stream_seeds[i].num_pipes;
+			     j++)
+				ia_css_pipe_destroy(
+					my_css_save.stream_seeds[i].pipes[j]);
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_TRACE,
+				"ia_css_stream_unload(): after unloading %d (%p)\n",
+				i, my_css_save.stream_seeds[i].stream);
 			break;
 		}
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,	"ia_css_stream_unload() exit,\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_stream_unload() exit,\n");
 	return 0;
 }
 
-int
-ia_css_temp_pipe_to_pipe_id(const struct ia_css_pipe *pipe,
-			    enum ia_css_pipe_id *pipe_id)
+int ia_css_temp_pipe_to_pipe_id(const struct ia_css_pipe *pipe,
+				enum ia_css_pipe_id *pipe_id)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_temp_pipe_to_pipe_id() enter/exit\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_temp_pipe_to_pipe_id() enter/exit\n");
 	if (pipe)
 		*pipe_id = pipe->mode;
 	else
@@ -8500,15 +8690,13 @@ ia_css_stream_get_format(const struct ia_css_stream *stream)
 	return stream->config.input_config.format;
 }
 
-bool
-ia_css_stream_get_two_pixels_per_clock(const struct ia_css_stream *stream)
+bool ia_css_stream_get_two_pixels_per_clock(const struct ia_css_stream *stream)
 {
 	return (stream->config.pixels_per_clock == 2);
 }
 
 struct ia_css_binary *
-ia_css_stream_get_shading_correction_binary(const struct ia_css_stream
-	*stream)
+ia_css_stream_get_shading_correction_binary(const struct ia_css_stream *stream)
 {
 	struct ia_css_pipe *pipe;
 
@@ -8568,9 +8756,8 @@ ia_css_stream_get_3a_binary(const struct ia_css_stream *stream)
 	return s3a_binary;
 }
 
-int
-ia_css_stream_set_output_padded_width(struct ia_css_stream *stream,
-				      unsigned int output_padded_width)
+int ia_css_stream_set_output_padded_width(struct ia_css_stream *stream,
+					  unsigned int output_padded_width)
 {
 	struct ia_css_pipe *pipe;
 
@@ -8581,8 +8768,10 @@ ia_css_stream_set_output_padded_width(struct ia_css_stream *stream,
 	assert(pipe);
 
 	/* set the config also just in case (redundant info? why do we save config in pipe?) */
-	pipe->config.output_info[IA_CSS_PIPE_OUTPUT_STAGE_0].padded_width = output_padded_width;
-	pipe->output_info[IA_CSS_PIPE_OUTPUT_STAGE_0].padded_width = output_padded_width;
+	pipe->config.output_info[IA_CSS_PIPE_OUTPUT_STAGE_0].padded_width =
+		output_padded_width;
+	pipe->output_info[IA_CSS_PIPE_OUTPUT_STAGE_0].padded_width =
+		output_padded_width;
 
 	return 0;
 }
@@ -8596,31 +8785,48 @@ ia_css_pipe_get_shading_correction_binary(const struct ia_css_pipe *pipe)
 
 	switch (pipe->config.mode) {
 	case IA_CSS_PIPE_MODE_PREVIEW:
-		binary = (struct ia_css_binary *)&pipe->pipe_settings.preview.preview_binary;
+		binary = (struct ia_css_binary *)&pipe->pipe_settings.preview
+				 .preview_binary;
 		break;
 	case IA_CSS_PIPE_MODE_VIDEO:
-		binary = (struct ia_css_binary *)&pipe->pipe_settings.video.video_binary;
+		binary = (struct ia_css_binary *)&pipe->pipe_settings.video
+				 .video_binary;
 		break;
 	case IA_CSS_PIPE_MODE_CAPTURE:
-		if (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_PRIMARY) {
+		if (pipe->config.default_capture_config.mode ==
+		    IA_CSS_CAPTURE_MODE_PRIMARY) {
 			unsigned int i;
 
-			for (i = 0; i < pipe->pipe_settings.capture.num_primary_stage; i++) {
-				if (pipe->pipe_settings.capture.primary_binary[i].info->sp.enable.sc) {
-					binary = (struct ia_css_binary *)&pipe->pipe_settings.capture.primary_binary[i];
+			for (i = 0;
+			     i < pipe->pipe_settings.capture.num_primary_stage;
+			     i++) {
+				if (pipe->pipe_settings.capture
+					    .primary_binary[i]
+					    .info->sp.enable.sc) {
+					binary = (struct ia_css_binary *)&pipe
+							 ->pipe_settings.capture
+							 .primary_binary[i];
 					break;
 				}
 			}
 		} else if (pipe->config.default_capture_config.mode ==
-			    IA_CSS_CAPTURE_MODE_BAYER)
-			binary = (struct ia_css_binary *)&pipe->pipe_settings.capture.pre_isp_binary;
+			   IA_CSS_CAPTURE_MODE_BAYER)
+			binary = (struct ia_css_binary *)&pipe->pipe_settings
+					 .capture.pre_isp_binary;
 		else if (pipe->config.default_capture_config.mode ==
-			    IA_CSS_CAPTURE_MODE_ADVANCED ||
-			    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT) {
-			if (pipe->config.isp_pipe_version == IA_CSS_PIPE_VERSION_1)
-				binary = (struct ia_css_binary *)&pipe->pipe_settings.capture.pre_isp_binary;
-			else if (pipe->config.isp_pipe_version == IA_CSS_PIPE_VERSION_2_2)
-				binary = (struct ia_css_binary *)&pipe->pipe_settings.capture.post_isp_binary;
+				 IA_CSS_CAPTURE_MODE_ADVANCED ||
+			 pipe->config.default_capture_config.mode ==
+				 IA_CSS_CAPTURE_MODE_LOW_LIGHT) {
+			if (pipe->config.isp_pipe_version ==
+			    IA_CSS_PIPE_VERSION_1)
+				binary = (struct ia_css_binary *)&pipe
+						 ->pipe_settings.capture
+						 .pre_isp_binary;
+			else if (pipe->config.isp_pipe_version ==
+				 IA_CSS_PIPE_VERSION_2_2)
+				binary = (struct ia_css_binary *)&pipe
+						 ->pipe_settings.capture
+						 .post_isp_binary;
 		}
 		break;
 	default:
@@ -8642,31 +8848,48 @@ ia_css_pipe_get_s3a_binary(const struct ia_css_pipe *pipe)
 
 	switch (pipe->config.mode) {
 	case IA_CSS_PIPE_MODE_PREVIEW:
-		binary = (struct ia_css_binary *)&pipe->pipe_settings.preview.preview_binary;
+		binary = (struct ia_css_binary *)&pipe->pipe_settings.preview
+				 .preview_binary;
 		break;
 	case IA_CSS_PIPE_MODE_VIDEO:
-		binary = (struct ia_css_binary *)&pipe->pipe_settings.video.video_binary;
+		binary = (struct ia_css_binary *)&pipe->pipe_settings.video
+				 .video_binary;
 		break;
 	case IA_CSS_PIPE_MODE_CAPTURE:
-		if (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_PRIMARY) {
+		if (pipe->config.default_capture_config.mode ==
+		    IA_CSS_CAPTURE_MODE_PRIMARY) {
 			unsigned int i;
 
-			for (i = 0; i < pipe->pipe_settings.capture.num_primary_stage; i++) {
-				if (pipe->pipe_settings.capture.primary_binary[i].info->sp.enable.s3a) {
-					binary = (struct ia_css_binary *)&pipe->pipe_settings.capture.primary_binary[i];
+			for (i = 0;
+			     i < pipe->pipe_settings.capture.num_primary_stage;
+			     i++) {
+				if (pipe->pipe_settings.capture
+					    .primary_binary[i]
+					    .info->sp.enable.s3a) {
+					binary = (struct ia_css_binary *)&pipe
+							 ->pipe_settings.capture
+							 .primary_binary[i];
 					break;
 				}
 			}
 		} else if (pipe->config.default_capture_config.mode ==
-			    IA_CSS_CAPTURE_MODE_BAYER) {
-			binary = (struct ia_css_binary *)&pipe->pipe_settings.capture.pre_isp_binary;
+			   IA_CSS_CAPTURE_MODE_BAYER) {
+			binary = (struct ia_css_binary *)&pipe->pipe_settings
+					 .capture.pre_isp_binary;
 		} else if (pipe->config.default_capture_config.mode ==
-			    IA_CSS_CAPTURE_MODE_ADVANCED ||
-			    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT) {
-			if (pipe->config.isp_pipe_version == IA_CSS_PIPE_VERSION_1)
-				binary = (struct ia_css_binary *)&pipe->pipe_settings.capture.pre_isp_binary;
-			else if (pipe->config.isp_pipe_version == IA_CSS_PIPE_VERSION_2_2)
-				binary = (struct ia_css_binary *)&pipe->pipe_settings.capture.post_isp_binary;
+				   IA_CSS_CAPTURE_MODE_ADVANCED ||
+			   pipe->config.default_capture_config.mode ==
+				   IA_CSS_CAPTURE_MODE_LOW_LIGHT) {
+			if (pipe->config.isp_pipe_version ==
+			    IA_CSS_PIPE_VERSION_1)
+				binary = (struct ia_css_binary *)&pipe
+						 ->pipe_settings.capture
+						 .pre_isp_binary;
+			else if (pipe->config.isp_pipe_version ==
+				 IA_CSS_PIPE_VERSION_2_2)
+				binary = (struct ia_css_binary *)&pipe
+						 ->pipe_settings.capture
+						 .post_isp_binary;
 			else
 				assert(0);
 		}
@@ -8690,7 +8913,8 @@ ia_css_pipe_get_sdis_binary(const struct ia_css_pipe *pipe)
 
 	switch (pipe->config.mode) {
 	case IA_CSS_PIPE_MODE_VIDEO:
-		binary = (struct ia_css_binary *)&pipe->pipe_settings.video.video_binary;
+		binary = (struct ia_css_binary *)&pipe->pipe_settings.video
+				 .video_binary;
 		break;
 	default:
 		break;
@@ -8702,16 +8926,14 @@ ia_css_pipe_get_sdis_binary(const struct ia_css_pipe *pipe)
 	return binary;
 }
 
-struct ia_css_pipeline *
-ia_css_pipe_get_pipeline(const struct ia_css_pipe *pipe)
+struct ia_css_pipeline *ia_css_pipe_get_pipeline(const struct ia_css_pipe *pipe)
 {
 	assert(pipe);
 
 	return (struct ia_css_pipeline *)&pipe->pipeline;
 }
 
-unsigned int
-ia_css_pipe_get_pipe_num(const struct ia_css_pipe *pipe)
+unsigned int ia_css_pipe_get_pipe_num(const struct ia_css_pipe *pipe)
 {
 	assert(pipe);
 
@@ -8729,8 +8951,7 @@ ia_css_pipe_get_pipe_num(const struct ia_css_pipe *pipe)
 	return pipe->pipe_num;
 }
 
-unsigned int
-ia_css_pipe_get_isp_pipe_version(const struct ia_css_pipe *pipe)
+unsigned int ia_css_pipe_get_isp_pipe_version(const struct ia_css_pipe *pipe)
 {
 	assert(pipe);
 
@@ -8739,8 +8960,7 @@ ia_css_pipe_get_isp_pipe_version(const struct ia_css_pipe *pipe)
 
 #define SP_START_TIMEOUT_US 30000000
 
-int
-ia_css_start_sp(void)
+int ia_css_start_sp(void)
 {
 	unsigned long timeout;
 	int err = 0;
@@ -8750,7 +8970,8 @@ ia_css_start_sp(void)
 
 	/* waiting for the SP is completely started */
 	timeout = SP_START_TIMEOUT_US;
-	while ((ia_css_spctrl_get_state(SP0_ID) != IA_CSS_SP_SW_INITIALIZED) && timeout) {
+	while ((ia_css_spctrl_get_state(SP0_ID) != IA_CSS_SP_SW_INITIALIZED) &&
+	       timeout) {
 		timeout--;
 		udelay(1);
 	}
@@ -8781,8 +9002,7 @@ ia_css_start_sp(void)
  */
 #define SP_SHUTDOWN_TIMEOUT_US 200000
 
-int
-ia_css_stop_sp(void)
+int ia_css_stop_sp(void)
 {
 	unsigned long timeout;
 	int err = 0;
@@ -8836,35 +9056,34 @@ ia_css_stop_sp(void)
 	return err;
 }
 
-int
-ia_css_update_continuous_frames(struct ia_css_stream *stream)
+int ia_css_update_continuous_frames(struct ia_css_stream *stream)
 {
 	struct ia_css_pipe *pipe;
 	unsigned int i;
 
-	ia_css_debug_dtrace(
-	    IA_CSS_DEBUG_TRACE,
-	    "sh_css_update_continuous_frames() enter:\n");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "sh_css_update_continuous_frames() enter:\n");
 
 	if (!stream) {
 		ia_css_debug_dtrace(
-		    IA_CSS_DEBUG_TRACE,
-		    "sh_css_update_continuous_frames() leave: invalid stream, return_void\n");
+			IA_CSS_DEBUG_TRACE,
+			"sh_css_update_continuous_frames() leave: invalid stream, return_void\n");
 		return -EINVAL;
 	}
 
 	pipe = stream->continuous_pipe;
 
 	for (i = stream->config.init_num_cont_raw_buf;
-		i < stream->config.target_num_cont_raw_buf; i++)
+	     i < stream->config.target_num_cont_raw_buf; i++)
 		sh_css_update_host2sp_offline_frame(i,
-						    pipe->continuous_frames[i], pipe->cont_md_buffers[i]);
+						    pipe->continuous_frames[i],
+						    pipe->cont_md_buffers[i]);
 
-	sh_css_update_host2sp_cont_num_raw_frames
-	(stream->config.target_num_cont_raw_buf, true);
+	sh_css_update_host2sp_cont_num_raw_frames(
+		stream->config.target_num_cont_raw_buf, true);
 	ia_css_debug_dtrace(
-	    IA_CSS_DEBUG_TRACE,
-	    "sh_css_update_continuous_frames() leave: return_void\n");
+		IA_CSS_DEBUG_TRACE,
+		"sh_css_update_continuous_frames() leave: return_void\n");
 
 	return 0;
 }
@@ -8885,87 +9104,133 @@ void ia_css_pipe_map_queue(struct ia_css_pipe *pipe, bool map)
 	if (IS_ISP2401)
 		need_input_queue = true;
 	else
-		need_input_queue = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;
+		need_input_queue = pipe->stream->config.mode ==
+				   IA_CSS_INPUT_MODE_MEMORY;
 
 	/* map required buffer queues to resources */
 	/* TODO: to be improved */
 	if (pipe->mode == IA_CSS_PIPE_ID_PREVIEW) {
 		if (need_input_queue)
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET, map);
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
+				 map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET,
+				 map);
+		ia_css_queue_map(thread_id,
+				 IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET,
+				 map);
 		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
 		if (pipe->pipe_settings.preview.preview_binary.info &&
-		    pipe->pipe_settings.preview.preview_binary.info->sp.enable.s3a)
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);
+		    pipe->pipe_settings.preview.preview_binary.info->sp.enable
+			    .s3a)
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);
 	} else if (pipe->mode == IA_CSS_PIPE_ID_CAPTURE) {
 		unsigned int i;
 
 		if (need_input_queue)
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET, map);
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
+				 map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME,
+				 map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET,
+				 map);
+		ia_css_queue_map(thread_id,
+				 IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET,
+				 map);
 		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
-		if (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_PRIMARY) {
-			for (i = 0; i < pipe->pipe_settings.capture.num_primary_stage; i++) {
-				if (pipe->pipe_settings.capture.primary_binary[i].info &&
-				    pipe->pipe_settings.capture.primary_binary[i].info->sp.enable.s3a) {
-					ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);
+		if (pipe->config.default_capture_config.mode ==
+		    IA_CSS_CAPTURE_MODE_PRIMARY) {
+			for (i = 0;
+			     i < pipe->pipe_settings.capture.num_primary_stage;
+			     i++) {
+				if (pipe->pipe_settings.capture
+					    .primary_binary[i]
+					    .info &&
+				    pipe->pipe_settings.capture
+					    .primary_binary[i]
+					    .info->sp.enable.s3a) {
+					ia_css_queue_map(
+						thread_id,
+						IA_CSS_BUFFER_TYPE_3A_STATISTICS,
+						map);
 					break;
 				}
 			}
 		} else if (pipe->config.default_capture_config.mode ==
-			    IA_CSS_CAPTURE_MODE_ADVANCED ||
-			    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT ||
-			    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER) {
+				   IA_CSS_CAPTURE_MODE_ADVANCED ||
+			   pipe->config.default_capture_config.mode ==
+				   IA_CSS_CAPTURE_MODE_LOW_LIGHT ||
+			   pipe->config.default_capture_config.mode ==
+				   IA_CSS_CAPTURE_MODE_BAYER) {
 			if (pipe->pipe_settings.capture.pre_isp_binary.info &&
-			    pipe->pipe_settings.capture.pre_isp_binary.info->sp.enable.s3a)
-				ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);
+			    pipe->pipe_settings.capture.pre_isp_binary.info->sp
+				    .enable.s3a)
+				ia_css_queue_map(
+					thread_id,
+					IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);
 		}
 	} else if (pipe->mode == IA_CSS_PIPE_ID_VIDEO) {
 		if (need_input_queue)
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
+				 map);
 		if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0])
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET, map);
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME,
+					 map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET,
+				 map);
+		ia_css_queue_map(thread_id,
+				 IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET,
+				 map);
 		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
 		if (pipe->pipe_settings.video.video_binary.info &&
 		    pipe->pipe_settings.video.video_binary.info->sp.enable.s3a)
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);
 		if (pipe->pipe_settings.video.video_binary.info &&
-		    (pipe->pipe_settings.video.video_binary.info->sp.enable.dis
-		    ))
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_DIS_STATISTICS, map);
+		    (pipe->pipe_settings.video.video_binary.info->sp.enable.dis))
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_DIS_STATISTICS,
+					 map);
 	} else if (pipe->mode == IA_CSS_PIPE_ID_COPY) {
 		if (need_input_queue)
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
 		if (!pipe->stream->config.continuous)
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
 		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
 	} else if (pipe->mode == IA_CSS_PIPE_ID_YUVPP) {
 		unsigned int idx;
 
 		for (idx = 0; idx < IA_CSS_PIPE_MAX_OUTPUT_STAGE; idx++) {
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx, map);
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx,
+					 map);
 			if (pipe->enable_viewfinder[idx])
-				ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME + idx, map);
+				ia_css_queue_map(
+					thread_id,
+					IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME +
+						idx,
+					map);
 		}
 		if (need_input_queue)
-			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
-		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);
+			ia_css_queue_map(thread_id,
+					 IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET,
+				 map);
 		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
 	}
 	IA_CSS_LEAVE("");
 }
 
-
-int
-ia_css_unlock_raw_frame(struct ia_css_stream *stream, uint32_t exp_id)
+int ia_css_unlock_raw_frame(struct ia_css_stream *stream, uint32_t exp_id)
 {
 	int ret;
 
@@ -8991,14 +9256,13 @@ ia_css_unlock_raw_frame(struct ia_css_stream *stream, uint32_t exp_id)
 	 * we can safely assign it to an 8-bit argument here.
 	 */
 	ret = ia_css_bufq_enqueue_psys_event(
-	    IA_CSS_PSYS_SW_EVENT_UNLOCK_RAW_BUFFER, exp_id, 0, 0);
+		IA_CSS_PSYS_SW_EVENT_UNLOCK_RAW_BUFFER, exp_id, 0, 0);
 
 	IA_CSS_LEAVE_ERR(ret);
 	return ret;
 }
 
-static void
-sh_css_hmm_buffer_record_init(void)
+static void sh_css_hmm_buffer_record_init(void)
 {
 	int i;
 
@@ -9006,8 +9270,7 @@ sh_css_hmm_buffer_record_init(void)
 		sh_css_hmm_buffer_record_reset(&hmm_buffer_record[i]);
 }
 
-static void
-sh_css_hmm_buffer_record_uninit(void)
+static void sh_css_hmm_buffer_record_uninit(void)
 {
 	int i;
 	struct sh_css_hmm_buffer_record *buffer_record = NULL;
@@ -9016,7 +9279,8 @@ sh_css_hmm_buffer_record_uninit(void)
 	for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
 		if (buffer_record->in_use) {
 			if (buffer_record->h_vbuf)
-				ia_css_rmgr_rel_vbuf(hmm_buffer_pool, &buffer_record->h_vbuf);
+				ia_css_rmgr_rel_vbuf(hmm_buffer_pool,
+						     &buffer_record->h_vbuf);
 			sh_css_hmm_buffer_record_reset(buffer_record);
 		}
 		buffer_record++;
@@ -9033,10 +9297,10 @@ sh_css_hmm_buffer_record_reset(struct sh_css_hmm_buffer_record *buffer_record)
 	buffer_record->kernel_ptr = 0;
 }
 
-static struct sh_css_hmm_buffer_record
-*sh_css_hmm_buffer_record_acquire(struct ia_css_rmgr_vbuf_handle *h_vbuf,
-				    enum ia_css_buffer_type type,
-				    hrt_address kernel_ptr)
+static struct sh_css_hmm_buffer_record *
+sh_css_hmm_buffer_record_acquire(struct ia_css_rmgr_vbuf_handle *h_vbuf,
+				 enum ia_css_buffer_type type,
+				 hrt_address kernel_ptr)
 {
 	int i;
 	struct sh_css_hmm_buffer_record *buffer_record = NULL;
@@ -9063,9 +9327,9 @@ static struct sh_css_hmm_buffer_record
 	return out_buffer_record;
 }
 
-static struct sh_css_hmm_buffer_record
-*sh_css_hmm_buffer_record_validate(ia_css_ptr ddr_buffer_addr,
-				    enum ia_css_buffer_type type)
+static struct sh_css_hmm_buffer_record *
+sh_css_hmm_buffer_record_validate(ia_css_ptr ddr_buffer_addr,
+				  enum ia_css_buffer_type type)
 {
 	int i;
 	struct sh_css_hmm_buffer_record *buffer_record = NULL;
@@ -9073,8 +9337,7 @@ static struct sh_css_hmm_buffer_record
 
 	buffer_record = &hmm_buffer_record[0];
 	for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
-		if ((buffer_record->in_use) &&
-		    (buffer_record->type == type) &&
+		if ((buffer_record->in_use) && (buffer_record->type == type) &&
 		    (buffer_record->h_vbuf) &&
 		    (buffer_record->h_vbuf->vptr == ddr_buffer_addr)) {
 			found_record = true;
diff --git a/drivers/staging/media/atomisp/pci/sh_css_defs.h b/drivers/staging/media/atomisp/pci/sh_css_defs.h
index 51491dfe05cc96a089d0d2d05914ddbc3a7c377b..fdbab33eb45ee450a3664c1d4ec3cec1a46b828e 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_defs.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_defs.h
@@ -11,66 +11,66 @@
 
 /*#include "vamem.h"*/ /* Cannot include for VAMEM properties this file is visible on ISP -> pipeline generator */
 
-#include "math_support.h"	/* max(), min, etc etc */
+#include "math_support.h" /* max(), min, etc etc */
 
 /* ID's for refcount */
-#define IA_CSS_REFCOUNT_PARAM_SET_POOL  0xCAFE0001
-#define IA_CSS_REFCOUNT_PARAM_BUFFER    0xCAFE0002
+#define IA_CSS_REFCOUNT_PARAM_SET_POOL 0xCAFE0001
+#define IA_CSS_REFCOUNT_PARAM_BUFFER 0xCAFE0002
 
 /* Digital Image Stabilization */
-#define SH_CSS_DIS_DECI_FACTOR_LOG2       6
+#define SH_CSS_DIS_DECI_FACTOR_LOG2 6
 
 /* UV offset: 1:uv=-128...127, 0:uv=0...255 */
-#define SH_CSS_UV_OFFSET_IS_0             0
+#define SH_CSS_UV_OFFSET_IS_0 0
 
 /* Bits of bayer is adjusted as 13 in ISP */
-#define SH_CSS_BAYER_BITS                 13
+#define SH_CSS_BAYER_BITS 13
 
 /* Max value of bayer data (unsigned 13bit in ISP) */
-#define SH_CSS_BAYER_MAXVAL               ((1U << SH_CSS_BAYER_BITS) - 1)
+#define SH_CSS_BAYER_MAXVAL ((1U << SH_CSS_BAYER_BITS) - 1)
 
 /* Bits of yuv in ISP */
-#define SH_CSS_ISP_YUV_BITS               8
-
-#define SH_CSS_DP_GAIN_SHIFT              5
-#define SH_CSS_BNR_GAIN_SHIFT             13
-#define SH_CSS_YNR_GAIN_SHIFT             13
-#define SH_CSS_AE_YCOEF_SHIFT             13
-#define SH_CSS_AF_FIR_SHIFT               13
-#define SH_CSS_YEE_DETAIL_GAIN_SHIFT      8  /* [u5.8] */
-#define SH_CSS_YEE_SCALE_SHIFT            8
-#define SH_CSS_TNR_COEF_SHIFT             13
-#define SH_CSS_MACC_COEF_SHIFT            11 /* [s2.11] for ISP1 */
-#define SH_CSS_MACC2_COEF_SHIFT           13 /* [s[exp].[13-exp]] for ISP2 */
-#define SH_CSS_DIS_COEF_SHIFT             13
+#define SH_CSS_ISP_YUV_BITS 8
+
+#define SH_CSS_DP_GAIN_SHIFT 5
+#define SH_CSS_BNR_GAIN_SHIFT 13
+#define SH_CSS_YNR_GAIN_SHIFT 13
+#define SH_CSS_AE_YCOEF_SHIFT 13
+#define SH_CSS_AF_FIR_SHIFT 13
+#define SH_CSS_YEE_DETAIL_GAIN_SHIFT 8 /* [u5.8] */
+#define SH_CSS_YEE_SCALE_SHIFT 8
+#define SH_CSS_TNR_COEF_SHIFT 13
+#define SH_CSS_MACC_COEF_SHIFT 11 /* [s2.11] for ISP1 */
+#define SH_CSS_MACC2_COEF_SHIFT 13 /* [s[exp].[13-exp]] for ISP2 */
+#define SH_CSS_DIS_COEF_SHIFT 13
 
 /* enumeration of the bayer downscale factors. When a binary supports multiple
  * factors, the OR of these defines is used to build the mask of supported
  * factors. The BDS factor is used in pre-processor expressions so we cannot
  * use an enum here. */
-#define SH_CSS_BDS_FACTOR_1_00	(0)
-#define SH_CSS_BDS_FACTOR_1_25	(1)
-#define SH_CSS_BDS_FACTOR_1_50	(2)
-#define SH_CSS_BDS_FACTOR_2_00	(3)
-#define SH_CSS_BDS_FACTOR_2_25	(4)
-#define SH_CSS_BDS_FACTOR_2_50	(5)
-#define SH_CSS_BDS_FACTOR_3_00	(6)
-#define SH_CSS_BDS_FACTOR_4_00	(7)
-#define SH_CSS_BDS_FACTOR_4_50	(8)
-#define SH_CSS_BDS_FACTOR_5_00	(9)
-#define SH_CSS_BDS_FACTOR_6_00	(10)
-#define SH_CSS_BDS_FACTOR_8_00	(11)
-#define NUM_BDS_FACTORS		(12)
-
-#define PACK_BDS_FACTOR(factor)	(1 << (factor))
+#define SH_CSS_BDS_FACTOR_1_00 (0)
+#define SH_CSS_BDS_FACTOR_1_25 (1)
+#define SH_CSS_BDS_FACTOR_1_50 (2)
+#define SH_CSS_BDS_FACTOR_2_00 (3)
+#define SH_CSS_BDS_FACTOR_2_25 (4)
+#define SH_CSS_BDS_FACTOR_2_50 (5)
+#define SH_CSS_BDS_FACTOR_3_00 (6)
+#define SH_CSS_BDS_FACTOR_4_00 (7)
+#define SH_CSS_BDS_FACTOR_4_50 (8)
+#define SH_CSS_BDS_FACTOR_5_00 (9)
+#define SH_CSS_BDS_FACTOR_6_00 (10)
+#define SH_CSS_BDS_FACTOR_8_00 (11)
+#define NUM_BDS_FACTORS (12)
+
+#define PACK_BDS_FACTOR(factor) (1 << (factor))
 
 /* Following macros should match with the type enum ia_css_pipe_version in
  * ia_css_pipe_public.h. The reason to add these macros is that enum type
  * will be evaluted to 0 in preprocessing time. */
-#define SH_CSS_ISP_PIPE_VERSION_1	1
-#define SH_CSS_ISP_PIPE_VERSION_2_2	2
-#define SH_CSS_ISP_PIPE_VERSION_2_6_1	3
-#define SH_CSS_ISP_PIPE_VERSION_2_7	4
+#define SH_CSS_ISP_PIPE_VERSION_1 1
+#define SH_CSS_ISP_PIPE_VERSION_2_2 2
+#define SH_CSS_ISP_PIPE_VERSION_2_6_1 3
+#define SH_CSS_ISP_PIPE_VERSION_2_7 4
 
 /*--------------- sRGB Gamma -----------------
 CCM        : YCgCo[0,8191] -> RGB[0,4095]
@@ -87,51 +87,51 @@ RGB[0,4095] -(interpolation step16)-> RGB[0,255] -(LUT 12bit)-> RGB[0,4095] -> R
 RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
 --------------------------------------------*/
 /* Bits of input/output of sRGB Gamma */
-#define SH_CSS_RGB_GAMMA_INPUT_BITS       12 /* [0,4095] */
-#define SH_CSS_RGB_GAMMA_OUTPUT_BITS      13 /* [0,8191] */
+#define SH_CSS_RGB_GAMMA_INPUT_BITS 12 /* [0,4095] */
+#define SH_CSS_RGB_GAMMA_OUTPUT_BITS 13 /* [0,8191] */
 
 /* Bits of fractional part of interpolation in vamem, [0,4095]->[0,255] */
-#define SH_CSS_RGB_GAMMA_FRAC_BITS        \
+#define SH_CSS_RGB_GAMMA_FRAC_BITS \
 	(SH_CSS_RGB_GAMMA_INPUT_BITS - SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE_LOG2)
-#define SH_CSS_RGB_GAMMA_ONE              BIT(SH_CSS_RGB_GAMMA_FRAC_BITS)
+#define SH_CSS_RGB_GAMMA_ONE BIT(SH_CSS_RGB_GAMMA_FRAC_BITS)
 
 /* Bits of input of CCM,  = 13, Y[0,8191],CgCo[-4096,4095] */
-#define SH_CSS_YUV2RGB_CCM_INPUT_BITS     SH_CSS_BAYER_BITS
+#define SH_CSS_YUV2RGB_CCM_INPUT_BITS SH_CSS_BAYER_BITS
 
 /* Bits of output of CCM,  = 12, RGB[0,4095] */
-#define SH_CSS_YUV2RGB_CCM_OUTPUT_BITS    SH_CSS_RGB_GAMMA_INPUT_BITS
+#define SH_CSS_YUV2RGB_CCM_OUTPUT_BITS SH_CSS_RGB_GAMMA_INPUT_BITS
 
 /* Maximum value of output of CCM */
-#define SH_CSS_YUV2RGB_CCM_MAX_OUTPUT     \
+#define SH_CSS_YUV2RGB_CCM_MAX_OUTPUT \
 	((1 << SH_CSS_YUV2RGB_CCM_OUTPUT_BITS) - 1)
 
-#define SH_CSS_NUM_INPUT_BUF_LINES        4
+#define SH_CSS_NUM_INPUT_BUF_LINES 4
 
 /* Left cropping only applicable for sufficiently large nway */
-#define SH_CSS_MAX_LEFT_CROPPING          12
-#define SH_CSS_MAX_TOP_CROPPING           12
+#define SH_CSS_MAX_LEFT_CROPPING 12
+#define SH_CSS_MAX_TOP_CROPPING 12
 
-#define	SH_CSS_SP_MAX_WIDTH               1280
+#define SH_CSS_SP_MAX_WIDTH 1280
 
 /* This is the maximum grid we can handle in the ISP binaries.
  * The host code makes sure no bigger grid is ever selected. */
-#define SH_CSS_MAX_BQ_GRID_WIDTH          80
-#define SH_CSS_MAX_BQ_GRID_HEIGHT         60
+#define SH_CSS_MAX_BQ_GRID_WIDTH 80
+#define SH_CSS_MAX_BQ_GRID_HEIGHT 60
 
 /* The minimum dvs envelope is 12x12(for IPU2) to make sure the
  * invalid rows/columns that result from filter initialization are skipped. */
-#define SH_CSS_MIN_DVS_ENVELOPE           12U
+#define SH_CSS_MIN_DVS_ENVELOPE 12U
 
 /* The FPGA system (vec_nelems == 16) only supports up to 5MP */
-#define SH_CSS_MAX_SENSOR_WIDTH           4608
-#define SH_CSS_MAX_SENSOR_HEIGHT          3450
+#define SH_CSS_MAX_SENSOR_WIDTH 4608
+#define SH_CSS_MAX_SENSOR_HEIGHT 3450
 
 /* Limited to reduce vmem pressure */
 #if ISP_VMEM_DEPTH >= 3072
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH  SH_CSS_MAX_SENSOR_WIDTH
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH SH_CSS_MAX_SENSOR_WIDTH
 #define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT SH_CSS_MAX_SENSOR_HEIGHT
 #else
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH  3264
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH 3264
 #define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT 2448
 #endif
 /* When using bayer decimation */
@@ -139,55 +139,55 @@ RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
 #define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC  4224
 #define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC 3168
 */
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC  SH_CSS_MAX_SENSOR_WIDTH
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC SH_CSS_MAX_SENSOR_WIDTH
 #define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC SH_CSS_MAX_SENSOR_HEIGHT
 
-#define SH_CSS_MIN_SENSOR_WIDTH           2
-#define SH_CSS_MIN_SENSOR_HEIGHT          2
+#define SH_CSS_MIN_SENSOR_WIDTH 2
+#define SH_CSS_MIN_SENSOR_HEIGHT 2
 
 /*
 #define SH_CSS_MAX_VF_WIDTH_DEC               1920
 #define SH_CSS_MAX_VF_HEIGHT_DEC              1080
 */
-#define SH_CSS_MAX_VF_WIDTH_DEC               SH_CSS_MAX_VF_WIDTH
-#define SH_CSS_MAX_VF_HEIGHT_DEC              SH_CSS_MAX_VF_HEIGHT
+#define SH_CSS_MAX_VF_WIDTH_DEC SH_CSS_MAX_VF_WIDTH
+#define SH_CSS_MAX_VF_HEIGHT_DEC SH_CSS_MAX_VF_HEIGHT
 
 /* We use 16 bits per coordinate component, including integer
    and fractional bits */
-#define SH_CSS_MORPH_TABLE_GRID               ISP_VEC_NELEMS
-#define SH_CSS_MORPH_TABLE_ELEM_BYTES         2
+#define SH_CSS_MORPH_TABLE_GRID ISP_VEC_NELEMS
+#define SH_CSS_MORPH_TABLE_ELEM_BYTES 2
 #define SH_CSS_MORPH_TABLE_ELEMS_PER_DDR_WORD \
 	(HIVE_ISP_DDR_WORD_BYTES / SH_CSS_MORPH_TABLE_ELEM_BYTES)
 
-#define SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR   (SH_CSS_MAX_BQ_GRID_WIDTH + 1)
-#define SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR   (SH_CSS_MAX_BQ_GRID_HEIGHT + 1)
+#define SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR (SH_CSS_MAX_BQ_GRID_WIDTH + 1)
+#define SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR (SH_CSS_MAX_BQ_GRID_HEIGHT + 1)
 
 #define SH_CSS_MAX_SCTBL_ALIGNED_WIDTH_PER_COLOR \
 	CEIL_MUL(SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR, ISP_VEC_NELEMS)
 
 /* Each line of this table is aligned to the maximum line width. */
-#define SH_CSS_MAX_S3ATBL_WIDTH              SH_CSS_MAX_BQ_GRID_WIDTH
+#define SH_CSS_MAX_S3ATBL_WIDTH SH_CSS_MAX_BQ_GRID_WIDTH
 
 /* Video mode specific DVS define */
 /* The video binary supports a delay of 1 or 2 frames */
-#define MAX_DVS_FRAME_DELAY		2
+#define MAX_DVS_FRAME_DELAY 2
 /* +1 because DVS reads the previous and writes the current frame concurrently */
-#define MAX_NUM_VIDEO_DELAY_FRAMES	(MAX_DVS_FRAME_DELAY + 1)
+#define MAX_NUM_VIDEO_DELAY_FRAMES (MAX_DVS_FRAME_DELAY + 1)
 
-#define NUM_VIDEO_TNR_FRAMES		2
+#define NUM_VIDEO_TNR_FRAMES 2
 
 /* Note that this is the define used to configure all data structures common for all modes */
 /* It should be equal or bigger to the max number of DVS frames for all possible modes */
 /* Rules: these implement logic shared between the host code and ISP firmware.
    The ISP firmware needs these rules to be applied at pre-processor time,
    that's why these are macros, not functions. */
-#define _ISP_BQS(num)  ((num) / 2)
+#define _ISP_BQS(num) ((num) / 2)
 #define _ISP_VECS(width) CEIL_DIV(width, ISP_VEC_NELEMS)
 
 #define ISP_BQ_GRID_WIDTH(elements_per_line, deci_factor_log2) \
-	CEIL_SHIFT(elements_per_line / 2,  deci_factor_log2)
+	CEIL_SHIFT(elements_per_line / 2, deci_factor_log2)
 #define ISP_BQ_GRID_HEIGHT(lines_per_frame, deci_factor_log2) \
-	CEIL_SHIFT(lines_per_frame / 2,  deci_factor_log2)
+	CEIL_SHIFT(lines_per_frame / 2, deci_factor_log2)
 #define ISP_C_VECTORS_PER_LINE(elements_per_line) \
 	_ISP_VECS(elements_per_line / 2)
 
@@ -197,7 +197,7 @@ RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
 	(CEIL_DIV(int_width, SH_CSS_MORPH_TABLE_GRID) + 1)
 #define _ISP_MORPH_TABLE_HEIGHT(int_height) \
 	(CEIL_DIV(int_height, SH_CSS_MORPH_TABLE_GRID) + 1)
-#define _ISP_MORPH_TABLE_ALIGNED_WIDTH(width) \
+#define _ISP_MORPH_TABLE_ALIGNED_WIDTH(width)   \
 	CEIL_MUL(_ISP_MORPH_TABLE_WIDTH(width), \
 		 SH_CSS_MORPH_TABLE_ELEMS_PER_DDR_WORD)
 
@@ -205,34 +205,36 @@ RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
 	(ISP_BQ_GRID_WIDTH(input_width, deci_factor_log2) + 1)
 #define _ISP_SCTBL_HEIGHT(input_height, deci_factor_log2) \
 	(ISP_BQ_GRID_HEIGHT(input_height, deci_factor_log2) + 1)
-#define _ISP_SCTBL_ALIGNED_WIDTH_PER_COLOR(input_width, deci_factor_log2) \
+#define _ISP_SCTBL_ALIGNED_WIDTH_PER_COLOR(input_width, deci_factor_log2)   \
 	CEIL_MUL(_ISP_SCTBL_WIDTH_PER_COLOR(input_width, deci_factor_log2), \
 		 ISP_VEC_NELEMS)
 
 /* To position the shading center grid point on the center of output image,
  * one more grid cell is needed as margin. */
-#define SH_CSS_SCTBL_CENTERING_MARGIN	1
+#define SH_CSS_SCTBL_CENTERING_MARGIN 1
 
 /* The shading table width and height are the number of grids, not cells. The last grid should be counted. */
-#define SH_CSS_SCTBL_LAST_GRID_COUNT	1
+#define SH_CSS_SCTBL_LAST_GRID_COUNT 1
 
 /* Number of horizontal grids per color in the shading table. */
 #define _ISP2401_SCTBL_WIDTH_PER_COLOR(input_width, deci_factor_log2) \
-	(ISP_BQ_GRID_WIDTH(input_width, deci_factor_log2) + \
-	SH_CSS_SCTBL_CENTERING_MARGIN + SH_CSS_SCTBL_LAST_GRID_COUNT)
+	(ISP_BQ_GRID_WIDTH(input_width, deci_factor_log2) +           \
+	 SH_CSS_SCTBL_CENTERING_MARGIN + SH_CSS_SCTBL_LAST_GRID_COUNT)
 
 /* Number of vertical grids per color in the shading table. */
 #define _ISP2401_SCTBL_HEIGHT(input_height, deci_factor_log2) \
 	(ISP_BQ_GRID_HEIGHT(input_height, deci_factor_log2) + \
-	SH_CSS_SCTBL_CENTERING_MARGIN + SH_CSS_SCTBL_LAST_GRID_COUNT)
+	 SH_CSS_SCTBL_CENTERING_MARGIN + SH_CSS_SCTBL_LAST_GRID_COUNT)
 
 /* ISP2401: Legacy API: Number of horizontal grids per color in the shading table. */
 #define _ISP_SCTBL_LEGACY_WIDTH_PER_COLOR(input_width, deci_factor_log2) \
-	(ISP_BQ_GRID_WIDTH(input_width, deci_factor_log2) + SH_CSS_SCTBL_LAST_GRID_COUNT)
+	(ISP_BQ_GRID_WIDTH(input_width, deci_factor_log2) +              \
+	 SH_CSS_SCTBL_LAST_GRID_COUNT)
 
 /* ISP2401: Legacy API: Number of vertical grids per color in the shading table. */
 #define _ISP_SCTBL_LEGACY_HEIGHT(input_height, deci_factor_log2) \
-	(ISP_BQ_GRID_HEIGHT(input_height, deci_factor_log2) + SH_CSS_SCTBL_LAST_GRID_COUNT)
+	(ISP_BQ_GRID_HEIGHT(input_height, deci_factor_log2) +    \
+	 SH_CSS_SCTBL_LAST_GRID_COUNT)
 
 /* *****************************************************************
  * Statistics for 3A (Auto Focus, Auto White Balance, Auto Exposure)
@@ -249,11 +251,10 @@ RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
 	CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2)
 #define _ISP_S3ATBL_ISP_HEIGHT(in_height, deci_factor_log2) \
 	CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)
-#define ISP_S3ATBL_VECTORS \
-	_ISP_VECS(SH_CSS_MAX_S3ATBL_WIDTH * \
-		  (sizeof(struct ia_css_3a_output) / sizeof(int32_t)))
-#define ISP_S3ATBL_HI_LO_STRIDE \
-	(ISP_S3ATBL_VECTORS * ISP_VEC_NELEMS)
+#define ISP_S3ATBL_VECTORS                                                    \
+	_ISP_VECS(SH_CSS_MAX_S3ATBL_WIDTH *(sizeof(struct ia_css_3a_output) / \
+					    sizeof(int32_t)))
+#define ISP_S3ATBL_HI_LO_STRIDE (ISP_S3ATBL_VECTORS * ISP_VEC_NELEMS)
 #define ISP_S3ATBL_HI_LO_STRIDE_BYTES \
 	(sizeof(unsigned short) * ISP_S3ATBL_HI_LO_STRIDE)
 
@@ -264,7 +265,7 @@ RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
 #define __ISP_VF_OUTPUT_WIDTH_VECS(out_width, vf_log_downscale) \
 	(_ISP_VECS((out_width) >> (vf_log_downscale)))
 
-#define _ISP_VF_OUTPUT_WIDTH(vf_out_vecs) ((vf_out_vecs) * ISP_VEC_NELEMS)
+#define _ISP_VF_OUTPUT_WIDTH(vf_out_vecs) ((vf_out_vecs)*ISP_VEC_NELEMS)
 #define _ISP_VF_OUTPUT_HEIGHT(out_height, vf_log_ds) \
 	((out_height) >> (vf_log_ds))
 
@@ -273,13 +274,14 @@ RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
 
 /* It is preferred to have not more than 2x scaling at one step
  * in GDC (assumption is for capture_pp and yuv_scale stages) */
-#define MAX_PREFERRED_YUV_DS_PER_STEP	2
+#define MAX_PREFERRED_YUV_DS_PER_STEP 2
 
 /* Rules for computing the internal width. This is extremely complicated
  * and definitely needs to be commented and explained. */
-#define _ISP_LEFT_CROP_EXTRA(left_crop) ((left_crop) > 0 ? 2 * ISP_VEC_NELEMS : 0)
+#define _ISP_LEFT_CROP_EXTRA(left_crop) \
+	((left_crop) > 0 ? 2 * ISP_VEC_NELEMS : 0)
 
-#define __ISP_MIN_INTERNAL_WIDTH(num_chunks, pipelining, mode) \
+#define __ISP_MIN_INTERNAL_WIDTH(num_chunks, pipelining, mode)             \
 	((num_chunks) * (pipelining) * (1 << _ISP_LOG_VECTOR_STEP(mode)) * \
 	 ISP_VEC_NELEMS)
 
@@ -290,25 +292,15 @@ RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
 	((1 << _ISP_LOG_VECTOR_STEP(mode)) * ISP_VEC_NELEMS)
 
 #define __ISP_CHUNK_STRIDE_DDR(c_subsampling, num_chunks) \
-	((c_subsampling) * (num_chunks) * HIVE_ISP_DDR_WORD_BYTES)
-#define __ISP_INTERNAL_WIDTH(out_width, \
-			     dvs_env_width, \
-			     left_crop, \
-			     mode, \
-			     c_subsampling, \
-			     num_chunks, \
-			     pipelining) \
-	CEIL_MUL2(CEIL_MUL2(MAX(__ISP_PADDED_OUTPUT_WIDTH(out_width, \
-							    dvs_env_width, \
-							    left_crop), \
-				  __ISP_MIN_INTERNAL_WIDTH(num_chunks, \
-							   pipelining, \
-							   mode) \
-				 ), \
-			  __ISP_CHUNK_STRIDE_ISP(mode) \
-			 ), \
-		 __ISP_CHUNK_STRIDE_DDR(c_subsampling, num_chunks) \
-		)
+	((c_subsampling) * (num_chunks)*HIVE_ISP_DDR_WORD_BYTES)
+#define __ISP_INTERNAL_WIDTH(out_width, dvs_env_width, left_crop, mode,       \
+			     c_subsampling, num_chunks, pipelining)           \
+	CEIL_MUL2(CEIL_MUL2(MAX(__ISP_PADDED_OUTPUT_WIDTH(                    \
+					out_width, dvs_env_width, left_crop), \
+				__ISP_MIN_INTERNAL_WIDTH(num_chunks,          \
+							 pipelining, mode)),  \
+			    __ISP_CHUNK_STRIDE_ISP(mode)),                    \
+		  __ISP_CHUNK_STRIDE_DDR(c_subsampling, num_chunks))
 
 #define __ISP_INTERNAL_HEIGHT(out_height, dvs_env_height, top_crop) \
 	((out_height) + (dvs_env_height) + top_crop)
@@ -317,30 +309,29 @@ RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
  *	or raw binning is enabled.
  *	Also, during continuous mode, we need to align to 4*NWAY since input
  *	should support binning */
-#define _ISP_MAX_INPUT_WIDTH(max_internal_width, enable_ds, enable_fixed_bayer_ds, enable_raw_bin, \
-				enable_continuous) \
-	((enable_ds) ? \
-	   SH_CSS_MAX_SENSOR_WIDTH :\
-	 (enable_fixed_bayer_ds) ? \
-	   CEIL_MUL(SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC, 4 * ISP_VEC_NELEMS) : \
-	 (enable_raw_bin) ? \
-	   CEIL_MUL(SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH, 4 * ISP_VEC_NELEMS) : \
-	 (enable_continuous) ? \
-	   SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH \
-	   : max_internal_width)
+#define _ISP_MAX_INPUT_WIDTH(max_internal_width, enable_ds,                 \
+			     enable_fixed_bayer_ds, enable_raw_bin,         \
+			     enable_continuous)                             \
+	((enable_ds) ? SH_CSS_MAX_SENSOR_WIDTH :                            \
+	 (enable_fixed_bayer_ds) ?                                          \
+		       CEIL_MUL(SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC,     \
+				4 * ISP_VEC_NELEMS) :                       \
+	 (enable_raw_bin)    ? CEIL_MUL(SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH, \
+					4 * ISP_VEC_NELEMS) :               \
+	 (enable_continuous) ? SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH :         \
+			       max_internal_width)
 
 #define _ISP_INPUT_WIDTH(internal_width, ds_input_width, enable_ds) \
 	((enable_ds) ? (ds_input_width) : (internal_width))
 
-#define _ISP_MAX_INPUT_HEIGHT(max_internal_height, enable_ds, enable_fixed_bayer_ds, enable_raw_bin, \
-				enable_continuous) \
-	((enable_ds) ? \
-	   SH_CSS_MAX_SENSOR_HEIGHT :\
-	 (enable_fixed_bayer_ds) ? \
-	   SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC : \
-	 (enable_raw_bin || enable_continuous) ? \
-	   SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT \
-	   : max_internal_height)
+#define _ISP_MAX_INPUT_HEIGHT(max_internal_height, enable_ds,                \
+			      enable_fixed_bayer_ds, enable_raw_bin,         \
+			      enable_continuous)                             \
+	((enable_ds)		 ? SH_CSS_MAX_SENSOR_HEIGHT :                \
+	 (enable_fixed_bayer_ds) ? SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC : \
+	 (enable_raw_bin || enable_continuous) ?                             \
+				   SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT :     \
+				   max_internal_height)
 
 #define _ISP_INPUT_HEIGHT(internal_height, ds_input_height, enable_ds) \
 	((enable_ds) ? (ds_input_height) : (internal_height))
diff --git a/drivers/staging/media/atomisp/pci/sh_css_firmware.c b/drivers/staging/media/atomisp/pci/sh_css_firmware.c
index bed5992237175a4a1641ce1ddd4681c9e41fc33c..631d465e328b77e164f78a4a8ee9241af6025b63 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_firmware.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_firmware.c
@@ -21,7 +21,7 @@
 
 #include "assert_support.h"
 
-#include "isp.h"				/* PMEM_WIDTH_LOG2 */
+#include "isp.h" /* PMEM_WIDTH_LOG2 */
 
 #include "ia_css_isp_params.h"
 #include "ia_css_isp_configs.h"
@@ -32,7 +32,7 @@
 
 struct firmware_header {
 	struct sh_css_fw_bi_file_h file_header;
-	struct ia_css_fw_info      binary_header;
+	struct ia_css_fw_info binary_header;
 };
 
 struct fw_param {
@@ -47,13 +47,15 @@ static struct firmware_header *firmware_header;
  * which will be replaced with the actual RELEASE_VERSION
  * during package generation. Please do not modify
  */
-static const char *release_version_2401 = STR(irci_stable_candrpv_0415_20150521_0458);
-static const char *release_version_2400 = STR(irci_stable_candrpv_0415_20150423_1753);
+static const char *release_version_2401 =
+	STR(irci_stable_candrpv_0415_20150521_0458);
+static const char *release_version_2400 =
+	STR(irci_stable_candrpv_0415_20150423_1753);
 
-#define MAX_FW_REL_VER_NAME	300
+#define MAX_FW_REL_VER_NAME 300
 static char FW_rel_ver_name[MAX_FW_REL_VER_NAME] = "---";
 
-struct ia_css_fw_info	  sh_css_sp_fw;
+struct ia_css_fw_info sh_css_sp_fw;
 struct ia_css_blob_descr *sh_css_blob_info; /* Only ISP blob info (no SP) */
 unsigned int sh_css_num_binaries; /* This includes 1 SP binary */
 
@@ -69,9 +71,9 @@ char *sh_css_get_fw_version(void)
  */
 
 /* Setup sp/sp1 binary */
-static int
-setup_binary(struct ia_css_fw_info *fw, const char *fw_data,
-	     struct ia_css_fw_info *sh_css_fw, unsigned int binary_id)
+static int setup_binary(struct ia_css_fw_info *fw, const char *fw_data,
+			struct ia_css_fw_info *sh_css_fw,
+			unsigned int binary_id)
 {
 	const char *blob_data;
 
@@ -87,16 +89,15 @@ setup_binary(struct ia_css_fw_info *fw, const char *fw_data,
 		return -ENOMEM;
 
 	memcpy((void *)sh_css_fw->blob.code, blob_data, fw->blob.size);
-	sh_css_fw->blob.data = (char *)sh_css_fw->blob.code + fw->blob.data_source;
+	sh_css_fw->blob.data =
+		(char *)sh_css_fw->blob.code + fw->blob.data_source;
 	fw_minibuffer[binary_id].buffer = sh_css_fw->blob.code;
 
 	return 0;
 }
 
-int
-sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi,
-		      struct ia_css_blob_descr *bd,
-		      unsigned int index)
+int sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi,
+			  struct ia_css_blob_descr *bd, unsigned int index)
 {
 	const char *name;
 	const unsigned char *blob;
@@ -112,9 +113,9 @@ sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi,
 	blob = (const unsigned char *)fw + bi->blob.offset;
 
 	/* sanity check */
-	if (bi->blob.size !=
-		bi->blob.text_size + bi->blob.icache_size +
-			bi->blob.data_size + bi->blob.padding_size) {
+	if (bi->blob.size != bi->blob.text_size + bi->blob.icache_size +
+				     bi->blob.data_size +
+				     bi->blob.padding_size) {
 		/* sanity check, note the padding bytes added for section to DDR alignment */
 		return -EINVAL;
 	}
@@ -138,11 +139,13 @@ sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi,
 
 	if (bi->type == ia_css_isp_firmware) {
 		size_t paramstruct_size = sizeof(struct ia_css_memory_offsets);
-		size_t configstruct_size = sizeof(struct ia_css_config_memory_offsets);
-		size_t statestruct_size = sizeof(struct ia_css_state_memory_offsets);
+		size_t configstruct_size =
+			sizeof(struct ia_css_config_memory_offsets);
+		size_t statestruct_size =
+			sizeof(struct ia_css_state_memory_offsets);
 
 		char *parambuf = kmalloc(paramstruct_size + configstruct_size +
-					 statestruct_size,
+						 statestruct_size,
 					 GFP_KERNEL);
 		if (!parambuf)
 			return -ENOMEM;
@@ -154,30 +157,35 @@ sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi,
 		fw_minibuffer[index].buffer = parambuf;
 
 		/* copy ia_css_memory_offsets */
-		memcpy(parambuf, (void *)(fw +
-					  bi->blob.memory_offsets.offsets[IA_CSS_PARAM_CLASS_PARAM]),
+		memcpy(parambuf,
+		       (void *)(fw +
+				bi->blob.memory_offsets
+					.offsets[IA_CSS_PARAM_CLASS_PARAM]),
 		       paramstruct_size);
 		bd->mem_offsets.array[IA_CSS_PARAM_CLASS_PARAM].ptr = parambuf;
 
 		/* copy ia_css_config_memory_offsets */
 		memcpy(parambuf + paramstruct_size,
-		       (void *)(fw + bi->blob.memory_offsets.offsets[IA_CSS_PARAM_CLASS_CONFIG]),
+		       (void *)(fw +
+				bi->blob.memory_offsets
+					.offsets[IA_CSS_PARAM_CLASS_CONFIG]),
 		       configstruct_size);
-		bd->mem_offsets.array[IA_CSS_PARAM_CLASS_CONFIG].ptr = parambuf +
-		paramstruct_size;
+		bd->mem_offsets.array[IA_CSS_PARAM_CLASS_CONFIG].ptr =
+			parambuf + paramstruct_size;
 
 		/* copy ia_css_state_memory_offsets */
 		memcpy(parambuf + paramstruct_size + configstruct_size,
-		       (void *)(fw + bi->blob.memory_offsets.offsets[IA_CSS_PARAM_CLASS_STATE]),
+		       (void *)(fw +
+				bi->blob.memory_offsets
+					.offsets[IA_CSS_PARAM_CLASS_STATE]),
 		       statestruct_size);
-		bd->mem_offsets.array[IA_CSS_PARAM_CLASS_STATE].ptr = parambuf +
-		paramstruct_size + configstruct_size;
+		bd->mem_offsets.array[IA_CSS_PARAM_CLASS_STATE].ptr =
+			parambuf + paramstruct_size + configstruct_size;
 	}
 	return 0;
 }
 
-bool
-sh_css_check_firmware_version(struct device *dev, const char *fw_data)
+bool sh_css_check_firmware_version(struct device *dev, const char *fw_data)
 {
 	const char *release_version;
 	struct sh_css_fw_bi_file_h *file_header;
@@ -191,7 +199,8 @@ sh_css_check_firmware_version(struct device *dev, const char *fw_data)
 	file_header = &firmware_header->file_header;
 
 	if (strcmp(file_header->version, release_version) != 0) {
-		dev_err(dev, "Firmware version may not be compatible with this driver\n");
+		dev_err(dev,
+			"Firmware version may not be compatible with this driver\n");
 		dev_err(dev, "Expecting version '%s', but firmware is '%s'.\n",
 			release_version, file_header->version);
 	}
@@ -200,23 +209,22 @@ sh_css_check_firmware_version(struct device *dev, const char *fw_data)
 	return false;
 }
 
-static const char * const fw_type_name[] = {
-	[ia_css_sp_firmware]		= "SP",
-	[ia_css_isp_firmware]		= "ISP",
-	[ia_css_bootloader_firmware]	= "BootLoader",
-	[ia_css_acc_firmware]		= "accel",
+static const char *const fw_type_name[] = {
+	[ia_css_sp_firmware] = "SP",
+	[ia_css_isp_firmware] = "ISP",
+	[ia_css_bootloader_firmware] = "BootLoader",
+	[ia_css_acc_firmware] = "accel",
 };
 
-static const char * const fw_acc_type_name[] = {
-	[IA_CSS_ACC_NONE] =		"Normal",
-	[IA_CSS_ACC_OUTPUT] =		"Accel for output",
-	[IA_CSS_ACC_VIEWFINDER] =	"Accel for viewfinder",
-	[IA_CSS_ACC_STANDALONE] =	"Stand-alone accel",
+static const char *const fw_acc_type_name[] = {
+	[IA_CSS_ACC_NONE] = "Normal",
+	[IA_CSS_ACC_OUTPUT] = "Accel for output",
+	[IA_CSS_ACC_VIEWFINDER] = "Accel for viewfinder",
+	[IA_CSS_ACC_STANDALONE] = "Stand-alone accel",
 };
 
-int
-sh_css_load_firmware(struct device *dev, const char *fw_data,
-		     unsigned int fw_size)
+int sh_css_load_firmware(struct device *dev, const char *fw_data,
+			 unsigned int fw_size)
 {
 	unsigned int i;
 	const char *release_version;
@@ -243,19 +251,21 @@ sh_css_load_firmware(struct device *dev, const char *fw_data,
 		release_version = release_version_2400;
 	ret = sh_css_check_firmware_version(dev, fw_data);
 	if (ret) {
-		IA_CSS_ERROR("CSS code version (%s) and firmware version (%s) mismatch!",
-			     file_header->version, release_version);
+		IA_CSS_ERROR(
+			"CSS code version (%s) and firmware version (%s) mismatch!",
+			file_header->version, release_version);
 		return -EINVAL;
 	} else {
-		IA_CSS_LOG("successfully load firmware version %s", release_version);
+		IA_CSS_LOG("successfully load firmware version %s",
+			   release_version);
 	}
 
 	sh_css_num_binaries = file_header->binary_nr;
 	/* Only allocate memory for ISP blob info */
 	if (sh_css_num_binaries > NUM_OF_SPS) {
-		sh_css_blob_info = kmalloc(
-		    (sh_css_num_binaries - NUM_OF_SPS) *
-		    sizeof(*sh_css_blob_info), GFP_KERNEL);
+		sh_css_blob_info = kmalloc((sh_css_num_binaries - NUM_OF_SPS) *
+						   sizeof(*sh_css_blob_info),
+					   GFP_KERNEL);
 		if (!sh_css_blob_info)
 			return -ENOMEM;
 	} else {
@@ -295,19 +305,15 @@ sh_css_load_firmware(struct device *dev, const char *fw_data,
 
 			dev_dbg(dev,
 				"binary #%-2d type %s (%s), binary id is %2d: %s\n",
-				i,
-				fw_type_name[bd.header.type],
+				i, fw_type_name[bd.header.type],
 				fw_acc_type_name[bd.header.info.isp.type],
-				bd.header.info.isp.sp.id,
-				bd.name);
+				bd.header.info.isp.sp.id, bd.name);
 			break;
 		case ia_css_sp_firmware:
 		case ia_css_bootloader_firmware:
 		case ia_css_acc_firmware:
-			dev_dbg(dev,
-				"binary #%-2d type %s: %s\n",
-				i, fw_type_name[bd.header.type],
-				bd.name);
+			dev_dbg(dev, "binary #%-2d type %s: %s\n", i,
+				fw_type_name[bd.header.type], bd.name);
 			break;
 		default:
 			if (bd.header.info.isp.type > IA_CSS_ACC_STANDALONE) {
@@ -366,8 +372,7 @@ void sh_css_unload_firmware(void)
 	sh_css_num_binaries = 0;
 }
 
-ia_css_ptr
-sh_css_load_blob(const unsigned char *blob, unsigned int size)
+ia_css_ptr sh_css_load_blob(const unsigned char *blob, unsigned int size)
 {
 	ia_css_ptr target_addr = hmm_alloc(size);
 	/*
diff --git a/drivers/staging/media/atomisp/pci/sh_css_firmware.h b/drivers/staging/media/atomisp/pci/sh_css_firmware.h
index 1c6bc29f68d5e3da4ab16e2c6e440fe48b570acf..1d9b8e6ca03bb648df49fb705335efa9abc8b5e7 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_firmware.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_firmware.h
@@ -13,33 +13,29 @@
 #include <ia_css_acc_types.h>
 
 /* This is for the firmware loaded from user space */
-struct  sh_css_fw_bi_file_h {
-	char version[64];		/* branch tag + week day + time */
-	int binary_nr;			/* Number of binaries */
-	unsigned int h_size;		/* sizeof(struct sh_css_fw_bi_file_h) */
+struct sh_css_fw_bi_file_h {
+	char version[64]; /* branch tag + week day + time */
+	int binary_nr; /* Number of binaries */
+	unsigned int h_size; /* sizeof(struct sh_css_fw_bi_file_h) */
 };
 
-extern struct ia_css_fw_info     sh_css_sp_fw;
+extern struct ia_css_fw_info sh_css_sp_fw;
 extern struct ia_css_blob_descr *sh_css_blob_info;
 extern unsigned int sh_css_num_binaries;
 
-char
-*sh_css_get_fw_version(void);
+char *sh_css_get_fw_version(void);
 
 struct device;
-bool
-sh_css_check_firmware_version(struct device *dev, const char *fw_data);
+bool sh_css_check_firmware_version(struct device *dev, const char *fw_data);
 
-int
-sh_css_load_firmware(struct device *dev, const char *fw_data,
-		     unsigned int fw_size);
+int sh_css_load_firmware(struct device *dev, const char *fw_data,
+			 unsigned int fw_size);
 
 void sh_css_unload_firmware(void);
 
 ia_css_ptr sh_css_load_blob(const unsigned char *blob, unsigned int size);
 
-int
-sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi,
-		      struct ia_css_blob_descr *bd, unsigned int i);
+int sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi,
+			  struct ia_css_blob_descr *bd, unsigned int i);
 
 #endif /* _SH_CSS_FIRMWARE_H_ */
diff --git a/drivers/staging/media/atomisp/pci/sh_css_frac.h b/drivers/staging/media/atomisp/pci/sh_css_frac.h
index c2cf244ac06ee1f8337cd7ab6ac902656b3e571b..ddb10322a5b676e212e1d25b2e15717b2f218a97 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_frac.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_frac.h
@@ -11,16 +11,16 @@
 
 #include "mamoiada_params.h"
 
-#define sISP_REG_BIT		      ISP_VEC_ELEMBITS
-#define uISP_REG_BIT		      ((unsigned int)(sISP_REG_BIT - 1))
-#define sSHIFT				    (16 - sISP_REG_BIT)
-#define uSHIFT				    ((unsigned int)(16 - uISP_REG_BIT))
+#define sISP_REG_BIT ISP_VEC_ELEMBITS
+#define uISP_REG_BIT ((unsigned int)(sISP_REG_BIT - 1))
+#define sSHIFT (16 - sISP_REG_BIT)
+#define uSHIFT ((unsigned int)(16 - uISP_REG_BIT))
 #define sFRACTION_BITS_FITTING(a) (a - sSHIFT)
 #define uFRACTION_BITS_FITTING(a) ((unsigned int)(a - uSHIFT))
-#define sISP_VAL_MIN		      (-(1 << uISP_REG_BIT))
-#define sISP_VAL_MAX		      ((1 << uISP_REG_BIT) - 1)
-#define uISP_VAL_MIN		      (0U)
-#define uISP_VAL_MAX		      ((unsigned int)((1 << uISP_REG_BIT) - 1))
+#define sISP_VAL_MIN (-(1 << uISP_REG_BIT))
+#define sISP_VAL_MAX ((1 << uISP_REG_BIT) - 1)
+#define uISP_VAL_MIN (0U)
+#define uISP_VAL_MAX ((unsigned int)((1 << uISP_REG_BIT) - 1))
 
 /* a:fraction bits for 16bit precision, b:fraction bits for ISP precision */
 static inline int sDIGIT_FITTING(int v, int a, int b)
diff --git a/drivers/staging/media/atomisp/pci/sh_css_host_data.c b/drivers/staging/media/atomisp/pci/sh_css_host_data.c
index 39efd8933034d636a4fa6185a4b8f67b22715a1f..89ed55a73863f20acaaf82139a0d20705a69b27c 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_host_data.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_host_data.c
@@ -12,7 +12,7 @@ struct ia_css_host_data *ia_css_host_data_allocate(size_t size)
 {
 	struct ia_css_host_data *me;
 
-	me =  kmalloc(sizeof(struct ia_css_host_data), GFP_KERNEL);
+	me = kmalloc(sizeof(struct ia_css_host_data), GFP_KERNEL);
 	if (!me)
 		return NULL;
 	me->size = (uint32_t)size;
diff --git a/drivers/staging/media/atomisp/pci/sh_css_hrt.c b/drivers/staging/media/atomisp/pci/sh_css_hrt.c
index d4633572f8f39a5644cb34ab7e0a82b17044a296..4aee36a4d8341655b1235f81d4d67a7b1d1f0b87 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_hrt.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_hrt.c
@@ -55,7 +55,7 @@ bool sh_css_hrt_system_is_idle(void)
 
 int sh_css_hrt_sp_wait(void)
 {
-	irq_sw_channel_id_t	irq_id = IRQ_SW_CHANNEL0_ID;
+	irq_sw_channel_id_t irq_id = IRQ_SW_CHANNEL0_ID;
 	/*
 	 * Wait till SP is idle or till there is a SW2 interrupt
 	 * The SW2 interrupt will be used when frameloop runs on SP
@@ -63,8 +63,7 @@ int sh_css_hrt_sp_wait(void)
 	 * (e.g. frame_done)
 	 */
 	while (!sp_ctrl_getbit(SP0_ID, SP_SC_REG, SP_IDLE_BIT) &&
-	       ((irq_reg_load(IRQ0_ID,
-			      _HRT_IRQ_CONTROLLER_STATUS_REG_IDX) &
+	       ((irq_reg_load(IRQ0_ID, _HRT_IRQ_CONTROLLER_STATUS_REG_IDX) &
 		 (1U << (irq_id + IRQ_SW_CHANNEL_OFFSET))) == 0)) {
 		udelay(1);
 	}
diff --git a/drivers/staging/media/atomisp/pci/sh_css_internal.h b/drivers/staging/media/atomisp/pci/sh_css_internal.h
index 7b34835857484436bf6c1e3934c149ce2f897984..c22d656ab335eddfb6a5b387580cf0bb304c189e 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_internal.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_internal.h
@@ -27,7 +27,7 @@
 #include "sh_css_legacy.h"
 #include "sh_css_defs.h"
 #include "sh_css_uds.h"
-#include "dma.h"	/* N_DMA_CHANNEL_ID */
+#include "dma.h" /* N_DMA_CHANNEL_ID */
 #include "ia_css_circbuf_comm.h" /* Circular buffer */
 #include "ia_css_frame_comm.h"
 #include "ia_css_3a.h"
@@ -37,27 +37,27 @@
 #include "ia_css_timer.h"
 
 /* TODO: Move to a more suitable place when sp pipeline design is done. */
-#define IA_CSS_NUM_CB_SEM_READ_RESOURCE	2
-#define IA_CSS_NUM_CB_SEM_WRITE_RESOURCE	1
-#define IA_CSS_NUM_CBS						2
-#define IA_CSS_CB_MAX_ELEMS					2
+#define IA_CSS_NUM_CB_SEM_READ_RESOURCE 2
+#define IA_CSS_NUM_CB_SEM_WRITE_RESOURCE 1
+#define IA_CSS_NUM_CBS 2
+#define IA_CSS_CB_MAX_ELEMS 2
 
 /* Use case specific. index limited to IA_CSS_NUM_CB_SEM_READ_RESOURCE or
  * IA_CSS_NUM_CB_SEM_WRITE_RESOURCE for read and write respectively.
  * TODO: Enforce the limitation above.
 */
-#define IA_CSS_COPYSINK_SEM_INDEX	0
-#define IA_CSS_TAGGER_SEM_INDEX	1
+#define IA_CSS_COPYSINK_SEM_INDEX 0
+#define IA_CSS_TAGGER_SEM_INDEX 1
 
 /* Force generation of output event. Used by acceleration pipe. */
-#define IA_CSS_POST_OUT_EVENT_FORCE		2
+#define IA_CSS_POST_OUT_EVENT_FORCE 2
 
-#define SH_CSS_MAX_BINARY_NAME	64
+#define SH_CSS_MAX_BINARY_NAME 64
 
-#define SP_DEBUG_NONE	(0)
-#define SP_DEBUG_DUMP	(1)
-#define SP_DEBUG_COPY	(2)
-#define SP_DEBUG_TRACE	(3)
+#define SP_DEBUG_NONE (0)
+#define SP_DEBUG_DUMP (1)
+#define SP_DEBUG_COPY (2)
+#define SP_DEBUG_TRACE (3)
 #define SP_DEBUG_MINIMAL (4)
 
 #define SP_DEBUG SP_DEBUG_NONE
@@ -67,17 +67,19 @@
 #define SH_CSS_REF_BIT_DEPTH 8
 
 /* keep next up to date with the definition for MAX_CB_ELEMS_FOR_TAGGER in tagger.sp.c */
-#define NUM_CONTINUOUS_FRAMES	15
-#define NUM_MIPI_FRAMES_PER_STREAM		2
+#define NUM_CONTINUOUS_FRAMES 15
+#define NUM_MIPI_FRAMES_PER_STREAM 2
 
-#define NUM_ONLINE_INIT_CONTINUOUS_FRAMES      2
+#define NUM_ONLINE_INIT_CONTINUOUS_FRAMES 2
 
-#define NR_OF_PIPELINES			IA_CSS_PIPE_ID_NUM /* Must match with IA_CSS_PIPE_ID_NUM */
+#define NR_OF_PIPELINES \
+	IA_CSS_PIPE_ID_NUM /* Must match with IA_CSS_PIPE_ID_NUM */
 
-#define SH_CSS_MAX_IF_CONFIGS	3 /* Must match with IA_CSS_NR_OF_CONFIGS (not defined yet).*/
-#define SH_CSS_IF_CONFIG_NOT_NEEDED	0xFF
+#define SH_CSS_MAX_IF_CONFIGS \
+	3 /* Must match with IA_CSS_NR_OF_CONFIGS (not defined yet).*/
+#define SH_CSS_IF_CONFIG_NOT_NEEDED 0xFF
 
-#define SH_CSS_MAX_SP_THREADS		5
+#define SH_CSS_MAX_SP_THREADS 5
 
 /**
  * The C99 standard does not specify the exact object representation of structs;
@@ -95,8 +97,8 @@
  * the SIZE_OF_XXX macro of the corresponding struct. If they are not
  * equal, functionality will break.
  */
-#define CALC_ALIGNMENT_MEMBER(x, y)	(CEIL_MUL(x, y) - x)
-#define SIZE_OF_HRT_VADDRESS		sizeof(hive_uint32)
+#define CALC_ALIGNMENT_MEMBER(x, y) (CEIL_MUL(x, y) - x)
+#define SIZE_OF_HRT_VADDRESS sizeof(hive_uint32)
 
 /* Number of SP's */
 #define NUM_OF_SPS 1
@@ -104,18 +106,15 @@
 #define NUM_OF_BLS 0
 
 /* Enum for order of Binaries */
-enum sh_css_order_binaries {
-	SP_FIRMWARE = 0,
-	ISP_FIRMWARE
-};
+enum sh_css_order_binaries { SP_FIRMWARE = 0, ISP_FIRMWARE };
 
 /*
 * JB: keep next enum in sync with thread id's
 * and pipe id's
 */
 enum sh_css_pipe_config_override {
-	SH_CSS_PIPE_CONFIG_OVRD_NONE     = 0,
-	SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD  = 0xffff
+	SH_CSS_PIPE_CONFIG_OVRD_NONE = 0,
+	SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD = 0xffff
 };
 
 enum host2sp_commands {
@@ -129,9 +128,9 @@ enum host2sp_commands {
 	 */
 	host2sp_cmd_ready = 1,
 	/* Command written by the Host */
-	host2sp_cmd_dummy,		/* No action, can be used as watchdog */
-	host2sp_cmd_start_flash,	/* Request SP to start the flash */
-	host2sp_cmd_terminate,		/* SP should terminate itself */
+	host2sp_cmd_dummy, /* No action, can be used as watchdog */
+	host2sp_cmd_start_flash, /* Request SP to start the flash */
+	host2sp_cmd_terminate, /* SP should terminate itself */
 	N_host2sp_cmd
 };
 
@@ -161,7 +160,7 @@ enum sh_css_sp_event_type {
 	SH_CSS_SP_EVENT_PORT_EOF,
 	SH_CSS_SP_EVENT_FW_WARNING,
 	SH_CSS_SP_EVENT_FW_ASSERT,
-	SH_CSS_SP_EVENT_NR_OF_TYPES		/* must be last */
+	SH_CSS_SP_EVENT_NR_OF_TYPES /* must be last */
 };
 
 /* xmem address map allocation per pipeline, css pointers */
@@ -189,12 +188,13 @@ struct sh_css_ddr_address_map {
 	ia_css_ptr dvs_6axis_params_y;
 };
 
-#define SIZE_OF_SH_CSS_DDR_ADDRESS_MAP_STRUCT					\
-	(SIZE_OF_HRT_VADDRESS +							\
-	(SH_CSS_MAX_STAGES * IA_CSS_NUM_MEMORIES * SIZE_OF_HRT_VADDRESS) +	\
-	(16 * SIZE_OF_HRT_VADDRESS))
+#define SIZE_OF_SH_CSS_DDR_ADDRESS_MAP_STRUCT                               \
+	(SIZE_OF_HRT_VADDRESS +                                             \
+	 (SH_CSS_MAX_STAGES * IA_CSS_NUM_MEMORIES * SIZE_OF_HRT_VADDRESS) + \
+	 (16 * SIZE_OF_HRT_VADDRESS))
 
-static_assert(sizeof(struct sh_css_ddr_address_map) == SIZE_OF_SH_CSS_DDR_ADDRESS_MAP_STRUCT);
+static_assert(sizeof(struct sh_css_ddr_address_map) ==
+	      SIZE_OF_SH_CSS_DDR_ADDRESS_MAP_STRUCT);
 
 /* xmem address map allocation per pipeline */
 struct sh_css_ddr_address_map_size {
@@ -219,32 +219,32 @@ struct sh_css_ddr_address_map_size {
 };
 
 struct sh_css_ddr_address_map_compound {
-	struct sh_css_ddr_address_map		map;
-	struct sh_css_ddr_address_map_size	size;
+	struct sh_css_ddr_address_map map;
+	struct sh_css_ddr_address_map_size size;
 };
 
 struct ia_css_isp_parameter_set_info {
 	struct sh_css_ddr_address_map
-		mem_map;/** pointers to Parameters in ISP format IMPT:
+		mem_map; /** pointers to Parameters in ISP format IMPT:
 						    This should be first member of this struct */
-	u32
-	isp_parameters_id;/** Unique ID to track which config was actually applied to a particular frame */
+	u32 isp_parameters_id; /** Unique ID to track which config was actually applied to a particular frame */
 	ia_css_ptr
-	output_frame_ptr;/** Output frame to which this config has to be applied (optional) */
+		output_frame_ptr; /** Output frame to which this config has to be applied (optional) */
 };
 
 /* this struct contains all arguments that can be passed to
    a binary. It depends on the binary which ones are used. */
 struct sh_css_binary_args {
-	struct ia_css_frame *in_frame;	     /* input frame */
+	struct ia_css_frame *in_frame; /* input frame */
+	const struct ia_css_frame *delay_frames
+		[MAX_NUM_VIDEO_DELAY_FRAMES]; /* reference input frame */
 	const struct ia_css_frame
-		*delay_frames[MAX_NUM_VIDEO_DELAY_FRAMES];   /* reference input frame */
-	const struct ia_css_frame *tnr_frames[NUM_VIDEO_TNR_FRAMES];   /* tnr frames */
+		*tnr_frames[NUM_VIDEO_TNR_FRAMES]; /* tnr frames */
 	struct ia_css_frame
-		*out_frame[IA_CSS_BINARY_MAX_OUTPUT_PORTS];      /* output frame */
-	struct ia_css_frame *out_vf_frame;   /* viewfinder output frame */
-	bool                 copy_vf;
-	bool                 copy_output;
+		*out_frame[IA_CSS_BINARY_MAX_OUTPUT_PORTS]; /* output frame */
+	struct ia_css_frame *out_vf_frame; /* viewfinder output frame */
+	bool copy_vf;
+	bool copy_output;
 	unsigned int vf_downscale_log2;
 };
 
@@ -259,7 +259,7 @@ struct sh_css_sp_debug_state {
 
 #elif SP_DEBUG == SP_DEBUG_COPY
 
-#define SH_CSS_SP_DBG_TRACE_DEPTH	(40)
+#define SH_CSS_SP_DBG_TRACE_DEPTH (40)
 
 struct sh_css_sp_debug_trace {
 	u16 frame;
@@ -275,27 +275,26 @@ struct sh_css_sp_debug_state {
 	u16 if_cropped_height;
 	u16 if_cropped_width;
 	unsigned int index;
-	struct sh_css_sp_debug_trace
-		trace[SH_CSS_SP_DBG_TRACE_DEPTH];
+	struct sh_css_sp_debug_trace trace[SH_CSS_SP_DBG_TRACE_DEPTH];
 };
 
 #elif SP_DEBUG == SP_DEBUG_TRACE
 
 /* Example of just one global trace */
-#define SH_CSS_SP_DBG_NR_OF_TRACES	(1)
-#define SH_CSS_SP_DBG_TRACE_DEPTH	(40)
+#define SH_CSS_SP_DBG_NR_OF_TRACES (1)
+#define SH_CSS_SP_DBG_TRACE_DEPTH (40)
 
 #define SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS (13)
 
 struct sh_css_sp_debug_trace {
 	u16 time_stamp;
-	u16 location;	/* bit 15..13 = file_id, 12..0 = line nr. */
+	u16 location; /* bit 15..13 = file_id, 12..0 = line nr. */
 	u32 data;
 };
 
 struct sh_css_sp_debug_state {
-	struct sh_css_sp_debug_trace
-		trace[SH_CSS_SP_DBG_NR_OF_TRACES][SH_CSS_SP_DBG_TRACE_DEPTH];
+	struct sh_css_sp_debug_trace trace[SH_CSS_SP_DBG_NR_OF_TRACES]
+					  [SH_CSS_SP_DBG_TRACE_DEPTH];
 	u16 index_last[SH_CSS_SP_DBG_NR_OF_TRACES];
 	u8 index[SH_CSS_SP_DBG_NR_OF_TRACES];
 };
@@ -328,9 +327,9 @@ struct sh_css_sp_debug_command {
 
 /* SP input formatter configuration.*/
 struct sh_css_sp_input_formatter_set {
-	u32				stream_format;
-	input_formatter_cfg_t	config_a;
-	input_formatter_cfg_t	config_b;
+	u32 stream_format;
+	input_formatter_cfg_t config_a;
+	input_formatter_cfg_t config_b;
 };
 
 #define IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT (3)
@@ -344,53 +343,51 @@ struct sh_css_sp_input_formatter_set {
  * Do NOT change this struct's layout or remove seemingly unused fields!
  */
 struct sh_css_sp_config {
-	u8			no_isp_sync; /* Signal host immediately after start */
-	u8			enable_raw_pool_locking; /** Enable Raw Buffer Locking for HALv3 Support */
-	u8			lock_all;
+	u8 no_isp_sync; /* Signal host immediately after start */
+	u8 enable_raw_pool_locking; /** Enable Raw Buffer Locking for HALv3 Support */
+	u8 lock_all;
 	/** If raw buffer locking is enabled, this flag indicates whether raw
 	     frames are locked when their EOF event is successfully sent to the
 	     host (true) or when they are passed to the preview/video pipe
 	     (false). */
 
-	 /*
+	/*
 	  * Note the fields below are only used on the ISP2400 not on the ISP2401,
 	  * sh_css_store_sp_group_to_ddr() skip copying these when run on the ISP2401.
 	  */
 	struct {
-		u8					a_changed;
-		u8					b_changed;
-		u8					isp_2ppc;
+		u8 a_changed;
+		u8 b_changed;
+		u8 isp_2ppc;
 		struct sh_css_sp_input_formatter_set
 			set[SH_CSS_MAX_IF_CONFIGS]; /* CSI-2 port is used as index. */
 	} input_formatter;
 
-	sync_generator_cfg_t	sync_gen;
-	tpg_cfg_t		tpg;
-	prbs_cfg_t		prbs;
-	input_system_cfg_t	input_circuit;
-	u8			input_circuit_cfg_changed;
-	u32			mipi_sizes_for_check[N_CSI_PORTS][IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT];
+	sync_generator_cfg_t sync_gen;
+	tpg_cfg_t tpg;
+	prbs_cfg_t prbs;
+	input_system_cfg_t input_circuit;
+	u8 input_circuit_cfg_changed;
+	u32 mipi_sizes_for_check[N_CSI_PORTS]
+				[IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT];
 	/* These last 2 fields are used on both the ISP2400 and the ISP2401 */
-	u8			enable_isys_event_queue;
-	u8			disable_cont_vf;
+	u8 enable_isys_event_queue;
+	u8 disable_cont_vf;
 };
 
-enum sh_css_stage_type {
-	SH_CSS_SP_STAGE_TYPE  = 0,
-	SH_CSS_ISP_STAGE_TYPE = 1
-};
+enum sh_css_stage_type { SH_CSS_SP_STAGE_TYPE = 0, SH_CSS_ISP_STAGE_TYPE = 1 };
 
 #define SH_CSS_NUM_STAGE_TYPES 2
 
-#define SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS	BIT(0)
+#define SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS BIT(0)
 #define SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS_MASK \
 	((SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << SH_CSS_MAX_SP_THREADS) - 1)
 
 struct sh_css_sp_pipeline_terminal {
 	union {
 		/* Input System 2401 */
-		virtual_input_system_stream_t
-		virtual_input_system_stream[IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH];
+		virtual_input_system_stream_t virtual_input_system_stream
+			[IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH];
 	} context;
 	/*
 	 * TODO
@@ -398,13 +395,13 @@ struct sh_css_sp_pipeline_terminal {
 	 */
 	union {
 		/* Input System 2401 */
-		virtual_input_system_stream_cfg_t
-		virtual_input_system_stream_cfg[IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH];
+		virtual_input_system_stream_cfg_t virtual_input_system_stream_cfg
+			[IA_CSS_STREAM_MAX_ISYS_STREAM_PER_CH];
 	} ctrl;
 };
 
 struct sh_css_sp_pipeline_io {
-	struct sh_css_sp_pipeline_terminal	input;
+	struct sh_css_sp_pipeline_terminal input;
 	/* pqiao: comment out temporarily to save dmem */
 	/*struct sh_css_sp_pipeline_terminal	output;*/
 };
@@ -414,41 +411,44 @@ struct sh_css_sp_pipeline_io {
  * Only when all streams are configured, the CSI RX is started for that port.
  */
 struct sh_css_sp_pipeline_io_status {
-	u32	active[N_INPUT_SYSTEM_CSI_PORT];	/** registered streams */
-	u32	running[N_INPUT_SYSTEM_CSI_PORT];	/** configured streams */
+	u32 active[N_INPUT_SYSTEM_CSI_PORT]; /** registered streams */
+	u32 running[N_INPUT_SYSTEM_CSI_PORT]; /** configured streams */
 };
 
-enum sh_css_port_dir {
-	SH_CSS_PORT_INPUT  = 0,
-	SH_CSS_PORT_OUTPUT  = 1
-};
+enum sh_css_port_dir { SH_CSS_PORT_INPUT = 0, SH_CSS_PORT_OUTPUT = 1 };
 
 enum sh_css_port_type {
-	SH_CSS_HOST_TYPE  = 0,
-	SH_CSS_COPYSINK_TYPE  = 1,
-	SH_CSS_TAGGERSINK_TYPE  = 2
+	SH_CSS_HOST_TYPE = 0,
+	SH_CSS_COPYSINK_TYPE = 1,
+	SH_CSS_TAGGERSINK_TYPE = 2
 };
 
 /* Pipe inout settings: output port on 7-4bits, input port on 3-0bits */
 #define SH_CSS_PORT_FLD_WIDTH_IN_BITS (4)
 #define SH_CSS_PORT_TYPE_BIT_FLD(pt) (0x1 << (pt))
 #define SH_CSS_PORT_FLD(pd) ((pd) ? SH_CSS_PORT_FLD_WIDTH_IN_BITS : 0)
-#define SH_CSS_PIPE_PORT_CONFIG_ON(p, pd, pt) ((p) |= (SH_CSS_PORT_TYPE_BIT_FLD(pt) << SH_CSS_PORT_FLD(pd)))
-#define SH_CSS_PIPE_PORT_CONFIG_OFF(p, pd, pt) ((p) &= ~(SH_CSS_PORT_TYPE_BIT_FLD(pt) << SH_CSS_PORT_FLD(pd)))
-#define SH_CSS_PIPE_PORT_CONFIG_SET(p, pd, pt, val) ((val) ? \
-		SH_CSS_PIPE_PORT_CONFIG_ON(p, pd, pt) : SH_CSS_PIPE_PORT_CONFIG_OFF(p, pd, pt))
-#define SH_CSS_PIPE_PORT_CONFIG_GET(p, pd, pt) ((p) & (SH_CSS_PORT_TYPE_BIT_FLD(pt) << SH_CSS_PORT_FLD(pd)))
-#define SH_CSS_PIPE_PORT_CONFIG_IS_CONTINUOUS(p) \
-	(!(SH_CSS_PIPE_PORT_CONFIG_GET(p, SH_CSS_PORT_INPUT, SH_CSS_HOST_TYPE) && \
-	   SH_CSS_PIPE_PORT_CONFIG_GET(p, SH_CSS_PORT_OUTPUT, SH_CSS_HOST_TYPE)))
-
-#define IA_CSS_ACQUIRE_ISP_POS	31
+#define SH_CSS_PIPE_PORT_CONFIG_ON(p, pd, pt) \
+	((p) |= (SH_CSS_PORT_TYPE_BIT_FLD(pt) << SH_CSS_PORT_FLD(pd)))
+#define SH_CSS_PIPE_PORT_CONFIG_OFF(p, pd, pt) \
+	((p) &= ~(SH_CSS_PORT_TYPE_BIT_FLD(pt) << SH_CSS_PORT_FLD(pd)))
+#define SH_CSS_PIPE_PORT_CONFIG_SET(p, pd, pt, val)      \
+	((val) ? SH_CSS_PIPE_PORT_CONFIG_ON(p, pd, pt) : \
+		 SH_CSS_PIPE_PORT_CONFIG_OFF(p, pd, pt))
+#define SH_CSS_PIPE_PORT_CONFIG_GET(p, pd, pt) \
+	((p) & (SH_CSS_PORT_TYPE_BIT_FLD(pt) << SH_CSS_PORT_FLD(pd)))
+#define SH_CSS_PIPE_PORT_CONFIG_IS_CONTINUOUS(p)              \
+	(!(SH_CSS_PIPE_PORT_CONFIG_GET(p, SH_CSS_PORT_INPUT,  \
+				       SH_CSS_HOST_TYPE) &&   \
+	   SH_CSS_PIPE_PORT_CONFIG_GET(p, SH_CSS_PORT_OUTPUT, \
+				       SH_CSS_HOST_TYPE)))
+
+#define IA_CSS_ACQUIRE_ISP_POS 31
 
 /* Flags for metadata processing */
-#define SH_CSS_METADATA_ENABLED        0x01
-#define SH_CSS_METADATA_PROCESSED      0x02
-#define SH_CSS_METADATA_OFFLINE_MODE   0x04
-#define SH_CSS_METADATA_WAIT_INPUT     0x08
+#define SH_CSS_METADATA_ENABLED 0x01
+#define SH_CSS_METADATA_PROCESSED 0x02
+#define SH_CSS_METADATA_OFFLINE_MODE 0x04
+#define SH_CSS_METADATA_WAIT_INPUT 0x08
 
 /* @brief Free an array of metadata buffers.
  *
@@ -457,53 +457,52 @@ enum sh_css_port_type {
  *
  * This function frees an array of metadata buffers.
  */
-void
-ia_css_metadata_free_multiple(unsigned int num_bufs,
-			      struct ia_css_metadata **bufs);
+void ia_css_metadata_free_multiple(unsigned int num_bufs,
+				   struct ia_css_metadata **bufs);
 
 /* Macro for handling pipe_qos_config */
-#define QOS_INVALID                  (~0U)
+#define QOS_INVALID (~0U)
 
 /* Information for a pipeline */
 struct sh_css_sp_pipeline {
-	u32	pipe_id;	/* the pipe ID */
-	u32	pipe_num;	/* the dynamic pipe number */
-	u32	thread_id;	/* the sp thread ID */
-	u32	pipe_config;	/* the pipe config */
-	u32	pipe_qos_config;	/* Bitmap of multiple QOS extension fw state.
+	u32 pipe_id; /* the pipe ID */
+	u32 pipe_num; /* the dynamic pipe number */
+	u32 thread_id; /* the sp thread ID */
+	u32 pipe_config; /* the pipe config */
+	u32 pipe_qos_config; /* Bitmap of multiple QOS extension fw state.
 						(0xFFFFFFFF) indicates non QOS pipe.*/
-	u32	inout_port_config;
-	u32	required_bds_factor;
-	u32	dvs_frame_delay;
-	u32	input_system_mode;	/* enum ia_css_input_mode */
-	u32	port_id;	/* port_id for input system */
-	u32	num_stages;		/* the pipe config */
-	u32	running;	/* needed for pipe termination */
-	ia_css_ptr	sp_stage_addr[SH_CSS_MAX_STAGES];
-	ia_css_ptr	scaler_pp_lut; /* Early bound LUT */
-	u32	dummy; /* stage ptr is only used on sp but lives in
+	u32 inout_port_config;
+	u32 required_bds_factor;
+	u32 dvs_frame_delay;
+	u32 input_system_mode; /* enum ia_css_input_mode */
+	u32 port_id; /* port_id for input system */
+	u32 num_stages; /* the pipe config */
+	u32 running; /* needed for pipe termination */
+	ia_css_ptr sp_stage_addr[SH_CSS_MAX_STAGES];
+	ia_css_ptr scaler_pp_lut; /* Early bound LUT */
+	u32 dummy; /* stage ptr is only used on sp but lives in
 				  this struct; needs cleanup */
 	s32 num_execs; /* number of times to run if this is
 			      an acceleration pipe. */
 	struct {
-		u32        format;   /* Metadata format in hrt format */
-		u32        width;    /* Width of a line */
-		u32        height;   /* Number of lines */
-		u32        stride;   /* Stride (in bytes) per line */
-		u32        size;     /* Total size (in bytes) */
-		ia_css_ptr    cont_buf; /* Address of continuous buffer */
+		u32 format; /* Metadata format in hrt format */
+		u32 width; /* Width of a line */
+		u32 height; /* Number of lines */
+		u32 stride; /* Stride (in bytes) per line */
+		u32 size; /* Total size (in bytes) */
+		ia_css_ptr cont_buf; /* Address of continuous buffer */
 	} metadata;
-	u32	output_frame_queue_id;
+	u32 output_frame_queue_id;
 	union {
 		struct {
-			u32	bytes_available;
+			u32 bytes_available;
 		} bin;
 		struct {
-			u32	height;
-			u32	width;
-			u32	padded_width;
-			u32	max_input_width;
-			u32	raw_bit_depth;
+			u32 height;
+			u32 width;
+			u32 padded_width;
+			u32 max_input_width;
+			u32 raw_bit_depth;
 		} raw;
 	} copy;
 };
@@ -520,10 +519,10 @@ struct sh_css_sp_pipeline {
 #define SH_CSS_NUM_DYNAMIC_FRAME_IDS (3)
 
 struct ia_css_frames_sp {
-	struct ia_css_frame_sp	in;
-	struct ia_css_frame_sp	out[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_frame_sp in;
+	struct ia_css_frame_sp out[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
 	struct ia_css_resolution effective_in_res;
-	struct ia_css_frame_sp	out_vf;
+	struct ia_css_frame_sp out_vf;
 	struct ia_css_frame_sp_info internal_frame_info;
 	struct ia_css_buffer_sp s3a_buf;
 	struct ia_css_buffer_sp dvs_buf;
@@ -540,9 +539,9 @@ struct sh_css_isp_stage {
 	 * Multiple boolean flags can be stored in an
 	 * integer
 	 */
-	struct ia_css_blob_info	  blob_info;
+	struct ia_css_blob_info blob_info;
 	struct ia_css_binary_info binary_info;
-	char			  binary_name[SH_CSS_MAX_BINARY_NAME];
+	char binary_name[SH_CSS_MAX_BINARY_NAME];
 	struct ia_css_isp_param_css_segments mem_initializers;
 };
 
@@ -556,49 +555,49 @@ struct sh_css_sp_stage {
 	 * Multiple boolean flags can be stored in an
 	 * integer
 	 */
-	u8			num; /* Stage number */
-	u8			isp_online;
-	u8			isp_copy_vf;
-	u8			isp_copy_output;
-	u8			sp_enable_xnr;
-	u8			isp_deci_log_factor;
-	u8			isp_vf_downscale_bits;
-	u8			deinterleaved;
+	u8 num; /* Stage number */
+	u8 isp_online;
+	u8 isp_copy_vf;
+	u8 isp_copy_output;
+	u8 sp_enable_xnr;
+	u8 isp_deci_log_factor;
+	u8 isp_vf_downscale_bits;
+	u8 deinterleaved;
 	/*
 	 * NOTE: Programming the input circuit can only be done at the
 	 * start of a session. It is illegal to program it during execution
 	 * The input circuit defines the connectivity
 	 */
-	u8			program_input_circuit;
+	u8 program_input_circuit;
 	/* enum ia_css_pipeline_stage_sp_func	func; */
-	u8			func;
+	u8 func;
 	/* The type of the pipe-stage */
 	/* enum sh_css_stage_type	stage_type; */
-	u8			stage_type;
-	u8			num_stripes;
-	u8			isp_pipe_version;
+	u8 stage_type;
+	u8 num_stripes;
+	u8 isp_pipe_version;
 	struct {
-		u8		vf_output;
-		u8		s3a;
-		u8		sdis;
-		u8		dvs_stats;
-		u8		lace_stats;
+		u8 vf_output;
+		u8 s3a;
+		u8 sdis;
+		u8 dvs_stats;
+		u8 lace_stats;
 	} enable;
 	/* Add padding to come to a word boundary */
 	/* unsigned char			padding[0]; */
 
-	struct sh_css_crop_pos		sp_out_crop_pos;
-	struct ia_css_frames_sp		frames;
-	struct ia_css_resolution	dvs_envelope;
-	struct sh_css_uds_info		uds;
-	ia_css_ptr			isp_stage_addr;
-	ia_css_ptr			xmem_bin_addr;
-	ia_css_ptr			xmem_map_addr;
+	struct sh_css_crop_pos sp_out_crop_pos;
+	struct ia_css_frames_sp frames;
+	struct ia_css_resolution dvs_envelope;
+	struct sh_css_uds_info uds;
+	ia_css_ptr isp_stage_addr;
+	ia_css_ptr xmem_bin_addr;
+	ia_css_ptr xmem_map_addr;
 
-	u16		top_cropping;
-	u16		row_stripes_height;
-	u16		row_stripes_overlap_lines;
-	u8			if_config_index; /* Which should be applied by this stage. */
+	u16 top_cropping;
+	u16 row_stripes_height;
+	u16 row_stripes_overlap_lines;
+	u8 if_config_index; /* Which should be applied by this stage. */
 };
 
 /*
@@ -614,28 +613,28 @@ struct sh_css_sp_stage {
  * The stage part itself is transferred through sh_css_sp_stage.
 */
 struct sh_css_sp_group {
-	struct sh_css_sp_config		config;
-	struct sh_css_sp_pipeline	pipe[SH_CSS_MAX_SP_THREADS];
-	struct sh_css_sp_pipeline_io	pipe_io[SH_CSS_MAX_SP_THREADS];
-	struct sh_css_sp_pipeline_io_status	pipe_io_status;
-	struct sh_css_sp_debug_command	debug;
+	struct sh_css_sp_config config;
+	struct sh_css_sp_pipeline pipe[SH_CSS_MAX_SP_THREADS];
+	struct sh_css_sp_pipeline_io pipe_io[SH_CSS_MAX_SP_THREADS];
+	struct sh_css_sp_pipeline_io_status pipe_io_status;
+	struct sh_css_sp_debug_command debug;
 };
 
 /* Data in SP dmem that is set from the host every stage. */
 struct sh_css_sp_per_frame_data {
 	/* ddr address of sp_group and sp_stage */
-	ia_css_ptr			sp_group_addr;
+	ia_css_ptr sp_group_addr;
 };
 
 #define SH_CSS_NUM_SDW_IRQS 3
 
 /* Output data from SP to css */
 struct sh_css_sp_output {
-	unsigned int			bin_copy_bytes_copied;
+	unsigned int bin_copy_bytes_copied;
 #if SP_DEBUG != SP_DEBUG_NONE
-	struct sh_css_sp_debug_state	debug;
+	struct sh_css_sp_debug_state debug;
 #endif
-	unsigned int		sw_interrupt_value[SH_CSS_NUM_SDW_IRQS];
+	unsigned int sw_interrupt_value[SH_CSS_NUM_SDW_IRQS];
 };
 
 /**
@@ -645,35 +644,36 @@ struct sh_css_sp_output {
  */
 /* Variable Sized Buffer Queue Elements */
 
-#define  IA_CSS_NUM_ELEMS_HOST2SP_BUFFER_QUEUE    6
-#define  IA_CSS_NUM_ELEMS_HOST2SP_PARAM_QUEUE    3
-#define  IA_CSS_NUM_ELEMS_HOST2SP_TAG_CMD_QUEUE  6
+#define IA_CSS_NUM_ELEMS_HOST2SP_BUFFER_QUEUE 6
+#define IA_CSS_NUM_ELEMS_HOST2SP_PARAM_QUEUE 3
+#define IA_CSS_NUM_ELEMS_HOST2SP_TAG_CMD_QUEUE 6
 
 /* sp-to-host queue is expected to be emptied in ISR since
  * it is used instead of HW interrupts (due to HW design issue).
  * We need one queue element per CSI port. */
-#define  IA_CSS_NUM_ELEMS_SP2HOST_ISYS_EVENT_QUEUE (2 * N_CSI_PORTS)
+#define IA_CSS_NUM_ELEMS_SP2HOST_ISYS_EVENT_QUEUE (2 * N_CSI_PORTS)
 /* The host-to-sp queue needs to allow for some delay
  * in the emptying of this queue in the SP since there is no
  * separate SP thread for this. */
-#define  IA_CSS_NUM_ELEMS_HOST2SP_ISYS_EVENT_QUEUE (2 * N_CSI_PORTS)
+#define IA_CSS_NUM_ELEMS_HOST2SP_ISYS_EVENT_QUEUE (2 * N_CSI_PORTS)
 
-#define  IA_CSS_NUM_ELEMS_HOST2SP_PSYS_EVENT_QUEUE    13
-#define  IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE        19
-#define  IA_CSS_NUM_ELEMS_SP2HOST_PSYS_EVENT_QUEUE    26 /* holds events for all type of buffers, hence deeper */
+#define IA_CSS_NUM_ELEMS_HOST2SP_PSYS_EVENT_QUEUE 13
+#define IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE 19
+#define IA_CSS_NUM_ELEMS_SP2HOST_PSYS_EVENT_QUEUE \
+	26 /* holds events for all type of buffers, hence deeper */
 
 struct sh_css_hmm_buffer {
 	union {
-		struct ia_css_isp_3a_statistics  s3a;
+		struct ia_css_isp_3a_statistics s3a;
 		struct ia_css_isp_dvs_statistics dis;
 		ia_css_ptr skc_dvs_statistics;
 		ia_css_ptr lace_stat;
-		struct ia_css_metadata	metadata;
+		struct ia_css_metadata metadata;
 		struct frame_data_wrapper {
-			ia_css_ptr	frame_data;
-			u32	flashed;
-			u32	exp_id;
-			u32	isp_parameters_id; /** Unique ID to track which config was
+			ia_css_ptr frame_data;
+			u32 flashed;
+			u32 exp_id;
+			u32 isp_parameters_id; /** Unique ID to track which config was
 								actually applied to a particular frame */
 		} frame;
 		ia_css_ptr ddr_ptrs;
@@ -684,35 +684,31 @@ struct sh_css_hmm_buffer {
 	 * uint64_t does not exist on SP/ISP.
 	 * Size of the struct is checked by sp.hive.c.
 	 */
-	CSS_ALIGN(u64 cookie_ptr, 8); /* TODO: check if this alignment is needed */
+	CSS_ALIGN(u64 cookie_ptr,
+		  8); /* TODO: check if this alignment is needed */
 	u64 kernel_ptr;
 	struct ia_css_time_meas timing_data;
 	clock_value_t isys_eof_clock_tick;
 };
 
-#define SIZE_OF_FRAME_STRUCT						\
-	(SIZE_OF_HRT_VADDRESS +						\
-	(3 * sizeof(uint32_t)))
+#define SIZE_OF_FRAME_STRUCT (SIZE_OF_HRT_VADDRESS + (3 * sizeof(uint32_t)))
 
-#define SIZE_OF_PAYLOAD_UNION						\
-	(MAX(MAX(MAX(MAX(						\
-	SIZE_OF_IA_CSS_ISP_3A_STATISTICS_STRUCT,			\
-	SIZE_OF_IA_CSS_ISP_DVS_STATISTICS_STRUCT),			\
-	SIZE_OF_IA_CSS_METADATA_STRUCT),				\
-	SIZE_OF_FRAME_STRUCT),						\
-	SIZE_OF_HRT_VADDRESS))
+#define SIZE_OF_PAYLOAD_UNION                                       \
+	(MAX(MAX(MAX(MAX(SIZE_OF_IA_CSS_ISP_3A_STATISTICS_STRUCT,   \
+			 SIZE_OF_IA_CSS_ISP_DVS_STATISTICS_STRUCT), \
+		     SIZE_OF_IA_CSS_METADATA_STRUCT),               \
+		 SIZE_OF_FRAME_STRUCT),                             \
+	     SIZE_OF_HRT_VADDRESS))
 
 /* Do not use sizeof(uint64_t) since that does not exist of SP */
-#define SIZE_OF_SH_CSS_HMM_BUFFER_STRUCT				\
-	(SIZE_OF_PAYLOAD_UNION +					\
-	CALC_ALIGNMENT_MEMBER(SIZE_OF_PAYLOAD_UNION, 8) +		\
-	8 +						\
-	8 +						\
-	SIZE_OF_IA_CSS_TIME_MEAS_STRUCT +				\
-	SIZE_OF_IA_CSS_CLOCK_TICK_STRUCT +			\
-	CALC_ALIGNMENT_MEMBER(SIZE_OF_IA_CSS_CLOCK_TICK_STRUCT, 8))
+#define SIZE_OF_SH_CSS_HMM_BUFFER_STRUCT                                      \
+	(SIZE_OF_PAYLOAD_UNION +                                              \
+	 CALC_ALIGNMENT_MEMBER(SIZE_OF_PAYLOAD_UNION, 8) + 8 + 8 +            \
+	 SIZE_OF_IA_CSS_TIME_MEAS_STRUCT + SIZE_OF_IA_CSS_CLOCK_TICK_STRUCT + \
+	 CALC_ALIGNMENT_MEMBER(SIZE_OF_IA_CSS_CLOCK_TICK_STRUCT, 8))
 
-static_assert(sizeof(struct sh_css_hmm_buffer) == SIZE_OF_SH_CSS_HMM_BUFFER_STRUCT);
+static_assert(sizeof(struct sh_css_hmm_buffer) ==
+	      SIZE_OF_SH_CSS_HMM_BUFFER_STRUCT);
 
 enum sh_css_queue_type {
 	sh_css_invalid_queue_type = -1,
@@ -730,10 +726,10 @@ struct sh_css_event_irq_mask {
 	u16 and_mask;
 };
 
-#define SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT				\
-	(2 * sizeof(uint16_t))
+#define SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT (2 * sizeof(uint16_t))
 
-static_assert(sizeof(struct sh_css_event_irq_mask) == SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT);
+static_assert(sizeof(struct sh_css_event_irq_mask) ==
+	      SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT);
 
 struct host_sp_communication {
 	/*
@@ -756,23 +752,25 @@ struct host_sp_communication {
 	ia_css_ptr host2sp_offline_metadata[NUM_CONTINUOUS_FRAMES];
 
 	ia_css_ptr host2sp_mipi_frames[N_CSI_PORTS][NUM_MIPI_FRAMES_PER_STREAM];
-	ia_css_ptr host2sp_mipi_metadata[N_CSI_PORTS][NUM_MIPI_FRAMES_PER_STREAM];
+	ia_css_ptr host2sp_mipi_metadata[N_CSI_PORTS]
+					[NUM_MIPI_FRAMES_PER_STREAM];
 	u32 host2sp_num_mipi_frames[N_CSI_PORTS];
 	u32 host2sp_cont_avail_num_raw_frames;
 	u32 host2sp_cont_extra_num_raw_frames;
 	u32 host2sp_cont_target_num_raw_frames;
 	struct sh_css_event_irq_mask host2sp_event_irq_mask[NR_OF_PIPELINES];
-
 };
 
-#define SIZE_OF_HOST_SP_COMMUNICATION_STRUCT				\
-	(sizeof(uint32_t) +						\
-	(NUM_CONTINUOUS_FRAMES * SIZE_OF_HRT_VADDRESS * 2) +		\
-	(N_CSI_PORTS * NUM_MIPI_FRAMES_PER_STREAM * SIZE_OF_HRT_VADDRESS * 2) +			\
-	((3 + N_CSI_PORTS) * sizeof(uint32_t)) +						\
-	(NR_OF_PIPELINES * SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT))
+#define SIZE_OF_HOST_SP_COMMUNICATION_STRUCT                                \
+	(sizeof(uint32_t) +                                                 \
+	 (NUM_CONTINUOUS_FRAMES * SIZE_OF_HRT_VADDRESS * 2) +               \
+	 (N_CSI_PORTS * NUM_MIPI_FRAMES_PER_STREAM * SIZE_OF_HRT_VADDRESS * \
+	  2) +                                                              \
+	 ((3 + N_CSI_PORTS) * sizeof(uint32_t)) +                           \
+	 (NR_OF_PIPELINES * SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT))
 
-static_assert(sizeof(struct host_sp_communication) == SIZE_OF_HOST_SP_COMMUNICATION_STRUCT);
+static_assert(sizeof(struct host_sp_communication) ==
+	      SIZE_OF_HOST_SP_COMMUNICATION_STRUCT);
 
 struct host_sp_queues {
 	/*
@@ -780,15 +778,14 @@ struct host_sp_queues {
 	 * i.e. the "in_frame" buffer, the "out_frame"
 	 * buffer and the "vf_out_frame" buffer.
 	 */
-	ia_css_circbuf_desc_t host2sp_buffer_queues_desc
-	[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES];
+	ia_css_circbuf_desc_t host2sp_buffer_queues_desc[SH_CSS_MAX_SP_THREADS]
+							[SH_CSS_MAX_NUM_QUEUES];
 	ia_css_circbuf_elem_t host2sp_buffer_queues_elems
-	[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES]
-	[IA_CSS_NUM_ELEMS_HOST2SP_BUFFER_QUEUE];
-	ia_css_circbuf_desc_t sp2host_buffer_queues_desc
-	[SH_CSS_MAX_NUM_QUEUES];
+		[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES]
+		[IA_CSS_NUM_ELEMS_HOST2SP_BUFFER_QUEUE];
+	ia_css_circbuf_desc_t sp2host_buffer_queues_desc[SH_CSS_MAX_NUM_QUEUES];
 	ia_css_circbuf_elem_t sp2host_buffer_queues_elems
-	[SH_CSS_MAX_NUM_QUEUES][IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE];
+		[SH_CSS_MAX_NUM_QUEUES][IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE];
 
 	/*
 	 * The queues for the events.
@@ -796,11 +793,11 @@ struct host_sp_queues {
 	ia_css_circbuf_desc_t host2sp_psys_event_queue_desc;
 
 	ia_css_circbuf_elem_t host2sp_psys_event_queue_elems
-	[IA_CSS_NUM_ELEMS_HOST2SP_PSYS_EVENT_QUEUE];
+		[IA_CSS_NUM_ELEMS_HOST2SP_PSYS_EVENT_QUEUE];
 	ia_css_circbuf_desc_t sp2host_psys_event_queue_desc;
 
 	ia_css_circbuf_elem_t sp2host_psys_event_queue_elems
-	[IA_CSS_NUM_ELEMS_SP2HOST_PSYS_EVENT_QUEUE];
+		[IA_CSS_NUM_ELEMS_SP2HOST_PSYS_EVENT_QUEUE];
 
 	/*
 	 * The queues for the ISYS events.
@@ -808,11 +805,11 @@ struct host_sp_queues {
 	ia_css_circbuf_desc_t host2sp_isys_event_queue_desc;
 
 	ia_css_circbuf_elem_t host2sp_isys_event_queue_elems
-	[IA_CSS_NUM_ELEMS_HOST2SP_ISYS_EVENT_QUEUE];
+		[IA_CSS_NUM_ELEMS_HOST2SP_ISYS_EVENT_QUEUE];
 	ia_css_circbuf_desc_t sp2host_isys_event_queue_desc;
 
 	ia_css_circbuf_elem_t sp2host_isys_event_queue_elems
-	[IA_CSS_NUM_ELEMS_SP2HOST_ISYS_EVENT_QUEUE];
+		[IA_CSS_NUM_ELEMS_SP2HOST_ISYS_EVENT_QUEUE];
 	/*
 	 * The queue for the tagger commands.
 	 * CHECK: are these last two present on the 2401 ?
@@ -820,35 +817,36 @@ struct host_sp_queues {
 	ia_css_circbuf_desc_t host2sp_tag_cmd_queue_desc;
 
 	ia_css_circbuf_elem_t host2sp_tag_cmd_queue_elems
-	[IA_CSS_NUM_ELEMS_HOST2SP_TAG_CMD_QUEUE];
+		[IA_CSS_NUM_ELEMS_HOST2SP_TAG_CMD_QUEUE];
 };
 
-#define SIZE_OF_QUEUES_ELEMS							\
-	(SIZE_OF_IA_CSS_CIRCBUF_ELEM_S_STRUCT *				\
-	((SH_CSS_MAX_SP_THREADS * SH_CSS_MAX_NUM_QUEUES * IA_CSS_NUM_ELEMS_HOST2SP_BUFFER_QUEUE) + \
-	(SH_CSS_MAX_NUM_QUEUES * IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE) +	\
-	(IA_CSS_NUM_ELEMS_HOST2SP_PSYS_EVENT_QUEUE) +				\
-	(IA_CSS_NUM_ELEMS_SP2HOST_PSYS_EVENT_QUEUE) +				\
-	(IA_CSS_NUM_ELEMS_HOST2SP_ISYS_EVENT_QUEUE) +				\
-	(IA_CSS_NUM_ELEMS_SP2HOST_ISYS_EVENT_QUEUE) +				\
-	(IA_CSS_NUM_ELEMS_HOST2SP_TAG_CMD_QUEUE)))
+#define SIZE_OF_QUEUES_ELEMS                                                \
+	(SIZE_OF_IA_CSS_CIRCBUF_ELEM_S_STRUCT *                             \
+	 ((SH_CSS_MAX_SP_THREADS * SH_CSS_MAX_NUM_QUEUES *                  \
+	   IA_CSS_NUM_ELEMS_HOST2SP_BUFFER_QUEUE) +                         \
+	  (SH_CSS_MAX_NUM_QUEUES * IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE) + \
+	  (IA_CSS_NUM_ELEMS_HOST2SP_PSYS_EVENT_QUEUE) +                     \
+	  (IA_CSS_NUM_ELEMS_SP2HOST_PSYS_EVENT_QUEUE) +                     \
+	  (IA_CSS_NUM_ELEMS_HOST2SP_ISYS_EVENT_QUEUE) +                     \
+	  (IA_CSS_NUM_ELEMS_SP2HOST_ISYS_EVENT_QUEUE) +                     \
+	  (IA_CSS_NUM_ELEMS_HOST2SP_TAG_CMD_QUEUE)))
 
 #define IA_CSS_NUM_CIRCBUF_DESCS 5
 
-#define SIZE_OF_QUEUES_DESC \
-	((SH_CSS_MAX_SP_THREADS * SH_CSS_MAX_NUM_QUEUES * \
-	  SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT) + \
+#define SIZE_OF_QUEUES_DESC                                               \
+	((SH_CSS_MAX_SP_THREADS * SH_CSS_MAX_NUM_QUEUES *                 \
+	  SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT) +                         \
 	 (SH_CSS_MAX_NUM_QUEUES * SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT) + \
 	 (IA_CSS_NUM_CIRCBUF_DESCS * SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT))
 
-#define SIZE_OF_HOST_SP_QUEUES_STRUCT		\
+#define SIZE_OF_HOST_SP_QUEUES_STRUCT \
 	(SIZE_OF_QUEUES_ELEMS + SIZE_OF_QUEUES_DESC)
 
 static_assert(sizeof(struct host_sp_queues) == SIZE_OF_HOST_SP_QUEUES_STRUCT);
 
-extern int  __printf(1, 0) (*sh_css_printf)(const char *fmt, va_list args);
+extern int __printf(1, 0) (*sh_css_printf)(const char *fmt, va_list args);
 
-static inline void  __printf(1, 2) sh_css_print(const char *fmt, ...)
+static inline void __printf(1, 2) sh_css_print(const char *fmt, ...)
 {
 	va_list ap;
 
@@ -859,7 +857,7 @@ static inline void  __printf(1, 2) sh_css_print(const char *fmt, ...)
 	}
 }
 
-static inline void  __printf(1, 0) sh_css_vprint(const char *fmt, va_list args)
+static inline void __printf(1, 0) sh_css_vprint(const char *fmt, va_list args)
 {
 	if (sh_css_printf)
 		sh_css_printf(fmt, args);
@@ -872,87 +870,63 @@ static inline void  __printf(1, 0) sh_css_vprint(const char *fmt, va_list args)
 */
 ia_css_ptr sh_css_params_ddr_address_map(void);
 
-int
-sh_css_params_init(void);
+int sh_css_params_init(void);
 
-void
-sh_css_params_uninit(void);
+void sh_css_params_uninit(void);
 
-void
-sh_css_binary_args_reset(struct sh_css_binary_args *args);
+void sh_css_binary_args_reset(struct sh_css_binary_args *args);
 
 /* Check two frames for equality (format, resolution, bits per element) */
-bool
-sh_css_frame_equal_types(const struct ia_css_frame *frame_a,
-			 const struct ia_css_frame *frame_b);
+bool sh_css_frame_equal_types(const struct ia_css_frame *frame_a,
+			      const struct ia_css_frame *frame_b);
 
-bool
-sh_css_frame_info_equal_resolution(const struct ia_css_frame_info *info_a,
-				   const struct ia_css_frame_info *info_b);
+bool sh_css_frame_info_equal_resolution(const struct ia_css_frame_info *info_a,
+					const struct ia_css_frame_info *info_b);
 
-void
-sh_css_capture_enable_bayer_downscaling(bool enable);
+void sh_css_capture_enable_bayer_downscaling(bool enable);
 
-void
-sh_css_binary_print(const struct ia_css_binary *binary);
+void sh_css_binary_print(const struct ia_css_binary *binary);
 
 /* aligned argument of sh_css_frame_info_set_width can be used for an extra alignment requirement.
   When 0, no extra alignment is done. */
-void
-sh_css_frame_info_set_width(struct ia_css_frame_info *info,
-			    unsigned int width,
-			    unsigned int aligned);
-
-
-unsigned int
-sh_css_get_mipi_sizes_for_check(const unsigned int port,
-				const unsigned int idx);
+void sh_css_frame_info_set_width(struct ia_css_frame_info *info,
+				 unsigned int width, unsigned int aligned);
 
+unsigned int sh_css_get_mipi_sizes_for_check(const unsigned int port,
+					     const unsigned int idx);
 
-ia_css_ptr
-sh_css_store_sp_group_to_ddr(void);
+ia_css_ptr sh_css_store_sp_group_to_ddr(void);
 
-ia_css_ptr
-sh_css_store_sp_stage_to_ddr(unsigned int pipe, unsigned int stage);
+ia_css_ptr sh_css_store_sp_stage_to_ddr(unsigned int pipe, unsigned int stage);
 
-ia_css_ptr
-sh_css_store_isp_stage_to_ddr(unsigned int pipe, unsigned int stage);
+ia_css_ptr sh_css_store_isp_stage_to_ddr(unsigned int pipe, unsigned int stage);
 
-void
-sh_css_update_uds_and_crop_info(
-    const struct ia_css_binary_info *info,
-    const struct ia_css_frame_info *in_frame_info,
-    const struct ia_css_frame_info *out_frame_info,
-    const struct ia_css_resolution *dvs_env,
-    const struct ia_css_dz_config *zoom,
-    const struct ia_css_vector *motion_vector,
-    struct sh_css_uds_info *uds,		/* out */
-    struct sh_css_crop_pos *sp_out_crop_pos,	/* out */
+void sh_css_update_uds_and_crop_info(
+	const struct ia_css_binary_info *info,
+	const struct ia_css_frame_info *in_frame_info,
+	const struct ia_css_frame_info *out_frame_info,
+	const struct ia_css_resolution *dvs_env,
+	const struct ia_css_dz_config *zoom,
+	const struct ia_css_vector *motion_vector,
+	struct sh_css_uds_info *uds, /* out */
+	struct sh_css_crop_pos *sp_out_crop_pos, /* out */
 
-    bool enable_zoom
-);
+	bool enable_zoom);
 
-void
-sh_css_invalidate_shading_tables(struct ia_css_stream *stream);
+void sh_css_invalidate_shading_tables(struct ia_css_stream *stream);
 
 struct ia_css_pipeline *
 ia_css_pipe_get_pipeline(const struct ia_css_pipe *pipe);
 
-unsigned int
-ia_css_pipe_get_pipe_num(const struct ia_css_pipe *pipe);
+unsigned int ia_css_pipe_get_pipe_num(const struct ia_css_pipe *pipe);
 
-unsigned int
-ia_css_pipe_get_isp_pipe_version(const struct ia_css_pipe *pipe);
+unsigned int ia_css_pipe_get_isp_pipe_version(const struct ia_css_pipe *pipe);
 
-bool
-sh_css_continuous_is_enabled(uint8_t pipe_num);
+bool sh_css_continuous_is_enabled(uint8_t pipe_num);
 
-struct ia_css_pipe *
-find_pipe_by_num(uint32_t pipe_num);
+struct ia_css_pipe *find_pipe_by_num(uint32_t pipe_num);
 
-void
-ia_css_get_crop_offsets(
-    struct ia_css_pipe *pipe,
-    struct ia_css_frame_info *in_frame);
+void ia_css_get_crop_offsets(struct ia_css_pipe *pipe,
+			     struct ia_css_frame_info *in_frame);
 
 #endif /* _SH_CSS_INTERNAL_H_ */
diff --git a/drivers/staging/media/atomisp/pci/sh_css_legacy.h b/drivers/staging/media/atomisp/pci/sh_css_legacy.h
index 1d3549c52a46067a9b49e0dbf241a515a610cfc0..c8933378acc2aaa85dc8f67dd867fc9b9687d2be 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_legacy.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_legacy.h
@@ -36,26 +36,21 @@ struct ia_css_pipe_extra_config {
 	bool disable_vf_pp;
 };
 
-int
-ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
-			 const struct ia_css_pipe_extra_config *extra_config,
-			 struct ia_css_pipe **pipe);
+int ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
+			     const struct ia_css_pipe_extra_config *extra_config,
+			     struct ia_css_pipe **pipe);
 
-void
-ia_css_pipe_extra_config_defaults(struct ia_css_pipe_extra_config
-				  *extra_config);
+void ia_css_pipe_extra_config_defaults(
+	struct ia_css_pipe_extra_config *extra_config);
 
-int
-ia_css_temp_pipe_to_pipe_id(const struct ia_css_pipe *pipe,
-			    enum ia_css_pipe_id *pipe_id);
+int ia_css_temp_pipe_to_pipe_id(const struct ia_css_pipe *pipe,
+				enum ia_css_pipe_id *pipe_id);
 
 /* DEPRECATED. FPN is not supported. */
-int
-sh_css_set_black_frame(struct ia_css_stream *stream,
-		       const struct ia_css_frame *raw_black_frame);
+int sh_css_set_black_frame(struct ia_css_stream *stream,
+			   const struct ia_css_frame *raw_black_frame);
 
 /* ISP2400 */
-void
-sh_css_enable_cont_capt(bool enable, bool stop_copy_preview);
+void sh_css_enable_cont_capt(bool enable, bool stop_copy_preview);
 
 #endif /* _SH_CSS_LEGACY_H_ */
diff --git a/drivers/staging/media/atomisp/pci/sh_css_metrics.c b/drivers/staging/media/atomisp/pci/sh_css_metrics.c
index edf473dd86ca457afa5b36d4be1da124e1aa96ea..28df1a7bd33fb5ad6ee612fa69771dfb9f58dc8b 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_metrics.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_metrics.c
@@ -13,10 +13,10 @@
 #include "sh_css_internal.h"
 
 #define MULTIPLE_PCS 0
-#define SUSPEND      0
-#define NOF_PCS      1
-#define RESUME_MASK  0x8
-#define STOP_MASK    0x0
+#define SUSPEND 0
+#define NOF_PCS 1
+#define RESUME_MASK 0x8
+#define STOP_MASK 0x0
 
 static bool pc_histogram_enabled;
 static struct sh_css_pc_histogram *isp_histogram;
@@ -24,14 +24,12 @@ static struct sh_css_pc_histogram *sp_histogram;
 
 struct sh_css_metrics sh_css_metrics;
 
-void
-sh_css_metrics_start_frame(void)
+void sh_css_metrics_start_frame(void)
 {
 	sh_css_metrics.frame_metrics.num_frames++;
 }
 
-static void
-clear_histogram(struct sh_css_pc_histogram *histogram)
+static void clear_histogram(struct sh_css_pc_histogram *histogram)
 {
 	unsigned int i;
 
@@ -44,14 +42,13 @@ clear_histogram(struct sh_css_pc_histogram *histogram)
 	}
 }
 
-void
-sh_css_metrics_enable_pc_histogram(bool enable)
+void sh_css_metrics_enable_pc_histogram(bool enable)
 {
 	pc_histogram_enabled = enable;
 }
 
-static void
-make_histogram(struct sh_css_pc_histogram *histogram, unsigned int length)
+static void make_histogram(struct sh_css_pc_histogram *histogram,
+			   unsigned int length)
 {
 	assert(histogram);
 
@@ -59,16 +56,15 @@ make_histogram(struct sh_css_pc_histogram *histogram, unsigned int length)
 		return;
 	if (histogram->run)
 		return;
-	histogram->run = kvmalloc(length * sizeof(*histogram->run),
-				  GFP_KERNEL);
+	histogram->run = kvmalloc(length * sizeof(*histogram->run), GFP_KERNEL);
 	if (!histogram->run)
 		return;
-	histogram->stall = kvmalloc(length * sizeof(*histogram->stall),
-				    GFP_KERNEL);
+	histogram->stall =
+		kvmalloc(length * sizeof(*histogram->stall), GFP_KERNEL);
 	if (!histogram->stall)
 		return;
-	histogram->msink = kvmalloc(length * sizeof(*histogram->msink),
-				    GFP_KERNEL);
+	histogram->msink =
+		kvmalloc(length * sizeof(*histogram->msink), GFP_KERNEL);
 	if (!histogram->msink)
 		return;
 
@@ -76,9 +72,8 @@ make_histogram(struct sh_css_pc_histogram *histogram, unsigned int length)
 	clear_histogram(histogram);
 }
 
-static void
-insert_binary_metrics(struct sh_css_binary_metrics **l,
-		      struct sh_css_binary_metrics *metrics)
+static void insert_binary_metrics(struct sh_css_binary_metrics **l,
+				  struct sh_css_binary_metrics *metrics)
 {
 	assert(l);
 	assert(*l);
@@ -92,8 +87,7 @@ insert_binary_metrics(struct sh_css_binary_metrics **l,
 	metrics->next = NULL;
 }
 
-void
-sh_css_metrics_start_binary(struct sh_css_binary_metrics *metrics)
+void sh_css_metrics_start_binary(struct sh_css_binary_metrics *metrics)
 {
 	assert(metrics);
 
@@ -107,15 +101,12 @@ sh_css_metrics_start_binary(struct sh_css_binary_metrics *metrics)
 	insert_binary_metrics(&sh_css_metrics.binary_metrics, metrics);
 }
 
-void
-sh_css_metrics_sample_pcs(void)
+void sh_css_metrics_sample_pcs(void)
 {
 	bool stall;
 	unsigned int pc;
 	unsigned int msink;
 
-
-
 	if (!pc_histogram_enabled)
 		return;
 
diff --git a/drivers/staging/media/atomisp/pci/sh_css_metrics.h b/drivers/staging/media/atomisp/pci/sh_css_metrics.h
index 0ae995b80d077d80f4b9feef41312e91761bc872..8304b709a722a3173c0493255321d76517816063 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_metrics.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_metrics.h
@@ -30,7 +30,7 @@ struct ia_css_frame_metrics {
 
 struct sh_css_metrics {
 	struct sh_css_binary_metrics *binary_metrics;
-	struct ia_css_frame_metrics   frame_metrics;
+	struct ia_css_frame_metrics frame_metrics;
 };
 
 extern struct sh_css_metrics sh_css_metrics;
diff --git a/drivers/staging/media/atomisp/pci/sh_css_mipi.c b/drivers/staging/media/atomisp/pci/sh_css_mipi.c
index 42f14ed853e1c953c4af1eb84586be98be6b6b83..82a4faf4e35d7e5249d3a415ed6fa78efe0c8aa1 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_mipi.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_mipi.c
@@ -21,8 +21,7 @@
 #include "sh_css_sp.h" /* sh_css_update_host2sp_mipi_frame sh_css_update_host2sp_num_mipi_frames ... */
 #include "sw_event_global.h" /* IA_CSS_PSYS_SW_EVENT_MIPI_BUFFERS_READY */
 
-static u32
-ref_count_mipi_allocation[N_CSI_PORTS]; /* Initialized in mipi_init */
+static u32 ref_count_mipi_allocation[N_CSI_PORTS]; /* Initialized in mipi_init */
 
 /* Assumptions:
  *	- A line is multiple of 4 bytes = 1 word.
@@ -35,13 +34,11 @@ ref_count_mipi_allocation[N_CSI_PORTS]; /* Initialized in mipi_init */
  *  etc.).
  * Result is given in DDR mem words, 32B or 256 bits
  */
-int
-ia_css_mipi_frame_calculate_size(const unsigned int width,
-				 const unsigned int height,
-				 const enum atomisp_input_format format,
-				 const bool hasSOLandEOL,
-				 const unsigned int embedded_data_size_words,
-				 unsigned int *size_mem_words)
+int ia_css_mipi_frame_calculate_size(
+	const unsigned int width, const unsigned int height,
+	const enum atomisp_input_format format, const bool hasSOLandEOL,
+	const unsigned int embedded_data_size_words,
+	unsigned int *size_mem_words)
 {
 	int err = 0;
 
@@ -65,67 +62,70 @@ ia_css_mipi_frame_calculate_size(const unsigned int width,
 	if (IS_ISP2401)
 		width_padded += (2 * ISP_VEC_NELEMS);
 
-	IA_CSS_ENTER("padded_width=%d, height=%d, format=%d, hasSOLandEOL=%d, embedded_data_size_words=%d\n",
-		     width_padded, height, format, hasSOLandEOL, embedded_data_size_words);
+	IA_CSS_ENTER(
+		"padded_width=%d, height=%d, format=%d, hasSOLandEOL=%d, embedded_data_size_words=%d\n",
+		width_padded, height, format, hasSOLandEOL,
+		embedded_data_size_words);
 
 	switch (format) {
-	case ATOMISP_INPUT_FORMAT_RAW_6:		/* 4p, 3B, 24bits */
+	case ATOMISP_INPUT_FORMAT_RAW_6: /* 4p, 3B, 24bits */
 		bits_per_pixel = 6;
 		break;
-	case ATOMISP_INPUT_FORMAT_RAW_7:		/* 8p, 7B, 56bits */
+	case ATOMISP_INPUT_FORMAT_RAW_7: /* 8p, 7B, 56bits */
 		bits_per_pixel = 7;
 		break;
-	case ATOMISP_INPUT_FORMAT_RAW_8:		/* 1p, 1B, 8bits */
-	case ATOMISP_INPUT_FORMAT_BINARY_8:		/*  8bits, TODO: check. */
-	case ATOMISP_INPUT_FORMAT_YUV420_8:		/* odd 2p, 2B, 16bits, even 2p, 4B, 32bits */
+	case ATOMISP_INPUT_FORMAT_RAW_8: /* 1p, 1B, 8bits */
+	case ATOMISP_INPUT_FORMAT_BINARY_8: /*  8bits, TODO: check. */
+	case ATOMISP_INPUT_FORMAT_YUV420_8: /* odd 2p, 2B, 16bits, even 2p, 4B, 32bits */
 		bits_per_pixel = 8;
 		break;
-	case ATOMISP_INPUT_FORMAT_YUV420_10:		/* odd 4p, 5B, 40bits, even 4p, 10B, 80bits */
-	case ATOMISP_INPUT_FORMAT_RAW_10:		/* 4p, 5B, 40bits */
+	case ATOMISP_INPUT_FORMAT_YUV420_10: /* odd 4p, 5B, 40bits, even 4p, 10B, 80bits */
+	case ATOMISP_INPUT_FORMAT_RAW_10: /* 4p, 5B, 40bits */
 		/* The changes will be reverted as soon as RAW
 		 * Buffers are deployed by the 2401 Input System
 		 * in the non-continuous use scenario.
 		 */
 		bits_per_pixel = 10;
 		break;
-	case ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY:	/* 2p, 3B, 24bits */
-	case ATOMISP_INPUT_FORMAT_RAW_12:		/* 2p, 3B, 24bits */
+	case ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY: /* 2p, 3B, 24bits */
+	case ATOMISP_INPUT_FORMAT_RAW_12: /* 2p, 3B, 24bits */
 		bits_per_pixel = 12;
 		break;
-	case ATOMISP_INPUT_FORMAT_RAW_14:		/* 4p, 7B, 56bits */
+	case ATOMISP_INPUT_FORMAT_RAW_14: /* 4p, 7B, 56bits */
 		bits_per_pixel = 14;
 		break;
-	case ATOMISP_INPUT_FORMAT_RGB_444:		/* 1p, 2B, 16bits */
-	case ATOMISP_INPUT_FORMAT_RGB_555:		/* 1p, 2B, 16bits */
-	case ATOMISP_INPUT_FORMAT_RGB_565:		/* 1p, 2B, 16bits */
-	case ATOMISP_INPUT_FORMAT_YUV422_8:		/* 2p, 4B, 32bits */
+	case ATOMISP_INPUT_FORMAT_RGB_444: /* 1p, 2B, 16bits */
+	case ATOMISP_INPUT_FORMAT_RGB_555: /* 1p, 2B, 16bits */
+	case ATOMISP_INPUT_FORMAT_RGB_565: /* 1p, 2B, 16bits */
+	case ATOMISP_INPUT_FORMAT_YUV422_8: /* 2p, 4B, 32bits */
 		bits_per_pixel = 16;
 		break;
-	case ATOMISP_INPUT_FORMAT_RGB_666:		/* 4p, 9B, 72bits */
+	case ATOMISP_INPUT_FORMAT_RGB_666: /* 4p, 9B, 72bits */
 		bits_per_pixel = 18;
 		break;
-	case ATOMISP_INPUT_FORMAT_YUV422_10:		/* 2p, 5B, 40bits */
+	case ATOMISP_INPUT_FORMAT_YUV422_10: /* 2p, 5B, 40bits */
 		bits_per_pixel = 20;
 		break;
-	case ATOMISP_INPUT_FORMAT_RGB_888:		/* 1p, 3B, 24bits */
+	case ATOMISP_INPUT_FORMAT_RGB_888: /* 1p, 3B, 24bits */
 		bits_per_pixel = 24;
 		break;
 
-	case ATOMISP_INPUT_FORMAT_YUV420_16:		/* Not supported */
-	case ATOMISP_INPUT_FORMAT_YUV422_16:		/* Not supported */
-	case ATOMISP_INPUT_FORMAT_RAW_16:		/* TODO: not specified in MIPI SPEC, check */
+	case ATOMISP_INPUT_FORMAT_YUV420_16: /* Not supported */
+	case ATOMISP_INPUT_FORMAT_YUV422_16: /* Not supported */
+	case ATOMISP_INPUT_FORMAT_RAW_16: /* TODO: not specified in MIPI SPEC, check */
 	default:
 		return -EINVAL;
 	}
 
-	odd_line_bytes = (width_padded * bits_per_pixel + 7) >> 3; /* ceil ( bits per line / 8) */
+	odd_line_bytes = (width_padded * bits_per_pixel + 7) >>
+			 3; /* ceil ( bits per line / 8) */
 
 	/* Even lines for YUV420 formats are double in bits_per_pixel. */
-	if (format == ATOMISP_INPUT_FORMAT_YUV420_8
-	    || format == ATOMISP_INPUT_FORMAT_YUV420_10
-	    || format == ATOMISP_INPUT_FORMAT_YUV420_16) {
+	if (format == ATOMISP_INPUT_FORMAT_YUV420_8 ||
+	    format == ATOMISP_INPUT_FORMAT_YUV420_10 ||
+	    format == ATOMISP_INPUT_FORMAT_YUV420_16) {
 		even_line_bytes = (width_padded * 2 * bits_per_pixel + 7) >>
-			3; /* ceil ( bits per line / 8) */
+				  3; /* ceil ( bits per line / 8) */
 	} else {
 		even_line_bytes = odd_line_bytes;
 	}
@@ -149,35 +149,37 @@ ia_css_mipi_frame_calculate_size(const unsigned int width,
 
 	words_per_odd_line = (odd_line_bytes + 3) >> 2;
 	/* ceil(odd_line_bytes/4); word = 4 bytes */
-	words_per_even_line  = (even_line_bytes  + 3) >> 2;
+	words_per_even_line = (even_line_bytes + 3) >> 2;
 	words_for_first_line = words_per_odd_line + 2 + (hasSOLandEOL ? 1 : 0);
 	/* + SOF +packet header + optionally (SOL), but (EOL) is not in the first line */
-	words_per_odd_line	+= (1 + (hasSOLandEOL ? 2 : 0));
+	words_per_odd_line += (1 + (hasSOLandEOL ? 2 : 0));
 	/* each non-first line has format header, and optionally (SOL) and (EOL). */
 	words_per_even_line += (1 + (hasSOLandEOL ? 2 : 0));
 
-	mem_words_per_odd_line	 = (words_per_odd_line + 7) >> 3;
+	mem_words_per_odd_line = (words_per_odd_line + 7) >> 3;
 	/* ceil(words_per_odd_line/8); mem_word = 32 bytes, 8 words */
 	mem_words_for_first_line = (words_for_first_line + 7) >> 3;
-	mem_words_per_even_line  = (words_per_even_line + 7) >> 3;
-	mem_words_for_EOF        = 1; /* last line consist of the optional (EOL) and EOF */
-
-	mem_words = ((embedded_data_size_words + 7) >> 3) +
-	mem_words_for_first_line +
-	(((height + 1) >> 1) - 1) * mem_words_per_odd_line +
-	/* ceil (height/2) - 1 (first line is calculated separately) */
-	(height      >> 1) * mem_words_per_even_line + /* floor(height/2) */
-	mem_words_for_EOF;
-
-	*size_mem_words = mem_words; /* ceil(words/8); mem word is 32B = 8words. */
+	mem_words_per_even_line = (words_per_even_line + 7) >> 3;
+	mem_words_for_EOF =
+		1; /* last line consist of the optional (EOL) and EOF */
+
+	mem_words =
+		((embedded_data_size_words + 7) >> 3) +
+		mem_words_for_first_line +
+		(((height + 1) >> 1) - 1) * mem_words_per_odd_line +
+		/* ceil (height/2) - 1 (first line is calculated separately) */
+		(height >> 1) * mem_words_per_even_line + /* floor(height/2) */
+		mem_words_for_EOF;
+
+	*size_mem_words =
+		mem_words; /* ceil(words/8); mem word is 32B = 8words. */
 	/* Check if the above is still needed. */
 
 	IA_CSS_LEAVE_ERR(err);
 	return err;
 }
 
-void
-mipi_init(void)
+void mipi_init(void)
 {
 	unsigned int i;
 
@@ -265,36 +267,41 @@ static int calculate_mipi_buff_size(struct ia_css_stream_config *stream_cfg,
 	width_padded = width + (2 * ISP_VEC_NELEMS);
 	/* end of NOTE */
 
-	IA_CSS_ENTER("padded_width=%d, height=%d, format=%d\n",
-		     width_padded, height, format);
+	IA_CSS_ENTER("padded_width=%d, height=%d, format=%d\n", width_padded,
+		     height, format);
 
 	bits_per_pixel = sh_css_stream_format_2_bits_per_subpixel(format);
 	bits_per_pixel =
-	(format == ATOMISP_INPUT_FORMAT_RAW_10 && pack_raw_pixels) ? bits_per_pixel : 16;
+		(format == ATOMISP_INPUT_FORMAT_RAW_10 && pack_raw_pixels) ?
+			bits_per_pixel :
+			16;
 	if (bits_per_pixel == 0)
 		return -EINVAL;
 
-	odd_line_bytes = (width_padded * bits_per_pixel + 7) >> 3; /* ceil ( bits per line / 8) */
+	odd_line_bytes = (width_padded * bits_per_pixel + 7) >>
+			 3; /* ceil ( bits per line / 8) */
 
 	/* Even lines for YUV420 formats are double in bits_per_pixel. */
-	if (format == ATOMISP_INPUT_FORMAT_YUV420_8
-	    || format == ATOMISP_INPUT_FORMAT_YUV420_10) {
+	if (format == ATOMISP_INPUT_FORMAT_YUV420_8 ||
+	    format == ATOMISP_INPUT_FORMAT_YUV420_10) {
 		even_line_bytes = (width_padded * 2 * bits_per_pixel + 7) >>
-			3; /* ceil ( bits per line / 8) */
+				  3; /* ceil ( bits per line / 8) */
 	} else {
 		even_line_bytes = odd_line_bytes;
 	}
 
-	words_per_odd_line	 = (odd_line_bytes   + 3) >> 2;
+	words_per_odd_line = (odd_line_bytes + 3) >> 2;
 	/* ceil(odd_line_bytes/4); word = 4 bytes */
-	words_per_even_line  = (even_line_bytes  + 3) >> 2;
+	words_per_even_line = (even_line_bytes + 3) >> 2;
 
-	mem_words_per_odd_line	 = (words_per_odd_line + 7) >> 3;
+	mem_words_per_odd_line = (words_per_odd_line + 7) >> 3;
 	/* ceil(words_per_odd_line/8); mem_word = 32 bytes, 8 words */
-	mem_words_per_even_line  = (words_per_even_line + 7) >> 3;
+	mem_words_per_even_line = (words_per_even_line + 7) >> 3;
 
 	mem_words_per_buff_line =
-	(mem_words_per_odd_line > mem_words_per_even_line) ? mem_words_per_odd_line : mem_words_per_even_line;
+		(mem_words_per_odd_line > mem_words_per_even_line) ?
+			mem_words_per_odd_line :
+			mem_words_per_even_line;
 	mem_words_per_buff = mem_words_per_buff_line * height;
 
 	*size_mem_words = mem_words_per_buff;
@@ -303,9 +310,8 @@ static int calculate_mipi_buff_size(struct ia_css_stream_config *stream_cfg,
 	return err;
 }
 
-int
-allocate_mipi_frames(struct ia_css_pipe *pipe,
-		     struct ia_css_stream_info *info)
+int allocate_mipi_frames(struct ia_css_pipe *pipe,
+			 struct ia_css_stream_info *info)
 {
 	int err = -EINVAL;
 	unsigned int port;
@@ -314,23 +320,26 @@ allocate_mipi_frames(struct ia_css_pipe *pipe,
 			    "allocate_mipi_frames(%p) enter:\n", pipe);
 
 	if (IS_ISP2401 && pipe->stream->config.online) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "allocate_mipi_frames(%p) exit: no buffers needed for 2401 pipe mode.\n",
-				    pipe);
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"allocate_mipi_frames(%p) exit: no buffers needed for 2401 pipe mode.\n",
+			pipe);
 		return 0;
 	}
 
 	if (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "allocate_mipi_frames(%p) exit: no buffers needed for pipe mode.\n",
-				    pipe);
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"allocate_mipi_frames(%p) exit: no buffers needed for pipe mode.\n",
+			pipe);
 		return 0; /* AM TODO: Check  */
 	}
 
 	port = (unsigned int)pipe->stream->config.source.port.port;
 	if (port >= N_CSI_PORTS) {
-		IA_CSS_ERROR("allocate_mipi_frames(%p) exit: port is not correct (port=%d).",
-			     pipe, port);
+		IA_CSS_ERROR(
+			"allocate_mipi_frames(%p) exit: port is not correct (port=%d).",
+			pipe, port);
 		return -EINVAL;
 	}
 
@@ -348,9 +357,10 @@ allocate_mipi_frames(struct ia_css_pipe *pipe,
 		if (IS_ISP2401)
 			ref_count_mipi_allocation[port]++;
 
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-				    "allocate_mipi_frames(%p) leave: nothing to do, already allocated for this port (port=%d).\n",
-				    pipe, port);
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE_PRIVATE,
+			"allocate_mipi_frames(%p) leave: nothing to do, already allocated for this port (port=%d).\n",
+			pipe, port);
 		return 0;
 	}
 
@@ -373,34 +383,45 @@ allocate_mipi_frames(struct ia_css_pipe *pipe,
 			if (i < my_css.num_mipi_frames[port]) {
 				/* allocate new frame */
 				err = ia_css_frame_allocate_with_buffer_size(
-					  &my_css.mipi_frames[port][i],
-					  my_css.mipi_frame_size[port] * HIVE_ISP_DDR_WORD_BYTES);
+					&my_css.mipi_frames[port][i],
+					my_css.mipi_frame_size[port] *
+						HIVE_ISP_DDR_WORD_BYTES);
 				if (err) {
 					for (j = 0; j < i; j++) {
 						if (my_css.mipi_frames[port][j]) {
-							ia_css_frame_free(my_css.mipi_frames[port][j]);
-							my_css.mipi_frames[port][j] = NULL;
+							ia_css_frame_free(
+								my_css.mipi_frames
+									[port]
+									[j]);
+							my_css.mipi_frames[port]
+									  [j] =
+								NULL;
 						}
 					}
-					IA_CSS_ERROR("allocate_mipi_frames(%p, %d) exit: allocation failed.",
-						     pipe, port);
+					IA_CSS_ERROR(
+						"allocate_mipi_frames(%p, %d) exit: allocation failed.",
+						pipe, port);
 					return err;
 				}
 			}
 			if (info->metadata_info.size > 0) {
 				/* free previous metadata buffer */
 				if (my_css.mipi_metadata[port][i]) {
-					ia_css_metadata_free(my_css.mipi_metadata[port][i]);
+					ia_css_metadata_free(
+						my_css.mipi_metadata[port][i]);
 					my_css.mipi_metadata[port][i] = NULL;
 				}
 				/* check if need to allocate a new metadata buffer */
 				if (i < my_css.num_mipi_frames[port]) {
 					/* allocate new metadata buffer */
-					my_css.mipi_metadata[port][i] = ia_css_metadata_allocate(&info->metadata_info);
+					my_css.mipi_metadata[port][i] =
+						ia_css_metadata_allocate(
+							&info->metadata_info);
 					if (!my_css.mipi_metadata[port][i]) {
-						ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-								    "allocate_mipi_metadata(%p, %d) failed.\n",
-								    pipe, port);
+						ia_css_debug_dtrace(
+							IA_CSS_DEBUG_TRACE_PRIVATE,
+							"allocate_mipi_metadata(%p, %d) failed.\n",
+							pipe, port);
 						return err;
 					}
 				}
@@ -413,8 +434,7 @@ allocate_mipi_frames(struct ia_css_pipe *pipe,
 	return err;
 }
 
-int
-free_mipi_frames(struct ia_css_pipe *pipe)
+int free_mipi_frames(struct ia_css_pipe *pipe)
 {
 	int err = -EINVAL;
 	unsigned int port;
@@ -426,12 +446,14 @@ free_mipi_frames(struct ia_css_pipe *pipe)
 	if (pipe) {
 		assert(pipe->stream);
 		if ((!pipe) || (!pipe->stream)) {
-			IA_CSS_ERROR("free_mipi_frames(%p) exit: pipe or stream is null.",
-				     pipe);
+			IA_CSS_ERROR(
+				"free_mipi_frames(%p) exit: pipe or stream is null.",
+				pipe);
 			return -EINVAL;
 		}
 
-		if (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+		if (pipe->stream->config.mode !=
+		    IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
 			IA_CSS_ERROR("free_mipi_frames(%p) exit: wrong mode.",
 				     pipe);
 			return err;
@@ -440,8 +462,9 @@ free_mipi_frames(struct ia_css_pipe *pipe)
 		port = (unsigned int)pipe->stream->config.source.port.port;
 
 		if (port >= N_CSI_PORTS) {
-			IA_CSS_ERROR("free_mipi_frames(%p, %d) exit: pipe port is not correct.",
-				     pipe, port);
+			IA_CSS_ERROR(
+				"free_mipi_frames(%p, %d) exit: pipe port is not correct.",
+				pipe, port);
 			return err;
 		}
 
@@ -449,8 +472,10 @@ free_mipi_frames(struct ia_css_pipe *pipe)
 			if (!IS_ISP2401) {
 				assert(ref_count_mipi_allocation[port] == 1);
 				if (ref_count_mipi_allocation[port] != 1) {
-					IA_CSS_ERROR("free_mipi_frames(%p) exit: wrong ref_count (ref_count=%d).",
-						     pipe, ref_count_mipi_allocation[port]);
+					IA_CSS_ERROR(
+						"free_mipi_frames(%p) exit: wrong ref_count (ref_count=%d).",
+						pipe,
+						ref_count_mipi_allocation[port]);
 					return err;
 				}
 			}
@@ -461,21 +486,32 @@ free_mipi_frames(struct ia_css_pipe *pipe)
 				/* no streams are using this buffer, so free it */
 				unsigned int i;
 
-				for (i = 0; i < my_css.num_mipi_frames[port]; i++) {
+				for (i = 0; i < my_css.num_mipi_frames[port];
+				     i++) {
 					if (my_css.mipi_frames[port][i]) {
-						ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-								    "free_mipi_frames(port=%d, num=%d).\n", port, i);
-						ia_css_frame_free(my_css.mipi_frames[port][i]);
-						my_css.mipi_frames[port][i] = NULL;
+						ia_css_debug_dtrace(
+							IA_CSS_DEBUG_TRACE_PRIVATE,
+							"free_mipi_frames(port=%d, num=%d).\n",
+							port, i);
+						ia_css_frame_free(
+							my_css.mipi_frames[port]
+									  [i]);
+						my_css.mipi_frames[port][i] =
+							NULL;
 					}
 					if (my_css.mipi_metadata[port][i]) {
-						ia_css_metadata_free(my_css.mipi_metadata[port][i]);
-						my_css.mipi_metadata[port][i] = NULL;
+						ia_css_metadata_free(
+							my_css.mipi_metadata
+								[port][i]);
+						my_css.mipi_metadata[port][i] =
+							NULL;
 					}
 				}
 
-				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-						    "free_mipi_frames(%p) exit (deallocated).\n", pipe);
+				ia_css_debug_dtrace(
+					IA_CSS_DEBUG_TRACE_PRIVATE,
+					"free_mipi_frames(%p) exit (deallocated).\n",
+					pipe);
 			}
 		}
 	} else { /* pipe ==NULL */
@@ -485,13 +521,17 @@ free_mipi_frames(struct ia_css_pipe *pipe)
 
 			for (i = 0; i < my_css.num_mipi_frames[port]; i++) {
 				if (my_css.mipi_frames[port][i]) {
-					ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-							    "free_mipi_frames(port=%d, num=%d).\n", port, i);
-					ia_css_frame_free(my_css.mipi_frames[port][i]);
+					ia_css_debug_dtrace(
+						IA_CSS_DEBUG_TRACE_PRIVATE,
+						"free_mipi_frames(port=%d, num=%d).\n",
+						port, i);
+					ia_css_frame_free(
+						my_css.mipi_frames[port][i]);
 					my_css.mipi_frames[port][i] = NULL;
 				}
 				if (my_css.mipi_metadata[port][i]) {
-					ia_css_metadata_free(my_css.mipi_metadata[port][i]);
+					ia_css_metadata_free(
+						my_css.mipi_metadata[port][i]);
 					my_css.mipi_metadata[port][i] = NULL;
 				}
 			}
@@ -501,8 +541,7 @@ free_mipi_frames(struct ia_css_pipe *pipe)
 	return 0;
 }
 
-int
-send_mipi_frames(struct ia_css_pipe *pipe)
+int send_mipi_frames(struct ia_css_pipe *pipe)
 {
 	int err = -EINVAL;
 	unsigned int i;
@@ -521,18 +560,21 @@ send_mipi_frames(struct ia_css_pipe *pipe)
 	port = (unsigned int)pipe->stream->config.source.port.port;
 
 	if (port >= N_CSI_PORTS) {
-		IA_CSS_ERROR("send_mipi_frames(%p) exit: invalid port specified (port=%d).",
-			     pipe, port);
+		IA_CSS_ERROR(
+			"send_mipi_frames(%p) exit: invalid port specified (port=%d).",
+			pipe, port);
 		return err;
 	}
 
 	/* Hand-over the SP-internal mipi buffers */
 	for (i = 0; i < my_css.num_mipi_frames[port]; i++) {
 		/* Need to include the offset for port. */
-		sh_css_update_host2sp_mipi_frame(port * NUM_MIPI_FRAMES_PER_STREAM + i,
-						 my_css.mipi_frames[port][i]);
-		sh_css_update_host2sp_mipi_metadata(port * NUM_MIPI_FRAMES_PER_STREAM + i,
-						    my_css.mipi_metadata[port][i]);
+		sh_css_update_host2sp_mipi_frame(
+			port * NUM_MIPI_FRAMES_PER_STREAM + i,
+			my_css.mipi_frames[port][i]);
+		sh_css_update_host2sp_mipi_metadata(
+			port * NUM_MIPI_FRAMES_PER_STREAM + i,
+			my_css.mipi_metadata[port][i]);
 	}
 	sh_css_update_host2sp_num_mipi_frames(my_css.num_mipi_frames[port]);
 
@@ -546,11 +588,10 @@ send_mipi_frames(struct ia_css_pipe *pipe)
 		return err;
 	}
 
-	ia_css_bufq_enqueue_psys_event(
-	    IA_CSS_PSYS_SW_EVENT_MIPI_BUFFERS_READY,
-	    (uint8_t)port,
-	    (uint8_t)my_css.num_mipi_frames[port],
-	    0 /* not used */);
+	ia_css_bufq_enqueue_psys_event(IA_CSS_PSYS_SW_EVENT_MIPI_BUFFERS_READY,
+				       (uint8_t)port,
+				       (uint8_t)my_css.num_mipi_frames[port],
+				       0 /* not used */);
 	IA_CSS_LEAVE_ERR_PRIVATE(0);
 	return 0;
 }
diff --git a/drivers/staging/media/atomisp/pci/sh_css_mipi.h b/drivers/staging/media/atomisp/pci/sh_css_mipi.h
index 6f7389f44baa7c7616fd79df58842b9b6689c214..ab4c5f4f1fe39149439412690893e0b08a9a2c26 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_mipi.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_mipi.h
@@ -7,22 +7,19 @@
 #ifndef __SH_CSS_MIPI_H
 #define __SH_CSS_MIPI_H
 
-#include <ia_css_err.h>		  /* ia_css_err */
-#include <ia_css_types.h>	  /* ia_css_pipe */
+#include <ia_css_err.h> /* ia_css_err */
+#include <ia_css_types.h> /* ia_css_pipe */
 #include <ia_css_stream_public.h> /* ia_css_stream_config */
 
-void
-mipi_init(void);
+void mipi_init(void);
 
 bool mipi_is_free(void);
 
-int
-allocate_mipi_frames(struct ia_css_pipe *pipe, struct ia_css_stream_info *info);
+int allocate_mipi_frames(struct ia_css_pipe *pipe,
+			 struct ia_css_stream_info *info);
 
-int
-free_mipi_frames(struct ia_css_pipe *pipe);
+int free_mipi_frames(struct ia_css_pipe *pipe);
 
-int
-send_mipi_frames(struct ia_css_pipe *pipe);
+int send_mipi_frames(struct ia_css_pipe *pipe);
 
 #endif /* __SH_CSS_MIPI_H */
diff --git a/drivers/staging/media/atomisp/pci/sh_css_mmu.c b/drivers/staging/media/atomisp/pci/sh_css_mmu.c
index f2a84c1d6e525a59cbbed79c38648029abf02c79..2967781cdfd9a8189ff660c26078a54005b850db 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_mmu.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_mmu.c
@@ -12,8 +12,7 @@
 #include "sp.h"
 #include "mmu_device.h"
 
-void
-ia_css_mmu_invalidate_cache(void)
+void ia_css_mmu_invalidate_cache(void)
 {
 	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
 	unsigned int HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb;
@@ -23,20 +22,21 @@ ia_css_mmu_invalidate_cache(void)
 
 	/* if the SP is not running we should not access its dmem */
 	if (sh_css_sp_is_running()) {
-		HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb = fw->info.sp.invalidate_tlb;
+		HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb =
+			fw->info.sp.invalidate_tlb;
 
 		(void)HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb; /* Suppres warnings in CRUN */
 
 		sp_dmem_store_uint32(SP0_ID,
-				     (unsigned int)sp_address_of(ia_css_dmaproxy_sp_invalidate_tlb),
+				     (unsigned int)sp_address_of(
+					     ia_css_dmaproxy_sp_invalidate_tlb),
 				     true);
 	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
 			    "ia_css_mmu_invalidate_cache() leave\n");
 }
 
-void
-sh_css_mmu_set_page_table_base_index(hrt_data base_index)
+void sh_css_mmu_set_page_table_base_index(hrt_data base_index)
 {
 	int i;
 
diff --git a/drivers/staging/media/atomisp/pci/sh_css_param_dvs.c b/drivers/staging/media/atomisp/pci/sh_css_param_dvs.c
index 7fa4aab35b0611803063868ffa2d72f670575499..47f323003556dfd01e0bd8e18a0e6c28e2950f49 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_param_dvs.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_param_dvs.c
@@ -13,52 +13,60 @@
 
 static struct ia_css_dvs_6axis_config *
 alloc_dvs_6axis_table(const struct ia_css_resolution *frame_res,
-		      struct ia_css_dvs_6axis_config  *dvs_config_src)
+		      struct ia_css_dvs_6axis_config *dvs_config_src)
 {
 	unsigned int width_y = 0;
 	unsigned int height_y = 0;
 	unsigned int width_uv = 0;
 	unsigned int height_uv = 0;
 	int err = 0;
-	struct ia_css_dvs_6axis_config  *dvs_config = NULL;
+	struct ia_css_dvs_6axis_config *dvs_config = NULL;
 
-	dvs_config = kvmalloc(sizeof(struct ia_css_dvs_6axis_config),
-			      GFP_KERNEL);
-	if (!dvs_config)	{
+	dvs_config =
+		kvmalloc(sizeof(struct ia_css_dvs_6axis_config), GFP_KERNEL);
+	if (!dvs_config) {
 		IA_CSS_ERROR("out of memory");
 		err = -ENOMEM;
 	} else {
 		/*Initialize new struct with latest config settings*/
 		if (dvs_config_src) {
 			dvs_config->width_y = width_y = dvs_config_src->width_y;
-			dvs_config->height_y = height_y = dvs_config_src->height_y;
-			dvs_config->width_uv = width_uv = dvs_config_src->width_uv;
-			dvs_config->height_uv = height_uv = dvs_config_src->height_uv;
-			IA_CSS_LOG("alloc_dvs_6axis_table Y: W %d H %d", width_y, height_y);
+			dvs_config->height_y = height_y =
+				dvs_config_src->height_y;
+			dvs_config->width_uv = width_uv =
+				dvs_config_src->width_uv;
+			dvs_config->height_uv = height_uv =
+				dvs_config_src->height_uv;
+			IA_CSS_LOG("alloc_dvs_6axis_table Y: W %d H %d",
+				   width_y, height_y);
 		} else if (frame_res) {
-			dvs_config->width_y = width_y = DVS_TABLE_IN_BLOCKDIM_X_LUMA(frame_res->width);
-			dvs_config->height_y = height_y = DVS_TABLE_IN_BLOCKDIM_Y_LUMA(
-							      frame_res->height);
-			dvs_config->width_uv = width_uv = DVS_TABLE_IN_BLOCKDIM_X_CHROMA(
-							      frame_res->width /
-							      2); /* UV = Y/2, depens on colour format YUV 4.2.0*/
-			dvs_config->height_uv = height_uv = DVS_TABLE_IN_BLOCKDIM_Y_CHROMA(
-								frame_res->height /
-								2);/* UV = Y/2, depens on colour format YUV 4.2.0*/
-			IA_CSS_LOG("alloc_dvs_6axis_table Y: W %d H %d", width_y, height_y);
+			dvs_config->width_y = width_y =
+				DVS_TABLE_IN_BLOCKDIM_X_LUMA(frame_res->width);
+			dvs_config->height_y = height_y =
+				DVS_TABLE_IN_BLOCKDIM_Y_LUMA(frame_res->height);
+			dvs_config->width_uv = width_uv =
+				DVS_TABLE_IN_BLOCKDIM_X_CHROMA(
+					frame_res->width /
+					2); /* UV = Y/2, depens on colour format YUV 4.2.0*/
+			dvs_config->height_uv = height_uv =
+				DVS_TABLE_IN_BLOCKDIM_Y_CHROMA(
+					frame_res->height /
+					2); /* UV = Y/2, depens on colour format YUV 4.2.0*/
+			IA_CSS_LOG("alloc_dvs_6axis_table Y: W %d H %d",
+				   width_y, height_y);
 		}
 
 		/* Generate Y buffers  */
-		dvs_config->xcoords_y = kvmalloc(width_y * height_y * sizeof(uint32_t),
-						 GFP_KERNEL);
+		dvs_config->xcoords_y = kvmalloc(
+			width_y * height_y * sizeof(uint32_t), GFP_KERNEL);
 		if (!dvs_config->xcoords_y) {
 			IA_CSS_ERROR("out of memory");
 			err = -ENOMEM;
 			goto exit;
 		}
 
-		dvs_config->ycoords_y = kvmalloc(width_y * height_y * sizeof(uint32_t),
-						 GFP_KERNEL);
+		dvs_config->ycoords_y = kvmalloc(
+			width_y * height_y * sizeof(uint32_t), GFP_KERNEL);
 		if (!dvs_config->ycoords_y) {
 			IA_CSS_ERROR("out of memory");
 			err = -ENOMEM;
@@ -68,16 +76,16 @@ alloc_dvs_6axis_table(const struct ia_css_resolution *frame_res,
 		/* Generate UV buffers  */
 		IA_CSS_LOG("UV W %d H %d", width_uv, height_uv);
 
-		dvs_config->xcoords_uv = kvmalloc(width_uv * height_uv * sizeof(uint32_t),
-						  GFP_KERNEL);
+		dvs_config->xcoords_uv = kvmalloc(
+			width_uv * height_uv * sizeof(uint32_t), GFP_KERNEL);
 		if (!dvs_config->xcoords_uv) {
 			IA_CSS_ERROR("out of memory");
 			err = -ENOMEM;
 			goto exit;
 		}
 
-		dvs_config->ycoords_uv = kvmalloc(width_uv * height_uv * sizeof(uint32_t),
-						  GFP_KERNEL);
+		dvs_config->ycoords_uv = kvmalloc(
+			width_uv * height_uv * sizeof(uint32_t), GFP_KERNEL);
 		if (!dvs_config->ycoords_uv) {
 			IA_CSS_ERROR("out of memory");
 			err = -ENOMEM;
@@ -85,7 +93,7 @@ alloc_dvs_6axis_table(const struct ia_css_resolution *frame_res,
 exit:
 		if (err) {
 			free_dvs_6axis_table(
-			    &dvs_config); /* we might have allocated some memory, release this */
+				&dvs_config); /* we might have allocated some memory, release this */
 			dvs_config = NULL;
 		}
 	}
@@ -108,39 +116,43 @@ init_dvs_6axis_table_from_default(struct ia_css_dvs_6axis_config *dvs_config,
 		   dvs_offset->width, dvs_offset->height, width_y, height_y);
 	for (y = 0; y < height_y; y++) {
 		for (x = 0; x < width_y; x++) {
-			dvs_config->xcoords_y[y * width_y + x] =  (dvs_offset->width + x *
-				DVS_BLOCKDIM_X) << DVS_COORD_FRAC_BITS;
+			dvs_config->xcoords_y[y * width_y + x] =
+				(dvs_offset->width + x * DVS_BLOCKDIM_X)
+				<< DVS_COORD_FRAC_BITS;
 		}
 	}
 
 	for (y = 0; y < height_y; y++) {
 		for (x = 0; x < width_y; x++) {
-			dvs_config->ycoords_y[y * width_y + x] =  (dvs_offset->height + y *
-				DVS_BLOCKDIM_Y_LUMA) << DVS_COORD_FRAC_BITS;
+			dvs_config->ycoords_y[y * width_y + x] =
+				(dvs_offset->height + y * DVS_BLOCKDIM_Y_LUMA)
+				<< DVS_COORD_FRAC_BITS;
 		}
 	}
 
 	for (y = 0; y < height_uv; y++) {
 		for (x = 0; x < width_uv;
 		     x++) { /* Envelope dimensions set in Ypixels hence offset UV = offset Y/2 */
-			dvs_config->xcoords_uv[y * width_uv + x] =  ((dvs_offset->width / 2) + x *
-				DVS_BLOCKDIM_X) << DVS_COORD_FRAC_BITS;
+			dvs_config->xcoords_uv[y * width_uv + x] =
+				((dvs_offset->width / 2) + x * DVS_BLOCKDIM_X)
+				<< DVS_COORD_FRAC_BITS;
 		}
 	}
 
 	for (y = 0; y < height_uv; y++) {
 		for (x = 0; x < width_uv;
 		     x++) { /* Envelope dimensions set in Ypixels hence offset UV = offset Y/2 */
-			dvs_config->ycoords_uv[y * width_uv + x] =  ((dvs_offset->height / 2) + y *
-				DVS_BLOCKDIM_Y_CHROMA) <<
-				DVS_COORD_FRAC_BITS;
+			dvs_config->ycoords_uv[y * width_uv + x] =
+				((dvs_offset->height / 2) +
+				 y * DVS_BLOCKDIM_Y_CHROMA)
+				<< DVS_COORD_FRAC_BITS;
 		}
 	}
 }
 
 static void
 init_dvs_6axis_table_from_config(struct ia_css_dvs_6axis_config *dvs_config,
-				 struct ia_css_dvs_6axis_config  *dvs_config_src)
+				 struct ia_css_dvs_6axis_config *dvs_config_src)
 {
 	unsigned int width_y = dvs_config->width_y;
 	unsigned int height_y = dvs_config->height_y;
@@ -174,9 +186,8 @@ generate_dvs_6axis_table(const struct ia_css_resolution *frame_res,
 	return NULL;
 }
 
-struct ia_css_dvs_6axis_config *
-generate_dvs_6axis_table_from_config(struct ia_css_dvs_6axis_config
-				     *dvs_config_src)
+struct ia_css_dvs_6axis_config *generate_dvs_6axis_table_from_config(
+	struct ia_css_dvs_6axis_config *dvs_config_src)
 {
 	struct ia_css_dvs_6axis_config *dvs_6axis_table;
 
@@ -184,17 +195,18 @@ generate_dvs_6axis_table_from_config(struct ia_css_dvs_6axis_config
 
 	dvs_6axis_table = alloc_dvs_6axis_table(NULL, dvs_config_src);
 	if (dvs_6axis_table) {
-		init_dvs_6axis_table_from_config(dvs_6axis_table, dvs_config_src);
+		init_dvs_6axis_table_from_config(dvs_6axis_table,
+						 dvs_config_src);
 		return dvs_6axis_table;
 	}
 	return NULL;
 }
 
-void
-free_dvs_6axis_table(struct ia_css_dvs_6axis_config  **dvs_6axis_config)
+void free_dvs_6axis_table(struct ia_css_dvs_6axis_config **dvs_6axis_config)
 {
 	if ((dvs_6axis_config) && (*dvs_6axis_config)) {
-		IA_CSS_ENTER_PRIVATE("dvs_6axis_config %p", (*dvs_6axis_config));
+		IA_CSS_ENTER_PRIVATE("dvs_6axis_config %p",
+				     (*dvs_6axis_config));
 		if ((*dvs_6axis_config)->xcoords_y) {
 			kvfree((*dvs_6axis_config)->xcoords_y);
 			(*dvs_6axis_config)->xcoords_y = NULL;
@@ -216,7 +228,8 @@ free_dvs_6axis_table(struct ia_css_dvs_6axis_config  **dvs_6axis_config)
 			(*dvs_6axis_config)->ycoords_uv = NULL;
 		}
 
-		IA_CSS_LEAVE_PRIVATE("dvs_6axis_config %p", (*dvs_6axis_config));
+		IA_CSS_LEAVE_PRIVATE("dvs_6axis_config %p",
+				     (*dvs_6axis_config));
 		kvfree(*dvs_6axis_config);
 		*dvs_6axis_config = NULL;
 	}
@@ -244,7 +257,8 @@ void copy_dvs_6axis_table(struct ia_css_dvs_6axis_config *dvs_config_dst,
 	width_y = dvs_config_src->width_y;
 	height_y = dvs_config_src->height_y;
 	width_uv =
-	    dvs_config_src->width_uv; /* = Y/2, depens on colour format YUV 4.2.0*/
+		dvs_config_src
+			->width_uv; /* = Y/2, depens on colour format YUV 4.2.0*/
 	height_uv = dvs_config_src->height_uv;
 
 	memcpy(dvs_config_dst->xcoords_y, dvs_config_src->xcoords_y,
@@ -258,10 +272,9 @@ void copy_dvs_6axis_table(struct ia_css_dvs_6axis_config *dvs_config_dst,
 	       (width_uv * height_uv * sizeof(uint32_t)));
 }
 
-void
-ia_css_dvs_statistics_get(enum dvs_statistics_type type,
-			  union ia_css_dvs_statistics_host  *host_stats,
-			  const union ia_css_dvs_statistics_isp *isp_stats)
+void ia_css_dvs_statistics_get(enum dvs_statistics_type type,
+			       union ia_css_dvs_statistics_host *host_stats,
+			       const union ia_css_dvs_statistics_isp *isp_stats)
 {
 	if (type == DVS_STATISTICS) {
 		ia_css_get_dvs_statistics(host_stats->p_dvs_statistics_host,
diff --git a/drivers/staging/media/atomisp/pci/sh_css_param_dvs.h b/drivers/staging/media/atomisp/pci/sh_css_param_dvs.h
index b7057887adea688df3e41810f84ede58cad0283f..6cf719b6f9a2b9adb7413a9cbec458fa224bf89a 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_param_dvs.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_param_dvs.h
@@ -14,24 +14,26 @@
 #define DVS_ENV_MIN_X (12)
 #define DVS_ENV_MIN_Y (12)
 
-#define DVS_BLOCKDIM_X (64)        /* X block height*/
-#define DVS_BLOCKDIM_Y_LUMA (64)   /* Y block height*/
-#define DVS_BLOCKDIM_Y_CHROMA (32) /* UV height block size is half the Y block height*/
+#define DVS_BLOCKDIM_X (64) /* X block height*/
+#define DVS_BLOCKDIM_Y_LUMA (64) /* Y block height*/
+#define DVS_BLOCKDIM_Y_CHROMA \
+	(32) /* UV height block size is half the Y block height*/
 
 /* ISP2400 */
 /* horizontal 64x64 blocks round up to DVS_BLOCKDIM_X, make even */
-#define DVS_NUM_BLOCKS_X(X)		(CEIL_MUL(CEIL_DIV((X), DVS_BLOCKDIM_X), 2))
+#define DVS_NUM_BLOCKS_X(X) (CEIL_MUL(CEIL_DIV((X), DVS_BLOCKDIM_X), 2))
 
 /* ISP2400 */
 /* vertical   64x64 blocks round up to DVS_BLOCKDIM_Y */
-#define DVS_NUM_BLOCKS_Y(X)		(CEIL_DIV((X), DVS_BLOCKDIM_Y_LUMA))
-#define DVS_NUM_BLOCKS_X_CHROMA(X)	(CEIL_DIV((X), DVS_BLOCKDIM_X))
-#define DVS_NUM_BLOCKS_Y_CHROMA(X)	(CEIL_DIV((X), DVS_BLOCKDIM_Y_CHROMA))
+#define DVS_NUM_BLOCKS_Y(X) (CEIL_DIV((X), DVS_BLOCKDIM_Y_LUMA))
+#define DVS_NUM_BLOCKS_X_CHROMA(X) (CEIL_DIV((X), DVS_BLOCKDIM_X))
+#define DVS_NUM_BLOCKS_Y_CHROMA(X) (CEIL_DIV((X), DVS_BLOCKDIM_Y_CHROMA))
 
-#define DVS_TABLE_IN_BLOCKDIM_X_LUMA(X)	(DVS_NUM_BLOCKS_X(X) + 1)  /* N blocks have N + 1 set of coords */
-#define DVS_TABLE_IN_BLOCKDIM_X_CHROMA(X)   (DVS_NUM_BLOCKS_X_CHROMA(X) + 1)
-#define DVS_TABLE_IN_BLOCKDIM_Y_LUMA(X)		(DVS_NUM_BLOCKS_Y(X) + 1)
-#define DVS_TABLE_IN_BLOCKDIM_Y_CHROMA(X)	(DVS_NUM_BLOCKS_Y_CHROMA(X) + 1)
+#define DVS_TABLE_IN_BLOCKDIM_X_LUMA(X) \
+	(DVS_NUM_BLOCKS_X(X) + 1) /* N blocks have N + 1 set of coords */
+#define DVS_TABLE_IN_BLOCKDIM_X_CHROMA(X) (DVS_NUM_BLOCKS_X_CHROMA(X) + 1)
+#define DVS_TABLE_IN_BLOCKDIM_Y_LUMA(X) (DVS_NUM_BLOCKS_Y(X) + 1)
+#define DVS_TABLE_IN_BLOCKDIM_Y_CHROMA(X) (DVS_NUM_BLOCKS_Y_CHROMA(X) + 1)
 
 #define DVS_ENVELOPE_X(X) (((X) == 0) ? (DVS_ENV_MIN_X) : (X))
 #define DVS_ENVELOPE_Y(X) (((X) == 0) ? (DVS_ENV_MIN_Y) : (X))
@@ -43,14 +45,14 @@
 
 #define XMEM_ALIGN_LOG2 (5)
 
-#define DVS_6AXIS_COORDS_ELEMS CEIL_MUL(sizeof(gdc_warp_param_mem_t) \
-					, HIVE_ISP_DDR_WORD_BYTES)
+#define DVS_6AXIS_COORDS_ELEMS \
+	CEIL_MUL(sizeof(gdc_warp_param_mem_t), HIVE_ISP_DDR_WORD_BYTES)
 
 /* currently we only support two output with the same resolution, output 0 is th default one. */
-#define DVS_6AXIS_BYTES(binary) \
-	(DVS_6AXIS_COORDS_ELEMS \
-	* DVS_NUM_BLOCKS_X((binary)->out_frame_info[0].res.width) \
-	* DVS_NUM_BLOCKS_Y((binary)->out_frame_info[0].res.height))
+#define DVS_6AXIS_BYTES(binary)                                    \
+	(DVS_6AXIS_COORDS_ELEMS *                                  \
+	 DVS_NUM_BLOCKS_X((binary)->out_frame_info[0].res.width) * \
+	 DVS_NUM_BLOCKS_Y((binary)->out_frame_info[0].res.height))
 
 /*
  * ISP2400:
@@ -59,18 +61,15 @@
 #define DVS_GDC_INTERP_METHOD HRT_GDC_BLI_MODE
 
 struct ia_css_dvs_6axis_config *
-generate_dvs_6axis_table(const struct ia_css_resolution	*frame_res,
+generate_dvs_6axis_table(const struct ia_css_resolution *frame_res,
 			 const struct ia_css_resolution *dvs_offset);
 
-struct ia_css_dvs_6axis_config *
-generate_dvs_6axis_table_from_config(struct ia_css_dvs_6axis_config
-				     *dvs_config_src);
+struct ia_css_dvs_6axis_config *generate_dvs_6axis_table_from_config(
+	struct ia_css_dvs_6axis_config *dvs_config_src);
 
-void
-free_dvs_6axis_table(struct ia_css_dvs_6axis_config  **dvs_6axis_config);
+void free_dvs_6axis_table(struct ia_css_dvs_6axis_config **dvs_6axis_config);
 
-void
-copy_dvs_6axis_table(struct ia_css_dvs_6axis_config *dvs_config_dst,
-		     const struct ia_css_dvs_6axis_config *dvs_config_src);
+void copy_dvs_6axis_table(struct ia_css_dvs_6axis_config *dvs_config_dst,
+			  const struct ia_css_dvs_6axis_config *dvs_config_src);
 
 #endif
diff --git a/drivers/staging/media/atomisp/pci/sh_css_param_shading.c b/drivers/staging/media/atomisp/pci/sh_css_param_shading.c
index 513e272f2fdc0cce5761c4389acf5f05e09ef18a..af0a38aa46c2601d11da2bca9a33134f0a39ee4c 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_param_shading.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_param_shading.c
@@ -62,47 +62,39 @@
  * fall. We extrapolate the shading table into the
  * padded area and then interpolate.
  */
-static void
-crop_and_interpolate(unsigned int cropped_width,
-		     unsigned int cropped_height,
-		     unsigned int left_padding,
-		     int right_padding,
-		     int top_padding,
-		     const struct ia_css_shading_table *in_table,
-		     struct ia_css_shading_table *out_table,
-		     enum ia_css_sc_color color)
+static void crop_and_interpolate(unsigned int cropped_width,
+				 unsigned int cropped_height,
+				 unsigned int left_padding, int right_padding,
+				 int top_padding,
+				 const struct ia_css_shading_table *in_table,
+				 struct ia_css_shading_table *out_table,
+				 enum ia_css_sc_color color)
 {
-	unsigned int i, j,
-		 sensor_width,
-		 sensor_height,
-		 table_width,
-		 table_height,
-		 table_cell_h,
-		 out_cell_size,
-		 in_cell_size,
-		 out_start_row,
-		 padded_width;
+	unsigned int i, j, sensor_width, sensor_height, table_width,
+		table_height, table_cell_h, out_cell_size, in_cell_size,
+		out_start_row, padded_width;
 	int out_start_col, /* can be negative to indicate padded space */
-	    table_cell_w;
-	unsigned short *in_ptr,
-		 *out_ptr;
+		table_cell_w;
+	unsigned short *in_ptr, *out_ptr;
 
 	assert(in_table);
 	assert(out_table);
 
-	sensor_width  = in_table->sensor_width;
+	sensor_width = in_table->sensor_width;
 	sensor_height = in_table->sensor_height;
-	table_width   = in_table->width;
-	table_height  = in_table->height;
+	table_width = in_table->width;
+	table_height = in_table->height;
 	in_ptr = in_table->data[color];
 	out_ptr = out_table->data[color];
 
 	padded_width = cropped_width + left_padding + right_padding;
 	out_cell_size = CEIL_DIV(padded_width, out_table->width - 1);
-	in_cell_size  = CEIL_DIV(sensor_width, table_width - 1);
+	in_cell_size = CEIL_DIV(sensor_width, table_width - 1);
 
-	out_start_col = ((int)sensor_width - (int)cropped_width) / 2 - left_padding;
-	out_start_row = ((int)sensor_height - (int)cropped_height) / 2 - top_padding;
+	out_start_col =
+		((int)sensor_width - (int)cropped_width) / 2 - left_padding;
+	out_start_row =
+		((int)sensor_height - (int)cropped_height) / 2 - top_padding;
 	table_cell_w = (int)((table_width - 1) * in_cell_size);
 	table_cell_h = (table_height - 1) * in_cell_size;
 
@@ -189,18 +181,18 @@ crop_and_interpolate(unsigned int cropped_width,
 			s_ll = in_ptr[(table_width * src_y1) + src_x0];
 			s_lr = in_ptr[(table_width * src_y1) + src_x1];
 
-			*out_ptr = (unsigned short)((dx0 * dy0 * s_lr + dx0 * dy1 * s_ur + dx1 * dy0 *
-						     s_ll + dx1 * dy1 * s_ul) /
+			*out_ptr = (unsigned short)((dx0 * dy0 * s_lr +
+						     dx0 * dy1 * s_ur +
+						     dx1 * dy0 * s_ll +
+						     dx1 * dy1 * s_ul) /
 						    (divx * divy));
 		}
 	}
 }
 
-void
-sh_css_params_shading_id_table_generate(
-    struct ia_css_shading_table **target_table,
-    unsigned int table_width,
-    unsigned int table_height)
+void sh_css_params_shading_id_table_generate(
+	struct ia_css_shading_table **target_table, unsigned int table_width,
+	unsigned int table_height)
 {
 	/* initialize table with ones, shift becomes zero */
 	unsigned int i, j;
@@ -222,12 +214,11 @@ sh_css_params_shading_id_table_generate(
 	*target_table = result;
 }
 
-void
-prepare_shading_table(const struct ia_css_shading_table *in_table,
-		      unsigned int sensor_binning,
-		      struct ia_css_shading_table **target_table,
-		      const struct ia_css_binary *binary,
-		      unsigned int bds_factor)
+void prepare_shading_table(const struct ia_css_shading_table *in_table,
+			   unsigned int sensor_binning,
+			   struct ia_css_shading_table **target_table,
+			   const struct ia_css_binary *binary,
+			   unsigned int bds_factor)
 {
 	unsigned int input_width, input_height, table_width, table_height, i;
 	unsigned int left_padding, top_padding, left_cropping;
@@ -239,9 +230,9 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 	assert(binary);
 
 	if (!in_table) {
-		sh_css_params_shading_id_table_generate(target_table,
-							binary->sctbl_width_per_color,
-							binary->sctbl_height);
+		sh_css_params_shading_id_table_generate(
+			target_table, binary->sctbl_width_per_color,
+			binary->sctbl_height);
 		return;
 	}
 
@@ -250,22 +241,26 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 	 * shading correction is performed in the bayer domain (before bayer
 	 * down scaling).
 	 */
-	input_height  = binary->in_frame_info.res.height;
-	input_width   = binary->in_frame_info.res.width;
-	left_padding  = binary->left_padding;
+	input_height = binary->in_frame_info.res.height;
+	input_width = binary->in_frame_info.res.width;
+	left_padding = binary->left_padding;
 	left_cropping = (binary->info->sp.pipeline.left_cropping == 0) ?
-			binary->dvs_envelope.width : 2 * ISP_VEC_NELEMS;
+				binary->dvs_envelope.width :
+				2 * ISP_VEC_NELEMS;
 
 	sh_css_bds_factor_get_fract(bds_factor, &bds);
 
-	left_padding  = (left_padding + binary->info->sp.pipeline.left_cropping) *
+	left_padding =
+		(left_padding + binary->info->sp.pipeline.left_cropping) *
 			bds.numerator / bds.denominator -
-			binary->info->sp.pipeline.left_cropping;
+		binary->info->sp.pipeline.left_cropping;
 	right_padding = (binary->internal_frame_info.res.width -
-			 binary->effective_in_frame_res.width * bds.denominator /
-			 bds.numerator - left_cropping) * bds.numerator / bds.denominator;
+			 binary->effective_in_frame_res.width *
+				 bds.denominator / bds.numerator -
+			 left_cropping) *
+			bds.numerator / bds.denominator;
 	top_padding = binary->info->sp.pipeline.top_cropping * bds.numerator /
-		      bds.denominator -
+			      bds.denominator -
 		      binary->info->sp.pipeline.top_cropping;
 
 	/*
@@ -273,27 +268,27 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 	 * by cropping the non-binned part of the shading table and then
 	 * increasing the size of a grid cell with this same binning factor.
 	 */
-	input_width  <<= sensor_binning;
+	input_width <<= sensor_binning;
 	input_height <<= sensor_binning;
 	/*
 	 * We also scale the padding by the same binning factor. This will
 	 * make it much easier later on to calculate the padding of the
 	 * shading table.
 	 */
-	left_padding  <<= sensor_binning;
+	left_padding <<= sensor_binning;
 	right_padding <<= sensor_binning;
-	top_padding   <<= sensor_binning;
+	top_padding <<= sensor_binning;
 
 	/*
 	 * during simulation, the used resolution can exceed the sensor
 	 * resolution, so we clip it.
 	 */
-	input_width  = min(input_width,  in_table->sensor_width);
+	input_width = min(input_width, in_table->sensor_width);
 	input_height = min(input_height, in_table->sensor_height);
 
 	/* This prepare_shading_table() function is called only in legacy API (not in new API).
 	   Then, the legacy shading table width and height should be used. */
-	table_width  = binary->sctbl_width_per_color;
+	table_width = binary->sctbl_width_per_color;
 	table_height = binary->sctbl_height;
 
 	result = ia_css_shading_table_alloc(table_width, table_height);
@@ -301,7 +296,7 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 		*target_table = NULL;
 		return;
 	}
-	result->sensor_width  = in_table->sensor_width;
+	result->sensor_width = in_table->sensor_width;
 	result->sensor_height = in_table->sensor_height;
 	result->fraction_bits = in_table->fraction_bits;
 
@@ -310,18 +305,15 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 	 * requested resolution and decimation factor.
 	 */
 	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
-		crop_and_interpolate(input_width, input_height,
-				     left_padding, right_padding, top_padding,
-				     in_table,
+		crop_and_interpolate(input_width, input_height, left_padding,
+				     right_padding, top_padding, in_table,
 				     result, i);
 	}
 	*target_table = result;
 }
 
-struct ia_css_shading_table *
-ia_css_shading_table_alloc(
-    unsigned int width,
-    unsigned int height)
+struct ia_css_shading_table *ia_css_shading_table_alloc(unsigned int width,
+							unsigned int height)
 {
 	unsigned int i;
 	struct ia_css_shading_table *me;
@@ -332,15 +324,14 @@ ia_css_shading_table_alloc(
 	if (!me)
 		return me;
 
-	me->width         = width;
-	me->height        = height;
-	me->sensor_width  = 0;
+	me->width = width;
+	me->height = height;
+	me->sensor_width = 0;
 	me->sensor_height = 0;
 	me->fraction_bits = 0;
 	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
-		me->data[i] =
-		    kvmalloc(width * height * sizeof(*me->data[0]),
-			     GFP_KERNEL);
+		me->data[i] = kvmalloc(width * height * sizeof(*me->data[0]),
+				       GFP_KERNEL);
 		if (!me->data[i]) {
 			unsigned int j;
 
@@ -357,8 +348,7 @@ ia_css_shading_table_alloc(
 	return me;
 }
 
-void
-ia_css_shading_table_free(struct ia_css_shading_table *table)
+void ia_css_shading_table_free(struct ia_css_shading_table *table)
 {
 	unsigned int i;
 
diff --git a/drivers/staging/media/atomisp/pci/sh_css_param_shading.h b/drivers/staging/media/atomisp/pci/sh_css_param_shading.h
index b4ca8815dc1bbf9af5c13918d7877dbe15f4ea83..73c52aba519a161d2a7ae6fa5e1b3f8211de0fc3 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_param_shading.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_param_shading.h
@@ -10,17 +10,14 @@
 #include <ia_css_types.h>
 #include <ia_css_binary.h>
 
-void
-sh_css_params_shading_id_table_generate(
-    struct ia_css_shading_table **target_table,
-    unsigned int table_width,
-    unsigned int table_height);
+void sh_css_params_shading_id_table_generate(
+	struct ia_css_shading_table **target_table, unsigned int table_width,
+	unsigned int table_height);
 
-void
-prepare_shading_table(const struct ia_css_shading_table *in_table,
-		      unsigned int sensor_binning,
-		      struct ia_css_shading_table **target_table,
-		      const struct ia_css_binary *binary,
-		      unsigned int bds_factor);
+void prepare_shading_table(const struct ia_css_shading_table *in_table,
+			   unsigned int sensor_binning,
+			   struct ia_css_shading_table **target_table,
+			   const struct ia_css_binary *binary,
+			   unsigned int bds_factor);
 
 #endif /* __SH_CSS_PARAMS_SHADING_H */
diff --git a/drivers/staging/media/atomisp/pci/sh_css_params.c b/drivers/staging/media/atomisp/pci/sh_css_params.c
index 0d4a936ad80f535beff38487de19a77b85c04387..67a096ff1c8b961ceb734a1eb4ea9a52a84c6b20 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_params.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_params.c
@@ -4,8 +4,8 @@
  * Copyright (c) 2015, Intel Corporation.
  */
 
-#include "gdc_device.h"		/* gdc_lut_store(), ... */
-#include "isp.h"			/* ISP_VEC_ELEMBITS */
+#include "gdc_device.h" /* gdc_lut_store(), ... */
+#include "isp.h" /* ISP_VEC_ELEMBITS */
 #include "vamem.h"
 #ifndef __INLINE_HMEM__
 #define __INLINE_HMEM__
@@ -17,12 +17,12 @@
 #include "hmm.h"
 #include "sh_css_params.h"
 #include "ia_css_queue.h"
-#include "sw_event_global.h"		/* Event IDs */
+#include "sw_event_global.h" /* Event IDs */
 
 #include "platform_support.h"
 #include "assert_support.h"
-#include "misc_support.h"	/* NOT_USED */
-#include "math_support.h"	/* max(), min()  EVEN_FLOOR()*/
+#include "misc_support.h" /* NOT_USED */
+#include "math_support.h" /* max(), min()  EVEN_FLOOR()*/
 
 #include "ia_css_stream.h"
 #include "sh_css_params_internal.h"
@@ -85,14 +85,12 @@
 
 #include "xnr/xnr_3.0/ia_css_xnr3.host.h"
 
-
 #include "sh_css_frac.h"
 #include "ia_css_bufq.h"
 
 static size_t fpntbl_bytes(const struct ia_css_binary *binary)
 {
-	return array3_size(sizeof(char),
-			   binary->in_frame_info.res.height,
+	return array3_size(sizeof(char), binary->in_frame_info.res.height,
 			   binary->in_frame_info.padded_width);
 }
 
@@ -118,10 +116,8 @@ static ia_css_ptr sp_ddr_ptrs;
 /* sp group address on DDR */
 static ia_css_ptr xmem_sp_group_ptrs;
 
-static ia_css_ptr xmem_sp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
-[SH_CSS_MAX_STAGES];
-static ia_css_ptr xmem_isp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
-[SH_CSS_MAX_STAGES];
+static ia_css_ptr xmem_sp_stage_ptrs[IA_CSS_PIPE_ID_NUM][SH_CSS_MAX_STAGES];
+static ia_css_ptr xmem_isp_stage_ptrs[IA_CSS_PIPE_ID_NUM][SH_CSS_MAX_STAGES];
 
 static ia_css_ptr default_gdc_lut;
 static int interleaved_lut_temp[4][HRT_GDC_N];
@@ -132,546 +128,609 @@ static int interleaved_lut_temp[4][HRT_GDC_N];
  * contents of this table.
  */
 static const int zoom_table[4][HRT_GDC_N] = {
-	{
-		0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
-		  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
-		  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
-		  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
-		  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
-		  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
-		  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
-		  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
-		  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
-		  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
-		  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
-		  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
-		  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
-		  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4,
-		  -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4,
-		  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
-		  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
-		  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
-		  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
-		  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
-		  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
-		  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
-		  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
-		  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
-		  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
-		  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
-		  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
-		  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
-		  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4
-	},
-	{
-		0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,
-		  2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,
-		  4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,
-		  4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,
-		  7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,
-		  7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,
-		  9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,
-		  9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,
-		  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,
-		  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,
-		  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,
-		  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,
-		  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,
-		  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,
-		  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,
-		  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,
-		  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,
-		  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,
-		  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,
-		  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,
-		  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,
-		  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,
-		  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,
-		  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,
-		  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,
-		  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,
-		  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,
-		  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,
-		  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,
-		  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,
-		  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,
-		  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,
-		  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,
-		  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,
-		  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,
-		  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,
-		  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,
-		  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,
-		  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,
-		  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,
-		  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,
-		  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,
-		  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,
-		  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,
-		  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,
-		  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,
-		  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,
-		  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,
-		  105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4,
-		  105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4,
-		  110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4,
-		  110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4,
-		  116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4,
-		  116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4,
-		  121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4,
-		  121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4,
-		  127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4,
-		  127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4,
-		  132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4,
-		  132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4,
-		  138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4,
-		  138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4,
-		  144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4,
-		  144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4,
-		  149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4,
-		  149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4,
-		  154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4,
-		  154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4,
-		  160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4,
-		  160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4,
-		  165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4,
-		  165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4,
-		  170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4,
-		  170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4,
-		  176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4,
-		  176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4,
-		  181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4,
-		  181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4,
-		  186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4,
-		  186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4,
-		  191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4,
-		  191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4,
-		  195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4,
-		  195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4,
-		  200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4,
-		  200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4,
-		  205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4,
-		  205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4,
-		  209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4,
-		  209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4,
-		  213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4,
-		  213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4,
-		  218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4,
-		  218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4,
-		  222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4,
-		  222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4,
-		  225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4,
-		  225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4,
-		  229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4,
-		  229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4,
-		  232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4,
-		  232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4,
-		  236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4,
-		  236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4,
-		  239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4,
-		  239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4,
-		  241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4,
-		  241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4,
-		  244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4,
-		  244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4,
-		  246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4,
-		  246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4,
-		  248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4,
-		  248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4,
-		  250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4,
-		  250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4,
-		  252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4,
-		  252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4,
-		  253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4,
-		  253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4,
-		  254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4,
-		  254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4,
-		  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
-		  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
-		  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
-		  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4
-	},
-	{
-		256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4,
-		    256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4,
-		    255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
-		    255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
-		    255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
-		    255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
-		    254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4,
-		    254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4,
-		    253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4,
-		    253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4,
-		    252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4,
-		    252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4,
-		    250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4,
-		    250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4,
-		    248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4,
-		    248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4,
-		    246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4,
-		    246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4,
-		    244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4,
-		    244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4,
-		    241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4,
-		    241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4,
-		    239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4,
-		    239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4,
-		    236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4,
-		    236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4,
-		    232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4,
-		    232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4,
-		    229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4,
-		    229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4,
-		    225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4,
-		    225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4,
-		    222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4,
-		    222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4,
-		    218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4,
-		    218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4,
-		    213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4,
-		    213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4,
-		    209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4,
-		    209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4,
-		    205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4,
-		    205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4,
-		    200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4,
-		    200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4,
-		    195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4,
-		    195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4,
-		    191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4,
-		    191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4,
-		    186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4,
-		    186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4,
-		    181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4,
-		    181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4,
-		    176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4,
-		    176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4,
-		    170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4,
-		    170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4,
-		    165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4,
-		    165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4,
-		    160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4,
-		    160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4,
-		    154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4,
-		    154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4,
-		    149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4,
-		    149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4,
-		    144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4,
-		    144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4,
-		    138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4,
-		    138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4,
-		    132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4,
-		    132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4,
-		    127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4,
-		    127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4,
-		    121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4,
-		    121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4,
-		    116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4,
-		    116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4,
-		    110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4,
-		    110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4,
-		    105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4,
-		    105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4,
-		    99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,
-		    99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,  99 << 4,
-		    94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,
-		    94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,  94 << 4,
-		    88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,
-		    88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,  88 << 4,
-		    83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,
-		    83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,  83 << 4,
-		    78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,
-		    78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,  78 << 4,
-		    73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,
-		    73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,  73 << 4,
-		    67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,
-		    67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,  67 << 4,
-		    62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,
-		    62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,  62 << 4,
-		    58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,
-		    58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,  58 << 4,
-		    53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,
-		    53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,  53 << 4,
-		    48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,
-		    48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,  48 << 4,
-		    43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,
-		    43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,  43 << 4,
-		    39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,
-		    39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,  39 << 4,
-		    35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,
-		    35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,  35 << 4,
-		    31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,
-		    31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,  31 << 4,
-		    27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,
-		    27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,  27 << 4,
-		    23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,
-		    23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,  23 << 4,
-		    19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,
-		    19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,  19 << 4,
-		    16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,
-		    16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,  16 << 4,
-		    12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,
-		    12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,  12 << 4,
-		    9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,
-		    9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,   9 << 4,
-		    7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,
-		    7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,   7 << 4,
-		    4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,
-		    4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,   4 << 4,
-		    2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,
-		    2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4,   2 << 4
-	},
-	{
-		0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
-		  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
-		  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4,
-		  -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
-		  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
-		  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
-		  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
-		  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
-		  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
-		  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
-		  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
-		  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
-		  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
-		  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
-		  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
-		  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
-		  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
-		  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
-		  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
-		  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
-		  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
-		  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
-		  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
-		  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
-		  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
-		  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
-		  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  1 << 4,   1 << 4,   1 << 4,   1 << 4,   1 << 4,   1 << 4,   1 << 4,   1 << 4,
-		  1 << 4,   1 << 4,   1 << 4,   1 << 4,   1 << 4,   1 << 4,   1 << 4,   1 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,
-		  0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4,   0 << 4
-	}
+	{ 0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
+	  -2 << 4,  -2 << 4,  -2 << 4,	-2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
+	  -2 << 4,  -2 << 4,  -2 << 4,	-2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
+	  -2 << 4,  -2 << 4,  -2 << 4,	-2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
+	  -2 << 4,  -2 << 4,  -2 << 4,	-2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
+	  -2 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -4 << 4,  -4 << 4,
+	  -4 << 4,  -4 << 4,  -4 << 4,	-4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
+	  -4 << 4,  -4 << 4,  -4 << 4,	-4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
+	  -4 << 4,  -4 << 4,  -4 << 4,	-4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
+	  -4 << 4,  -4 << 4,  -4 << 4,	-4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
+	  -4 << 4,  -4 << 4,  -5 << 4,	-5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
+	  -5 << 4,  -5 << 4,  -5 << 4,	-5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
+	  -5 << 4,  -5 << 4,  -5 << 4,	-5 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -7 << 4,  -7 << 4,	-7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
+	  -7 << 4,  -7 << 4,  -7 << 4,	-7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
+	  -7 << 4,  -7 << 4,  -7 << 4,	-7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
+	  -7 << 4,  -7 << 4,  -7 << 4,	-7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
+	  -7 << 4,  -7 << 4,  -7 << 4,	-7 << 4,  -7 << 4,  -8 << 4,  -8 << 4,
+	  -8 << 4,  -8 << 4,  -8 << 4,	-8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
+	  -8 << 4,  -8 << 4,  -8 << 4,	-8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -10 << 4, -10 << 4, -10 << 4,
+	  -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4,
+	  -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -8 << 4,
+	  -8 << 4,  -8 << 4,  -8 << 4,	-8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
+	  -8 << 4,  -8 << 4,  -8 << 4,	-8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
+	  -8 << 4,  -7 << 4,  -7 << 4,	-7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
+	  -7 << 4,  -7 << 4,  -7 << 4,	-7 << 4,  -7 << 4,  -7 << 4,  -7 << 4,
+	  -7 << 4,  -7 << 4,  -7 << 4,	-5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
+	  -5 << 4,  -5 << 4,  -5 << 4,	-5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
+	  -5 << 4,  -5 << 4,  -5 << 4,	-5 << 4,  -5 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4 },
+	{ 0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   2 << 4,	2 << 4,	  2 << 4,   2 << 4,   2 << 4,
+	  2 << 4,   2 << 4,   2 << 4,	2 << 4,	  2 << 4,   2 << 4,   2 << 4,
+	  2 << 4,   2 << 4,   2 << 4,	2 << 4,	  4 << 4,   4 << 4,   4 << 4,
+	  4 << 4,   4 << 4,   4 << 4,	4 << 4,	  4 << 4,   4 << 4,   4 << 4,
+	  4 << 4,   4 << 4,   4 << 4,	4 << 4,	  4 << 4,   4 << 4,   7 << 4,
+	  7 << 4,   7 << 4,   7 << 4,	7 << 4,	  7 << 4,   7 << 4,   7 << 4,
+	  7 << 4,   7 << 4,   7 << 4,	7 << 4,	  7 << 4,   7 << 4,   7 << 4,
+	  7 << 4,   9 << 4,   9 << 4,	9 << 4,	  9 << 4,   9 << 4,   9 << 4,
+	  9 << 4,   9 << 4,   9 << 4,	9 << 4,	  9 << 4,   9 << 4,   9 << 4,
+	  9 << 4,   9 << 4,   9 << 4,	12 << 4,  12 << 4,  12 << 4,  12 << 4,
+	  12 << 4,  12 << 4,  12 << 4,	12 << 4,  12 << 4,  12 << 4,  12 << 4,
+	  12 << 4,  12 << 4,  12 << 4,	12 << 4,  12 << 4,  16 << 4,  16 << 4,
+	  16 << 4,  16 << 4,  16 << 4,	16 << 4,  16 << 4,  16 << 4,  16 << 4,
+	  16 << 4,  16 << 4,  16 << 4,	16 << 4,  16 << 4,  16 << 4,  16 << 4,
+	  19 << 4,  19 << 4,  19 << 4,	19 << 4,  19 << 4,  19 << 4,  19 << 4,
+	  19 << 4,  19 << 4,  19 << 4,	19 << 4,  19 << 4,  19 << 4,  19 << 4,
+	  19 << 4,  19 << 4,  23 << 4,	23 << 4,  23 << 4,  23 << 4,  23 << 4,
+	  23 << 4,  23 << 4,  23 << 4,	23 << 4,  23 << 4,  23 << 4,  23 << 4,
+	  23 << 4,  23 << 4,  23 << 4,	23 << 4,  27 << 4,  27 << 4,  27 << 4,
+	  27 << 4,  27 << 4,  27 << 4,	27 << 4,  27 << 4,  27 << 4,  27 << 4,
+	  27 << 4,  27 << 4,  27 << 4,	27 << 4,  27 << 4,  27 << 4,  31 << 4,
+	  31 << 4,  31 << 4,  31 << 4,	31 << 4,  31 << 4,  31 << 4,  31 << 4,
+	  31 << 4,  31 << 4,  31 << 4,	31 << 4,  31 << 4,  31 << 4,  31 << 4,
+	  31 << 4,  35 << 4,  35 << 4,	35 << 4,  35 << 4,  35 << 4,  35 << 4,
+	  35 << 4,  35 << 4,  35 << 4,	35 << 4,  35 << 4,  35 << 4,  35 << 4,
+	  35 << 4,  35 << 4,  35 << 4,	39 << 4,  39 << 4,  39 << 4,  39 << 4,
+	  39 << 4,  39 << 4,  39 << 4,	39 << 4,  39 << 4,  39 << 4,  39 << 4,
+	  39 << 4,  39 << 4,  39 << 4,	39 << 4,  39 << 4,  43 << 4,  43 << 4,
+	  43 << 4,  43 << 4,  43 << 4,	43 << 4,  43 << 4,  43 << 4,  43 << 4,
+	  43 << 4,  43 << 4,  43 << 4,	43 << 4,  43 << 4,  43 << 4,  43 << 4,
+	  48 << 4,  48 << 4,  48 << 4,	48 << 4,  48 << 4,  48 << 4,  48 << 4,
+	  48 << 4,  48 << 4,  48 << 4,	48 << 4,  48 << 4,  48 << 4,  48 << 4,
+	  48 << 4,  48 << 4,  53 << 4,	53 << 4,  53 << 4,  53 << 4,  53 << 4,
+	  53 << 4,  53 << 4,  53 << 4,	53 << 4,  53 << 4,  53 << 4,  53 << 4,
+	  53 << 4,  53 << 4,  53 << 4,	53 << 4,  58 << 4,  58 << 4,  58 << 4,
+	  58 << 4,  58 << 4,  58 << 4,	58 << 4,  58 << 4,  58 << 4,  58 << 4,
+	  58 << 4,  58 << 4,  58 << 4,	58 << 4,  58 << 4,  58 << 4,  62 << 4,
+	  62 << 4,  62 << 4,  62 << 4,	62 << 4,  62 << 4,  62 << 4,  62 << 4,
+	  62 << 4,  62 << 4,  62 << 4,	62 << 4,  62 << 4,  62 << 4,  62 << 4,
+	  62 << 4,  67 << 4,  67 << 4,	67 << 4,  67 << 4,  67 << 4,  67 << 4,
+	  67 << 4,  67 << 4,  67 << 4,	67 << 4,  67 << 4,  67 << 4,  67 << 4,
+	  67 << 4,  67 << 4,  67 << 4,	73 << 4,  73 << 4,  73 << 4,  73 << 4,
+	  73 << 4,  73 << 4,  73 << 4,	73 << 4,  73 << 4,  73 << 4,  73 << 4,
+	  73 << 4,  73 << 4,  73 << 4,	73 << 4,  73 << 4,  78 << 4,  78 << 4,
+	  78 << 4,  78 << 4,  78 << 4,	78 << 4,  78 << 4,  78 << 4,  78 << 4,
+	  78 << 4,  78 << 4,  78 << 4,	78 << 4,  78 << 4,  78 << 4,  78 << 4,
+	  83 << 4,  83 << 4,  83 << 4,	83 << 4,  83 << 4,  83 << 4,  83 << 4,
+	  83 << 4,  83 << 4,  83 << 4,	83 << 4,  83 << 4,  83 << 4,  83 << 4,
+	  83 << 4,  83 << 4,  88 << 4,	88 << 4,  88 << 4,  88 << 4,  88 << 4,
+	  88 << 4,  88 << 4,  88 << 4,	88 << 4,  88 << 4,  88 << 4,  88 << 4,
+	  88 << 4,  88 << 4,  88 << 4,	88 << 4,  94 << 4,  94 << 4,  94 << 4,
+	  94 << 4,  94 << 4,  94 << 4,	94 << 4,  94 << 4,  94 << 4,  94 << 4,
+	  94 << 4,  94 << 4,  94 << 4,	94 << 4,  94 << 4,  94 << 4,  99 << 4,
+	  99 << 4,  99 << 4,  99 << 4,	99 << 4,  99 << 4,  99 << 4,  99 << 4,
+	  99 << 4,  99 << 4,  99 << 4,	99 << 4,  99 << 4,  99 << 4,  99 << 4,
+	  99 << 4,  105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4,
+	  105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4,
+	  105 << 4, 105 << 4, 105 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4,
+	  110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4,
+	  110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 116 << 4, 116 << 4,
+	  116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4,
+	  116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4,
+	  121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4,
+	  121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4,
+	  121 << 4, 121 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4,
+	  127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4,
+	  127 << 4, 127 << 4, 127 << 4, 127 << 4, 132 << 4, 132 << 4, 132 << 4,
+	  132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4,
+	  132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 138 << 4,
+	  138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4,
+	  138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4,
+	  138 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4,
+	  144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4,
+	  144 << 4, 144 << 4, 144 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4,
+	  149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4,
+	  149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 154 << 4, 154 << 4,
+	  154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4,
+	  154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4,
+	  160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4,
+	  160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4,
+	  160 << 4, 160 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4,
+	  165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4,
+	  165 << 4, 165 << 4, 165 << 4, 165 << 4, 170 << 4, 170 << 4, 170 << 4,
+	  170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4,
+	  170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 176 << 4,
+	  176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4,
+	  176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4,
+	  176 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4,
+	  181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4,
+	  181 << 4, 181 << 4, 181 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4,
+	  186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4,
+	  186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 191 << 4, 191 << 4,
+	  191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4,
+	  191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4,
+	  195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4,
+	  195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4,
+	  195 << 4, 195 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4,
+	  200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4,
+	  200 << 4, 200 << 4, 200 << 4, 200 << 4, 205 << 4, 205 << 4, 205 << 4,
+	  205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4,
+	  205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 209 << 4,
+	  209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4,
+	  209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4,
+	  209 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4,
+	  213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4,
+	  213 << 4, 213 << 4, 213 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4,
+	  218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4,
+	  218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 222 << 4, 222 << 4,
+	  222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4,
+	  222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4,
+	  225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4,
+	  225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4,
+	  225 << 4, 225 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4,
+	  229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4,
+	  229 << 4, 229 << 4, 229 << 4, 229 << 4, 232 << 4, 232 << 4, 232 << 4,
+	  232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4,
+	  232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 236 << 4,
+	  236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4,
+	  236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4,
+	  236 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4,
+	  239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4,
+	  239 << 4, 239 << 4, 239 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4,
+	  241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4,
+	  241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 244 << 4, 244 << 4,
+	  244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4,
+	  244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4,
+	  246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4,
+	  246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4,
+	  246 << 4, 246 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4,
+	  248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4,
+	  248 << 4, 248 << 4, 248 << 4, 248 << 4, 250 << 4, 250 << 4, 250 << 4,
+	  250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4,
+	  250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 252 << 4,
+	  252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4,
+	  252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4,
+	  252 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4,
+	  253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4,
+	  253 << 4, 253 << 4, 253 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4,
+	  254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4,
+	  254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 255 << 4, 255 << 4,
+	  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
+	  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
+	  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
+	  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
+	  255 << 4, 255 << 4 },
+	{ 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4,
+	  256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4, 256 << 4,
+	  256 << 4, 256 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
+	  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
+	  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
+	  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4,
+	  255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 255 << 4, 254 << 4,
+	  254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4,
+	  254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4, 254 << 4,
+	  254 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4,
+	  253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4, 253 << 4,
+	  253 << 4, 253 << 4, 253 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4,
+	  252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4,
+	  252 << 4, 252 << 4, 252 << 4, 252 << 4, 252 << 4, 250 << 4, 250 << 4,
+	  250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4,
+	  250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4, 250 << 4,
+	  248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4,
+	  248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4, 248 << 4,
+	  248 << 4, 248 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4,
+	  246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4, 246 << 4,
+	  246 << 4, 246 << 4, 246 << 4, 246 << 4, 244 << 4, 244 << 4, 244 << 4,
+	  244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4,
+	  244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 244 << 4, 241 << 4,
+	  241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4,
+	  241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4, 241 << 4,
+	  241 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4,
+	  239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4, 239 << 4,
+	  239 << 4, 239 << 4, 239 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4,
+	  236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4,
+	  236 << 4, 236 << 4, 236 << 4, 236 << 4, 236 << 4, 232 << 4, 232 << 4,
+	  232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4,
+	  232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4, 232 << 4,
+	  229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4,
+	  229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4, 229 << 4,
+	  229 << 4, 229 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4,
+	  225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4, 225 << 4,
+	  225 << 4, 225 << 4, 225 << 4, 225 << 4, 222 << 4, 222 << 4, 222 << 4,
+	  222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4,
+	  222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 222 << 4, 218 << 4,
+	  218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4,
+	  218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4, 218 << 4,
+	  218 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4,
+	  213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4, 213 << 4,
+	  213 << 4, 213 << 4, 213 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4,
+	  209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4,
+	  209 << 4, 209 << 4, 209 << 4, 209 << 4, 209 << 4, 205 << 4, 205 << 4,
+	  205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4,
+	  205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4, 205 << 4,
+	  200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4,
+	  200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4, 200 << 4,
+	  200 << 4, 200 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4,
+	  195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4, 195 << 4,
+	  195 << 4, 195 << 4, 195 << 4, 195 << 4, 191 << 4, 191 << 4, 191 << 4,
+	  191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4,
+	  191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 191 << 4, 186 << 4,
+	  186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4,
+	  186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4, 186 << 4,
+	  186 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4,
+	  181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4, 181 << 4,
+	  181 << 4, 181 << 4, 181 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4,
+	  176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4,
+	  176 << 4, 176 << 4, 176 << 4, 176 << 4, 176 << 4, 170 << 4, 170 << 4,
+	  170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4,
+	  170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4, 170 << 4,
+	  165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4,
+	  165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4, 165 << 4,
+	  165 << 4, 165 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4,
+	  160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4, 160 << 4,
+	  160 << 4, 160 << 4, 160 << 4, 160 << 4, 154 << 4, 154 << 4, 154 << 4,
+	  154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4,
+	  154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 154 << 4, 149 << 4,
+	  149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4,
+	  149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4, 149 << 4,
+	  149 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4,
+	  144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4, 144 << 4,
+	  144 << 4, 144 << 4, 144 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4,
+	  138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4,
+	  138 << 4, 138 << 4, 138 << 4, 138 << 4, 138 << 4, 132 << 4, 132 << 4,
+	  132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4,
+	  132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4, 132 << 4,
+	  127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4,
+	  127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4, 127 << 4,
+	  127 << 4, 127 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4,
+	  121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4, 121 << 4,
+	  121 << 4, 121 << 4, 121 << 4, 121 << 4, 116 << 4, 116 << 4, 116 << 4,
+	  116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4,
+	  116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 116 << 4, 110 << 4,
+	  110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4,
+	  110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4, 110 << 4,
+	  110 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4,
+	  105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4, 105 << 4,
+	  105 << 4, 105 << 4, 105 << 4, 99 << 4,  99 << 4,  99 << 4,  99 << 4,
+	  99 << 4,  99 << 4,  99 << 4,	99 << 4,  99 << 4,  99 << 4,  99 << 4,
+	  99 << 4,  99 << 4,  99 << 4,	99 << 4,  99 << 4,  94 << 4,  94 << 4,
+	  94 << 4,  94 << 4,  94 << 4,	94 << 4,  94 << 4,  94 << 4,  94 << 4,
+	  94 << 4,  94 << 4,  94 << 4,	94 << 4,  94 << 4,  94 << 4,  94 << 4,
+	  88 << 4,  88 << 4,  88 << 4,	88 << 4,  88 << 4,  88 << 4,  88 << 4,
+	  88 << 4,  88 << 4,  88 << 4,	88 << 4,  88 << 4,  88 << 4,  88 << 4,
+	  88 << 4,  88 << 4,  83 << 4,	83 << 4,  83 << 4,  83 << 4,  83 << 4,
+	  83 << 4,  83 << 4,  83 << 4,	83 << 4,  83 << 4,  83 << 4,  83 << 4,
+	  83 << 4,  83 << 4,  83 << 4,	83 << 4,  78 << 4,  78 << 4,  78 << 4,
+	  78 << 4,  78 << 4,  78 << 4,	78 << 4,  78 << 4,  78 << 4,  78 << 4,
+	  78 << 4,  78 << 4,  78 << 4,	78 << 4,  78 << 4,  78 << 4,  73 << 4,
+	  73 << 4,  73 << 4,  73 << 4,	73 << 4,  73 << 4,  73 << 4,  73 << 4,
+	  73 << 4,  73 << 4,  73 << 4,	73 << 4,  73 << 4,  73 << 4,  73 << 4,
+	  73 << 4,  67 << 4,  67 << 4,	67 << 4,  67 << 4,  67 << 4,  67 << 4,
+	  67 << 4,  67 << 4,  67 << 4,	67 << 4,  67 << 4,  67 << 4,  67 << 4,
+	  67 << 4,  67 << 4,  67 << 4,	62 << 4,  62 << 4,  62 << 4,  62 << 4,
+	  62 << 4,  62 << 4,  62 << 4,	62 << 4,  62 << 4,  62 << 4,  62 << 4,
+	  62 << 4,  62 << 4,  62 << 4,	62 << 4,  62 << 4,  58 << 4,  58 << 4,
+	  58 << 4,  58 << 4,  58 << 4,	58 << 4,  58 << 4,  58 << 4,  58 << 4,
+	  58 << 4,  58 << 4,  58 << 4,	58 << 4,  58 << 4,  58 << 4,  58 << 4,
+	  53 << 4,  53 << 4,  53 << 4,	53 << 4,  53 << 4,  53 << 4,  53 << 4,
+	  53 << 4,  53 << 4,  53 << 4,	53 << 4,  53 << 4,  53 << 4,  53 << 4,
+	  53 << 4,  53 << 4,  48 << 4,	48 << 4,  48 << 4,  48 << 4,  48 << 4,
+	  48 << 4,  48 << 4,  48 << 4,	48 << 4,  48 << 4,  48 << 4,  48 << 4,
+	  48 << 4,  48 << 4,  48 << 4,	48 << 4,  43 << 4,  43 << 4,  43 << 4,
+	  43 << 4,  43 << 4,  43 << 4,	43 << 4,  43 << 4,  43 << 4,  43 << 4,
+	  43 << 4,  43 << 4,  43 << 4,	43 << 4,  43 << 4,  43 << 4,  39 << 4,
+	  39 << 4,  39 << 4,  39 << 4,	39 << 4,  39 << 4,  39 << 4,  39 << 4,
+	  39 << 4,  39 << 4,  39 << 4,	39 << 4,  39 << 4,  39 << 4,  39 << 4,
+	  39 << 4,  35 << 4,  35 << 4,	35 << 4,  35 << 4,  35 << 4,  35 << 4,
+	  35 << 4,  35 << 4,  35 << 4,	35 << 4,  35 << 4,  35 << 4,  35 << 4,
+	  35 << 4,  35 << 4,  35 << 4,	31 << 4,  31 << 4,  31 << 4,  31 << 4,
+	  31 << 4,  31 << 4,  31 << 4,	31 << 4,  31 << 4,  31 << 4,  31 << 4,
+	  31 << 4,  31 << 4,  31 << 4,	31 << 4,  31 << 4,  27 << 4,  27 << 4,
+	  27 << 4,  27 << 4,  27 << 4,	27 << 4,  27 << 4,  27 << 4,  27 << 4,
+	  27 << 4,  27 << 4,  27 << 4,	27 << 4,  27 << 4,  27 << 4,  27 << 4,
+	  23 << 4,  23 << 4,  23 << 4,	23 << 4,  23 << 4,  23 << 4,  23 << 4,
+	  23 << 4,  23 << 4,  23 << 4,	23 << 4,  23 << 4,  23 << 4,  23 << 4,
+	  23 << 4,  23 << 4,  19 << 4,	19 << 4,  19 << 4,  19 << 4,  19 << 4,
+	  19 << 4,  19 << 4,  19 << 4,	19 << 4,  19 << 4,  19 << 4,  19 << 4,
+	  19 << 4,  19 << 4,  19 << 4,	19 << 4,  16 << 4,  16 << 4,  16 << 4,
+	  16 << 4,  16 << 4,  16 << 4,	16 << 4,  16 << 4,  16 << 4,  16 << 4,
+	  16 << 4,  16 << 4,  16 << 4,	16 << 4,  16 << 4,  16 << 4,  12 << 4,
+	  12 << 4,  12 << 4,  12 << 4,	12 << 4,  12 << 4,  12 << 4,  12 << 4,
+	  12 << 4,  12 << 4,  12 << 4,	12 << 4,  12 << 4,  12 << 4,  12 << 4,
+	  12 << 4,  9 << 4,   9 << 4,	9 << 4,	  9 << 4,   9 << 4,   9 << 4,
+	  9 << 4,   9 << 4,   9 << 4,	9 << 4,	  9 << 4,   9 << 4,   9 << 4,
+	  9 << 4,   9 << 4,   9 << 4,	7 << 4,	  7 << 4,   7 << 4,   7 << 4,
+	  7 << 4,   7 << 4,   7 << 4,	7 << 4,	  7 << 4,   7 << 4,   7 << 4,
+	  7 << 4,   7 << 4,   7 << 4,	7 << 4,	  7 << 4,   4 << 4,   4 << 4,
+	  4 << 4,   4 << 4,   4 << 4,	4 << 4,	  4 << 4,   4 << 4,   4 << 4,
+	  4 << 4,   4 << 4,   4 << 4,	4 << 4,	  4 << 4,   4 << 4,   4 << 4,
+	  2 << 4,   2 << 4,   2 << 4,	2 << 4,	  2 << 4,   2 << 4,   2 << 4,
+	  2 << 4,   2 << 4,   2 << 4,	2 << 4,	  2 << 4,   2 << 4,   2 << 4,
+	  2 << 4,   2 << 4 },
+	{ 0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -5 << 4,
+	  -5 << 4,  -5 << 4,  -5 << 4,	-5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
+	  -5 << 4,  -5 << 4,  -5 << 4,	-5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
+	  -5 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
+	  -8 << 4,  -8 << 4,  -8 << 4,	-8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
+	  -8 << 4,  -8 << 4,  -8 << 4,	-8 << 4,  -8 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4,
+	  -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4, -10 << 4,
+	  -10 << 4, -10 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -13 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
+	  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
+	  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
+	  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
+	  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -19 << 4, -19 << 4, -19 << 4,
+	  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
+	  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
+	  -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4, -19 << 4,
+	  -19 << 4, -19 << 4, -19 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4,
+	  -18 << 4, -18 << 4, -18 << 4, -18 << 4, -18 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4, -17 << 4,
+	  -17 << 4, -17 << 4, -17 << 4, -17 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4, -16 << 4,
+	  -16 << 4, -16 << 4, -16 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4,
+	  -15 << 4, -15 << 4, -15 << 4, -15 << 4, -15 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4, -14 << 4,
+	  -14 << 4, -14 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4, -13 << 4,
+	  -13 << 4, -13 << 4, -13 << 4, -13 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4, -12 << 4,
+	  -12 << 4, -12 << 4, -12 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4, -11 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -9 << 4,
+	  -9 << 4,  -9 << 4,  -9 << 4,	-9 << 4,  -9 << 4,  -9 << 4,  -8 << 4,
+	  -8 << 4,  -8 << 4,  -8 << 4,	-8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
+	  -8 << 4,  -8 << 4,  -8 << 4,	-8 << 4,  -8 << 4,  -8 << 4,  -8 << 4,
+	  -8 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -6 << 4,  -6 << 4,  -6 << 4,	-6 << 4,  -6 << 4,  -6 << 4,  -6 << 4,
+	  -5 << 4,  -5 << 4,  -5 << 4,	-5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
+	  -5 << 4,  -5 << 4,  -5 << 4,	-5 << 4,  -5 << 4,  -5 << 4,  -5 << 4,
+	  -5 << 4,  -5 << 4,  -4 << 4,	-4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
+	  -4 << 4,  -4 << 4,  -4 << 4,	-4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
+	  -4 << 4,  -4 << 4,  -4 << 4,	-4 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -4 << 4,
+	  -4 << 4,  -4 << 4,  -4 << 4,	-4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
+	  -4 << 4,  -4 << 4,  -4 << 4,	-4 << 4,  -4 << 4,  -4 << 4,  -4 << 4,
+	  -4 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-3 << 4,  -3 << 4,  -3 << 4,  -3 << 4,
+	  -3 << 4,  -3 << 4,  -3 << 4,	-2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
+	  -2 << 4,  -2 << 4,  -2 << 4,	-2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
+	  -2 << 4,  -2 << 4,  -2 << 4,	-2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
+	  -2 << 4,  -2 << 4,  -2 << 4,	-2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
+	  -2 << 4,  -2 << 4,  -2 << 4,	-2 << 4,  -2 << 4,  -2 << 4,  -2 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  -1 << 4,
+	  -1 << 4,  -1 << 4,  -1 << 4,	-1 << 4,  -1 << 4,  -1 << 4,  0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   1 << 4,   1 << 4,	1 << 4,	  1 << 4,   1 << 4,   1 << 4,
+	  1 << 4,   1 << 4,   1 << 4,	1 << 4,	  1 << 4,   1 << 4,   1 << 4,
+	  1 << 4,   1 << 4,   1 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4,   0 << 4,	0 << 4,	  0 << 4,   0 << 4,   0 << 4,
+	  0 << 4,   0 << 4 }
 };
 
-static const struct ia_css_dz_config default_dz_config = {
-	HRT_GDC_N,
-	HRT_GDC_N,
-	{
-		\
-		{0, 0}, \
-		{0, 0}, \
-	}
-};
+static const struct ia_css_dz_config default_dz_config = { HRT_GDC_N,
+							   HRT_GDC_N,
+							   {
 
-static const struct ia_css_vector default_motion_config = {
-	0,
-	0
-};
+								   { 0, 0 },
+								   { 0, 0 },
+							   } };
+
+static const struct ia_css_vector default_motion_config = { 0, 0 };
 
 /* ------ deprecated(bz675) : from ------ */
 static const struct ia_css_shading_settings default_shading_settings = {
-	1	/* enable shading table conversion in the css
+	1 /* enable shading table conversion in the css
 		(This matches the legacy way.) */
 };
 
@@ -681,71 +740,55 @@ struct ia_css_isp_skc_dvs_statistics {
 	ia_css_ptr p_data;
 };
 
-static int
-ref_sh_css_ddr_address_map(
-    struct sh_css_ddr_address_map *map,
-    struct sh_css_ddr_address_map *out);
+static int ref_sh_css_ddr_address_map(struct sh_css_ddr_address_map *map,
+				      struct sh_css_ddr_address_map *out);
 
-static int
-write_ia_css_isp_parameter_set_info_to_ddr(
-    struct ia_css_isp_parameter_set_info *me,
-    ia_css_ptr *out);
+static int write_ia_css_isp_parameter_set_info_to_ddr(
+	struct ia_css_isp_parameter_set_info *me, ia_css_ptr *out);
 
-static int
-free_ia_css_isp_parameter_set_info(ia_css_ptr ptr);
+static int free_ia_css_isp_parameter_set_info(ia_css_ptr ptr);
 
-static int
-sh_css_params_write_to_ddr_internal(
-    struct ia_css_pipe *pipe,
-    unsigned int pipe_id,
-    struct ia_css_isp_parameters *params,
-    const struct ia_css_pipeline_stage *stage,
-    struct sh_css_ddr_address_map *ddr_map,
-    struct sh_css_ddr_address_map_size *ddr_map_size);
+static int sh_css_params_write_to_ddr_internal(
+	struct ia_css_pipe *pipe, unsigned int pipe_id,
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_pipeline_stage *stage,
+	struct sh_css_ddr_address_map *ddr_map,
+	struct sh_css_ddr_address_map_size *ddr_map_size);
 
 static int
 sh_css_create_isp_params(struct ia_css_stream *stream,
 			 struct ia_css_isp_parameters **isp_params_out);
 
-static bool
-sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
-				   struct ia_css_isp_parameters *params,
-				   bool use_default_config,
-				   struct ia_css_pipe *pipe_in);
-
-static int
-sh_css_init_isp_params_from_config(struct ia_css_pipe *pipe,
-				   struct ia_css_isp_parameters *params,
-				   const struct ia_css_isp_config *config,
-				   struct ia_css_pipe *pipe_in);
+static bool sh_css_init_isp_params_from_global(
+	struct ia_css_stream *stream, struct ia_css_isp_parameters *params,
+	bool use_default_config, struct ia_css_pipe *pipe_in);
 
-static int
-sh_css_set_global_isp_config_on_pipe(
-    struct ia_css_pipe *curr_pipe,
-    const struct ia_css_isp_config *config,
-    struct ia_css_pipe *pipe);
+static int sh_css_init_isp_params_from_config(
+	struct ia_css_pipe *pipe, struct ia_css_isp_parameters *params,
+	const struct ia_css_isp_config *config, struct ia_css_pipe *pipe_in);
 
 static int
-sh_css_set_per_frame_isp_config_on_pipe(
-    struct ia_css_stream *stream,
-    const struct ia_css_isp_config *config,
-    struct ia_css_pipe *pipe);
+sh_css_set_global_isp_config_on_pipe(struct ia_css_pipe *curr_pipe,
+				     const struct ia_css_isp_config *config,
+				     struct ia_css_pipe *pipe);
 
 static int
-sh_css_update_uds_and_crop_info_based_on_zoom_region(
-    const struct ia_css_binary_info *info,
-    const struct ia_css_frame_info *in_frame_info,
-    const struct ia_css_frame_info *out_frame_info,
-    const struct ia_css_resolution *dvs_env,
-    const struct ia_css_dz_config *zoom,
-    const struct ia_css_vector *motion_vector,
-    struct sh_css_uds_info *uds,		/* out */
-    struct sh_css_crop_pos *sp_out_crop_pos,	/* out */
-    struct ia_css_resolution pipe_in_res,
-    bool enable_zoom);
-
-ia_css_ptr
-sh_css_params_ddr_address_map(void)
+sh_css_set_per_frame_isp_config_on_pipe(struct ia_css_stream *stream,
+					const struct ia_css_isp_config *config,
+					struct ia_css_pipe *pipe);
+
+static int sh_css_update_uds_and_crop_info_based_on_zoom_region(
+	const struct ia_css_binary_info *info,
+	const struct ia_css_frame_info *in_frame_info,
+	const struct ia_css_frame_info *out_frame_info,
+	const struct ia_css_resolution *dvs_env,
+	const struct ia_css_dz_config *zoom,
+	const struct ia_css_vector *motion_vector,
+	struct sh_css_uds_info *uds, /* out */
+	struct sh_css_crop_pos *sp_out_crop_pos, /* out */
+	struct ia_css_resolution pipe_in_res, bool enable_zoom);
+
+ia_css_ptr sh_css_params_ddr_address_map(void)
 {
 	return sp_ddr_ptrs;
 }
@@ -777,8 +820,8 @@ convert_allocate_fpntbl(struct ia_css_isp_parameters *params)
 	assert(params);
 
 	data_ptr = params->fpn_config.data;
-	isp_format_data_size = params->fpn_config.height * params->fpn_config.width *
-			       sizeof(uint32_t);
+	isp_format_data_size = params->fpn_config.height *
+			       params->fpn_config.width * sizeof(uint32_t);
 
 	me = ia_css_host_data_allocate(isp_format_data_size);
 
@@ -788,21 +831,17 @@ convert_allocate_fpntbl(struct ia_css_isp_parameters *params)
 	isp_format_data_ptr = (uint32_t *)me->address;
 
 	for (i = 0; i < params->fpn_config.height; i++) {
-		for (j = 0;
-		     j < params->fpn_config.width;
+		for (j = 0; j < params->fpn_config.width;
 		     j += 4, data_ptr += 4, isp_format_data_ptr++) {
-			int data = data_ptr[0] << 0 |
-				   data_ptr[1] << 7 |
-				   data_ptr[2] << 16 |
-				   data_ptr[3] << 23;
+			int data = data_ptr[0] << 0 | data_ptr[1] << 7 |
+				   data_ptr[2] << 16 | data_ptr[3] << 23;
 			*isp_format_data_ptr = data;
 		}
 	}
 	return me;
 }
 
-static int
-store_fpntbl(struct ia_css_isp_parameters *params, ia_css_ptr ptr)
+static int store_fpntbl(struct ia_css_isp_parameters *params, ia_css_ptr ptr)
 {
 	struct ia_css_host_data *isp_data;
 
@@ -820,8 +859,7 @@ store_fpntbl(struct ia_css_isp_parameters *params, ia_css_ptr ptr)
 	return 0;
 }
 
-static void
-convert_raw_to_fpn(struct ia_css_isp_parameters *params)
+static void convert_raw_to_fpn(struct ia_css_isp_parameters *params)
 {
 	int maxval = 0;
 	unsigned int i;
@@ -829,7 +867,8 @@ convert_raw_to_fpn(struct ia_css_isp_parameters *params)
 	assert(params);
 
 	/* Find the maximum value in the table */
-	for (i = 0; i < params->fpn_config.height * params->fpn_config.width; i++) {
+	for (i = 0; i < params->fpn_config.height * params->fpn_config.width;
+	     i++) {
 		int val = params->fpn_config.data[i];
 		/* Make sure FPN value can be represented in 13-bit unsigned
 		 * number (ISP precision - 1), but note that actual input range
@@ -855,8 +894,10 @@ convert_raw_to_fpn(struct ia_css_isp_parameters *params)
 		params->fpn_config.shift++;
 	}
 	/* Adjust the values in the table for the shift value */
-	for (i = 0; i < params->fpn_config.height * params->fpn_config.width; i++)
-		((unsigned short *)params->fpn_config.data)[i] >>= params->fpn_config.shift;
+	for (i = 0; i < params->fpn_config.height * params->fpn_config.width;
+	     i++)
+		((unsigned short *)params->fpn_config.data)[i] >>=
+			params->fpn_config.shift;
 }
 
 static void
@@ -870,20 +911,21 @@ ia_css_process_kernel(struct ia_css_stream *stream,
 
 	for (i = 0; i < stream->num_pipes; i++) {
 		struct ia_css_pipe *pipe = stream->pipes[i];
-		struct ia_css_pipeline *pipeline = ia_css_pipe_get_pipeline(pipe);
+		struct ia_css_pipeline *pipeline =
+			ia_css_pipe_get_pipeline(pipe);
 		struct ia_css_pipeline_stage *stage;
 
 		/* update the other buffers to the pipe specific copies */
 		for (stage = pipeline->stages; stage; stage = stage->next) {
-			if (!stage || !stage->binary) continue;
+			if (!stage || !stage->binary)
+				continue;
 			process(pipeline->pipe_id, stage, params);
 		}
 	}
 }
 
-static int
-sh_css_select_dp_10bpp_config(const struct ia_css_pipe *pipe,
-			      bool *is_dp_10bpp)
+static int sh_css_select_dp_10bpp_config(const struct ia_css_pipe *pipe,
+					 bool *is_dp_10bpp)
 {
 	int err = 0;
 	/* Currently we check if 10bpp DPC configuration is required based
@@ -902,15 +944,18 @@ sh_css_select_dp_10bpp_config(const struct ia_css_pipe *pipe,
 		/* check if DPC is enabled from the host */
 		if (pipe->config.enable_dpc) {
 			/*check if BDS is enabled*/
-			unsigned int required_bds_factor = SH_CSS_BDS_FACTOR_1_00;
+			unsigned int required_bds_factor =
+				SH_CSS_BDS_FACTOR_1_00;
 
 			if ((pipe->config.bayer_ds_out_res.width != 0) &&
 			    (pipe->config.bayer_ds_out_res.height != 0)) {
-				if (0 == binarydesc_calculate_bds_factor(
-					pipe->config.input_effective_res,
-					pipe->config.bayer_ds_out_res,
-					&required_bds_factor)) {
-					if (required_bds_factor != SH_CSS_BDS_FACTOR_1_00) {
+				if (0 ==
+				    binarydesc_calculate_bds_factor(
+					    pipe->config.input_effective_res,
+					    pipe->config.bayer_ds_out_res,
+					    &required_bds_factor)) {
+					if (required_bds_factor !=
+					    SH_CSS_BDS_FACTOR_1_00) {
 						/*we use 10bpp BDS configuration*/
 						*is_dp_10bpp = true;
 					}
@@ -922,9 +967,8 @@ sh_css_select_dp_10bpp_config(const struct ia_css_pipe *pipe,
 	return err;
 }
 
-int
-sh_css_set_black_frame(struct ia_css_stream *stream,
-		       const struct ia_css_frame *raw_black_frame)
+int sh_css_set_black_frame(struct ia_css_stream *stream,
+			   const struct ia_css_frame *raw_black_frame)
 {
 	struct ia_css_isp_parameters *params;
 	/* this function desperately needs to be moved to the ISP or SP such
@@ -940,19 +984,18 @@ sh_css_set_black_frame(struct ia_css_stream *stream,
 	height = raw_black_frame->frame_info.res.height;
 	width = raw_black_frame->frame_info.padded_width;
 
-	ptr = raw_black_frame->data
-	+ raw_black_frame->planes.raw.offset;
+	ptr = raw_black_frame->data + raw_black_frame->planes.raw.offset;
 
 	IA_CSS_ENTER_PRIVATE("black_frame=%p", raw_black_frame);
 
-	if (params->fpn_config.data &&
-	    (params->fpn_config.width != width || params->fpn_config.height != height)) {
+	if (params->fpn_config.data && (params->fpn_config.width != width ||
+					params->fpn_config.height != height)) {
 		kvfree(params->fpn_config.data);
 		params->fpn_config.data = NULL;
 	}
 	if (!params->fpn_config.data) {
-		params->fpn_config.data = kvmalloc(array3_size(height, width, sizeof(short)),
-						   GFP_KERNEL);
+		params->fpn_config.data = kvmalloc(
+			array3_size(height, width, sizeof(short)), GFP_KERNEL);
 		if (!params->fpn_config.data) {
 			IA_CSS_ERROR("out of memory");
 			IA_CSS_LEAVE_ERR_PRIVATE(-ENOMEM);
@@ -971,18 +1014,18 @@ sh_css_set_black_frame(struct ia_css_stream *stream,
 			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
 				hmm_load(ptr, (void *)(&data), sizeof(int));
 				params->fpn_config.data[ofs + 2 * k] =
-				    (short)(data & 0xFFFF);
+					(short)(data & 0xFFFF);
 				params->fpn_config.data[ofs + 2 * k + 2] =
-				    (short)((data >> 16) & 0xFFFF);
-				ptr += sizeof(int);	/* byte system address */
+					(short)((data >> 16) & 0xFFFF);
+				ptr += sizeof(int); /* byte system address */
 			}
 			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
 				hmm_load(ptr, (void *)(&data), sizeof(int));
 				params->fpn_config.data[ofs + 2 * k + 1] =
-				    (short)(data & 0xFFFF);
+					(short)(data & 0xFFFF);
 				params->fpn_config.data[ofs + 2 * k + 3] =
-				    (short)((data >> 16) & 0xFFFF);
-				ptr += sizeof(int);	/* byte system address */
+					(short)((data >> 16) & 0xFFFF);
+				ptr += sizeof(int); /* byte system address */
 			}
 		}
 	}
@@ -991,16 +1034,16 @@ sh_css_set_black_frame(struct ia_css_stream *stream,
 	convert_raw_to_fpn(params);
 
 	/* overwrite isp parameter */
-	ia_css_process_kernel(stream, params, ia_css_kernel_process_param[IA_CSS_FPN_ID]);
+	ia_css_process_kernel(stream, params,
+			      ia_css_kernel_process_param[IA_CSS_FPN_ID]);
 
 	IA_CSS_LEAVE_ERR_PRIVATE(0);
 
 	return 0;
 }
 
-bool
-sh_css_params_set_binning_factor(struct ia_css_stream *stream,
-				 unsigned int binning_fact)
+bool sh_css_params_set_binning_factor(struct ia_css_stream *stream,
+				      unsigned int binning_fact)
 {
 	struct ia_css_isp_parameters *params;
 
@@ -1019,10 +1062,9 @@ sh_css_params_set_binning_factor(struct ia_css_stream *stream,
 	return params->sc_table_changed;
 }
 
-static void
-sh_css_set_shading_table(struct ia_css_stream *stream,
-			 struct ia_css_isp_parameters *params,
-			 const struct ia_css_shading_table *table)
+static void sh_css_set_shading_table(struct ia_css_stream *stream,
+				     struct ia_css_isp_parameters *params,
+				     const struct ia_css_shading_table *table)
 {
 	IA_CSS_ENTER_PRIVATE("");
 	if (!table)
@@ -1046,10 +1088,8 @@ sh_css_set_shading_table(struct ia_css_stream *stream,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-void
-ia_css_params_store_ia_css_host_data(
-    ia_css_ptr ddr_addr,
-    struct ia_css_host_data *data)
+void ia_css_params_store_ia_css_host_data(ia_css_ptr ddr_addr,
+					  struct ia_css_host_data *data)
 {
 	assert(data);
 	assert(data->address);
@@ -1057,23 +1097,20 @@ ia_css_params_store_ia_css_host_data(
 
 	IA_CSS_ENTER_PRIVATE("");
 
-	hmm_store(ddr_addr,
-		   (void *)(data->address),
-		   (size_t)data->size);
+	hmm_store(ddr_addr, (void *)(data->address), (size_t)data->size);
 
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-struct ia_css_host_data *
-ia_css_params_alloc_convert_sctbl(
-    const struct ia_css_pipeline_stage *stage,
-    const struct ia_css_shading_table *shading_table)
+struct ia_css_host_data *ia_css_params_alloc_convert_sctbl(
+	const struct ia_css_pipeline_stage *stage,
+	const struct ia_css_shading_table *shading_table)
 {
 	const struct ia_css_binary *binary = stage->binary;
-	struct ia_css_host_data    *sctbl;
+	struct ia_css_host_data *sctbl;
 	unsigned int i, j, aligned_width;
 	unsigned int sctbl_size;
-	short int    *ptr;
+	short int *ptr;
 
 	assert(binary);
 	assert(shading_table);
@@ -1086,23 +1123,20 @@ ia_css_params_alloc_convert_sctbl(
 	}
 
 	aligned_width = binary->sctbl_aligned_width_per_color;
-	sctbl_size = shading_table->height * IA_CSS_SC_NUM_COLORS * aligned_width *
-		     sizeof(short);
+	sctbl_size = shading_table->height * IA_CSS_SC_NUM_COLORS *
+		     aligned_width * sizeof(short);
 
 	sctbl = ia_css_host_data_allocate((size_t)sctbl_size);
 
 	if (!sctbl)
 		return NULL;
 	ptr = (short int *)sctbl->address;
-	memset(ptr,
-	       0,
-	       sctbl_size);
+	memset(ptr, 0, sctbl_size);
 
 	for (i = 0; i < shading_table->height; i++) {
 		for (j = 0; j < IA_CSS_SC_NUM_COLORS; j++) {
 			memcpy(ptr,
-			       &shading_table->data[j]
-			       [i * shading_table->width],
+			       &shading_table->data[j][i * shading_table->width],
 			       shading_table->width * sizeof(short));
 			ptr += aligned_width;
 		}
@@ -1112,10 +1146,9 @@ ia_css_params_alloc_convert_sctbl(
 	return sctbl;
 }
 
-int ia_css_params_store_sctbl(
-    const struct ia_css_pipeline_stage *stage,
-    ia_css_ptr sc_tbl,
-    const struct ia_css_shading_table  *sc_config)
+int ia_css_params_store_sctbl(const struct ia_css_pipeline_stage *stage,
+			      ia_css_ptr sc_tbl,
+			      const struct ia_css_shading_table *sc_config)
 {
 	struct ia_css_host_data *isp_sc_tbl;
 
@@ -1140,8 +1173,7 @@ int ia_css_params_store_sctbl(
 	return 0;
 }
 
-static void
-sh_css_enable_pipeline(const struct ia_css_binary *binary)
+static void sh_css_enable_pipeline(const struct ia_css_binary *binary)
 {
 	if (!binary)
 		return;
@@ -1154,9 +1186,8 @@ sh_css_enable_pipeline(const struct ia_css_binary *binary)
 }
 
 static int
-ia_css_process_zoom_and_motion(
-    struct ia_css_isp_parameters *params,
-    const struct ia_css_pipeline_stage *first_stage)
+ia_css_process_zoom_and_motion(struct ia_css_isp_parameters *params,
+			       const struct ia_css_pipeline_stage *first_stage)
 {
 	/* first_stage can be  NULL */
 	const struct ia_css_pipeline_stage *stage;
@@ -1186,20 +1217,21 @@ ia_css_process_zoom_and_motion(
 			info = binary->info;
 		} else {
 			const struct sh_css_binary_args *args = &stage->args;
-			const struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {NULL};
+			const struct ia_css_frame_info
+				*out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {
+					NULL
+				};
 
-			out_infos[0] = ia_css_frame_get_info(args->out_frame[0]);
+			out_infos[0] =
+				ia_css_frame_get_info(args->out_frame[0]);
 
 			info = &stage->firmware->info.isp;
-			ia_css_binary_fill_info(info, false, false,
-						ATOMISP_INPUT_FORMAT_RAW_10,
-						ia_css_frame_get_info(args->in_frame),
-						NULL,
-						out_infos,
-						ia_css_frame_get_info(args->out_vf_frame),
-						&tmp_binary,
-						NULL,
-						-1, true);
+			ia_css_binary_fill_info(
+				info, false, false, ATOMISP_INPUT_FORMAT_RAW_10,
+				ia_css_frame_get_info(args->in_frame), NULL,
+				out_infos,
+				ia_css_frame_get_info(args->out_vf_frame),
+				&tmp_binary, NULL, -1, true);
 			binary = &tmp_binary;
 			binary->info = info;
 		}
@@ -1213,27 +1245,22 @@ ia_css_process_zoom_and_motion(
 		if (params->dz_config.zoom_region.resolution.width == 0 &&
 		    params->dz_config.zoom_region.resolution.height == 0) {
 			sh_css_update_uds_and_crop_info(
-			    &info->sp,
-			    &binary->in_frame_info,
-			    &binary->out_frame_info[0],
-			    &binary->dvs_envelope,
-			    &params->dz_config,
-			    &params->motion_config,
-			    &params->uds[stage->stage_num].uds,
-			    &params->uds[stage->stage_num].crop_pos,
-			    stage->enable_zoom);
+				&info->sp, &binary->in_frame_info,
+				&binary->out_frame_info[0],
+				&binary->dvs_envelope, &params->dz_config,
+				&params->motion_config,
+				&params->uds[stage->stage_num].uds,
+				&params->uds[stage->stage_num].crop_pos,
+				stage->enable_zoom);
 		} else {
 			err = sh_css_update_uds_and_crop_info_based_on_zoom_region(
-				  &info->sp,
-				  &binary->in_frame_info,
-				  &binary->out_frame_info[0],
-				  &binary->dvs_envelope,
-				  &params->dz_config,
-				  &params->motion_config,
-				  &params->uds[stage->stage_num].uds,
-				  &params->uds[stage->stage_num].crop_pos,
-				  pipe_in_res,
-				  stage->enable_zoom);
+				&info->sp, &binary->in_frame_info,
+				&binary->out_frame_info[0],
+				&binary->dvs_envelope, &params->dz_config,
+				&params->motion_config,
+				&params->uds[stage->stage_num].uds,
+				&params->uds[stage->stage_num].crop_pos,
+				pipe_in_res, stage->enable_zoom);
 			if (err)
 				return err;
 		}
@@ -1244,9 +1271,8 @@ ia_css_process_zoom_and_motion(
 	return err;
 }
 
-static void
-sh_css_set_gamma_table(struct ia_css_isp_parameters *params,
-		       const struct ia_css_gamma_table *table)
+static void sh_css_set_gamma_table(struct ia_css_isp_parameters *params,
+				   const struct ia_css_gamma_table *table)
 {
 	if (!table)
 		return;
@@ -1259,9 +1285,8 @@ sh_css_set_gamma_table(struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_get_gamma_table(const struct ia_css_isp_parameters *params,
-		       struct ia_css_gamma_table *table)
+static void sh_css_get_gamma_table(const struct ia_css_isp_parameters *params,
+				   struct ia_css_gamma_table *table)
 {
 	if (!table)
 		return;
@@ -1273,9 +1298,8 @@ sh_css_get_gamma_table(const struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_set_ctc_table(struct ia_css_isp_parameters *params,
-		     const struct ia_css_ctc_table *table)
+static void sh_css_set_ctc_table(struct ia_css_isp_parameters *params,
+				 const struct ia_css_ctc_table *table)
 {
 	if (!table)
 		return;
@@ -1289,9 +1313,8 @@ sh_css_set_ctc_table(struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_get_ctc_table(const struct ia_css_isp_parameters *params,
-		     struct ia_css_ctc_table *table)
+static void sh_css_get_ctc_table(const struct ia_css_isp_parameters *params,
+				 struct ia_css_ctc_table *table)
 {
 	if (!table)
 		return;
@@ -1304,9 +1327,8 @@ sh_css_get_ctc_table(const struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_set_macc_table(struct ia_css_isp_parameters *params,
-		      const struct ia_css_macc_table *table)
+static void sh_css_set_macc_table(struct ia_css_isp_parameters *params,
+				  const struct ia_css_macc_table *table)
 {
 	if (!table)
 		return;
@@ -1320,9 +1342,8 @@ sh_css_set_macc_table(struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_get_macc_table(const struct ia_css_isp_parameters *params,
-		      struct ia_css_macc_table *table)
+static void sh_css_get_macc_table(const struct ia_css_isp_parameters *params,
+				  struct ia_css_macc_table *table)
 {
 	if (!table)
 		return;
@@ -1335,8 +1356,7 @@ sh_css_get_macc_table(const struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-void ia_css_morph_table_free(
-    struct ia_css_morph_table *me)
+void ia_css_morph_table_free(struct ia_css_morph_table *me)
 {
 	unsigned int i;
 
@@ -1360,9 +1380,8 @@ void ia_css_morph_table_free(
 	IA_CSS_LEAVE("void");
 }
 
-struct ia_css_morph_table *ia_css_morph_table_allocate(
-    unsigned int width,
-    unsigned int height)
+struct ia_css_morph_table *ia_css_morph_table_allocate(unsigned int width,
+						       unsigned int height)
 {
 	unsigned int i;
 	struct ia_css_morph_table *me;
@@ -1381,15 +1400,14 @@ struct ia_css_morph_table *ia_css_morph_table_allocate(
 	}
 
 	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-		me->coordinates_x[i] = kvmalloc(height * width *
-						sizeof(*me->coordinates_x[i]),
-						GFP_KERNEL);
-		me->coordinates_y[i] = kvmalloc(height * width *
-						sizeof(*me->coordinates_y[i]),
-						GFP_KERNEL);
-
-		if ((!me->coordinates_x[i]) ||
-		    (!me->coordinates_y[i])) {
+		me->coordinates_x[i] =
+			kvmalloc(height * width * sizeof(*me->coordinates_x[i]),
+				 GFP_KERNEL);
+		me->coordinates_y[i] =
+			kvmalloc(height * width * sizeof(*me->coordinates_y[i]),
+				 GFP_KERNEL);
+
+		if ((!me->coordinates_x[i]) || (!me->coordinates_y[i])) {
 			ia_css_morph_table_free(me);
 			me = NULL;
 			return me;
@@ -1401,14 +1419,13 @@ struct ia_css_morph_table *ia_css_morph_table_allocate(
 	return me;
 }
 
-static int sh_css_params_default_morph_table(
-    struct ia_css_morph_table **table,
-    const struct ia_css_binary *binary)
+static int sh_css_params_default_morph_table(struct ia_css_morph_table **table,
+					     const struct ia_css_binary *binary)
 {
 	/* MW 2400 advanced requires different scaling */
 	unsigned int i, j, k, step, width, height;
 	short start_x[IA_CSS_MORPH_TABLE_NUM_PLANES] = { -8, 0, -8, 0, 0, -8 },
-		start_y[IA_CSS_MORPH_TABLE_NUM_PLANES] = { 0, 0, -8, -8, -8, 0 };
+	      start_y[IA_CSS_MORPH_TABLE_NUM_PLANES] = { 0, 0, -8, -8, -8, 0 };
 	struct ia_css_morph_table *tab;
 
 	assert(table);
@@ -1456,9 +1473,8 @@ static int sh_css_params_default_morph_table(
 	return 0;
 }
 
-static void
-sh_css_set_morph_table(struct ia_css_isp_parameters *params,
-		       const struct ia_css_morph_table *table)
+static void sh_css_set_morph_table(struct ia_css_isp_parameters *params,
+				   const struct ia_css_morph_table *table)
 {
 	if (!table)
 		return;
@@ -1473,10 +1489,9 @@ sh_css_set_morph_table(struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-void
-ia_css_translate_3a_statistics(
-    struct ia_css_3a_statistics               *host_stats,
-    const struct ia_css_isp_3a_statistics_map *isp_stats)
+void ia_css_translate_3a_statistics(
+	struct ia_css_3a_statistics *host_stats,
+	const struct ia_css_isp_3a_statistics_map *isp_stats)
 {
 	IA_CSS_ENTER("");
 	if (host_stats->grid.use_dmem) {
@@ -1493,8 +1508,7 @@ ia_css_translate_3a_statistics(
 	IA_CSS_LEAVE("void");
 }
 
-void
-ia_css_isp_3a_statistics_map_free(struct ia_css_isp_3a_statistics_map *me)
+void ia_css_isp_3a_statistics_map_free(struct ia_css_isp_3a_statistics_map *me)
 {
 	if (me) {
 		if (me->data_allocated) {
@@ -1506,10 +1520,8 @@ ia_css_isp_3a_statistics_map_free(struct ia_css_isp_3a_statistics_map *me)
 	}
 }
 
-struct ia_css_isp_3a_statistics_map *
-ia_css_isp_3a_statistics_map_allocate(
-    const struct ia_css_isp_3a_statistics *isp_stats,
-    void *data_ptr)
+struct ia_css_isp_3a_statistics_map *ia_css_isp_3a_statistics_map_allocate(
+	const struct ia_css_isp_3a_statistics *isp_stats, void *data_ptr)
 {
 	struct ia_css_isp_3a_statistics_map *me;
 	/* Windows compiler does not like adding sizes to a void *
@@ -1536,12 +1548,12 @@ ia_css_isp_3a_statistics_map_allocate(
 	me->size = isp_stats->size;
 	/* GCC complains when we assign a char * to a void *, so these
 	 * casts are necessary unfortunately. */
-	me->dmem_stats    = (void *)base_ptr;
+	me->dmem_stats = (void *)base_ptr;
 	me->vmem_stats_hi = (void *)(base_ptr + isp_stats->dmem_size);
 	me->vmem_stats_lo = (void *)(base_ptr + isp_stats->dmem_size +
 				     isp_stats->vmem_size);
-	me->hmem_stats    = (void *)(base_ptr + isp_stats->dmem_size +
-				     2 * isp_stats->vmem_size);
+	me->hmem_stats = (void *)(base_ptr + isp_stats->dmem_size +
+				  2 * isp_stats->vmem_size);
 
 	IA_CSS_LEAVE("map=%p", me);
 	return me;
@@ -1551,9 +1563,8 @@ ia_css_isp_3a_statistics_map_allocate(
 	return NULL;
 }
 
-int
-ia_css_get_3a_statistics(struct ia_css_3a_statistics           *host_stats,
-			 const struct ia_css_isp_3a_statistics *isp_stats)
+int ia_css_get_3a_statistics(struct ia_css_3a_statistics *host_stats,
+			     const struct ia_css_isp_3a_statistics *isp_stats)
 {
 	struct ia_css_isp_3a_statistics_map *map;
 	int ret = 0;
@@ -1580,22 +1591,20 @@ ia_css_get_3a_statistics(struct ia_css_3a_statistics           *host_stats,
 /* Parameter encoding is not yet orthogonal.
    This function hnadles some of the exceptions.
 */
-static void
-ia_css_set_param_exceptions(const struct ia_css_pipe *pipe,
-			    struct ia_css_isp_parameters *params)
+static void ia_css_set_param_exceptions(const struct ia_css_pipe *pipe,
+					struct ia_css_isp_parameters *params)
 {
 	assert(params);
 
 	/* Copy also to DP. Should be done by the driver. */
 	params->dp_config.gr = params->wb_config.gr;
-	params->dp_config.r  = params->wb_config.r;
-	params->dp_config.b  = params->wb_config.b;
+	params->dp_config.r = params->wb_config.r;
+	params->dp_config.b = params->wb_config.b;
 	params->dp_config.gb = params->wb_config.gb;
 }
 
-static void
-sh_css_set_nr_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_nr_config *config)
+static void sh_css_set_nr_config(struct ia_css_isp_parameters *params,
+				 const struct ia_css_nr_config *config)
 {
 	if (!config)
 		return;
@@ -1606,16 +1615,15 @@ sh_css_set_nr_config(struct ia_css_isp_parameters *params,
 	ia_css_nr_debug_dtrace(config, IA_CSS_DEBUG_TRACE_PRIVATE);
 	params->nr_config = *config;
 	params->yee_config.nr = *config;
-	params->config_changed[IA_CSS_NR_ID]  = true;
+	params->config_changed[IA_CSS_NR_ID] = true;
 	params->config_changed[IA_CSS_YEE_ID] = true;
 	params->config_changed[IA_CSS_BNR_ID] = true;
 
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_set_ee_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_ee_config *config)
+static void sh_css_set_ee_config(struct ia_css_isp_parameters *params,
+				 const struct ia_css_ee_config *config)
 {
 	if (!config)
 		return;
@@ -1631,9 +1639,8 @@ sh_css_set_ee_config(struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_get_ee_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_ee_config *config)
+static void sh_css_get_ee_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_ee_config *config)
 {
 	if (!config)
 		return;
@@ -1647,10 +1654,9 @@ sh_css_get_ee_config(const struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_set_pipe_dvs_6axis_config(const struct ia_css_pipe *pipe,
-				 struct ia_css_isp_parameters *params,
-				 const struct ia_css_dvs_6axis_config  *dvs_config)
+static void sh_css_set_pipe_dvs_6axis_config(
+	const struct ia_css_pipe *pipe, struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_6axis_config *dvs_config)
 {
 	if (!dvs_config)
 		return;
@@ -1662,7 +1668,8 @@ sh_css_set_pipe_dvs_6axis_config(const struct ia_css_pipe *pipe,
 
 	IA_CSS_ENTER_PRIVATE("dvs_config=%p", dvs_config);
 
-	copy_dvs_6axis_table(params->pipe_dvs_6axis_config[pipe->mode], dvs_config);
+	copy_dvs_6axis_table(params->pipe_dvs_6axis_config[pipe->mode],
+			     dvs_config);
 
 	params->pipe_dvs_6axis_config_changed[pipe->mode] = true;
 
@@ -1684,24 +1691,25 @@ sh_css_get_pipe_dvs_6axis_config(const struct ia_css_pipe *pipe,
 	IA_CSS_ENTER_PRIVATE("dvs_config=%p", dvs_config);
 
 	if ((pipe->mode < IA_CSS_PIPE_ID_NUM) &&
-	    (dvs_config->width_y == params->pipe_dvs_6axis_config[pipe->mode]->width_y) &&
-	    (dvs_config->height_y == params->pipe_dvs_6axis_config[pipe->mode]->height_y) &&
-	    (dvs_config->width_uv == params->pipe_dvs_6axis_config[pipe->mode]->width_uv) &&
-	    (dvs_config->height_uv == params->pipe_dvs_6axis_config[pipe->mode]->height_uv)
-	    &&
-	    dvs_config->xcoords_y &&
-	    dvs_config->ycoords_y &&
-	    dvs_config->xcoords_uv &&
-	    dvs_config->ycoords_uv) {
-		copy_dvs_6axis_table(dvs_config, params->pipe_dvs_6axis_config[pipe->mode]);
+	    (dvs_config->width_y ==
+	     params->pipe_dvs_6axis_config[pipe->mode]->width_y) &&
+	    (dvs_config->height_y ==
+	     params->pipe_dvs_6axis_config[pipe->mode]->height_y) &&
+	    (dvs_config->width_uv ==
+	     params->pipe_dvs_6axis_config[pipe->mode]->width_uv) &&
+	    (dvs_config->height_uv ==
+	     params->pipe_dvs_6axis_config[pipe->mode]->height_uv) &&
+	    dvs_config->xcoords_y && dvs_config->ycoords_y &&
+	    dvs_config->xcoords_uv && dvs_config->ycoords_uv) {
+		copy_dvs_6axis_table(dvs_config,
+				     params->pipe_dvs_6axis_config[pipe->mode]);
 	}
 
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_set_baa_config(struct ia_css_isp_parameters *params,
-		      const struct ia_css_aa_config *config)
+static void sh_css_set_baa_config(struct ia_css_isp_parameters *params,
+				  const struct ia_css_aa_config *config)
 {
 	if (!config)
 		return;
@@ -1715,9 +1723,8 @@ sh_css_set_baa_config(struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_get_baa_config(const struct ia_css_isp_parameters *params,
-		      struct ia_css_aa_config *config)
+static void sh_css_get_baa_config(const struct ia_css_isp_parameters *params,
+				  struct ia_css_aa_config *config)
 {
 	if (!config)
 		return;
@@ -1730,9 +1737,8 @@ sh_css_get_baa_config(const struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_set_dz_config(struct ia_css_isp_parameters *params,
-		     const struct ia_css_dz_config *config)
+static void sh_css_set_dz_config(struct ia_css_isp_parameters *params,
+				 const struct ia_css_dz_config *config)
 {
 	if (!config)
 		return;
@@ -1751,9 +1757,8 @@ sh_css_set_dz_config(struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_get_dz_config(const struct ia_css_isp_parameters *params,
-		     struct ia_css_dz_config *config)
+static void sh_css_get_dz_config(const struct ia_css_isp_parameters *params,
+				 struct ia_css_dz_config *config)
 {
 	if (!config)
 		return;
@@ -1766,9 +1771,8 @@ sh_css_get_dz_config(const struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("dx=%d, dy=%d", config->dx, config->dy);
 }
 
-static void
-sh_css_set_motion_vector(struct ia_css_isp_parameters *params,
-			 const struct ia_css_vector *motion)
+static void sh_css_set_motion_vector(struct ia_css_isp_parameters *params,
+				     const struct ia_css_vector *motion)
 {
 	if (!motion)
 		return;
@@ -1784,9 +1788,8 @@ sh_css_set_motion_vector(struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-sh_css_get_motion_vector(const struct ia_css_isp_parameters *params,
-			 struct ia_css_vector *motion)
+static void sh_css_get_motion_vector(const struct ia_css_isp_parameters *params,
+				     struct ia_css_vector *motion)
 {
 	if (!motion)
 		return;
@@ -1799,8 +1802,7 @@ sh_css_get_motion_vector(const struct ia_css_isp_parameters *params,
 	IA_CSS_LEAVE_PRIVATE("x=%d, y=%d", motion->x, motion->y);
 }
 
-struct ia_css_isp_config *
-sh_css_pipe_isp_config_get(struct ia_css_pipe *pipe)
+struct ia_css_isp_config *sh_css_pipe_isp_config_get(struct ia_css_pipe *pipe)
 {
 	if (!pipe) {
 		IA_CSS_ERROR("pipe=%p", NULL);
@@ -1809,19 +1811,15 @@ sh_css_pipe_isp_config_get(struct ia_css_pipe *pipe)
 	return pipe->config.p_isp_config;
 }
 
-int
-ia_css_stream_set_isp_config(
-    struct ia_css_stream *stream,
-    const struct ia_css_isp_config *config)
+int ia_css_stream_set_isp_config(struct ia_css_stream *stream,
+				 const struct ia_css_isp_config *config)
 {
 	return ia_css_stream_set_isp_config_on_pipe(stream, config, NULL);
 }
 
-int
-ia_css_stream_set_isp_config_on_pipe(
-    struct ia_css_stream *stream,
-    const struct ia_css_isp_config *config,
-    struct ia_css_pipe *pipe)
+int ia_css_stream_set_isp_config_on_pipe(struct ia_css_stream *stream,
+					 const struct ia_css_isp_config *config,
+					 struct ia_css_pipe *pipe)
 {
 	int err = 0;
 
@@ -1831,17 +1829,18 @@ ia_css_stream_set_isp_config_on_pipe(
 	IA_CSS_ENTER("stream=%p, config=%p, pipe=%p", stream, config, pipe);
 
 	if (config->output_frame)
-		err = sh_css_set_per_frame_isp_config_on_pipe(stream, config, pipe);
+		err = sh_css_set_per_frame_isp_config_on_pipe(stream, config,
+							      pipe);
 	else
-		err = sh_css_set_global_isp_config_on_pipe(stream->pipes[0], config, pipe);
+		err = sh_css_set_global_isp_config_on_pipe(stream->pipes[0],
+							   config, pipe);
 
 	IA_CSS_LEAVE_ERR(err);
 	return err;
 }
 
-int
-ia_css_pipe_set_isp_config(struct ia_css_pipe *pipe,
-			   struct ia_css_isp_config *config)
+int ia_css_pipe_set_isp_config(struct ia_css_pipe *pipe,
+			       struct ia_css_isp_config *config)
 {
 	struct ia_css_pipe *pipe_in = pipe;
 	int err = 0;
@@ -1854,29 +1853,34 @@ ia_css_pipe_set_isp_config(struct ia_css_pipe *pipe,
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "config=%p\n", config);
 
 	if (config->output_frame)
-		err = sh_css_set_per_frame_isp_config_on_pipe(pipe->stream, config, pipe);
+		err = sh_css_set_per_frame_isp_config_on_pipe(pipe->stream,
+							      config, pipe);
 	else
-		err = sh_css_set_global_isp_config_on_pipe(pipe, config, pipe_in);
+		err = sh_css_set_global_isp_config_on_pipe(pipe, config,
+							   pipe_in);
 	IA_CSS_LEAVE_ERR(err);
 	return err;
 }
 
 static int
-sh_css_set_global_isp_config_on_pipe(
-    struct ia_css_pipe *curr_pipe,
-    const struct ia_css_isp_config *config,
-    struct ia_css_pipe *pipe)
+sh_css_set_global_isp_config_on_pipe(struct ia_css_pipe *curr_pipe,
+				     const struct ia_css_isp_config *config,
+				     struct ia_css_pipe *pipe)
 {
 	int err = 0;
 	int err1 = 0;
 	int err2 = 0;
 
-	IA_CSS_ENTER_PRIVATE("stream=%p, config=%p, pipe=%p", curr_pipe, config, pipe);
+	IA_CSS_ENTER_PRIVATE("stream=%p, config=%p, pipe=%p", curr_pipe, config,
+			     pipe);
 
-	err1 = sh_css_init_isp_params_from_config(curr_pipe, curr_pipe->stream->isp_params_configs, config, pipe);
+	err1 = sh_css_init_isp_params_from_config(
+		curr_pipe, curr_pipe->stream->isp_params_configs, config, pipe);
 
 	/* Now commit all changes to the SP */
-	err2 = sh_css_param_update_isp_params(curr_pipe, curr_pipe->stream->isp_params_configs, sh_css_sp_is_running(), pipe);
+	err2 = sh_css_param_update_isp_params(
+		curr_pipe, curr_pipe->stream->isp_params_configs,
+		sh_css_sp_is_running(), pipe);
 
 	/* The following code is intentional. The sh_css_init_isp_params_from_config interface
 	 * throws an error when both DPC and BDS is enabled. The CSS API must pass this error
@@ -1891,10 +1895,9 @@ sh_css_set_global_isp_config_on_pipe(
 }
 
 static int
-sh_css_set_per_frame_isp_config_on_pipe(
-    struct ia_css_stream *stream,
-    const struct ia_css_isp_config *config,
-    struct ia_css_pipe *pipe)
+sh_css_set_per_frame_isp_config_on_pipe(struct ia_css_stream *stream,
+					const struct ia_css_isp_config *config,
+					struct ia_css_pipe *pipe)
 {
 	unsigned int i;
 	bool per_frame_config_created = false;
@@ -1907,7 +1910,8 @@ sh_css_set_per_frame_isp_config_on_pipe(
 	struct sh_css_ddr_address_map_size *ddr_ptrs_size;
 	struct ia_css_isp_parameters *params;
 
-	IA_CSS_ENTER_PRIVATE("stream=%p, config=%p, pipe=%p", stream, config, pipe);
+	IA_CSS_ENTER_PRIVATE("stream=%p, config=%p, pipe=%p", stream, config,
+			     pipe);
 
 	if (!pipe) {
 		err = -EINVAL;
@@ -1918,8 +1922,8 @@ sh_css_set_per_frame_isp_config_on_pipe(
 	 * from stream->isp_params_configs if one doesn't already exist
 	*/
 	if (!stream->per_frame_isp_params_configs) {
-		err = sh_css_create_isp_params(stream,
-					       &stream->per_frame_isp_params_configs);
+		err = sh_css_create_isp_params(
+			stream, &stream->per_frame_isp_params_configs);
 		if (err)
 			goto exit;
 		per_frame_config_created = true;
@@ -1932,20 +1936,23 @@ sh_css_set_per_frame_isp_config_on_pipe(
 		err1 = -EINVAL;
 	}
 
-	err2 = sh_css_init_isp_params_from_config(stream->pipes[0], params, config, pipe);
+	err2 = sh_css_init_isp_params_from_config(stream->pipes[0], params,
+						  config, pipe);
 
 	if (per_frame_config_created) {
 		ddr_ptrs = &params->ddr_ptrs;
 		ddr_ptrs_size = &params->ddr_ptrs_size;
 		/* create per pipe reference to general ddr_ptrs */
 		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
-			ref_sh_css_ddr_address_map(ddr_ptrs, &params->pipe_ddr_ptrs[i]);
+			ref_sh_css_ddr_address_map(ddr_ptrs,
+						   &params->pipe_ddr_ptrs[i]);
 			params->pipe_ddr_ptrs_size[i] = *ddr_ptrs_size;
 		}
 	}
 
 	/* now commit to ddr */
-	err3 = sh_css_param_update_isp_params(stream->pipes[0], params, sh_css_sp_is_running(), pipe);
+	err3 = sh_css_param_update_isp_params(stream->pipes[0], params,
+					      sh_css_sp_is_running(), pipe);
 
 	/* The following code is intentional. The sh_css_init_sp_params_from_config and
 	 * sh_css_init_isp_params_from_config throws an error when both DPC and BDS is enabled.
@@ -1954,24 +1961,24 @@ sh_css_set_per_frame_isp_config_on_pipe(
 	 *  to enable testing of features which are currently in TR phase. */
 	err = (err1 != 0) ? err1 :
 	      (err2 != 0) ? err2 :
-	      (err3 != 0) ? err3 : err;
+	      (err3 != 0) ? err3 :
+			    err;
 exit:
 	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
-static int
-sh_css_init_isp_params_from_config(struct ia_css_pipe *pipe,
-				   struct ia_css_isp_parameters *params,
-				   const struct ia_css_isp_config *config,
-				   struct ia_css_pipe *pipe_in)
+static int sh_css_init_isp_params_from_config(
+	struct ia_css_pipe *pipe, struct ia_css_isp_parameters *params,
+	const struct ia_css_isp_config *config, struct ia_css_pipe *pipe_in)
 {
 	int err = 0;
 	bool is_dp_10bpp = true;
 
 	assert(pipe);
 
-	IA_CSS_ENTER_PRIVATE("pipe=%p, config=%p, params=%p", pipe, config, params);
+	IA_CSS_ENTER_PRIVATE("pipe=%p, config=%p, params=%p", pipe, config,
+			     params);
 
 	ia_css_set_configs(params, config);
 
@@ -1980,7 +1987,8 @@ sh_css_init_isp_params_from_config(struct ia_css_pipe *pipe,
 	sh_css_set_baa_config(params, config->baa_config);
 	if ((pipe->mode < IA_CSS_PIPE_ID_NUM) &&
 	    (params->pipe_dvs_6axis_config[pipe->mode]))
-		sh_css_set_pipe_dvs_6axis_config(pipe, params, config->dvs_6axis_config);
+		sh_css_set_pipe_dvs_6axis_config(pipe, params,
+						 config->dvs_6axis_config);
 	sh_css_set_dz_config(params, config->dz_config);
 	sh_css_set_motion_vector(params, config->motion_vector);
 	sh_css_set_shading_table(pipe->stream, params, config->shading_table);
@@ -1998,8 +2006,7 @@ sh_css_init_isp_params_from_config(struct ia_css_pipe *pipe,
 	params->output_frame = config->output_frame;
 	params->isp_parameters_id = config->isp_config_id;
 
-	if (0 ==
-	    sh_css_select_dp_10bpp_config(pipe, &is_dp_10bpp)) {
+	if (0 == sh_css_select_dp_10bpp_config(pipe, &is_dp_10bpp)) {
 		/* return an error when both DPC and BDS is enabled by the
 		 * user. */
 		/* we do not exit from this point immediately to allow internal
@@ -2019,19 +2026,16 @@ sh_css_init_isp_params_from_config(struct ia_css_pipe *pipe,
 	return err;
 }
 
-void
-ia_css_stream_get_isp_config(
-    const struct ia_css_stream *stream,
-    struct ia_css_isp_config *config)
+void ia_css_stream_get_isp_config(const struct ia_css_stream *stream,
+				  struct ia_css_isp_config *config)
 {
 	IA_CSS_ENTER("void");
 	ia_css_pipe_get_isp_config(stream->pipes[0], config);
 	IA_CSS_LEAVE("void");
 }
 
-void
-ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
-			   struct ia_css_isp_config *config)
+void ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
+				struct ia_css_isp_config *config)
 {
 	struct ia_css_isp_parameters *params = NULL;
 
@@ -2046,7 +2050,8 @@ ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
 
 	sh_css_get_ee_config(params, config->ee_config);
 	sh_css_get_baa_config(params, config->baa_config);
-	sh_css_get_pipe_dvs_6axis_config(pipe, params, config->dvs_6axis_config);
+	sh_css_get_pipe_dvs_6axis_config(pipe, params,
+					 config->dvs_6axis_config);
 	sh_css_get_macc_table(params, config->macc_table);
 	sh_css_get_gamma_table(params, config->gamma_table);
 	sh_css_get_ctc_table(params, config->ctc_table);
@@ -2067,12 +2072,8 @@ ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
  *
  * Deprecated: Implement mmgr_realloc()
  */
-static bool realloc_isp_css_mm_buf(
-    ia_css_ptr *curr_buf,
-    size_t *curr_size,
-    size_t needed_size,
-    bool force,
-    int *err)
+static bool realloc_isp_css_mm_buf(ia_css_ptr *curr_buf, size_t *curr_size,
+				   size_t needed_size, bool force, int *err)
 {
 	s32 id;
 
@@ -2105,19 +2106,15 @@ static bool realloc_isp_css_mm_buf(
 	return true;
 }
 
-static bool reallocate_buffer(
-    ia_css_ptr *curr_buf,
-    size_t *curr_size,
-    size_t needed_size,
-    bool force,
-    int *err)
+static bool reallocate_buffer(ia_css_ptr *curr_buf, size_t *curr_size,
+			      size_t needed_size, bool force, int *err)
 {
 	bool ret;
 
 	IA_CSS_ENTER_PRIVATE("void");
 
-	ret = realloc_isp_css_mm_buf(curr_buf,
-				     curr_size, needed_size, force, err);
+	ret = realloc_isp_css_mm_buf(curr_buf, curr_size, needed_size, force,
+				     err);
 
 	IA_CSS_LEAVE_PRIVATE("ret=%d", ret);
 	return ret;
@@ -2142,11 +2139,10 @@ ia_css_isp_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
 
 	if (grid->use_dmem) {
 		me->dmem_size = sizeof(struct ia_css_3a_output) *
-				grid->aligned_width *
-				grid->aligned_height;
+				grid->aligned_width * grid->aligned_height;
 	} else {
-		me->vmem_size = ISP_S3ATBL_HI_LO_STRIDE_BYTES *
-				grid->aligned_height;
+		me->vmem_size =
+			ISP_S3ATBL_HI_LO_STRIDE_BYTES * grid->aligned_height;
 	}
 	me->hmem_size = sizeof_hmem(HMEM0_ID);
 
@@ -2166,18 +2162,19 @@ ia_css_isp_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
 		me->data.dmem.s3a_tbl = me->data_ptr;
 	if (me->vmem_size) {
 		me->data.vmem.s3a_tbl_hi = me->data_ptr + me->dmem_size;
-		me->data.vmem.s3a_tbl_lo = me->data_ptr + me->dmem_size + me->vmem_size;
+		me->data.vmem.s3a_tbl_lo =
+			me->data_ptr + me->dmem_size + me->vmem_size;
 	}
 	if (me->hmem_size)
-		me->data_hmem.rgby_tbl = me->data_ptr + me->dmem_size + 2 * me->vmem_size;
+		me->data_hmem.rgby_tbl =
+			me->data_ptr + me->dmem_size + 2 * me->vmem_size;
 
 err:
 	IA_CSS_LEAVE("return=%p", me);
 	return me;
 }
 
-void
-ia_css_isp_3a_statistics_free(struct ia_css_isp_3a_statistics *me)
+void ia_css_isp_3a_statistics_free(struct ia_css_isp_3a_statistics *me)
 {
 	if (me) {
 		hmm_free(me->data_ptr);
@@ -2219,8 +2216,7 @@ ia_css_metadata_allocate(const struct ia_css_metadata_info *metadata_info)
 	return NULL;
 }
 
-void
-ia_css_metadata_free(struct ia_css_metadata *me)
+void ia_css_metadata_free(struct ia_css_metadata *me)
 {
 	if (me) {
 		/* The enter and leave macros are placed inside
@@ -2235,9 +2231,8 @@ ia_css_metadata_free(struct ia_css_metadata *me)
 	}
 }
 
-void
-ia_css_metadata_free_multiple(unsigned int num_bufs,
-			      struct ia_css_metadata **bufs)
+void ia_css_metadata_free_multiple(unsigned int num_bufs,
+				   struct ia_css_metadata **bufs)
 {
 	unsigned int i;
 
@@ -2250,8 +2245,7 @@ ia_css_metadata_free_multiple(unsigned int num_bufs,
 static unsigned int g_param_buffer_dequeue_count;
 static unsigned int g_param_buffer_enqueue_count;
 
-int
-ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
+int ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
 {
 	int err = 0;
 	unsigned int i;
@@ -2271,8 +2265,7 @@ ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
 	g_param_buffer_enqueue_count = 0;
 
 	stream->per_frame_isp_params_configs = NULL;
-	err = sh_css_create_isp_params(stream,
-				       &stream->isp_params_configs);
+	err = sh_css_create_isp_params(stream, &stream->isp_params_configs);
 	if (err)
 		goto ERR;
 
@@ -2298,9 +2291,8 @@ ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
 }
 
 static void
-ia_css_set_sdis_config(
-    struct ia_css_isp_parameters *params,
-    const struct ia_css_dvs_coefficients *dvs_coefs)
+ia_css_set_sdis_config(struct ia_css_isp_parameters *params,
+		       const struct ia_css_dvs_coefficients *dvs_coefs)
 {
 	ia_css_set_sdis_horicoef_config(params, dvs_coefs);
 	ia_css_set_sdis_vertcoef_config(params, dvs_coefs);
@@ -2309,9 +2301,8 @@ ia_css_set_sdis_config(
 }
 
 static void
-ia_css_set_sdis2_config(
-    struct ia_css_isp_parameters *params,
-    const struct ia_css_dvs2_coefficients *dvs2_coefs)
+ia_css_set_sdis2_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_dvs2_coefficients *dvs2_coefs)
 {
 	ia_css_set_sdis2_horicoef_config(params, dvs2_coefs);
 	ia_css_set_sdis2_vertcoef_config(params, dvs2_coefs);
@@ -2330,12 +2321,13 @@ sh_css_create_isp_params(struct ia_css_stream *stream,
 	int err;
 	size_t params_size;
 	struct ia_css_isp_parameters *params =
-	kvmalloc(sizeof(struct ia_css_isp_parameters), GFP_KERNEL);
+		kvmalloc(sizeof(struct ia_css_isp_parameters), GFP_KERNEL);
 
 	if (!params) {
 		*isp_params_out = NULL;
 		err = -ENOMEM;
-		IA_CSS_ERROR("%s:%d error: cannot allocate memory", __FILE__, __LINE__);
+		IA_CSS_ERROR("%s:%d error: cannot allocate memory", __FILE__,
+			     __LINE__);
 		IA_CSS_LEAVE_ERR_PRIVATE(err);
 		return err;
 	} else {
@@ -2357,15 +2349,14 @@ sh_css_create_isp_params(struct ia_css_stream *stream,
 
 	params_size = sizeof(params->uds);
 	ddr_ptrs_size->isp_param = params_size;
-	ddr_ptrs->isp_param =
-	ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
-				  hmm_alloc(params_size));
+	ddr_ptrs->isp_param = ia_css_refcount_increment(
+		IA_CSS_REFCOUNT_PARAM_BUFFER, hmm_alloc(params_size));
 	succ &= (ddr_ptrs->isp_param != mmgr_NULL);
 
 	ddr_ptrs_size->macc_tbl = sizeof(struct ia_css_macc_table);
-	ddr_ptrs->macc_tbl =
-	ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
-				  hmm_alloc(sizeof(struct ia_css_macc_table)));
+	ddr_ptrs->macc_tbl = ia_css_refcount_increment(
+		IA_CSS_REFCOUNT_PARAM_BUFFER,
+		hmm_alloc(sizeof(struct ia_css_macc_table)));
 	succ &= (ddr_ptrs->macc_tbl != mmgr_NULL);
 
 	*isp_params_out = params;
@@ -2376,18 +2367,17 @@ sh_css_create_isp_params(struct ia_css_stream *stream,
 	return 0;
 }
 
-static bool
-sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
-				   struct ia_css_isp_parameters *params,
-				   bool use_default_config,
-				   struct ia_css_pipe *pipe_in)
+static bool sh_css_init_isp_params_from_global(
+	struct ia_css_stream *stream, struct ia_css_isp_parameters *params,
+	bool use_default_config, struct ia_css_pipe *pipe_in)
 {
 	bool retval = true;
 	int i = 0;
 	bool is_dp_10bpp = true;
-	unsigned int isp_pipe_version = ia_css_pipe_get_isp_pipe_version(
-					    stream->pipes[0]);
-	struct ia_css_isp_parameters *stream_params = stream->isp_params_configs;
+	unsigned int isp_pipe_version =
+		ia_css_pipe_get_isp_pipe_version(stream->pipes[0]);
+	struct ia_css_isp_parameters *stream_params =
+		stream->isp_params_configs;
 
 	if (!use_default_config && !stream_params) {
 		retval = false;
@@ -2470,15 +2460,18 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 		sh_css_set_nr_config(params, &stream_params->nr_config);
 		sh_css_set_ee_config(params, &stream_params->ee_config);
 		if (isp_pipe_version == SH_CSS_ISP_PIPE_VERSION_1)
-			sh_css_set_macc_table(params, &stream_params->macc_table);
+			sh_css_set_macc_table(params,
+					      &stream_params->macc_table);
 		else if (isp_pipe_version == SH_CSS_ISP_PIPE_VERSION_2_2)
-			sh_css_set_macc_table(params, &stream_params->macc_table);
+			sh_css_set_macc_table(params,
+					      &stream_params->macc_table);
 		sh_css_set_gamma_table(params, &stream_params->gc_table);
 		sh_css_set_ctc_table(params, &stream_params->ctc_table);
 		sh_css_set_baa_config(params, &stream_params->bds_config);
 		sh_css_set_dz_config(params, &stream_params->dz_config);
 		/* ------ deprecated(bz675) : from ------ */
-		sh_css_set_shading_settings(params, &stream_params->shading_settings);
+		sh_css_set_shading_settings(params,
+					    &stream_params->shading_settings);
 		/* ------ deprecated(bz675) : to ------ */
 
 		ia_css_set_s3a_config(params, &stream_params->s3a_config);
@@ -2500,17 +2493,23 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 		ia_css_set_macc_config(params, &stream_params->macc_config);
 		ia_css_set_ctc_config(params, &stream_params->ctc_config);
 		ia_css_set_aa_config(params, &stream_params->aa_config);
-		ia_css_set_r_gamma_config(params, &stream_params->r_gamma_table);
-		ia_css_set_g_gamma_config(params, &stream_params->g_gamma_table);
-		ia_css_set_b_gamma_config(params, &stream_params->b_gamma_table);
-		ia_css_set_yuv2rgb_config(params, &stream_params->yuv2rgb_cc_config);
-		ia_css_set_rgb2yuv_config(params, &stream_params->rgb2yuv_cc_config);
+		ia_css_set_r_gamma_config(params,
+					  &stream_params->r_gamma_table);
+		ia_css_set_g_gamma_config(params,
+					  &stream_params->g_gamma_table);
+		ia_css_set_b_gamma_config(params,
+					  &stream_params->b_gamma_table);
+		ia_css_set_yuv2rgb_config(params,
+					  &stream_params->yuv2rgb_cc_config);
+		ia_css_set_rgb2yuv_config(params,
+					  &stream_params->rgb2yuv_cc_config);
 		ia_css_set_xnr_config(params, &stream_params->xnr_config);
-		ia_css_set_formats_config(params, &stream_params->formats_config);
+		ia_css_set_formats_config(params,
+					  &stream_params->formats_config);
 
 		for (i = 0; i < stream->num_pipes; i++) {
-			if (0 ==
-			    sh_css_select_dp_10bpp_config(stream->pipes[i], &is_dp_10bpp)) {
+			if (0 == sh_css_select_dp_10bpp_config(stream->pipes[i],
+							       &is_dp_10bpp)) {
 				/* set the return value as false if both DPC and
 				 * BDS is enabled by the user. But we do not return
 				 * the value immediately to enable internal firmware
@@ -2527,14 +2526,15 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 
 		params->fpn_config.data = stream_params->fpn_config.data;
 		params->config_changed[IA_CSS_FPN_ID] =
-		    stream_params->config_changed[IA_CSS_FPN_ID];
+			stream_params->config_changed[IA_CSS_FPN_ID];
 		params->fpn_config.enabled = stream_params->fpn_config.enabled;
 
 		sh_css_set_motion_vector(params, &stream_params->motion_config);
 		sh_css_set_morph_table(params, stream_params->morph_table);
 
 		if (stream_params->sc_table) {
-			sh_css_set_shading_table(stream, params, stream_params->sc_table);
+			sh_css_set_shading_table(stream, params,
+						 stream_params->sc_table);
 		} else {
 			params->sc_table = NULL;
 			params->sc_table_changed = true;
@@ -2544,19 +2544,27 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
 			if (stream_params->pipe_dvs_6axis_config[i]) {
 				if (params->pipe_dvs_6axis_config[i]) {
-					copy_dvs_6axis_table(params->pipe_dvs_6axis_config[i],
-							     stream_params->pipe_dvs_6axis_config[i]);
+					copy_dvs_6axis_table(
+						params->pipe_dvs_6axis_config[i],
+						stream_params
+							->pipe_dvs_6axis_config
+								[i]);
 				} else {
 					params->pipe_dvs_6axis_config[i] =
-					    generate_dvs_6axis_table_from_config(stream_params->pipe_dvs_6axis_config[i]);
+						generate_dvs_6axis_table_from_config(
+							stream_params
+								->pipe_dvs_6axis_config
+									[i]);
 				}
 			}
 		}
 		ia_css_set_sdis_config(params, &stream_params->dvs_coefs);
-		params->dis_coef_table_changed = stream_params->dis_coef_table_changed;
+		params->dis_coef_table_changed =
+			stream_params->dis_coef_table_changed;
 
 		ia_css_set_sdis2_config(params, &stream_params->dvs2_coefs);
-		params->dvs2_coef_table_changed = stream_params->dvs2_coef_table_changed;
+		params->dvs2_coef_table_changed =
+			stream_params->dvs2_coef_table_changed;
 		params->sensor_binning = stream_params->sensor_binning;
 	}
 
@@ -2564,8 +2572,7 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 	return retval;
 }
 
-int
-sh_css_params_init(void)
+int sh_css_params_init(void)
 {
 	int i, p;
 
@@ -2577,12 +2584,10 @@ sh_css_params_init(void)
 
 	for (p = 0; p < IA_CSS_PIPE_ID_NUM; p++) {
 		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
-			xmem_sp_stage_ptrs[p][i] =
-			ia_css_refcount_increment(-1,
-						  hmm_alloc(sizeof(struct sh_css_sp_stage)));
-			xmem_isp_stage_ptrs[p][i] =
-			ia_css_refcount_increment(-1,
-						  hmm_alloc(sizeof(struct sh_css_sp_stage)));
+			xmem_sp_stage_ptrs[p][i] = ia_css_refcount_increment(
+				-1, hmm_alloc(sizeof(struct sh_css_sp_stage)));
+			xmem_isp_stage_ptrs[p][i] = ia_css_refcount_increment(
+				-1, hmm_alloc(sizeof(struct sh_css_sp_stage)));
 
 			if ((xmem_sp_stage_ptrs[p][i] == mmgr_NULL) ||
 			    (xmem_isp_stage_ptrs[p][i] == mmgr_NULL)) {
@@ -2591,8 +2596,10 @@ sh_css_params_init(void)
 				return -ENOMEM;
 			}
 
-			hmm_set(xmem_sp_stage_ptrs[p][i], 0, sizeof(struct sh_css_sp_stage));
-			hmm_set(xmem_isp_stage_ptrs[p][i], 0, sizeof(struct sh_css_sp_stage));
+			hmm_set(xmem_sp_stage_ptrs[p][i], 0,
+				sizeof(struct sh_css_sp_stage));
+			hmm_set(xmem_isp_stage_ptrs[p][i], 0,
+				sizeof(struct sh_css_sp_stage));
 		}
 	}
 
@@ -2601,20 +2608,20 @@ sh_css_params_init(void)
 	ia_css_config_rgb_gamma_tables();
 	ia_css_config_xnr_table();
 
-	sp_ddr_ptrs = ia_css_refcount_increment(-1,
-						hmm_alloc(CEIL_MUL(sizeof(struct sh_css_ddr_address_map),
-								   HIVE_ISP_DDR_WORD_BYTES)));
-	xmem_sp_group_ptrs = ia_css_refcount_increment(-1,
-						       hmm_alloc(sizeof(struct sh_css_sp_group)));
+	sp_ddr_ptrs = ia_css_refcount_increment(
+		-1, hmm_alloc(CEIL_MUL(sizeof(struct sh_css_ddr_address_map),
+				       HIVE_ISP_DDR_WORD_BYTES)));
+	xmem_sp_group_ptrs = ia_css_refcount_increment(
+		-1, hmm_alloc(sizeof(struct sh_css_sp_group)));
 
-	if ((sp_ddr_ptrs == mmgr_NULL) ||
-	    (xmem_sp_group_ptrs == mmgr_NULL)) {
+	if ((sp_ddr_ptrs == mmgr_NULL) || (xmem_sp_group_ptrs == mmgr_NULL)) {
 		ia_css_uninit();
 		IA_CSS_LEAVE_ERR_PRIVATE(-ENOMEM);
 		return -ENOMEM;
 	}
-	hmm_set(sp_ddr_ptrs, 0, CEIL_MUL(sizeof(struct sh_css_ddr_address_map),
-					 HIVE_ISP_DDR_WORD_BYTES));
+	hmm_set(sp_ddr_ptrs, 0,
+		CEIL_MUL(sizeof(struct sh_css_ddr_address_map),
+			 HIVE_ISP_DDR_WORD_BYTES));
 	hmm_set(xmem_sp_group_ptrs, 0, sizeof(struct sh_css_sp_group));
 	IA_CSS_LEAVE_ERR_PRIVATE(0);
 	return 0;
@@ -2625,11 +2632,10 @@ static void host_lut_store(const void *lut)
 	unsigned int i;
 
 	for (i = 0; i < N_GDC_ID; i++)
-		gdc_lut_store((gdc_ID_t)i, (const int (*)[HRT_GDC_N]) lut);
+		gdc_lut_store((gdc_ID_t)i, (const int(*)[HRT_GDC_N])lut);
 }
 
-int ia_css_pipe_set_bci_scaler_lut(struct ia_css_pipe *pipe,
-	const void *lut)
+int ia_css_pipe_set_bci_scaler_lut(struct ia_css_pipe *pipe, const void *lut)
 {
 	int err = 0;
 	bool stream_started = false;
@@ -2647,8 +2653,9 @@ int ia_css_pipe_set_bci_scaler_lut(struct ia_css_pipe *pipe,
 	 * created with this pipe, so it is safe to do this operation as long as
 	 * ia_css_init() has been called. */
 	if (pipe->stream && pipe->stream->started) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
-				    "unable to set scaler lut since stream has started\n");
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_ERROR,
+			"unable to set scaler lut since stream has started\n");
 		stream_started = true;
 		err = -ENOTSUPP;
 	}
@@ -2663,15 +2670,17 @@ int ia_css_pipe_set_bci_scaler_lut(struct ia_css_pipe *pipe,
 		pipe->scaler_pp_lut = hmm_alloc(sizeof(zoom_table));
 
 		if (pipe->scaler_pp_lut == mmgr_NULL) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
-					    "unable to allocate scaler_pp_lut\n");
+			ia_css_debug_dtrace(
+				IA_CSS_DEBUG_ERROR,
+				"unable to allocate scaler_pp_lut\n");
 			err = -ENOMEM;
 		} else {
-			gdc_lut_convert_to_isp_format((const int(*)[HRT_GDC_N])lut,
-						      interleaved_lut_temp);
+			gdc_lut_convert_to_isp_format(
+				(const int(*)[HRT_GDC_N])lut,
+				interleaved_lut_temp);
 			hmm_store(pipe->scaler_pp_lut,
-				   (int *)interleaved_lut_temp,
-				   sizeof(zoom_table));
+				  (int *)interleaved_lut_temp,
+				  sizeof(zoom_table));
 		}
 	}
 
@@ -2710,7 +2719,7 @@ int sh_css_params_map_and_store_default_gdc_lut(void)
 	gdc_lut_convert_to_isp_format((const int(*)[HRT_GDC_N])zoom_table,
 				      interleaved_lut_temp);
 	hmm_store(default_gdc_lut, (int *)interleaved_lut_temp,
-		   sizeof(zoom_table));
+		  sizeof(zoom_table));
 
 	IA_CSS_LEAVE_PRIVATE("lut(%u) err=%d", default_gdc_lut, err);
 	return err;
@@ -2733,8 +2742,7 @@ ia_css_ptr sh_css_params_get_default_gdc_lut(void)
 	return default_gdc_lut;
 }
 
-static void free_param_set_callback(
-    ia_css_ptr ptr)
+static void free_param_set_callback(ia_css_ptr ptr)
 {
 	IA_CSS_ENTER_PRIVATE("void");
 
@@ -2743,8 +2751,7 @@ static void free_param_set_callback(
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void free_buffer_callback(
-    ia_css_ptr ptr)
+static void free_buffer_callback(ia_css_ptr ptr)
 {
 	IA_CSS_ENTER_PRIVATE("void");
 
@@ -2753,12 +2760,12 @@ static void free_buffer_callback(
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-void
-sh_css_param_clear_param_sets(void)
+void sh_css_param_clear_param_sets(void)
 {
 	IA_CSS_ENTER_PRIVATE("void");
 
-	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_SET_POOL, &free_param_set_callback);
+	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_SET_POOL,
+			      &free_param_set_callback);
 
 	IA_CSS_LEAVE_PRIVATE("void");
 }
@@ -2767,10 +2774,10 @@ sh_css_param_clear_param_sets(void)
  * MW: we can define hmm_free() to return a NULL
  * then you can write ptr = hmm_free(ptr);
  */
-#define safe_free(id, x)      \
-	do {                  \
-		ia_css_refcount_decrement(id, x);     \
-		(x) = mmgr_NULL;  \
+#define safe_free(id, x)                          \
+	do {                                      \
+		ia_css_refcount_decrement(id, x); \
+		(x) = mmgr_NULL;                  \
 	} while (0)
 
 static void free_map(struct sh_css_ddr_address_map *map)
@@ -2782,8 +2789,9 @@ static void free_map(struct sh_css_ddr_address_map *map)
 	IA_CSS_ENTER_PRIVATE("void");
 
 	/* free buffers */
-	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size) /
-			 sizeof(size_t)); i++) {
+	for (i = 0;
+	     i < (sizeof(struct sh_css_ddr_address_map_size) / sizeof(size_t));
+	     i++) {
 		if (addrs[i] == mmgr_NULL)
 			continue;
 		safe_free(IA_CSS_REFCOUNT_PARAM_BUFFER, addrs[i]);
@@ -2792,13 +2800,12 @@ static void free_map(struct sh_css_ddr_address_map *map)
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-void
-ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
+void ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
 {
 	int i;
 	struct ia_css_isp_parameters *params = stream->isp_params_configs;
 	struct ia_css_isp_parameters *per_frame_params =
-		    stream->per_frame_isp_params_configs;
+		stream->per_frame_isp_params_configs;
 
 	IA_CSS_ENTER_PRIVATE("void");
 	if (!params) {
@@ -2814,8 +2821,10 @@ ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
 		/* Free up theDVS table memory blocks before recomputing new table */
 		if (params->pipe_dvs_6axis_config[i])
 			free_dvs_6axis_table(&params->pipe_dvs_6axis_config[i]);
-		if (per_frame_params && per_frame_params->pipe_dvs_6axis_config[i])
-			free_dvs_6axis_table(&per_frame_params->pipe_dvs_6axis_config[i]);
+		if (per_frame_params &&
+		    per_frame_params->pipe_dvs_6axis_config[i])
+			free_dvs_6axis_table(
+				&per_frame_params->pipe_dvs_6axis_config[i]);
 	}
 	free_map(&params->ddr_ptrs);
 	if (per_frame_params)
@@ -2846,8 +2855,7 @@ ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-void
-sh_css_params_uninit(void)
+void sh_css_params_uninit(void)
 {
 	unsigned int p, i;
 
@@ -2862,24 +2870,24 @@ sh_css_params_uninit(void)
 		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
 			ia_css_refcount_decrement(-1, xmem_sp_stage_ptrs[p][i]);
 			xmem_sp_stage_ptrs[p][i] = mmgr_NULL;
-			ia_css_refcount_decrement(-1, xmem_isp_stage_ptrs[p][i]);
+			ia_css_refcount_decrement(-1,
+						  xmem_isp_stage_ptrs[p][i]);
 			xmem_isp_stage_ptrs[p][i] = mmgr_NULL;
 		}
 
 	/* go through the pools to clear references */
-	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_SET_POOL, &free_param_set_callback);
-	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_BUFFER, &free_buffer_callback);
+	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_SET_POOL,
+			      &free_param_set_callback);
+	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_BUFFER,
+			      &free_buffer_callback);
 	ia_css_refcount_clear(-1, &free_buffer_callback);
 
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
 static struct ia_css_host_data *
-convert_allocate_morph_plane(
-    unsigned short *data,
-    unsigned int width,
-    unsigned int height,
-    unsigned int aligned_width)
+convert_allocate_morph_plane(unsigned short *data, unsigned int width,
+			     unsigned int height, unsigned int aligned_width)
 {
 	unsigned int i, j, padding, w;
 	struct ia_css_host_data *me;
@@ -2922,19 +2930,16 @@ convert_allocate_morph_plane(
 	return me;
 }
 
-static int
-store_morph_plane(
-    unsigned short *data,
-    unsigned int width,
-    unsigned int height,
-    ia_css_ptr dest,
-    unsigned int aligned_width)
+static int store_morph_plane(unsigned short *data, unsigned int width,
+			     unsigned int height, ia_css_ptr dest,
+			     unsigned int aligned_width)
 {
 	struct ia_css_host_data *isp_data;
 
 	assert(dest != mmgr_NULL);
 
-	isp_data = convert_allocate_morph_plane(data, width, height, aligned_width);
+	isp_data = convert_allocate_morph_plane(data, width, height,
+						aligned_width);
 	if (!isp_data) {
 		IA_CSS_LEAVE_ERR_PRIVATE(-ENOMEM);
 		return -ENOMEM;
@@ -2945,9 +2950,9 @@ store_morph_plane(
 	return 0;
 }
 
-static void sh_css_update_isp_params_to_ddr(
-    struct ia_css_isp_parameters *params,
-    ia_css_ptr ddr_ptr)
+static void
+sh_css_update_isp_params_to_ddr(struct ia_css_isp_parameters *params,
+				ia_css_ptr ddr_ptr)
 {
 	size_t size = sizeof(params->uds);
 
@@ -2959,11 +2964,10 @@ static void sh_css_update_isp_params_to_ddr(
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void sh_css_update_isp_mem_params_to_ddr(
-    const struct ia_css_binary *binary,
-    ia_css_ptr ddr_mem_ptr,
-    size_t size,
-    enum ia_css_isp_memories mem)
+static void
+sh_css_update_isp_mem_params_to_ddr(const struct ia_css_binary *binary,
+				    ia_css_ptr ddr_mem_ptr, size_t size,
+				    enum ia_css_isp_memories mem)
 {
 	const struct ia_css_host_data *params;
 
@@ -2980,10 +2984,10 @@ void ia_css_dequeue_param_buffers(/*unsigned int pipe_num*/ void)
 {
 	unsigned int i;
 	ia_css_ptr cpy;
-	enum sh_css_queue_id param_queue_ids[3] = {	IA_CSS_PARAMETER_SET_QUEUE_ID,
-						    IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID,
-						    SH_CSS_INVALID_QUEUE_ID
-						  };
+	enum sh_css_queue_id param_queue_ids[3] = {
+		IA_CSS_PARAMETER_SET_QUEUE_ID,
+		IA_CSS_PER_FRAME_PARAMETER_SET_QUEUE_ID, SH_CSS_INVALID_QUEUE_ID
+	};
 
 	IA_CSS_ENTER_PRIVATE("void");
 
@@ -3002,12 +3006,11 @@ void ia_css_dequeue_param_buffers(/*unsigned int pipe_num*/ void)
 			 */
 			g_param_buffer_dequeue_count++;
 			ia_css_bufq_enqueue_psys_event(
-			    IA_CSS_PSYS_SW_EVENT_BUFFER_DEQUEUED,
-			    0,
-			    param_queue_ids[i],
-			    0);
+				IA_CSS_PSYS_SW_EVENT_BUFFER_DEQUEUED, 0,
+				param_queue_ids[i], 0);
 
-			IA_CSS_LOG("dequeued param set %x from %d, release ref", cpy, 0);
+			IA_CSS_LOG("dequeued param set %x from %d, release ref",
+				   cpy, 0);
 			free_ia_css_isp_parameter_set_info(cpy);
 			cpy = (ia_css_ptr)0;
 		}
@@ -3016,12 +3019,11 @@ void ia_css_dequeue_param_buffers(/*unsigned int pipe_num*/ void)
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static void
-process_kernel_parameters(unsigned int pipe_id,
-			  struct ia_css_pipeline_stage *stage,
-			  struct ia_css_isp_parameters *params,
-			  unsigned int isp_pipe_version,
-			  unsigned int raw_bit_depth)
+static void process_kernel_parameters(unsigned int pipe_id,
+				      struct ia_css_pipeline_stage *stage,
+				      struct ia_css_isp_parameters *params,
+				      unsigned int isp_pipe_version,
+				      unsigned int raw_bit_depth)
 {
 	unsigned int param_id;
 
@@ -3040,22 +3042,22 @@ process_kernel_parameters(unsigned int pipe_id,
 	/* Copy stage uds parameters to config, since they can differ per stage.
 	 */
 	params->crop_config.crop_pos = params->uds[stage->stage_num].crop_pos;
-	params->uds_config.crop_pos  = params->uds[stage->stage_num].crop_pos;
-	params->uds_config.uds       = params->uds[stage->stage_num].uds;
+	params->uds_config.crop_pos = params->uds[stage->stage_num].crop_pos;
+	params->uds_config.uds = params->uds[stage->stage_num].uds;
 	/* Call parameter process functions for all kernels */
 	/* Skip SC, since that is called on a temp sc table */
 	for (param_id = 0; param_id < IA_CSS_NUM_PARAMETER_IDS; param_id++) {
-		if (param_id == IA_CSS_SC_ID) continue;
+		if (param_id == IA_CSS_SC_ID)
+			continue;
 		if (params->config_changed[param_id])
-			ia_css_kernel_process_param[param_id](pipe_id, stage, params);
+			ia_css_kernel_process_param[param_id](pipe_id, stage,
+							      params);
 	}
 }
 
-int
-sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
-			       struct ia_css_isp_parameters *params,
-			       bool commit,
-			       struct ia_css_pipe *pipe_in)
+int sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
+				   struct ia_css_isp_parameters *params,
+				   bool commit, struct ia_css_pipe *pipe_in)
 {
 	int err = 0;
 	ia_css_ptr cpy;
@@ -3069,8 +3071,10 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 
 	assert(curr_pipe);
 
-	IA_CSS_ENTER_PRIVATE("pipe=%p, isp_parameters_id=%d", pipe_in, params->isp_parameters_id);
-	raw_bit_depth = ia_css_stream_input_format_bits_per_pixel(curr_pipe->stream);
+	IA_CSS_ENTER_PRIVATE("pipe=%p, isp_parameters_id=%d", pipe_in,
+			     params->isp_parameters_id);
+	raw_bit_depth =
+		ia_css_stream_input_format_bits_per_pixel(curr_pipe->stream);
 
 	/* now make the map available to the sp */
 	if (!commit) {
@@ -3095,10 +3099,11 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 		isp_pipe_version = ia_css_pipe_get_isp_pipe_version(pipe);
 		ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
 
-		ia_css_query_internal_queue_id(params->output_frame
-					       ? IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET
-					       : IA_CSS_BUFFER_TYPE_PARAMETER_SET,
-					       thread_id, &queue_id);
+		ia_css_query_internal_queue_id(
+			params->output_frame ?
+				IA_CSS_BUFFER_TYPE_PER_FRAME_PARAMETER_SET :
+				IA_CSS_BUFFER_TYPE_PARAMETER_SET,
+			thread_id, &queue_id);
 		if (!sh_css_sp_is_running()) {
 			/* SP is not running. The queues are not valid */
 			err = -EBUSY;
@@ -3136,23 +3141,20 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 			if (!stage || !stage->binary)
 				continue;
 
-			process_kernel_parameters(pipeline->pipe_id,
-						  stage, params,
-						  isp_pipe_version, raw_bit_depth);
+			process_kernel_parameters(pipeline->pipe_id, stage,
+						  params, isp_pipe_version,
+						  raw_bit_depth);
 
 			err = sh_css_params_write_to_ddr_internal(
-				  pipe,
-				  pipeline->pipe_id,
-				  params,
-				  stage,
-				  cur_map,
-				  cur_map_size);
+				pipe, pipeline->pipe_id, params, stage, cur_map,
+				cur_map_size);
 
 			if (err)
 				break;
 			for (mem = 0; mem < IA_CSS_NUM_MEMORIES; mem++) {
-				params->isp_mem_params_changed
-				[pipeline->pipe_id][stage->stage_num][mem] = false;
+				params->isp_mem_params_changed[pipeline->pipe_id]
+							      [stage->stage_num]
+							      [mem] = false;
 			}
 		} /* for */
 		if (err)
@@ -3161,18 +3163,16 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 		if (params->isp_params_changed) {
 			reallocate_buffer(&cur_map->isp_param,
 					  &cur_map_size->isp_param,
-					  cur_map_size->isp_param,
-					  true,
-					  &err);
+					  cur_map_size->isp_param, true, &err);
 			if (err)
 				break;
-			sh_css_update_isp_params_to_ddr(params, cur_map->isp_param);
+			sh_css_update_isp_params_to_ddr(params,
+							cur_map->isp_param);
 		}
 
 		/* last make referenced copy */
-		err = ref_sh_css_ddr_address_map(
-			  cur_map,
-			  &isp_params_info.mem_map);
+		err = ref_sh_css_ddr_address_map(cur_map,
+						 &isp_params_info.mem_map);
 		if (err)
 			break;
 
@@ -3181,30 +3181,35 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 
 		/* Update output frame pointer */
 		isp_params_info.output_frame_ptr =
-		    (params->output_frame) ? params->output_frame->data : mmgr_NULL;
+			(params->output_frame) ? params->output_frame->data :
+						 mmgr_NULL;
 
 		/* now write the copy to ddr */
-		err = write_ia_css_isp_parameter_set_info_to_ddr(&isp_params_info, &cpy);
+		err = write_ia_css_isp_parameter_set_info_to_ddr(
+			&isp_params_info, &cpy);
 		if (err)
 			break;
 
 		/* enqueue the set to sp */
 		IA_CSS_LOG("queue param set %x to %d", cpy, thread_id);
 
-		err = ia_css_bufq_enqueue_buffer(thread_id, queue_id, (uint32_t)cpy);
+		err = ia_css_bufq_enqueue_buffer(thread_id, queue_id,
+						 (uint32_t)cpy);
 		if (err) {
 			free_ia_css_isp_parameter_set_info(cpy);
-			IA_CSS_LOG("pfp: FAILED to add config id %d for OF %d to q %d on thread %d",
-				   isp_params_info.isp_parameters_id,
-				   isp_params_info.output_frame_ptr,
-				   queue_id, thread_id);
+			IA_CSS_LOG(
+				"pfp: FAILED to add config id %d for OF %d to q %d on thread %d",
+				isp_params_info.isp_parameters_id,
+				isp_params_info.output_frame_ptr, queue_id,
+				thread_id);
 			break;
 		} else {
 			/* TMP: check discrepancy between nr of enqueued
 			 * parameter sets and dequeued sets
 			 */
 			g_param_buffer_enqueue_count++;
-			assert(g_param_buffer_enqueue_count < g_param_buffer_dequeue_count + 50);
+			assert(g_param_buffer_enqueue_count <
+			       g_param_buffer_dequeue_count + 50);
 			/*
 			 * Tell the SP which queues are not empty,
 			 * by sending the software event.
@@ -3215,18 +3220,18 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 				return -EBUSY;
 			}
 			ia_css_bufq_enqueue_psys_event(
-			    IA_CSS_PSYS_SW_EVENT_BUFFER_ENQUEUED,
-			    (uint8_t)thread_id,
-			    (uint8_t)queue_id,
-			    0);
-			IA_CSS_LOG("pfp: added config id %d for OF %d to q %d on thread %d",
-				   isp_params_info.isp_parameters_id,
-				   isp_params_info.output_frame_ptr,
-				   queue_id, thread_id);
+				IA_CSS_PSYS_SW_EVENT_BUFFER_ENQUEUED,
+				(uint8_t)thread_id, (uint8_t)queue_id, 0);
+			IA_CSS_LOG(
+				"pfp: added config id %d for OF %d to q %d on thread %d",
+				isp_params_info.isp_parameters_id,
+				isp_params_info.output_frame_ptr, queue_id,
+				thread_id);
 		}
 		/* clean-up old copy */
 		ia_css_dequeue_param_buffers(/*pipe_num*/);
-		params->pipe_dvs_6axis_config_changed[pipeline->pipe_id] = false;
+		params->pipe_dvs_6axis_config_changed[pipeline->pipe_id] =
+			false;
 	} /* end for each 'active' pipeline */
 	/* clear the changed flags after all params
 	for all pipelines have been updated */
@@ -3247,14 +3252,12 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 	return err;
 }
 
-static int
-sh_css_params_write_to_ddr_internal(
-    struct ia_css_pipe *pipe,
-    unsigned int pipe_id,
-    struct ia_css_isp_parameters *params,
-    const struct ia_css_pipeline_stage *stage,
-    struct sh_css_ddr_address_map *ddr_map,
-    struct sh_css_ddr_address_map_size *ddr_map_size)
+static int sh_css_params_write_to_ddr_internal(
+	struct ia_css_pipe *pipe, unsigned int pipe_id,
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_pipeline_stage *stage,
+	struct sh_css_ddr_address_map *ddr_map,
+	struct sh_css_ddr_address_map_size *ddr_map_size)
 {
 	int err;
 	const struct ia_css_binary *binary;
@@ -3278,11 +3281,10 @@ sh_css_params_write_to_ddr_internal(
 	stage_num = stage->stage_num;
 
 	if (binary->info->sp.enable.fpnr) {
-		buff_realloced = reallocate_buffer(&ddr_map->fpn_tbl,
-						   &ddr_map_size->fpn_tbl,
-						   fpntbl_bytes(binary),
-						   params->config_changed[IA_CSS_FPN_ID],
-						   &err);
+		buff_realloced = reallocate_buffer(
+			&ddr_map->fpn_tbl, &ddr_map_size->fpn_tbl,
+			fpntbl_bytes(binary),
+			params->config_changed[IA_CSS_FPN_ID], &err);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
@@ -3301,13 +3303,12 @@ sh_css_params_write_to_ddr_internal(
 	if (binary->info->sp.enable.sc) {
 		u32 enable_conv;
 
-		enable_conv = params->shading_settings.enable_shading_table_conversion;
+		enable_conv =
+			params->shading_settings.enable_shading_table_conversion;
 
-		buff_realloced = reallocate_buffer(&ddr_map->sc_tbl,
-						   &ddr_map_size->sc_tbl,
-						   sctbl_bytes(binary),
-						   params->sc_table_changed,
-						   &err);
+		buff_realloced = reallocate_buffer(
+			&ddr_map->sc_tbl, &ddr_map_size->sc_tbl,
+			sctbl_bytes(binary), params->sc_table_changed, &err);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
@@ -3318,69 +3319,86 @@ sh_css_params_write_to_ddr_internal(
 			if (enable_conv == 0) {
 				if (params->sc_table) {
 					/* store the shading table to ddr */
-					err = ia_css_params_store_sctbl(stage, ddr_map->sc_tbl, params->sc_table);
+					err = ia_css_params_store_sctbl(
+						stage, ddr_map->sc_tbl,
+						params->sc_table);
 					if (err) {
 						IA_CSS_LEAVE_ERR_PRIVATE(err);
 						return err;
 					}
 					/* set sc_config to isp */
-					params->sc_config = (struct ia_css_shading_table *)params->sc_table;
-					ia_css_kernel_process_param[IA_CSS_SC_ID](pipe_id, stage, params);
+					params->sc_config =
+						(struct ia_css_shading_table *)
+							params->sc_table;
+					ia_css_kernel_process_param[IA_CSS_SC_ID](
+						pipe_id, stage, params);
 					params->sc_config = NULL;
 				} else {
 					/* generate the identical shading table */
 					if (params->sc_config) {
-						ia_css_shading_table_free(params->sc_config);
+						ia_css_shading_table_free(
+							params->sc_config);
 						params->sc_config = NULL;
 					}
-					sh_css_params_shading_id_table_generate(&params->sc_config,
-										binary->sctbl_width_per_color,
-										binary->sctbl_height);
+					sh_css_params_shading_id_table_generate(
+						&params->sc_config,
+						binary->sctbl_width_per_color,
+						binary->sctbl_height);
 					if (!params->sc_config) {
-						IA_CSS_LEAVE_ERR_PRIVATE(-ENOMEM);
+						IA_CSS_LEAVE_ERR_PRIVATE(
+							-ENOMEM);
 						return -ENOMEM;
 					}
 
 					/* store the shading table to ddr */
-					err = ia_css_params_store_sctbl(stage, ddr_map->sc_tbl, params->sc_config);
+					err = ia_css_params_store_sctbl(
+						stage, ddr_map->sc_tbl,
+						params->sc_config);
 					if (err) {
 						IA_CSS_LEAVE_ERR_PRIVATE(err);
 						return err;
 					}
 
 					/* set sc_config to isp */
-					ia_css_kernel_process_param[IA_CSS_SC_ID](pipe_id, stage, params);
+					ia_css_kernel_process_param[IA_CSS_SC_ID](
+						pipe_id, stage, params);
 
 					/* free the shading table */
-					ia_css_shading_table_free(params->sc_config);
+					ia_css_shading_table_free(
+						params->sc_config);
 					params->sc_config = NULL;
 				}
 			} else { /* legacy */
 				/* ------ deprecated(bz675) : from ------ */
 				/* shading table is full resolution, reduce */
 				if (params->sc_config) {
-					ia_css_shading_table_free(params->sc_config);
+					ia_css_shading_table_free(
+						params->sc_config);
 					params->sc_config = NULL;
 				}
 				prepare_shading_table(
-				    (const struct ia_css_shading_table *)params->sc_table,
-				    params->sensor_binning,
-				    &params->sc_config,
-				    binary, pipe->required_bds_factor);
+					(const struct ia_css_shading_table *)
+						params->sc_table,
+					params->sensor_binning,
+					&params->sc_config, binary,
+					pipe->required_bds_factor);
 				if (!params->sc_config) {
 					IA_CSS_LEAVE_ERR_PRIVATE(-ENOMEM);
 					return -ENOMEM;
 				}
 
 				/* store the shading table to ddr */
-				err = ia_css_params_store_sctbl(stage, ddr_map->sc_tbl, params->sc_config);
+				err = ia_css_params_store_sctbl(
+					stage, ddr_map->sc_tbl,
+					params->sc_config);
 				if (err) {
 					IA_CSS_LEAVE_ERR_PRIVATE(err);
 					return err;
 				}
 
 				/* set sc_config to isp */
-				ia_css_kernel_process_param[IA_CSS_SC_ID](pipe_id, stage, params);
+				ia_css_kernel_process_param[IA_CSS_SC_ID](
+					pipe_id, stage, params);
 
 				/* free the shading table */
 				ia_css_shading_table_free(params->sc_config);
@@ -3390,53 +3408,55 @@ sh_css_params_write_to_ddr_internal(
 		}
 	}
 
-	if (params->config_changed[IA_CSS_MACC_ID] && binary->info->sp.enable.macc) {
+	if (params->config_changed[IA_CSS_MACC_ID] &&
+	    binary->info->sp.enable.macc) {
 		unsigned int i, j, idx;
-		static const unsigned int idx_map[] = {
-			0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8
-		};
+		static const unsigned int idx_map[] = { 0,  1,	3,  2,	6,  7,
+							5,  4,	12, 13, 15, 14,
+							10, 11, 9,  8 };
 
 		for (i = 0; i < IA_CSS_MACC_NUM_AXES; i++) {
 			idx = 4 * idx_map[i];
-			j   = 4 * i;
+			j = 4 * i;
 
-			if (binary->info->sp.pipeline.isp_pipe_version == SH_CSS_ISP_PIPE_VERSION_1) {
+			if (binary->info->sp.pipeline.isp_pipe_version ==
+			    SH_CSS_ISP_PIPE_VERSION_1) {
 				converted_macc_table.data[idx] =
-				    (int16_t)sDIGIT_FITTING(params->macc_table.data[j],
-							    13, SH_CSS_MACC_COEF_SHIFT);
+					(int16_t)sDIGIT_FITTING(
+						params->macc_table.data[j], 13,
+						SH_CSS_MACC_COEF_SHIFT);
 				converted_macc_table.data[idx + 1] =
-				    (int16_t)sDIGIT_FITTING(params->macc_table.data[j + 1],
-							    13, SH_CSS_MACC_COEF_SHIFT);
+					(int16_t)sDIGIT_FITTING(
+						params->macc_table.data[j + 1],
+						13, SH_CSS_MACC_COEF_SHIFT);
 				converted_macc_table.data[idx + 2] =
-				    (int16_t)sDIGIT_FITTING(params->macc_table.data[j + 2],
-							    13, SH_CSS_MACC_COEF_SHIFT);
+					(int16_t)sDIGIT_FITTING(
+						params->macc_table.data[j + 2],
+						13, SH_CSS_MACC_COEF_SHIFT);
 				converted_macc_table.data[idx + 3] =
-				    (int16_t)sDIGIT_FITTING(params->macc_table.data[j + 3],
-							    13, SH_CSS_MACC_COEF_SHIFT);
+					(int16_t)sDIGIT_FITTING(
+						params->macc_table.data[j + 3],
+						13, SH_CSS_MACC_COEF_SHIFT);
 			} else if (binary->info->sp.pipeline.isp_pipe_version ==
 				   SH_CSS_ISP_PIPE_VERSION_2_2) {
 				converted_macc_table.data[idx] =
-				    params->macc_table.data[j];
+					params->macc_table.data[j];
 				converted_macc_table.data[idx + 1] =
-				    params->macc_table.data[j + 1];
+					params->macc_table.data[j + 1];
 				converted_macc_table.data[idx + 2] =
-				    params->macc_table.data[j + 2];
+					params->macc_table.data[j + 2];
 				converted_macc_table.data[idx + 3] =
-				    params->macc_table.data[j + 3];
+					params->macc_table.data[j + 3];
 			}
 		}
-		reallocate_buffer(&ddr_map->macc_tbl,
-				  &ddr_map_size->macc_tbl,
-				  ddr_map_size->macc_tbl,
-				  true,
-				  &err);
+		reallocate_buffer(&ddr_map->macc_tbl, &ddr_map_size->macc_tbl,
+				  ddr_map_size->macc_tbl, true, &err);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
 		}
-		hmm_store(ddr_map->macc_tbl,
-			   converted_macc_table.data,
-			   sizeof(converted_macc_table.data));
+		hmm_store(ddr_map->macc_tbl, converted_macc_table.data,
+			  sizeof(converted_macc_table.data));
 	}
 
 	if (binary->info->sp.enable.dvs_6axis) {
@@ -3445,47 +3465,58 @@ sh_css_params_write_to_ddr_internal(
 		 * total YYU size = UV-only * 3.
 		 */
 		buff_realloced = reallocate_buffer(
-				     &ddr_map->dvs_6axis_params_y,
-				     &ddr_map_size->dvs_6axis_params_y,
-				     (size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3),
-				     params->pipe_dvs_6axis_config_changed[pipe_id],
-				     &err);
+			&ddr_map->dvs_6axis_params_y,
+			&ddr_map_size->dvs_6axis_params_y,
+			(size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3),
+			params->pipe_dvs_6axis_config_changed[pipe_id], &err);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
 		}
 
-		if (params->pipe_dvs_6axis_config_changed[pipe_id] || buff_realloced) {
+		if (params->pipe_dvs_6axis_config_changed[pipe_id] ||
+		    buff_realloced) {
 			const struct ia_css_frame_info *dvs_in_frame_info;
 
 			if (stage->args.delay_frames[0]) {
 				/*When delay frames are present(as in case of video),
 				they are used for dvs. Configure DVS using those params*/
-				dvs_in_frame_info = &stage->args.delay_frames[0]->frame_info;
+				dvs_in_frame_info =
+					&stage->args.delay_frames[0]->frame_info;
 			} else {
 				/*Otherwise, use input frame to configure DVS*/
-				dvs_in_frame_info = &stage->args.in_frame->frame_info;
+				dvs_in_frame_info =
+					&stage->args.in_frame->frame_info;
 			}
 
 			/* Generate default DVS unity table on start up*/
 			if (!params->pipe_dvs_6axis_config[pipe_id]) {
-				struct ia_css_resolution dvs_offset = {0};
+				struct ia_css_resolution dvs_offset = { 0 };
 
-				dvs_offset.width = (PIX_SHIFT_FILTER_RUN_IN_X + binary->dvs_envelope.width) / 2;
-				dvs_offset.height = (PIX_SHIFT_FILTER_RUN_IN_Y + binary->dvs_envelope.height) / 2;
+				dvs_offset.width =
+					(PIX_SHIFT_FILTER_RUN_IN_X +
+					 binary->dvs_envelope.width) /
+					2;
+				dvs_offset.height =
+					(PIX_SHIFT_FILTER_RUN_IN_Y +
+					 binary->dvs_envelope.height) /
+					2;
 
 				params->pipe_dvs_6axis_config[pipe_id] =
-				    generate_dvs_6axis_table(&binary->out_frame_info[0].res, &dvs_offset);
+					generate_dvs_6axis_table(
+						&binary->out_frame_info[0].res,
+						&dvs_offset);
 				if (!params->pipe_dvs_6axis_config[pipe_id]) {
 					IA_CSS_LEAVE_ERR_PRIVATE(-ENOMEM);
 					return -ENOMEM;
 				}
-				params->pipe_dvs_6axis_config_changed[pipe_id] = true;
+				params->pipe_dvs_6axis_config_changed[pipe_id] =
+					true;
 
-				store_dvs_6axis_config(params->pipe_dvs_6axis_config[pipe_id],
-						    binary,
-						    dvs_in_frame_info,
-						    ddr_map->dvs_6axis_params_y);
+				store_dvs_6axis_config(
+					params->pipe_dvs_6axis_config[pipe_id],
+					binary, dvs_in_frame_info,
+					ddr_map->dvs_6axis_params_y);
 				params->isp_params_changed = true;
 			}
 		}
@@ -3495,16 +3526,16 @@ sh_css_params_write_to_ddr_internal(
 		unsigned int i;
 		ia_css_ptr *virt_addr_tetra_x[
 
-		IA_CSS_MORPH_TABLE_NUM_PLANES];
+			IA_CSS_MORPH_TABLE_NUM_PLANES];
 		size_t *virt_size_tetra_x[
 
-		IA_CSS_MORPH_TABLE_NUM_PLANES];
+			IA_CSS_MORPH_TABLE_NUM_PLANES];
 		ia_css_ptr *virt_addr_tetra_y[
 
-		IA_CSS_MORPH_TABLE_NUM_PLANES];
+			IA_CSS_MORPH_TABLE_NUM_PLANES];
 		size_t *virt_size_tetra_y[
 
-		IA_CSS_MORPH_TABLE_NUM_PLANES];
+			IA_CSS_MORPH_TABLE_NUM_PLANES];
 
 		virt_addr_tetra_x[0] = &ddr_map->tetra_r_x;
 		virt_addr_tetra_x[1] = &ddr_map->tetra_gr_x;
@@ -3536,39 +3567,36 @@ sh_css_params_write_to_ddr_internal(
 
 		buff_realloced = false;
 		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-			buff_realloced |=
-			    reallocate_buffer(virt_addr_tetra_x[i],
-					    virt_size_tetra_x[i],
-					    morph_plane_bytes(binary),
-					    params->morph_table_changed,
-					    &err);
+			buff_realloced |= reallocate_buffer(
+				virt_addr_tetra_x[i], virt_size_tetra_x[i],
+				morph_plane_bytes(binary),
+				params->morph_table_changed, &err);
 			if (err) {
 				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
 			}
-			buff_realloced |=
-			    reallocate_buffer(virt_addr_tetra_y[i],
-					    virt_size_tetra_y[i],
-					    morph_plane_bytes(binary),
-					    params->morph_table_changed,
-					    &err);
+			buff_realloced |= reallocate_buffer(
+				virt_addr_tetra_y[i], virt_size_tetra_y[i],
+				morph_plane_bytes(binary),
+				params->morph_table_changed, &err);
 			if (err) {
 				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
 			}
 		}
 		if (params->morph_table_changed || buff_realloced) {
-			const struct ia_css_morph_table *table = params->morph_table;
+			const struct ia_css_morph_table *table =
+				params->morph_table;
 			struct ia_css_morph_table *id_table = NULL;
 
 			if ((table) &&
 			    (table->width < binary->morph_tbl_width ||
-			    table->height < binary->morph_tbl_height)) {
+			     table->height < binary->morph_tbl_height)) {
 				table = NULL;
 			}
 			if (!table) {
-				err = sh_css_params_default_morph_table(&id_table,
-									binary);
+				err = sh_css_params_default_morph_table(
+					&id_table, binary);
 				if (err) {
 					IA_CSS_LEAVE_ERR_PRIVATE(err);
 					return err;
@@ -3577,16 +3605,14 @@ sh_css_params_write_to_ddr_internal(
 			}
 
 			for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-				store_morph_plane(table->coordinates_x[i],
-						table->width,
-						table->height,
-						*virt_addr_tetra_x[i],
-						binary->morph_tbl_aligned_width);
-				store_morph_plane(table->coordinates_y[i],
-						table->width,
-						table->height,
-						*virt_addr_tetra_y[i],
-						binary->morph_tbl_aligned_width);
+				store_morph_plane(
+					table->coordinates_x[i], table->width,
+					table->height, *virt_addr_tetra_x[i],
+					binary->morph_tbl_aligned_width);
+				store_morph_plane(
+					table->coordinates_y[i], table->width,
+					table->height, *virt_addr_tetra_y[i],
+					binary->morph_tbl_aligned_width);
 			}
 			if (id_table)
 				ia_css_morph_table_free(id_table);
@@ -3596,24 +3622,28 @@ sh_css_params_write_to_ddr_internal(
 	/* After special cases like SC, FPN since they may change parameters */
 	for (mem = 0; mem < N_IA_CSS_MEMORIES; mem++) {
 		const struct ia_css_isp_data *isp_data =
-		    ia_css_isp_param_get_isp_mem_init(&binary->info->sp.mem_initializers,
-						    IA_CSS_PARAM_CLASS_PARAM, mem);
+			ia_css_isp_param_get_isp_mem_init(
+				&binary->info->sp.mem_initializers,
+				IA_CSS_PARAM_CLASS_PARAM, mem);
 		size_t size = isp_data->size;
 
-		if (!size) continue;
-		buff_realloced = reallocate_buffer(&ddr_map->isp_mem_param[stage_num][mem],
-						&ddr_map_size->isp_mem_param[stage_num][mem],
-						size,
-						params->isp_mem_params_changed[pipe_id][stage_num][mem],
-						&err);
+		if (!size)
+			continue;
+		buff_realloced = reallocate_buffer(
+			&ddr_map->isp_mem_param[stage_num][mem],
+			&ddr_map_size->isp_mem_param[stage_num][mem], size,
+			params->isp_mem_params_changed[pipe_id][stage_num][mem],
+			&err);
 		if (err) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
 		}
-		if (params->isp_mem_params_changed[pipe_id][stage_num][mem] || buff_realloced) {
-			sh_css_update_isp_mem_params_to_ddr(binary,
-							    ddr_map->isp_mem_param[stage_num][mem],
-							    ddr_map_size->isp_mem_param[stage_num][mem], mem);
+		if (params->isp_mem_params_changed[pipe_id][stage_num][mem] ||
+		    buff_realloced) {
+			sh_css_update_isp_mem_params_to_ddr(
+				binary, ddr_map->isp_mem_param[stage_num][mem],
+				ddr_map_size->isp_mem_param[stage_num][mem],
+				mem);
 		}
 	}
 
@@ -3621,8 +3651,8 @@ sh_css_params_write_to_ddr_internal(
 	return 0;
 }
 
-const struct ia_css_fpn_table *ia_css_get_fpn_table(struct ia_css_stream
-	*stream)
+const struct ia_css_fpn_table *
+ia_css_get_fpn_table(struct ia_css_stream *stream)
 {
 	struct ia_css_isp_parameters *params;
 
@@ -3634,8 +3664,8 @@ const struct ia_css_fpn_table *ia_css_get_fpn_table(struct ia_css_stream
 	return &params->fpn_config;
 }
 
-struct ia_css_shading_table *ia_css_get_shading_table(struct ia_css_stream
-	*stream)
+struct ia_css_shading_table *
+ia_css_get_shading_table(struct ia_css_stream *stream)
 {
 	struct ia_css_shading_table *table = NULL;
 	struct ia_css_isp_parameters *params;
@@ -3652,17 +3682,20 @@ struct ia_css_shading_table *ia_css_get_shading_table(struct ia_css_stream
 		if (params->sc_table) {
 			table = (struct ia_css_shading_table *)params->sc_table;
 		} else {
-			const struct ia_css_binary *binary
-			    = ia_css_stream_get_shading_correction_binary(stream);
+			const struct ia_css_binary *binary =
+				ia_css_stream_get_shading_correction_binary(
+					stream);
 			if (binary) {
 				/* generate the identical shading table */
 				if (params->sc_config) {
-					ia_css_shading_table_free(params->sc_config);
+					ia_css_shading_table_free(
+						params->sc_config);
 					params->sc_config = NULL;
 				}
-				sh_css_params_shading_id_table_generate(&params->sc_config,
-									binary->sctbl_width_per_color,
-									binary->sctbl_height);
+				sh_css_params_shading_id_table_generate(
+					&params->sc_config,
+					binary->sctbl_width_per_color,
+					binary->sctbl_height);
 				table = params->sc_config;
 				/* The sc_config will be freed in the
 				 * ia_css_stream_isp_parameters_uninit function. */
@@ -3670,8 +3703,8 @@ struct ia_css_shading_table *ia_css_get_shading_table(struct ia_css_stream
 		}
 	} else {
 		/* ------ deprecated(bz675) : from ------ */
-		const struct ia_css_binary *binary
-		    = ia_css_stream_get_shading_correction_binary(stream);
+		const struct ia_css_binary *binary =
+			ia_css_stream_get_shading_correction_binary(stream);
 		struct ia_css_pipe *pipe;
 
 		/**********************************************************************/
@@ -3681,8 +3714,10 @@ struct ia_css_shading_table *ia_css_get_shading_table(struct ia_css_stream
 
 		if (stream->num_pipes == 2) {
 			assert(stream->pipes[1]);
-			if (stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_VIDEO ||
-			    stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_PREVIEW)
+			if (stream->pipes[1]->config.mode ==
+				    IA_CSS_PIPE_MODE_VIDEO ||
+			    stream->pipes[1]->config.mode ==
+				    IA_CSS_PIPE_MODE_PREVIEW)
 				pipe = stream->pipes[1];
 		}
 		/**********************************************************************/
@@ -3692,10 +3727,10 @@ struct ia_css_shading_table *ia_css_get_shading_table(struct ia_css_stream
 				params->sc_config = NULL;
 			}
 			prepare_shading_table(
-			    (const struct ia_css_shading_table *)params->sc_table,
-			    params->sensor_binning,
-			    &params->sc_config,
-			    binary, pipe->required_bds_factor);
+				(const struct ia_css_shading_table *)
+					params->sc_table,
+				params->sensor_binning, &params->sc_config,
+				binary, pipe->required_bds_factor);
 
 			table = params->sc_config;
 			/* The sc_config will be freed in the
@@ -3729,7 +3764,8 @@ ia_css_ptr sh_css_store_sp_group_to_ddr(void)
 		memset(buf_ptr, 0, 3);
 		buf_ptr += 3; /* Padding 3 bytes for struct sh_css_sp_config*/
 	} else {
-		memcpy(buf_ptr, &sh_css_sp_group.config, sizeof(sh_css_sp_group.config));
+		memcpy(buf_ptr, &sh_css_sp_group.config,
+		       sizeof(sh_css_sp_group.config));
 		buf_ptr += sizeof(sh_css_sp_group.config);
 	}
 
@@ -3737,7 +3773,8 @@ ia_css_ptr sh_css_store_sp_group_to_ddr(void)
 	buf_ptr += sizeof(sh_css_sp_group.pipe);
 
 	if (IS_ISP2401) {
-		memcpy(buf_ptr, &sh_css_sp_group.pipe_io, sizeof(sh_css_sp_group.pipe_io));
+		memcpy(buf_ptr, &sh_css_sp_group.pipe_io,
+		       sizeof(sh_css_sp_group.pipe_io));
 		buf_ptr += sizeof(sh_css_sp_group.pipe_io);
 		memcpy(buf_ptr, &sh_css_sp_group.pipe_io_status,
 		       sizeof(sh_css_sp_group.pipe_io_status));
@@ -3747,39 +3784,30 @@ ia_css_ptr sh_css_store_sp_group_to_ddr(void)
 	memcpy(buf_ptr, &sh_css_sp_group.debug, sizeof(sh_css_sp_group.debug));
 	buf_ptr += sizeof(sh_css_sp_group.debug);
 
-	hmm_store(xmem_sp_group_ptrs,
-		  write_buf,
-		  buf_ptr - write_buf);
+	hmm_store(xmem_sp_group_ptrs, write_buf, buf_ptr - write_buf);
 
 	kfree(write_buf);
 	return xmem_sp_group_ptrs;
 }
 
-ia_css_ptr sh_css_store_sp_stage_to_ddr(
-    unsigned int pipe,
-    unsigned int stage)
+ia_css_ptr sh_css_store_sp_stage_to_ddr(unsigned int pipe, unsigned int stage)
 {
 	IA_CSS_ENTER_LEAVE_PRIVATE("void");
-	hmm_store(xmem_sp_stage_ptrs[pipe][stage],
-		   &sh_css_sp_stage,
-		   sizeof(struct sh_css_sp_stage));
+	hmm_store(xmem_sp_stage_ptrs[pipe][stage], &sh_css_sp_stage,
+		  sizeof(struct sh_css_sp_stage));
 	return xmem_sp_stage_ptrs[pipe][stage];
 }
 
-ia_css_ptr sh_css_store_isp_stage_to_ddr(
-    unsigned int pipe,
-    unsigned int stage)
+ia_css_ptr sh_css_store_isp_stage_to_ddr(unsigned int pipe, unsigned int stage)
 {
 	IA_CSS_ENTER_LEAVE_PRIVATE("void");
-	hmm_store(xmem_isp_stage_ptrs[pipe][stage],
-		   &sh_css_isp_stage,
-		   sizeof(struct sh_css_isp_stage));
+	hmm_store(xmem_isp_stage_ptrs[pipe][stage], &sh_css_isp_stage,
+		  sizeof(struct sh_css_isp_stage));
 	return xmem_isp_stage_ptrs[pipe][stage];
 }
 
-static int ref_sh_css_ddr_address_map(
-    struct sh_css_ddr_address_map *map,
-    struct sh_css_ddr_address_map *out)
+static int ref_sh_css_ddr_address_map(struct sh_css_ddr_address_map *map,
+				      struct sh_css_ddr_address_map *out)
 {
 	int err = 0;
 	unsigned int i;
@@ -3804,13 +3832,15 @@ static int ref_sh_css_ddr_address_map(
 	       sizeof(struct sh_css_ddr_address_map) / sizeof(ia_css_ptr));
 
 	/* copy map using size info */
-	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size) /
-			 sizeof(size_t)); i++) {
+	for (i = 0;
+	     i < (sizeof(struct sh_css_ddr_address_map_size) / sizeof(size_t));
+	     i++) {
 		if (in_addrs.addrs[i] == mmgr_NULL)
 			to_addrs.addrs[i] = mmgr_NULL;
 		else
-			to_addrs.addrs[i] = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
-					    in_addrs.addrs[i]);
+			to_addrs.addrs[i] = ia_css_refcount_increment(
+				IA_CSS_REFCOUNT_PARAM_BUFFER,
+				in_addrs.addrs[i]);
 	}
 
 	IA_CSS_LEAVE_ERR_PRIVATE(err);
@@ -3818,8 +3848,7 @@ static int ref_sh_css_ddr_address_map(
 }
 
 static int write_ia_css_isp_parameter_set_info_to_ddr(
-    struct ia_css_isp_parameter_set_info *me,
-    ia_css_ptr *out)
+	struct ia_css_isp_parameter_set_info *me, ia_css_ptr *out)
 {
 	int err = 0;
 	bool succ;
@@ -3829,12 +3858,13 @@ static int write_ia_css_isp_parameter_set_info_to_ddr(
 	assert(me);
 	assert(out);
 
-	*out = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_SET_POOL,
-					 hmm_alloc(sizeof(struct ia_css_isp_parameter_set_info)));
+	*out = ia_css_refcount_increment(
+		IA_CSS_REFCOUNT_PARAM_SET_POOL,
+		hmm_alloc(sizeof(struct ia_css_isp_parameter_set_info)));
 	succ = (*out != mmgr_NULL);
 	if (succ)
-		hmm_store(*out,
-			   me, sizeof(struct ia_css_isp_parameter_set_info));
+		hmm_store(*out, me,
+			  sizeof(struct ia_css_isp_parameter_set_info));
 	else
 		err = -ENOMEM;
 
@@ -3842,9 +3872,7 @@ static int write_ia_css_isp_parameter_set_info_to_ddr(
 	return err;
 }
 
-static int
-free_ia_css_isp_parameter_set_info(
-    ia_css_ptr ptr)
+static int free_ia_css_isp_parameter_set_info(ia_css_ptr ptr)
 {
 	int err = 0;
 	struct ia_css_isp_parameter_set_info isp_params_info;
@@ -3855,29 +3883,34 @@ free_ia_css_isp_parameter_set_info(
 
 	/* sanity check - ptr must be valid */
 	if (!ia_css_refcount_is_valid(ptr)) {
-		IA_CSS_ERROR("%s: IA_CSS_REFCOUNT_PARAM_SET_POOL(0x%x) invalid arg", __func__,
-			     ptr);
+		IA_CSS_ERROR(
+			"%s: IA_CSS_REFCOUNT_PARAM_SET_POOL(0x%x) invalid arg",
+			__func__, ptr);
 		err = -EINVAL;
 		IA_CSS_LEAVE_ERR_PRIVATE(err);
 		return err;
 	}
 
-	hmm_load(ptr, &isp_params_info.mem_map, sizeof(struct sh_css_ddr_address_map));
+	hmm_load(ptr, &isp_params_info.mem_map,
+		 sizeof(struct sh_css_ddr_address_map));
 	/* copy map using size info */
-	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size) /
-			 sizeof(size_t)); i++) {
+	for (i = 0;
+	     i < (sizeof(struct sh_css_ddr_address_map_size) / sizeof(size_t));
+	     i++) {
 		if (addrs[i] == mmgr_NULL)
 			continue;
 
 		/* sanity check - ptr must be valid */
 		if (!ia_css_refcount_is_valid(addrs[i])) {
-			IA_CSS_ERROR("%s: IA_CSS_REFCOUNT_PARAM_BUFFER(0x%x) invalid arg", __func__,
-				     ptr);
+			IA_CSS_ERROR(
+				"%s: IA_CSS_REFCOUNT_PARAM_BUFFER(0x%x) invalid arg",
+				__func__, ptr);
 			err = -EINVAL;
 			continue;
 		}
 
-		ia_css_refcount_decrement(IA_CSS_REFCOUNT_PARAM_BUFFER, addrs[i]);
+		ia_css_refcount_decrement(IA_CSS_REFCOUNT_PARAM_BUFFER,
+					  addrs[i]);
 	}
 	ia_css_refcount_decrement(IA_CSS_REFCOUNT_PARAM_SET_POOL, ptr);
 
@@ -3886,10 +3919,9 @@ free_ia_css_isp_parameter_set_info(
 }
 
 /* Mark all parameters as changed to force recomputing the derived ISP parameters */
-void
-sh_css_invalidate_params(struct ia_css_stream *stream)
+void sh_css_invalidate_params(struct ia_css_stream *stream)
 {
-	struct	ia_css_isp_parameters *params;
+	struct ia_css_isp_parameters *params;
 	unsigned int i, j, mem;
 
 	IA_CSS_ENTER_PRIVATE("void");
@@ -3900,7 +3932,8 @@ sh_css_invalidate_params(struct ia_css_stream *stream)
 	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
 		for (j = 0; j < SH_CSS_MAX_STAGES; j++) {
 			for (mem = 0; mem < N_IA_CSS_MEMORIES; mem++) {
-				params->isp_mem_params_changed[i][j][mem] = true;
+				params->isp_mem_params_changed[i][j][mem] =
+					true;
 			}
 		}
 	}
@@ -3924,18 +3957,17 @@ sh_css_invalidate_params(struct ia_css_stream *stream)
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-void
-sh_css_update_uds_and_crop_info(
-    const struct ia_css_binary_info *info,
-    const struct ia_css_frame_info *in_frame_info,
-    const struct ia_css_frame_info *out_frame_info,
-    const struct ia_css_resolution *dvs_env,
-    const struct ia_css_dz_config *zoom,
-    const struct ia_css_vector *motion_vector,
-    struct sh_css_uds_info *uds,		/* out */
-    struct sh_css_crop_pos *sp_out_crop_pos,	/* out */
-
-    bool enable_zoom)
+void sh_css_update_uds_and_crop_info(
+	const struct ia_css_binary_info *info,
+	const struct ia_css_frame_info *in_frame_info,
+	const struct ia_css_frame_info *out_frame_info,
+	const struct ia_css_resolution *dvs_env,
+	const struct ia_css_dz_config *zoom,
+	const struct ia_css_vector *motion_vector,
+	struct sh_css_uds_info *uds, /* out */
+	struct sh_css_crop_pos *sp_out_crop_pos, /* out */
+
+	bool enable_zoom)
 {
 	IA_CSS_ENTER_PRIVATE("void");
 
@@ -3948,20 +3980,19 @@ sh_css_update_uds_and_crop_info(
 	assert(uds);
 	assert(sp_out_crop_pos);
 
-	uds->curr_dx   = enable_zoom ? (uint16_t)zoom->dx : HRT_GDC_N;
-	uds->curr_dy   = enable_zoom ? (uint16_t)zoom->dy : HRT_GDC_N;
+	uds->curr_dx = enable_zoom ? (uint16_t)zoom->dx : HRT_GDC_N;
+	uds->curr_dy = enable_zoom ? (uint16_t)zoom->dy : HRT_GDC_N;
 
 	if (info->enable.dvs_envelope) {
-		unsigned int crop_x = 0,
-			     crop_y = 0,
-			     uds_xc = 0,
-			     uds_yc = 0,
+		unsigned int crop_x = 0, crop_y = 0, uds_xc = 0, uds_yc = 0,
 			     env_width, env_height;
 		int half_env_x, half_env_y;
 		int motion_x = motion_vector->x;
 		int motion_y = motion_vector->y;
-		bool upscale_x = in_frame_info->res.width < out_frame_info->res.width;
-		bool upscale_y = in_frame_info->res.height < out_frame_info->res.height;
+		bool upscale_x = in_frame_info->res.width <
+				 out_frame_info->res.width;
+		bool upscale_y = in_frame_info->res.height <
+				 out_frame_info->res.height;
 
 		if (info->enable.uds && !info->enable.ds) {
 			/**
@@ -3969,10 +4000,8 @@ sh_css_update_uds_and_crop_info(
 			 * use, the min dvs envelope is for the filter
 			 * initialization.
 			 */
-			env_width  = dvs_env->width -
-				     SH_CSS_MIN_DVS_ENVELOPE;
-			env_height = dvs_env->height -
-				     SH_CSS_MIN_DVS_ENVELOPE;
+			env_width = dvs_env->width - SH_CSS_MIN_DVS_ENVELOPE;
+			env_height = dvs_env->height - SH_CSS_MIN_DVS_ENVELOPE;
 			half_env_x = env_width / 2;
 			half_env_y = env_height / 2;
 			/**
@@ -3981,22 +4010,25 @@ sh_css_update_uds_and_crop_info(
 			 * 8 topmost rows.
 			 */
 			if (upscale_x) {
-				uds_xc = (in_frame_info->res.width
-					  + env_width
-					  + SH_CSS_MIN_DVS_ENVELOPE) / 2;
+				uds_xc = (in_frame_info->res.width + env_width +
+					  SH_CSS_MIN_DVS_ENVELOPE) /
+					 2;
 			} else {
-				uds_xc = (out_frame_info->res.width
-					  + env_width) / 2
-					 + SH_CSS_MIN_DVS_ENVELOPE;
+				uds_xc = (out_frame_info->res.width +
+					  env_width) /
+						 2 +
+					 SH_CSS_MIN_DVS_ENVELOPE;
 			}
 			if (upscale_y) {
-				uds_yc = (in_frame_info->res.height
-					  + env_height
-					  + SH_CSS_MIN_DVS_ENVELOPE) / 2;
+				uds_yc =
+					(in_frame_info->res.height +
+					 env_height + SH_CSS_MIN_DVS_ENVELOPE) /
+					2;
 			} else {
-				uds_yc = (out_frame_info->res.height
-					  + env_height) / 2
-					 + SH_CSS_MIN_DVS_ENVELOPE;
+				uds_yc = (out_frame_info->res.height +
+					  env_height) /
+						 2 +
+					 SH_CSS_MIN_DVS_ENVELOPE;
 			}
 			/* clip the motion vector to +/- half the envelope */
 			motion_x = clamp(motion_x, -half_env_x, half_env_x);
@@ -4006,7 +4038,7 @@ sh_css_update_uds_and_crop_info(
 			/* uds can be pipelined, remove top lines */
 			crop_y = 2;
 		} else if (info->enable.ds) {
-			env_width  = dvs_env->width;
+			env_width = dvs_env->width;
 			env_height = dvs_env->height;
 			half_env_x = env_width / 2;
 			half_env_y = env_height / 2;
@@ -4027,18 +4059,16 @@ sh_css_update_uds_and_crop_info(
 		} else {
 			/* video nodz: here we can only crop. We make sure we
 			   crop at least the first 8x8 pixels away. */
-			env_width  = dvs_env->width -
-				     SH_CSS_MIN_DVS_ENVELOPE;
-			env_height = dvs_env->height -
-				     SH_CSS_MIN_DVS_ENVELOPE;
+			env_width = dvs_env->width - SH_CSS_MIN_DVS_ENVELOPE;
+			env_height = dvs_env->height - SH_CSS_MIN_DVS_ENVELOPE;
 			half_env_x = env_width / 2;
 			half_env_y = env_height / 2;
 			motion_x = clamp(motion_x, -half_env_x, half_env_x);
 			motion_y = clamp(motion_y, -half_env_y, half_env_y);
-			crop_x = SH_CSS_MIN_DVS_ENVELOPE
-				 + half_env_x + motion_x;
-			crop_y = SH_CSS_MIN_DVS_ENVELOPE
-				 + half_env_y + motion_y;
+			crop_x =
+				SH_CSS_MIN_DVS_ENVELOPE + half_env_x + motion_x;
+			crop_y =
+				SH_CSS_MIN_DVS_ENVELOPE + half_env_y + motion_y;
 		}
 
 		/* Must enforce that the crop position is even */
@@ -4061,18 +4091,16 @@ sh_css_update_uds_and_crop_info(
 	IA_CSS_LEAVE_PRIVATE("void");
 }
 
-static int
-sh_css_update_uds_and_crop_info_based_on_zoom_region(
-    const struct ia_css_binary_info *info,
-    const struct ia_css_frame_info *in_frame_info,
-    const struct ia_css_frame_info *out_frame_info,
-    const struct ia_css_resolution *dvs_env,
-    const struct ia_css_dz_config *zoom,
-    const struct ia_css_vector *motion_vector,
-    struct sh_css_uds_info *uds,		/* out */
-    struct sh_css_crop_pos *sp_out_crop_pos,	/* out */
-    struct ia_css_resolution pipe_in_res,
-    bool enable_zoom)
+static int sh_css_update_uds_and_crop_info_based_on_zoom_region(
+	const struct ia_css_binary_info *info,
+	const struct ia_css_frame_info *in_frame_info,
+	const struct ia_css_frame_info *out_frame_info,
+	const struct ia_css_resolution *dvs_env,
+	const struct ia_css_dz_config *zoom,
+	const struct ia_css_vector *motion_vector,
+	struct sh_css_uds_info *uds, /* out */
+	struct sh_css_crop_pos *sp_out_crop_pos, /* out */
+	struct ia_css_resolution pipe_in_res, bool enable_zoom)
 {
 	unsigned int x0 = 0, y0 = 0, x1 = 0, y1 = 0;
 	int err = 0;
@@ -4101,7 +4129,8 @@ sh_css_update_uds_and_crop_info_based_on_zoom_region(
 	x1 = zoom->zoom_region.resolution.width + x0;
 	y1 = zoom->zoom_region.resolution.height + y0;
 
-	if ((x0 > x1) || (y0 > y1) || (x1 > pipe_in_res.width) || (y1 > pipe_in_res.height))
+	if ((x0 > x1) || (y0 > y1) || (x1 > pipe_in_res.width) ||
+	    (y1 > pipe_in_res.height))
 		return -EINVAL;
 
 	if (!enable_zoom) {
@@ -4121,15 +4150,21 @@ sh_css_update_uds_and_crop_info_based_on_zoom_region(
 			*/
 			if (in_frame_info->res.width != pipe_in_res.width ||
 			    in_frame_info->res.height != pipe_in_res.height) {
-				x0 = (x0 * in_frame_info->res.width) / (pipe_in_res.width);
-				y0 = (y0 * in_frame_info->res.height) / (pipe_in_res.height);
-				x1 = (x1 * in_frame_info->res.width) / (pipe_in_res.width);
-				y1 = (y1 * in_frame_info->res.height) / (pipe_in_res.height);
+				x0 = (x0 * in_frame_info->res.width) /
+				     (pipe_in_res.width);
+				y0 = (y0 * in_frame_info->res.height) /
+				     (pipe_in_res.height);
+				x1 = (x1 * in_frame_info->res.width) /
+				     (pipe_in_res.width);
+				y1 = (y1 * in_frame_info->res.height) /
+				     (pipe_in_res.height);
 			}
 			uds->curr_dx =
-			    ((x1 - x0 - filter_envelope) * HRT_GDC_N) / in_frame_info->res.width;
+				((x1 - x0 - filter_envelope) * HRT_GDC_N) /
+				in_frame_info->res.width;
 			uds->curr_dy =
-			    ((y1 - y0 - filter_envelope) * HRT_GDC_N) / in_frame_info->res.height;
+				((y1 - y0 - filter_envelope) * HRT_GDC_N) /
+				in_frame_info->res.height;
 
 			/* B. Calculate xc/yc based on crop region */
 			uds->xc = (uint16_t)x0 + (((x1) - (x0)) / 2);
@@ -4142,8 +4177,9 @@ sh_css_update_uds_and_crop_info_based_on_zoom_region(
 		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
 				    "uds->curr_dx=%d, uds->xc=%d, uds->yc=%d\n",
 				    uds->curr_dx, uds->xc, uds->yc);
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "x0=%d, y0=%d, x1=%d, y1=%d\n",
-				    x0, y0, x1, y1);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				    "x0=%d, y0=%d, x1=%d, y1=%d\n", x0, y0, x1,
+				    y1);
 		sp_out_crop_pos->x = (uint16_t)info->pipeline.left_cropping;
 		sp_out_crop_pos->y = (uint16_t)info->pipeline.top_cropping;
 	}
@@ -4184,8 +4220,7 @@ ia_css_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
 	return NULL;
 }
 
-void
-ia_css_3a_statistics_free(struct ia_css_3a_statistics *me)
+void ia_css_3a_statistics_free(struct ia_css_3a_statistics *me)
 {
 	if (me) {
 		kvfree(me->rgby_data);
@@ -4207,12 +4242,14 @@ ia_css_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
 
 	me->grid = *grid;
 	me->hor_proj = kvmalloc(grid->height * IA_CSS_DVS_NUM_COEF_TYPES *
-				sizeof(*me->hor_proj), GFP_KERNEL);
+					sizeof(*me->hor_proj),
+				GFP_KERNEL);
 	if (!me->hor_proj)
 		goto err;
 
 	me->ver_proj = kvmalloc(grid->width * IA_CSS_DVS_NUM_COEF_TYPES *
-				sizeof(*me->ver_proj), GFP_KERNEL);
+					sizeof(*me->ver_proj),
+				GFP_KERNEL);
 	if (!me->ver_proj)
 		goto err;
 
@@ -4222,8 +4259,7 @@ ia_css_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
 	return NULL;
 }
 
-void
-ia_css_dvs_statistics_free(struct ia_css_dvs_statistics *me)
+void ia_css_dvs_statistics_free(struct ia_css_dvs_statistics *me)
 {
 	if (me) {
 		kvfree(me->hor_proj);
@@ -4245,15 +4281,17 @@ ia_css_dvs_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
 
 	me->grid = *grid;
 
-	me->hor_coefs = kvmalloc(grid->num_hor_coefs *
-				 IA_CSS_DVS_NUM_COEF_TYPES *
-				 sizeof(*me->hor_coefs), GFP_KERNEL);
+	me->hor_coefs =
+		kvmalloc(grid->num_hor_coefs * IA_CSS_DVS_NUM_COEF_TYPES *
+				 sizeof(*me->hor_coefs),
+			 GFP_KERNEL);
 	if (!me->hor_coefs)
 		goto err;
 
-	me->ver_coefs = kvmalloc(grid->num_ver_coefs *
-				 IA_CSS_DVS_NUM_COEF_TYPES *
-				 sizeof(*me->ver_coefs), GFP_KERNEL);
+	me->ver_coefs =
+		kvmalloc(grid->num_ver_coefs * IA_CSS_DVS_NUM_COEF_TYPES *
+				 sizeof(*me->ver_coefs),
+			 GFP_KERNEL);
 	if (!me->ver_coefs)
 		goto err;
 
@@ -4263,8 +4301,7 @@ ia_css_dvs_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
 	return NULL;
 }
 
-void
-ia_css_dvs_coefficients_free(struct ia_css_dvs_coefficients *me)
+void ia_css_dvs_coefficients_free(struct ia_css_dvs_coefficients *me)
 {
 	if (me) {
 		kvfree(me->hor_coefs);
@@ -4286,59 +4323,59 @@ ia_css_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
 
 	me->grid = *grid;
 
-	me->hor_prod.odd_real = kvmalloc(grid->aligned_width *
-					 grid->aligned_height *
-					 sizeof(*me->hor_prod.odd_real),
-					 GFP_KERNEL);
+	me->hor_prod.odd_real =
+		kvmalloc(grid->aligned_width * grid->aligned_height *
+				 sizeof(*me->hor_prod.odd_real),
+			 GFP_KERNEL);
 	if (!me->hor_prod.odd_real)
 		goto err;
 
-	me->hor_prod.odd_imag = kvmalloc(grid->aligned_width *
-					 grid->aligned_height *
-					 sizeof(*me->hor_prod.odd_imag),
-					 GFP_KERNEL);
+	me->hor_prod.odd_imag =
+		kvmalloc(grid->aligned_width * grid->aligned_height *
+				 sizeof(*me->hor_prod.odd_imag),
+			 GFP_KERNEL);
 	if (!me->hor_prod.odd_imag)
 		goto err;
 
-	me->hor_prod.even_real = kvmalloc(grid->aligned_width *
-					  grid->aligned_height *
-					  sizeof(*me->hor_prod.even_real),
-					  GFP_KERNEL);
+	me->hor_prod.even_real =
+		kvmalloc(grid->aligned_width * grid->aligned_height *
+				 sizeof(*me->hor_prod.even_real),
+			 GFP_KERNEL);
 	if (!me->hor_prod.even_real)
 		goto err;
 
-	me->hor_prod.even_imag = kvmalloc(grid->aligned_width *
-					  grid->aligned_height *
-					  sizeof(*me->hor_prod.even_imag),
-					  GFP_KERNEL);
+	me->hor_prod.even_imag =
+		kvmalloc(grid->aligned_width * grid->aligned_height *
+				 sizeof(*me->hor_prod.even_imag),
+			 GFP_KERNEL);
 	if (!me->hor_prod.even_imag)
 		goto err;
 
-	me->ver_prod.odd_real = kvmalloc(grid->aligned_width *
-					 grid->aligned_height *
-					 sizeof(*me->ver_prod.odd_real),
-					 GFP_KERNEL);
+	me->ver_prod.odd_real =
+		kvmalloc(grid->aligned_width * grid->aligned_height *
+				 sizeof(*me->ver_prod.odd_real),
+			 GFP_KERNEL);
 	if (!me->ver_prod.odd_real)
 		goto err;
 
-	me->ver_prod.odd_imag = kvmalloc(grid->aligned_width *
-					 grid->aligned_height *
-					 sizeof(*me->ver_prod.odd_imag),
-					 GFP_KERNEL);
+	me->ver_prod.odd_imag =
+		kvmalloc(grid->aligned_width * grid->aligned_height *
+				 sizeof(*me->ver_prod.odd_imag),
+			 GFP_KERNEL);
 	if (!me->ver_prod.odd_imag)
 		goto err;
 
-	me->ver_prod.even_real = kvmalloc(grid->aligned_width *
-					  grid->aligned_height *
-					  sizeof(*me->ver_prod.even_real),
-					  GFP_KERNEL);
+	me->ver_prod.even_real =
+		kvmalloc(grid->aligned_width * grid->aligned_height *
+				 sizeof(*me->ver_prod.even_real),
+			 GFP_KERNEL);
 	if (!me->ver_prod.even_real)
 		goto err;
 
-	me->ver_prod.even_imag = kvmalloc(grid->aligned_width *
-					  grid->aligned_height *
-					  sizeof(*me->ver_prod.even_imag),
-					  GFP_KERNEL);
+	me->ver_prod.even_imag =
+		kvmalloc(grid->aligned_width * grid->aligned_height *
+				 sizeof(*me->ver_prod.even_imag),
+			 GFP_KERNEL);
 	if (!me->ver_prod.even_imag)
 		goto err;
 
@@ -4348,8 +4385,7 @@ ia_css_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
 	return NULL;
 }
 
-void
-ia_css_dvs2_statistics_free(struct ia_css_dvs2_statistics *me)
+void ia_css_dvs2_statistics_free(struct ia_css_dvs2_statistics *me)
 {
 	if (me) {
 		kvfree(me->hor_prod.odd_real);
@@ -4377,51 +4413,51 @@ ia_css_dvs2_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
 
 	me->grid = *grid;
 
-	me->hor_coefs.odd_real = kvmalloc(grid->num_hor_coefs *
-					  sizeof(*me->hor_coefs.odd_real),
-					  GFP_KERNEL);
+	me->hor_coefs.odd_real =
+		kvmalloc(grid->num_hor_coefs * sizeof(*me->hor_coefs.odd_real),
+			 GFP_KERNEL);
 	if (!me->hor_coefs.odd_real)
 		goto err;
 
-	me->hor_coefs.odd_imag = kvmalloc(grid->num_hor_coefs *
-					  sizeof(*me->hor_coefs.odd_imag),
-					  GFP_KERNEL);
+	me->hor_coefs.odd_imag =
+		kvmalloc(grid->num_hor_coefs * sizeof(*me->hor_coefs.odd_imag),
+			 GFP_KERNEL);
 	if (!me->hor_coefs.odd_imag)
 		goto err;
 
-	me->hor_coefs.even_real = kvmalloc(grid->num_hor_coefs *
-					   sizeof(*me->hor_coefs.even_real),
-					   GFP_KERNEL);
+	me->hor_coefs.even_real =
+		kvmalloc(grid->num_hor_coefs * sizeof(*me->hor_coefs.even_real),
+			 GFP_KERNEL);
 	if (!me->hor_coefs.even_real)
 		goto err;
 
-	me->hor_coefs.even_imag = kvmalloc(grid->num_hor_coefs *
-					   sizeof(*me->hor_coefs.even_imag),
-					   GFP_KERNEL);
+	me->hor_coefs.even_imag =
+		kvmalloc(grid->num_hor_coefs * sizeof(*me->hor_coefs.even_imag),
+			 GFP_KERNEL);
 	if (!me->hor_coefs.even_imag)
 		goto err;
 
-	me->ver_coefs.odd_real = kvmalloc(grid->num_ver_coefs *
-					  sizeof(*me->ver_coefs.odd_real),
-					  GFP_KERNEL);
+	me->ver_coefs.odd_real =
+		kvmalloc(grid->num_ver_coefs * sizeof(*me->ver_coefs.odd_real),
+			 GFP_KERNEL);
 	if (!me->ver_coefs.odd_real)
 		goto err;
 
-	me->ver_coefs.odd_imag = kvmalloc(grid->num_ver_coefs *
-					  sizeof(*me->ver_coefs.odd_imag),
-					  GFP_KERNEL);
+	me->ver_coefs.odd_imag =
+		kvmalloc(grid->num_ver_coefs * sizeof(*me->ver_coefs.odd_imag),
+			 GFP_KERNEL);
 	if (!me->ver_coefs.odd_imag)
 		goto err;
 
-	me->ver_coefs.even_real = kvmalloc(grid->num_ver_coefs *
-					   sizeof(*me->ver_coefs.even_real),
-					   GFP_KERNEL);
+	me->ver_coefs.even_real =
+		kvmalloc(grid->num_ver_coefs * sizeof(*me->ver_coefs.even_real),
+			 GFP_KERNEL);
 	if (!me->ver_coefs.even_real)
 		goto err;
 
-	me->ver_coefs.even_imag = kvmalloc(grid->num_ver_coefs *
-					   sizeof(*me->ver_coefs.even_imag),
-					   GFP_KERNEL);
+	me->ver_coefs.even_imag =
+		kvmalloc(grid->num_ver_coefs * sizeof(*me->ver_coefs.even_imag),
+			 GFP_KERNEL);
 	if (!me->ver_coefs.even_imag)
 		goto err;
 
@@ -4431,8 +4467,7 @@ ia_css_dvs2_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
 	return NULL;
 }
 
-void
-ia_css_dvs2_coefficients_free(struct ia_css_dvs2_coefficients *me)
+void ia_css_dvs2_coefficients_free(struct ia_css_dvs2_coefficients *me)
 {
 	if (me) {
 		kvfree(me->hor_coefs.odd_real);
@@ -4464,40 +4499,38 @@ ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream)
 	if (!params || !params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO])
 		goto err;
 
-	dvs_config = kvcalloc(1, sizeof(struct ia_css_dvs_6axis_config),
-			      GFP_KERNEL);
+	dvs_config =
+		kvcalloc(1, sizeof(struct ia_css_dvs_6axis_config), GFP_KERNEL);
 	if (!dvs_config)
 		goto err;
 
 	dvs_config->width_y = width_y =
-				  params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->width_y;
+		params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->width_y;
 	dvs_config->height_y = height_y =
-				   params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->height_y;
+		params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->height_y;
 	dvs_config->width_uv = width_uv =
-				   params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->width_uv;
+		params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->width_uv;
 	dvs_config->height_uv = height_uv =
-				    params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->height_uv;
+		params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->height_uv;
 	IA_CSS_LOG("table Y: W %d H %d", width_y, height_y);
 	IA_CSS_LOG("table UV: W %d H %d", width_uv, height_uv);
-	dvs_config->xcoords_y = kvmalloc(width_y * height_y * sizeof(uint32_t),
-					 GFP_KERNEL);
+	dvs_config->xcoords_y =
+		kvmalloc(width_y * height_y * sizeof(uint32_t), GFP_KERNEL);
 	if (!dvs_config->xcoords_y)
 		goto err;
 
-	dvs_config->ycoords_y = kvmalloc(width_y * height_y * sizeof(uint32_t),
-					 GFP_KERNEL);
+	dvs_config->ycoords_y =
+		kvmalloc(width_y * height_y * sizeof(uint32_t), GFP_KERNEL);
 	if (!dvs_config->ycoords_y)
 		goto err;
 
-	dvs_config->xcoords_uv = kvmalloc(width_uv * height_uv *
-					  sizeof(uint32_t),
-					  GFP_KERNEL);
+	dvs_config->xcoords_uv =
+		kvmalloc(width_uv * height_uv * sizeof(uint32_t), GFP_KERNEL);
 	if (!dvs_config->xcoords_uv)
 		goto err;
 
-	dvs_config->ycoords_uv = kvmalloc(width_uv * height_uv *
-					  sizeof(uint32_t),
-					  GFP_KERNEL);
+	dvs_config->ycoords_uv =
+		kvmalloc(width_uv * height_uv * sizeof(uint32_t), GFP_KERNEL);
 	if (!dvs_config->ycoords_uv)
 		goto err;
 
@@ -4507,8 +4540,8 @@ ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream)
 	return NULL;
 }
 
-void
-ia_css_dvs2_6axis_config_free(struct ia_css_dvs_6axis_config *dvs_6axis_config)
+void ia_css_dvs2_6axis_config_free(
+	struct ia_css_dvs_6axis_config *dvs_6axis_config)
 {
 	if (dvs_6axis_config) {
 		kvfree(dvs_6axis_config->xcoords_y);
@@ -4519,8 +4552,7 @@ ia_css_dvs2_6axis_config_free(struct ia_css_dvs_6axis_config *dvs_6axis_config)
 	}
 }
 
-void
-ia_css_en_dz_capt_pipe(struct ia_css_stream *stream, bool enable)
+void ia_css_en_dz_capt_pipe(struct ia_css_stream *stream, bool enable)
 {
 	struct ia_css_pipe *pipe;
 	struct ia_css_pipeline *pipeline;
@@ -4538,8 +4570,9 @@ ia_css_en_dz_capt_pipe(struct ia_css_stream *stream, bool enable)
 		pipe_id = pipeline->pipe_id;
 
 		if (pipe_id == IA_CSS_PIPE_ID_CAPTURE) {
-			err = ia_css_pipeline_get_stage(pipeline, IA_CSS_BINARY_MODE_CAPTURE_PP,
-							&stage);
+			err = ia_css_pipeline_get_stage(
+				pipeline, IA_CSS_BINARY_MODE_CAPTURE_PP,
+				&stage);
 			if (!err)
 				stage->enable_zoom = enable;
 			break;
diff --git a/drivers/staging/media/atomisp/pci/sh_css_params.h b/drivers/staging/media/atomisp/pci/sh_css_params.h
index 75957dea3c387e66e1aca11fa142aadf2110712c..7ce6fec5bce4b9703858fd2ef993c9efd291c9f1 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_params.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_params.h
@@ -17,7 +17,7 @@ struct ia_css_isp_parameters;
 #include "ia_css_binary.h"
 #include "sh_css_legacy.h"
 
-#include "sh_css_defs.h"	/* SH_CSS_MAX_STAGES */
+#include "sh_css_defs.h" /* SH_CSS_MAX_STAGES */
 #include "ia_css_pipeline.h"
 #include "ia_css_isp_params.h"
 #include "uds/uds_1.0/ia_css_uds_param.h"
@@ -38,74 +38,75 @@ struct ia_css_isp_parameters {
 	/* UDS */
 	struct sh_css_sp_uds_params uds[SH_CSS_MAX_STAGES];
 	struct sh_css_isp_param_configs stream_configs;
-	struct ia_css_fpn_table     fpn_config;
-	struct ia_css_vector	    motion_config;
-	const struct ia_css_morph_table   *morph_table;
+	struct ia_css_fpn_table fpn_config;
+	struct ia_css_vector motion_config;
+	const struct ia_css_morph_table *morph_table;
 	const struct ia_css_shading_table *sc_table;
 	struct ia_css_shading_table *sc_config;
-	struct ia_css_macc_table    macc_table;
-	struct ia_css_gamma_table   gc_table;
-	struct ia_css_ctc_table     ctc_table;
-	struct ia_css_xnr_table     xnr_table;
-
-	struct ia_css_dz_config     dz_config;
-	struct ia_css_3a_config     s3a_config;
-	struct ia_css_wb_config     wb_config;
-	struct ia_css_cc_config     cc_config;
-	struct ia_css_cc_config     yuv2rgb_cc_config;
-	struct ia_css_cc_config     rgb2yuv_cc_config;
-	struct ia_css_tnr_config    tnr_config;
-	struct ia_css_ob_config     ob_config;
+	struct ia_css_macc_table macc_table;
+	struct ia_css_gamma_table gc_table;
+	struct ia_css_ctc_table ctc_table;
+	struct ia_css_xnr_table xnr_table;
+
+	struct ia_css_dz_config dz_config;
+	struct ia_css_3a_config s3a_config;
+	struct ia_css_wb_config wb_config;
+	struct ia_css_cc_config cc_config;
+	struct ia_css_cc_config yuv2rgb_cc_config;
+	struct ia_css_cc_config rgb2yuv_cc_config;
+	struct ia_css_tnr_config tnr_config;
+	struct ia_css_ob_config ob_config;
 	/*----- DPC configuration -----*/
 	/* The default DPC configuration is retained and currently set
 	 * using the stream configuration. The code generated from genparams
 	 * uses this configuration to set the DPC parameters per stage but this
 	 * will be overwritten by the per pipe configuration */
-	struct ia_css_dp_config     dp_config;
+	struct ia_css_dp_config dp_config;
 	/* ------ pipe specific DPC configuration ------ */
 	/* Please note that this implementation is a temporary solution and
 	 * should be replaced by CSS per pipe configuration when the support
 	 * is ready (HSD 1303967698)*/
-	struct ia_css_dp_config     pipe_dp_config[IA_CSS_PIPE_ID_NUM];
-	struct ia_css_nr_config     nr_config;
-	struct ia_css_ee_config     ee_config;
-	struct ia_css_de_config     de_config;
-	struct ia_css_gc_config     gc_config;
-	struct ia_css_anr_config    anr_config;
-	struct ia_css_ce_config     ce_config;
-	struct ia_css_formats_config     formats_config;
+	struct ia_css_dp_config pipe_dp_config[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_nr_config nr_config;
+	struct ia_css_ee_config ee_config;
+	struct ia_css_de_config de_config;
+	struct ia_css_gc_config gc_config;
+	struct ia_css_anr_config anr_config;
+	struct ia_css_ce_config ce_config;
+	struct ia_css_formats_config formats_config;
 	/* ---- deprecated: replaced with pipe_dvs_6axis_config---- */
-	struct ia_css_dvs_6axis_config  *dvs_6axis_config;
-	struct ia_css_ecd_config    ecd_config;
-	struct ia_css_ynr_config    ynr_config;
-	struct ia_css_yee_config    yee_config;
-	struct ia_css_fc_config     fc_config;
-	struct ia_css_cnr_config    cnr_config;
-	struct ia_css_macc_config   macc_config;
-	struct ia_css_ctc_config    ctc_config;
-	struct ia_css_aa_config     aa_config;
-	struct ia_css_aa_config     bds_config;
-	struct ia_css_aa_config     raa_config;
-	struct ia_css_rgb_gamma_table     r_gamma_table;
-	struct ia_css_rgb_gamma_table     g_gamma_table;
-	struct ia_css_rgb_gamma_table     b_gamma_table;
-	struct ia_css_anr_thres     anr_thres;
-	struct ia_css_xnr_config    xnr_config;
-	struct ia_css_xnr3_config   xnr3_config;
-	struct ia_css_uds_config    uds_config;
-	struct ia_css_crop_config   crop_config;
+	struct ia_css_dvs_6axis_config *dvs_6axis_config;
+	struct ia_css_ecd_config ecd_config;
+	struct ia_css_ynr_config ynr_config;
+	struct ia_css_yee_config yee_config;
+	struct ia_css_fc_config fc_config;
+	struct ia_css_cnr_config cnr_config;
+	struct ia_css_macc_config macc_config;
+	struct ia_css_ctc_config ctc_config;
+	struct ia_css_aa_config aa_config;
+	struct ia_css_aa_config bds_config;
+	struct ia_css_aa_config raa_config;
+	struct ia_css_rgb_gamma_table r_gamma_table;
+	struct ia_css_rgb_gamma_table g_gamma_table;
+	struct ia_css_rgb_gamma_table b_gamma_table;
+	struct ia_css_anr_thres anr_thres;
+	struct ia_css_xnr_config xnr_config;
+	struct ia_css_xnr3_config xnr3_config;
+	struct ia_css_uds_config uds_config;
+	struct ia_css_crop_config crop_config;
 	struct ia_css_output_config output_config;
-	struct ia_css_dvs_6axis_config  *pipe_dvs_6axis_config[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_dvs_6axis_config
+		*pipe_dvs_6axis_config[IA_CSS_PIPE_ID_NUM];
 	/* ------ deprecated(bz675) : from ------ */
 	struct ia_css_shading_settings shading_settings;
 	/* ------ deprecated(bz675) : to ------ */
-	struct ia_css_dvs_coefficients  dvs_coefs;
+	struct ia_css_dvs_coefficients dvs_coefs;
 	struct ia_css_dvs2_coefficients dvs2_coefs;
 
 	bool isp_params_changed;
 
-	bool isp_mem_params_changed
-	[IA_CSS_PIPE_ID_NUM][SH_CSS_MAX_STAGES][IA_CSS_NUM_MEMORIES];
+	bool isp_mem_params_changed[IA_CSS_PIPE_ID_NUM][SH_CSS_MAX_STAGES]
+				   [IA_CSS_NUM_MEMORIES];
 	bool dz_config_changed;
 	bool motion_config_changed;
 	bool dis_coef_table_changed;
@@ -130,43 +131,34 @@ struct ia_css_isp_parameters {
 	unsigned int sensor_binning;
 	/* local buffers, used to re-order the 3a statistics in vmem-format */
 	struct sh_css_ddr_address_map pipe_ddr_ptrs[IA_CSS_PIPE_ID_NUM];
-	struct sh_css_ddr_address_map_size pipe_ddr_ptrs_size[IA_CSS_PIPE_ID_NUM];
+	struct sh_css_ddr_address_map_size
+		pipe_ddr_ptrs_size[IA_CSS_PIPE_ID_NUM];
 	struct sh_css_ddr_address_map ddr_ptrs;
 	struct sh_css_ddr_address_map_size ddr_ptrs_size;
-	struct ia_css_frame
-		*output_frame; /** Output frame the config is to be applied to (optional) */
+	struct ia_css_frame *
+		output_frame; /** Output frame the config is to be applied to (optional) */
 	u32 isp_parameters_id; /** Unique ID to track which config was actually applied to a particular frame */
 };
 
-void
-ia_css_params_store_ia_css_host_data(
-    ia_css_ptr ddr_addr,
-    struct ia_css_host_data *data);
+void ia_css_params_store_ia_css_host_data(ia_css_ptr ddr_addr,
+					  struct ia_css_host_data *data);
 
-int
-ia_css_params_store_sctbl(
-    const struct ia_css_pipeline_stage *stage,
-    ia_css_ptr ddr_addr,
-    const struct ia_css_shading_table *shading_table);
+int ia_css_params_store_sctbl(const struct ia_css_pipeline_stage *stage,
+			      ia_css_ptr ddr_addr,
+			      const struct ia_css_shading_table *shading_table);
 
-struct ia_css_host_data *
-ia_css_params_alloc_convert_sctbl(
-    const struct ia_css_pipeline_stage *stage,
-    const struct ia_css_shading_table *shading_table);
+struct ia_css_host_data *ia_css_params_alloc_convert_sctbl(
+	const struct ia_css_pipeline_stage *stage,
+	const struct ia_css_shading_table *shading_table);
 
-struct ia_css_isp_config *
-sh_css_pipe_isp_config_get(struct ia_css_pipe *pipe);
+struct ia_css_isp_config *sh_css_pipe_isp_config_get(struct ia_css_pipe *pipe);
 
-int
-sh_css_params_map_and_store_default_gdc_lut(void);
+int sh_css_params_map_and_store_default_gdc_lut(void);
 
-void
-sh_css_params_free_default_gdc_lut(void);
+void sh_css_params_free_default_gdc_lut(void);
 
-ia_css_ptr
-sh_css_params_get_default_gdc_lut(void);
+ia_css_ptr sh_css_params_get_default_gdc_lut(void);
 
-ia_css_ptr
-sh_css_pipe_get_pp_gdc_lut(const struct ia_css_pipe *pipe);
+ia_css_ptr sh_css_pipe_get_pp_gdc_lut(const struct ia_css_pipe *pipe);
 
 #endif /* _SH_CSS_PARAMS_H_ */
diff --git a/drivers/staging/media/atomisp/pci/sh_css_params_internal.h b/drivers/staging/media/atomisp/pci/sh_css_params_internal.h
index b832e18b42e4823f68f3d4fee8d88bb0393f69e9..54d15b2816cb7d3ec4280e81f7056974b11a5279 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_params_internal.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_params_internal.h
@@ -7,7 +7,6 @@
 #ifndef _SH_CSS_PARAMS_INTERNAL_H_
 #define _SH_CSS_PARAMS_INTERNAL_H_
 
-void
-sh_css_param_clear_param_sets(void);
+void sh_css_param_clear_param_sets(void);
 
 #endif /* _SH_CSS_PARAMS_INTERNAL_H_ */
diff --git a/drivers/staging/media/atomisp/pci/sh_css_properties.c b/drivers/staging/media/atomisp/pci/sh_css_properties.c
index caeeaf9a95360963db67b5855e957290cef71c07..b1f95fa5c9a37389da83b77dc2998a0c88e90ec6 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_properties.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_properties.c
@@ -9,15 +9,15 @@
 #include "ia_css_types.h"
 #include "gdc_device.h"
 
-void
-ia_css_get_properties(struct ia_css_properties *properties)
+void ia_css_get_properties(struct ia_css_properties *properties)
 {
 	assert(properties);
 	/*
 	 * MW: We don't want to store the coordinates
 	 * full range in memory: Truncate
 	 */
-	properties->gdc_coord_one = gdc_get_unity(GDC0_ID) / HRT_GDC_COORD_SCALE;
+	properties->gdc_coord_one =
+		gdc_get_unity(GDC0_ID) / HRT_GDC_COORD_SCALE;
 
 	properties->l1_base_is_index = true;
 
diff --git a/drivers/staging/media/atomisp/pci/sh_css_sp.c b/drivers/staging/media/atomisp/pci/sh_css_sp.c
index 6da151e7a873280ca8b7ddbe5cf826690cfed154..7139f52b313fc2d6206d996869d1cc87d1da1e6e 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_sp.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_sp.c
@@ -10,7 +10,7 @@
 
 #include "input_formatter.h"
 
-#include "dma.h"	/* N_DMA_CHANNEL_ID */
+#include "dma.h" /* N_DMA_CHANNEL_ID */
 
 #include "ia_css_buffer.h"
 #include "ia_css_binary.h"
@@ -29,14 +29,13 @@
 #include "ia_css_frame_comm.h"
 #include "ia_css_isys.h"
 
-#include "gdc_device.h"				/* HRT_GDC_N */
-
-/*#include "sp.h"*/	/* host2sp_enqueue_frame_data() */
+#include "gdc_device.h" /* HRT_GDC_N */
 
+/*#include "sp.h"*/ /* host2sp_enqueue_frame_data() */
 
 #include "assert_support.h"
 
-#include "sw_event_global.h"			/* Event IDs.*/
+#include "sw_event_global.h" /* Event IDs.*/
 #include "ia_css_event.h"
 #include "mmu_device.h"
 #include "ia_css_spctrl.h"
@@ -53,10 +52,10 @@
 
 #include "isp/kernels/ipu2_io_ls/bayer_io_ls/ia_css_bayer_io.host.h"
 
-struct sh_css_sp_group		sh_css_sp_group;
-struct sh_css_sp_stage		sh_css_sp_stage;
-struct sh_css_isp_stage		sh_css_isp_stage;
-static struct sh_css_sp_output		sh_css_sp_output;
+struct sh_css_sp_group sh_css_sp_group;
+struct sh_css_sp_stage sh_css_sp_stage;
+struct sh_css_isp_stage sh_css_isp_stage;
+static struct sh_css_sp_output sh_css_sp_output;
 static struct sh_css_sp_per_frame_data per_frame_data;
 
 /* true if SP supports frame loop and host2sp_commands */
@@ -64,48 +63,43 @@ static struct sh_css_sp_per_frame_data per_frame_data;
 /* TODO: add code that sets this bool to false */
 static bool sp_running;
 
-static int
-set_output_frame_buffer(const struct ia_css_frame *frame,
-			unsigned int idx);
+static int set_output_frame_buffer(const struct ia_css_frame *frame,
+				   unsigned int idx);
 
-static void
-sh_css_copy_buffer_attr_to_spbuffer(struct ia_css_buffer_sp *dest_buf,
-				    const enum sh_css_queue_id queue_id,
-				    const ia_css_ptr xmem_addr,
-				    const enum ia_css_buffer_type buf_type);
+static void sh_css_copy_buffer_attr_to_spbuffer(
+	struct ia_css_buffer_sp *dest_buf, const enum sh_css_queue_id queue_id,
+	const ia_css_ptr xmem_addr, const enum ia_css_buffer_type buf_type);
 
 static void
 initialize_frame_buffer_attribute(struct ia_css_buffer_sp *buf_attr);
 
-static void
-initialize_stage_frames(struct ia_css_frames_sp *frames);
+static void initialize_stage_frames(struct ia_css_frames_sp *frames);
 
 /* This data is stored every frame */
-void
-store_sp_group_data(void)
+void store_sp_group_data(void)
 {
 	per_frame_data.sp_group_addr = sh_css_store_sp_group_to_ddr();
 }
 
-static void
-copy_isp_stage_to_sp_stage(void)
+static void copy_isp_stage_to_sp_stage(void)
 {
 	/* [WW07.5]type casting will cause potential issues */
-	sh_css_sp_stage.num_stripes = (uint8_t)
-				      sh_css_isp_stage.binary_info.iterator.num_stripes;
-	sh_css_sp_stage.row_stripes_height = (uint16_t)
-					     sh_css_isp_stage.binary_info.iterator.row_stripes_height;
-	sh_css_sp_stage.row_stripes_overlap_lines = (uint16_t)
-		sh_css_isp_stage.binary_info.iterator.row_stripes_overlap_lines;
-	sh_css_sp_stage.top_cropping = (uint16_t)
-				       sh_css_isp_stage.binary_info.pipeline.top_cropping;
+	sh_css_sp_stage.num_stripes =
+		(uint8_t)sh_css_isp_stage.binary_info.iterator.num_stripes;
+	sh_css_sp_stage.row_stripes_height =
+		(uint16_t)sh_css_isp_stage.binary_info.iterator
+			.row_stripes_height;
+	sh_css_sp_stage.row_stripes_overlap_lines =
+		(uint16_t)sh_css_isp_stage.binary_info.iterator
+			.row_stripes_overlap_lines;
+	sh_css_sp_stage.top_cropping =
+		(uint16_t)sh_css_isp_stage.binary_info.pipeline.top_cropping;
 	sh_css_sp_stage.enable.sdis = sh_css_isp_stage.binary_info.enable.dis;
 	sh_css_sp_stage.enable.s3a = sh_css_isp_stage.binary_info.enable.s3a;
 }
 
-void
-store_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num,
-		    unsigned int stage)
+void store_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num,
+			 unsigned int stage)
 {
 	unsigned int thread_id;
 
@@ -113,16 +107,15 @@ store_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num,
 	copy_isp_stage_to_sp_stage();
 	if (id != IA_CSS_PIPE_ID_COPY)
 		sh_css_sp_stage.isp_stage_addr =
-		    sh_css_store_isp_stage_to_ddr(pipe_num, stage);
+			sh_css_store_isp_stage_to_ddr(pipe_num, stage);
 	sh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] =
-	    sh_css_store_sp_stage_to_ddr(pipe_num, stage);
+		sh_css_store_sp_stage_to_ddr(pipe_num, stage);
 
 	/* Clear for next frame */
 	sh_css_sp_stage.program_input_circuit = false;
 }
 
-static void
-store_sp_per_frame_data(const struct ia_css_fw_info *fw)
+static void store_sp_per_frame_data(const struct ia_css_fw_info *fw)
 {
 	unsigned int HIVE_ADDR_sp_per_frame_data = 0;
 
@@ -139,16 +132,13 @@ store_sp_per_frame_data(const struct ia_css_fw_info *fw)
 		return;
 	}
 
-	sp_dmem_store(SP0_ID,
-		      (unsigned int)sp_address_of(sp_per_frame_data),
-		      &per_frame_data,
-		      sizeof(per_frame_data));
+	sp_dmem_store(SP0_ID, (unsigned int)sp_address_of(sp_per_frame_data),
+		      &per_frame_data, sizeof(per_frame_data));
 }
 
-static void
-sh_css_store_sp_per_frame_data(enum ia_css_pipe_id pipe_id,
-			       unsigned int pipe_num,
-			       const struct ia_css_fw_info *sp_fw)
+static void sh_css_store_sp_per_frame_data(enum ia_css_pipe_id pipe_id,
+					   unsigned int pipe_num,
+					   const struct ia_css_fw_info *sp_fw)
 {
 	if (!sp_fw)
 		sp_fw = &sh_css_sp_fw;
@@ -160,28 +150,28 @@ sh_css_store_sp_per_frame_data(enum ia_css_pipe_id pipe_id,
 
 #if SP_DEBUG != SP_DEBUG_NONE
 
-void
-sh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state)
+void sh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state)
 {
 	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
 	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
 	unsigned int i;
-	unsigned int offset = (unsigned int)offsetof(struct sh_css_sp_output,
-			      debug) / sizeof(int);
+	unsigned int offset =
+		(unsigned int)offsetof(struct sh_css_sp_output, debug) /
+		sizeof(int);
 
 	assert(state);
 
 	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
 	for (i = 0; i < sizeof(*state) / sizeof(int); i++)
-		((unsigned int *)state)[i] = load_sp_array_uint(sp_output, i + offset);
+		((unsigned int *)state)[i] =
+			load_sp_array_uint(sp_output, i + offset);
 }
 
 #endif
 
-void
-sh_css_sp_start_binary_copy(unsigned int pipe_num,
-			    struct ia_css_frame *out_frame,
-			    unsigned int two_ppc)
+void sh_css_sp_start_binary_copy(unsigned int pipe_num,
+				 struct ia_css_frame *out_frame,
+				 unsigned int two_ppc)
 {
 	enum ia_css_pipe_id pipe_id;
 	unsigned int thread_id;
@@ -209,16 +199,16 @@ sh_css_sp_start_binary_copy(unsigned int pipe_num,
 					    (uint8_t)SH_CSS_PORT_OUTPUT,
 					    (uint8_t)SH_CSS_HOST_TYPE, 1);
 	}
-	IA_CSS_LOG("pipe_id %d port_config %08x",
-		   pipe->pipe_id, pipe->inout_port_config);
+	IA_CSS_LOG("pipe_id %d port_config %08x", pipe->pipe_id,
+		   pipe->inout_port_config);
 
 	if (!IS_ISP2401)
-		sh_css_sp_group.config.input_formatter.isp_2ppc = (uint8_t)two_ppc;
+		sh_css_sp_group.config.input_formatter.isp_2ppc =
+			(uint8_t)two_ppc;
 
 	sh_css_sp_stage.num = stage_num;
 	sh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;
-	sh_css_sp_stage.func =
-	    (unsigned int)IA_CSS_PIPELINE_BIN_COPY;
+	sh_css_sp_stage.func = (unsigned int)IA_CSS_PIPELINE_BIN_COPY;
 
 	set_output_frame_buffer(out_frame, 0);
 
@@ -228,10 +218,8 @@ sh_css_sp_start_binary_copy(unsigned int pipe_num,
 }
 
 static void
-sh_css_sp_start_raw_copy(struct ia_css_frame *out_frame,
-			 unsigned int pipe_num,
-			 unsigned int two_ppc,
-			 unsigned int max_input_width,
+sh_css_sp_start_raw_copy(struct ia_css_frame *out_frame, unsigned int pipe_num,
+			 unsigned int two_ppc, unsigned int max_input_width,
 			 enum sh_css_pipe_config_override pipe_conf_override,
 			 unsigned int if_config_index)
 {
@@ -259,9 +247,9 @@ sh_css_sp_start_raw_copy(struct ia_css_frame *out_frame,
 	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
 	pipe = &sh_css_sp_group.pipe[thread_id];
 
-	pipe->copy.raw.height	    = out_frame->frame_info.res.height;
-	pipe->copy.raw.width	    = out_frame->frame_info.res.width;
-	pipe->copy.raw.padded_width  = out_frame->frame_info.padded_width;
+	pipe->copy.raw.height = out_frame->frame_info.res.height;
+	pipe->copy.raw.width = out_frame->frame_info.res.width;
+	pipe->copy.raw.padded_width = out_frame->frame_info.padded_width;
 	pipe->copy.raw.raw_bit_depth = out_frame->frame_info.raw_bit_depth;
 	pipe->copy.raw.max_input_width = max_input_width;
 	pipe->num_stages = 1;
@@ -270,7 +258,7 @@ sh_css_sp_start_raw_copy(struct ia_css_frame *out_frame,
 		 sampled, needs checking/improvement */
 	if (pipe_conf_override == SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD)
 		pipe->pipe_config =
-		    (SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id);
+			(SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id);
 	else
 		pipe->pipe_config = pipe_conf_override;
 
@@ -284,11 +272,12 @@ sh_css_sp_start_raw_copy(struct ia_css_frame *out_frame,
 					    (uint8_t)SH_CSS_PORT_OUTPUT,
 					    (uint8_t)SH_CSS_HOST_TYPE, 1);
 	}
-	IA_CSS_LOG("pipe_id %d port_config %08x",
-		   pipe->pipe_id, pipe->inout_port_config);
+	IA_CSS_LOG("pipe_id %d port_config %08x", pipe->pipe_id,
+		   pipe->inout_port_config);
 
 	if (!IS_ISP2401)
-		sh_css_sp_group.config.input_formatter.isp_2ppc = (uint8_t)two_ppc;
+		sh_css_sp_group.config.input_formatter.isp_2ppc =
+			(uint8_t)two_ppc;
 
 	sh_css_sp_stage.num = stage_num;
 	sh_css_sp_stage.xmem_bin_addr = 0x0;
@@ -300,10 +289,10 @@ sh_css_sp_start_raw_copy(struct ia_css_frame *out_frame,
 	ia_css_debug_pipe_graph_dump_sp_raw_copy(out_frame);
 }
 
-static void
-sh_css_sp_start_isys_copy(struct ia_css_frame *out_frame,
-			  unsigned int pipe_num, unsigned int max_input_width,
-			  unsigned int if_config_index)
+static void sh_css_sp_start_isys_copy(struct ia_css_frame *out_frame,
+				      unsigned int pipe_num,
+				      unsigned int max_input_width,
+				      unsigned int if_config_index)
 {
 	enum ia_css_pipe_id pipe_id;
 	unsigned int thread_id;
@@ -330,15 +319,15 @@ sh_css_sp_start_isys_copy(struct ia_css_frame *out_frame,
 	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
 	pipe = &sh_css_sp_group.pipe[thread_id];
 
-	pipe->copy.raw.height		= out_frame->frame_info.res.height;
-	pipe->copy.raw.width		= out_frame->frame_info.res.width;
-	pipe->copy.raw.padded_width	= out_frame->frame_info.padded_width;
-	pipe->copy.raw.raw_bit_depth	= out_frame->frame_info.raw_bit_depth;
-	pipe->copy.raw.max_input_width	= max_input_width;
-	pipe->num_stages		= 1;
-	pipe->pipe_id			= pipe_id;
-	pipe->pipe_config		= 0x0;	/* No parameters */
-	pipe->pipe_qos_config		= QOS_INVALID;
+	pipe->copy.raw.height = out_frame->frame_info.res.height;
+	pipe->copy.raw.width = out_frame->frame_info.res.width;
+	pipe->copy.raw.padded_width = out_frame->frame_info.padded_width;
+	pipe->copy.raw.raw_bit_depth = out_frame->frame_info.raw_bit_depth;
+	pipe->copy.raw.max_input_width = max_input_width;
+	pipe->num_stages = 1;
+	pipe->pipe_id = pipe_id;
+	pipe->pipe_config = 0x0; /* No parameters */
+	pipe->pipe_qos_config = QOS_INVALID;
 
 	initialize_stage_frames(&sh_css_sp_stage.frames);
 	sh_css_sp_stage.num = stage_num;
@@ -350,44 +339,41 @@ sh_css_sp_start_isys_copy(struct ia_css_frame *out_frame,
 	set_output_frame_buffer(out_frame, 0);
 
 	if (pipe->metadata.height > 0) {
-		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_METADATA, thread_id,
-					       &queue_id);
-		sh_css_copy_buffer_attr_to_spbuffer(&sh_css_sp_stage.frames.metadata_buf,
-						    queue_id, mmgr_EXCEPTION,
-						    IA_CSS_BUFFER_TYPE_METADATA);
+		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_METADATA,
+					       thread_id, &queue_id);
+		sh_css_copy_buffer_attr_to_spbuffer(
+			&sh_css_sp_stage.frames.metadata_buf, queue_id,
+			mmgr_EXCEPTION, IA_CSS_BUFFER_TYPE_METADATA);
 	}
 
 	ia_css_debug_pipe_graph_dump_sp_raw_copy(out_frame);
 }
 
-unsigned int
-sh_css_sp_get_binary_copy_size(void)
+unsigned int sh_css_sp_get_binary_copy_size(void)
 {
 	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
 	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
 	unsigned int offset = (unsigned int)offsetof(struct sh_css_sp_output,
-			      bin_copy_bytes_copied) / sizeof(int);
+						     bin_copy_bytes_copied) /
+			      sizeof(int);
 	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
 	return load_sp_array_uint(sp_output, offset);
 }
 
-unsigned int
-sh_css_sp_get_sw_interrupt_value(unsigned int irq)
+unsigned int sh_css_sp_get_sw_interrupt_value(unsigned int irq)
 {
 	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
 	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
 	unsigned int offset = (unsigned int)offsetof(struct sh_css_sp_output,
-			      sw_interrupt_value)
-			      / sizeof(int);
+						     sw_interrupt_value) /
+			      sizeof(int);
 	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
 	return load_sp_array_uint(sp_output, offset + irq);
 }
 
-static void
-sh_css_copy_buffer_attr_to_spbuffer(struct ia_css_buffer_sp *dest_buf,
-				    const enum sh_css_queue_id queue_id,
-				    const ia_css_ptr xmem_addr,
-				    const enum ia_css_buffer_type buf_type)
+static void sh_css_copy_buffer_attr_to_spbuffer(
+	struct ia_css_buffer_sp *dest_buf, const enum sh_css_queue_id queue_id,
+	const ia_css_ptr xmem_addr, const enum ia_css_buffer_type buf_type)
 {
 	assert(buf_type < IA_CSS_NUM_BUFFER_TYPE);
 	if (queue_id > SH_CSS_INVALID_QUEUE_ID) {
@@ -416,9 +402,8 @@ sh_css_copy_buffer_attr_to_spbuffer(struct ia_css_buffer_sp *dest_buf,
 	dest_buf->buf_type = buf_type;
 }
 
-static void
-sh_css_copy_frame_to_spframe(struct ia_css_frame_sp *sp_frame_out,
-			     const struct ia_css_frame *frame_in)
+static void sh_css_copy_frame_to_spframe(struct ia_css_frame_sp *sp_frame_out,
+					 const struct ia_css_frame *frame_in)
 {
 	assert(frame_in);
 
@@ -427,10 +412,10 @@ sh_css_copy_frame_to_spframe(struct ia_css_frame_sp *sp_frame_out,
 
 	sh_css_copy_buffer_attr_to_spbuffer(&sp_frame_out->buf_attr,
 					    frame_in->dynamic_queue_id,
-					    frame_in->data,
-					    frame_in->buf_type);
+					    frame_in->data, frame_in->buf_type);
 
-	ia_css_frame_info_to_frame_sp_info(&sp_frame_out->info, &frame_in->frame_info);
+	ia_css_frame_info_to_frame_sp_info(&sp_frame_out->info,
+					   &frame_in->frame_info);
 
 	switch (frame_in->frame_info.format) {
 	case IA_CSS_FRAME_FORMAT_RAW_PACKED:
@@ -443,11 +428,11 @@ sh_css_copy_frame_to_spframe(struct ia_css_frame_sp *sp_frame_out,
 		break;
 	case IA_CSS_FRAME_FORMAT_PLANAR_RGB888:
 		sp_frame_out->planes.planar_rgb.r.offset =
-		    frame_in->planes.planar_rgb.r.offset;
+			frame_in->planes.planar_rgb.r.offset;
 		sp_frame_out->planes.planar_rgb.g.offset =
-		    frame_in->planes.planar_rgb.g.offset;
+			frame_in->planes.planar_rgb.g.offset;
 		sp_frame_out->planes.planar_rgb.b.offset =
-		    frame_in->planes.planar_rgb.b.offset;
+			frame_in->planes.planar_rgb.b.offset;
 		break;
 	case IA_CSS_FRAME_FORMAT_YUYV:
 	case IA_CSS_FRAME_FORMAT_UYVY:
@@ -463,10 +448,9 @@ sh_css_copy_frame_to_spframe(struct ia_css_frame_sp *sp_frame_out,
 	case IA_CSS_FRAME_FORMAT_NV21:
 	case IA_CSS_FRAME_FORMAT_NV16:
 	case IA_CSS_FRAME_FORMAT_NV61:
-		sp_frame_out->planes.nv.y.offset =
-		    frame_in->planes.nv.y.offset;
+		sp_frame_out->planes.nv.y.offset = frame_in->planes.nv.y.offset;
 		sp_frame_out->planes.nv.uv.offset =
-		    frame_in->planes.nv.uv.offset;
+			frame_in->planes.nv.uv.offset;
 		break;
 	case IA_CSS_FRAME_FORMAT_YUV420:
 	case IA_CSS_FRAME_FORMAT_YUV422:
@@ -476,29 +460,29 @@ sh_css_copy_frame_to_spframe(struct ia_css_frame_sp *sp_frame_out,
 	case IA_CSS_FRAME_FORMAT_YV12:
 	case IA_CSS_FRAME_FORMAT_YV16:
 		sp_frame_out->planes.yuv.y.offset =
-		    frame_in->planes.yuv.y.offset;
+			frame_in->planes.yuv.y.offset;
 		sp_frame_out->planes.yuv.u.offset =
-		    frame_in->planes.yuv.u.offset;
+			frame_in->planes.yuv.u.offset;
 		sp_frame_out->planes.yuv.v.offset =
-		    frame_in->planes.yuv.v.offset;
+			frame_in->planes.yuv.v.offset;
 		break;
 	case IA_CSS_FRAME_FORMAT_QPLANE6:
 		sp_frame_out->planes.plane6.r.offset =
-		    frame_in->planes.plane6.r.offset;
+			frame_in->planes.plane6.r.offset;
 		sp_frame_out->planes.plane6.r_at_b.offset =
-		    frame_in->planes.plane6.r_at_b.offset;
+			frame_in->planes.plane6.r_at_b.offset;
 		sp_frame_out->planes.plane6.gr.offset =
-		    frame_in->planes.plane6.gr.offset;
+			frame_in->planes.plane6.gr.offset;
 		sp_frame_out->planes.plane6.gb.offset =
-		    frame_in->planes.plane6.gb.offset;
+			frame_in->planes.plane6.gb.offset;
 		sp_frame_out->planes.plane6.b.offset =
-		    frame_in->planes.plane6.b.offset;
+			frame_in->planes.plane6.b.offset;
 		sp_frame_out->planes.plane6.b_at_r.offset =
-		    frame_in->planes.plane6.b_at_r.offset;
+			frame_in->planes.plane6.b_at_r.offset;
 		break;
 	case IA_CSS_FRAME_FORMAT_BINARY_8:
 		sp_frame_out->planes.binary.data.offset =
-		    frame_in->planes.binary.data.offset;
+			frame_in->planes.binary.data.offset;
 		break;
 	default:
 		/*
@@ -510,8 +494,7 @@ sh_css_copy_frame_to_spframe(struct ia_css_frame_sp *sp_frame_out,
 	}
 }
 
-static int
-set_input_frame_buffer(const struct ia_css_frame *frame)
+static int set_input_frame_buffer(const struct ia_css_frame *frame)
 {
 	if (!frame)
 		return -EINVAL;
@@ -540,9 +523,8 @@ set_input_frame_buffer(const struct ia_css_frame *frame)
 	return 0;
 }
 
-static int
-set_output_frame_buffer(const struct ia_css_frame *frame,
-			unsigned int idx)
+static int set_output_frame_buffer(const struct ia_css_frame *frame,
+				   unsigned int idx)
 {
 	if (!frame)
 		return -EINVAL;
@@ -582,8 +564,7 @@ set_output_frame_buffer(const struct ia_css_frame *frame,
 	return 0;
 }
 
-static int
-set_view_finder_buffer(const struct ia_css_frame *frame)
+static int set_view_finder_buffer(const struct ia_css_frame *frame)
 {
 	if (!frame)
 		return -EINVAL;
@@ -612,35 +593,31 @@ set_view_finder_buffer(const struct ia_css_frame *frame)
 	return 0;
 }
 
-void sh_css_sp_set_if_configs(
-    const input_formatter_cfg_t	*config_a,
-    const input_formatter_cfg_t	*config_b,
-    const uint8_t		if_config_index
-)
+void sh_css_sp_set_if_configs(const input_formatter_cfg_t *config_a,
+			      const input_formatter_cfg_t *config_b,
+			      const uint8_t if_config_index)
 {
 	assert(if_config_index < SH_CSS_MAX_IF_CONFIGS);
 	assert(config_a);
 
 	sh_css_sp_group.config.input_formatter.set[if_config_index].config_a =
-	    *config_a;
+		*config_a;
 	sh_css_sp_group.config.input_formatter.a_changed = true;
 
 	if (config_b) {
-		sh_css_sp_group.config.input_formatter.set[if_config_index].config_b =
-		    *config_b;
+		sh_css_sp_group.config.input_formatter.set[if_config_index]
+			.config_b = *config_b;
 		sh_css_sp_group.config.input_formatter.b_changed = true;
 	}
 }
 
-void
-sh_css_sp_program_input_circuit(int fmt_type,
-				int ch_id,
-				enum ia_css_input_mode input_mode)
+void sh_css_sp_program_input_circuit(int fmt_type, int ch_id,
+				     enum ia_css_input_mode input_mode)
 {
 	sh_css_sp_group.config.input_circuit.no_side_band = false;
-	sh_css_sp_group.config.input_circuit.fmt_type     = fmt_type;
-	sh_css_sp_group.config.input_circuit.ch_id	      = ch_id;
-	sh_css_sp_group.config.input_circuit.input_mode   = input_mode;
+	sh_css_sp_group.config.input_circuit.fmt_type = fmt_type;
+	sh_css_sp_group.config.input_circuit.ch_id = ch_id;
+	sh_css_sp_group.config.input_circuit.input_mode = input_mode;
 	/*
 	 * The SP group is only loaded at SP boot time and is read once
 	 * change flags as "input_circuit_cfg_changed" must be reset on the SP
@@ -649,44 +626,37 @@ sh_css_sp_program_input_circuit(int fmt_type,
 	sh_css_sp_stage.program_input_circuit = true;
 }
 
-void
-sh_css_sp_configure_sync_gen(int width, int height,
-			     int hblank_cycles,
-			     int vblank_cycles)
+void sh_css_sp_configure_sync_gen(int width, int height, int hblank_cycles,
+				  int vblank_cycles)
 {
-	sh_css_sp_group.config.sync_gen.width	       = width;
-	sh_css_sp_group.config.sync_gen.height	       = height;
+	sh_css_sp_group.config.sync_gen.width = width;
+	sh_css_sp_group.config.sync_gen.height = height;
 	sh_css_sp_group.config.sync_gen.hblank_cycles = hblank_cycles;
 	sh_css_sp_group.config.sync_gen.vblank_cycles = vblank_cycles;
 }
 
-void
-sh_css_sp_configure_prbs(int seed)
+void sh_css_sp_configure_prbs(int seed)
 {
 	sh_css_sp_group.config.prbs.seed = seed;
 }
 
-void
-sh_css_sp_configure_enable_raw_pool_locking(bool lock_all)
+void sh_css_sp_configure_enable_raw_pool_locking(bool lock_all)
 {
 	sh_css_sp_group.config.enable_raw_pool_locking = true;
 	sh_css_sp_group.config.lock_all = lock_all;
 }
 
-void
-sh_css_sp_enable_isys_event_queue(bool enable)
+void sh_css_sp_enable_isys_event_queue(bool enable)
 {
 	sh_css_sp_group.config.enable_isys_event_queue = enable;
 }
 
-void
-sh_css_sp_set_disable_continuous_viewfinder(bool flag)
+void sh_css_sp_set_disable_continuous_viewfinder(bool flag)
 {
 	sh_css_sp_group.config.disable_cont_vf = flag;
 }
 
-static int
-sh_css_sp_write_frame_pointers(const struct sh_css_binary_args *args)
+static int sh_css_sp_write_frame_pointers(const struct sh_css_binary_args *args)
 {
 	int err = 0;
 	int i;
@@ -709,11 +679,9 @@ sh_css_sp_write_frame_pointers(const struct sh_css_binary_args *args)
 	return err;
 }
 
-static void
-sh_css_sp_init_group(bool two_ppc,
-		     enum atomisp_input_format input_format,
-		     bool no_isp_sync,
-		     uint8_t if_config_index)
+static void sh_css_sp_init_group(bool two_ppc,
+				 enum atomisp_input_format input_format,
+				 bool no_isp_sync, uint8_t if_config_index)
 {
 	if (!IS_ISP2401)
 		sh_css_sp_group.config.input_formatter.isp_2ppc = two_ppc;
@@ -725,85 +693,88 @@ sh_css_sp_init_group(bool two_ppc,
 
 	if (!IS_ISP2401) {
 		assert(if_config_index < SH_CSS_MAX_IF_CONFIGS);
-		sh_css_sp_group.config.input_formatter.set[if_config_index].stream_format =
-		    input_format;
+		sh_css_sp_group.config.input_formatter.set[if_config_index]
+			.stream_format = input_format;
 	}
 }
 
-void
-sh_css_stage_write_binary_info(struct ia_css_binary_info *info)
+void sh_css_stage_write_binary_info(struct ia_css_binary_info *info)
 {
 	assert(info);
 	sh_css_isp_stage.binary_info = *info;
 }
 
-static int
-copy_isp_mem_if_to_ddr(struct ia_css_binary *binary)
+static int copy_isp_mem_if_to_ddr(struct ia_css_binary *binary)
 {
 	int err;
 
 	err = ia_css_isp_param_copy_isp_mem_if_to_ddr(
-	    &binary->css_params,
-	    &binary->mem_params,
-	    IA_CSS_PARAM_CLASS_CONFIG);
+		&binary->css_params, &binary->mem_params,
+		IA_CSS_PARAM_CLASS_CONFIG);
 	if (err)
 		return err;
-	err = ia_css_isp_param_copy_isp_mem_if_to_ddr(
-	    &binary->css_params,
-	    &binary->mem_params,
-	    IA_CSS_PARAM_CLASS_STATE);
+	err = ia_css_isp_param_copy_isp_mem_if_to_ddr(&binary->css_params,
+						      &binary->mem_params,
+						      IA_CSS_PARAM_CLASS_STATE);
 	if (err)
 		return err;
 	return 0;
 }
 
-static bool
-is_sp_stage(struct ia_css_pipeline_stage *stage)
+static bool is_sp_stage(struct ia_css_pipeline_stage *stage)
 {
 	assert(stage);
 	return stage->sp_func != IA_CSS_PIPELINE_NO_FUNC;
 }
 
 static int configure_isp_from_args(const struct sh_css_sp_pipeline *pipeline,
-				   const struct ia_css_binary      *binary,
+				   const struct ia_css_binary *binary,
 				   const struct sh_css_binary_args *args,
-				   bool				   two_ppc,
-				   bool				   deinterleaved)
+				   bool two_ppc, bool deinterleaved)
 {
 	int ret;
 
-	ret = ia_css_fpn_configure(binary,  &binary->in_frame_info);
+	ret = ia_css_fpn_configure(binary, &binary->in_frame_info);
 	if (ret)
 		return ret;
-	ret = ia_css_crop_configure(binary, ia_css_frame_get_info(args->delay_frames[0]));
+	ret = ia_css_crop_configure(
+		binary, ia_css_frame_get_info(args->delay_frames[0]));
 	if (ret)
 		return ret;
 	ret = ia_css_qplane_configure(pipeline, binary, &binary->in_frame_info);
 	if (ret)
 		return ret;
-	ret = ia_css_output0_configure(binary, ia_css_frame_get_info(args->out_frame[0]));
+	ret = ia_css_output0_configure(
+		binary, ia_css_frame_get_info(args->out_frame[0]));
 	if (ret)
 		return ret;
-	ret = ia_css_output1_configure(binary, ia_css_frame_get_info(args->out_vf_frame));
+	ret = ia_css_output1_configure(
+		binary, ia_css_frame_get_info(args->out_vf_frame));
 	if (ret)
 		return ret;
 	ret = ia_css_copy_output_configure(binary, args->copy_output);
 	if (ret)
 		return ret;
-	ret = ia_css_output0_configure(binary, ia_css_frame_get_info(args->out_frame[0]));
+	ret = ia_css_output0_configure(
+		binary, ia_css_frame_get_info(args->out_frame[0]));
 	if (ret)
 		return ret;
-	ret = ia_css_iterator_configure(binary, ia_css_frame_get_info(args->in_frame));
+	ret = ia_css_iterator_configure(binary,
+					ia_css_frame_get_info(args->in_frame));
 	if (ret)
 		return ret;
-	ret = ia_css_dvs_configure(binary, ia_css_frame_get_info(args->out_frame[0]));
+	ret = ia_css_dvs_configure(binary,
+				   ia_css_frame_get_info(args->out_frame[0]));
 	if (ret)
 		return ret;
-	ret = ia_css_output_configure(binary, ia_css_frame_get_info(args->out_frame[0]));
+	ret = ia_css_output_configure(
+		binary, ia_css_frame_get_info(args->out_frame[0]));
 	if (ret)
 		return ret;
-	ret = ia_css_raw_configure(pipeline, binary, ia_css_frame_get_info(args->in_frame),
-				   &binary->in_frame_info, two_ppc, deinterleaved);
+	ret = ia_css_raw_configure(pipeline, binary,
+				   ia_css_frame_get_info(args->in_frame),
+				   &binary->in_frame_info, two_ppc,
+				   deinterleaved);
 	if (ret)
 		return ret;
 
@@ -817,7 +788,8 @@ static int configure_isp_from_args(const struct sh_css_sp_pipeline *pipeline,
 	 * without crashing, but the pipeline should likely be built without
 	 * adding it at the first place (or there are a hidden bug somewhere)
 	 */
-	ret = ia_css_ref_configure(binary, args->delay_frames, pipeline->dvs_frame_delay);
+	ret = ia_css_ref_configure(binary, args->delay_frames,
+				   pipeline->dvs_frame_delay);
 	if (ret)
 		return ret;
 	ret = ia_css_tnr_configure(binary, args->tnr_frames);
@@ -826,8 +798,7 @@ static int configure_isp_from_args(const struct sh_css_sp_pipeline *pipeline,
 	return ia_css_bayer_io_config(binary, args);
 }
 
-static void
-initialize_isp_states(const struct ia_css_binary *binary)
+static void initialize_isp_states(const struct ia_css_binary *binary)
 {
 	unsigned int i;
 
@@ -838,15 +809,13 @@ initialize_isp_states(const struct ia_css_binary *binary)
 		ia_css_kernel_init_state[i](binary);
 }
 
-static void
-initialize_frame_buffer_attribute(struct ia_css_buffer_sp *buf_attr)
+static void initialize_frame_buffer_attribute(struct ia_css_buffer_sp *buf_attr)
 {
 	buf_attr->buf_src.queue_id = SH_CSS_INVALID_QUEUE_ID;
 	buf_attr->buf_type = IA_CSS_BUFFER_TYPE_INVALID;
 }
 
-static void
-initialize_stage_frames(struct ia_css_frames_sp *frames)
+static void initialize_stage_frames(struct ia_css_frames_sp *frames)
 {
 	unsigned int i;
 
@@ -861,19 +830,15 @@ initialize_stage_frames(struct ia_css_frames_sp *frames)
 }
 
 static int
-sh_css_sp_init_stage(struct ia_css_binary *binary,
-		     const char *binary_name,
+sh_css_sp_init_stage(struct ia_css_binary *binary, const char *binary_name,
 		     const struct ia_css_blob_info *blob_info,
 		     const struct sh_css_binary_args *args,
-		     unsigned int pipe_num,
-		     unsigned int stage,
-		     bool xnr,
+		     unsigned int pipe_num, unsigned int stage, bool xnr,
 		     const struct ia_css_isp_param_css_segments *isp_mem_if,
-		     unsigned int if_config_index,
-		     bool two_ppc)
+		     unsigned int if_config_index, bool two_ppc)
 {
 	const struct ia_css_binary_xinfo *xinfo;
-	const struct ia_css_binary_info  *info;
+	const struct ia_css_binary_info *info;
 	int err = 0;
 	int i;
 	struct ia_css_pipe *pipe = NULL;
@@ -887,7 +852,7 @@ sh_css_sp_init_stage(struct ia_css_binary *binary,
 	assert(isp_mem_if);
 
 	xinfo = binary->info;
-	info  = &xinfo->sp;
+	info = &xinfo->sp;
 	{
 		/*
 		 * Clear sh_css_sp_stage for easy debugging.
@@ -898,13 +863,15 @@ sh_css_sp_init_stage(struct ia_css_binary *binary,
 
 		program_input_circuit = sh_css_sp_stage.program_input_circuit;
 		memset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));
-		sh_css_sp_stage.program_input_circuit = (uint8_t)program_input_circuit;
+		sh_css_sp_stage.program_input_circuit =
+			(uint8_t)program_input_circuit;
 	}
 
 	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
 
 	if (!info) {
-		sh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] = mmgr_NULL;
+		sh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] =
+			mmgr_NULL;
 		return 0;
 	}
 
@@ -919,9 +886,9 @@ sh_css_sp_init_stage(struct ia_css_binary *binary,
 	 * the stage type.
 	 */
 	sh_css_sp_stage.stage_type = SH_CSS_ISP_STAGE_TYPE;
-	sh_css_sp_stage.num		= (uint8_t)stage;
-	sh_css_sp_stage.isp_online	= (uint8_t)binary->online;
-	sh_css_sp_stage.isp_copy_vf     = (uint8_t)args->copy_vf;
+	sh_css_sp_stage.num = (uint8_t)stage;
+	sh_css_sp_stage.isp_online = (uint8_t)binary->online;
+	sh_css_sp_stage.isp_copy_vf = (uint8_t)args->copy_vf;
 	sh_css_sp_stage.isp_copy_output = (uint8_t)args->copy_output;
 	sh_css_sp_stage.enable.vf_output = (args->out_vf_frame != NULL);
 
@@ -929,22 +896,28 @@ sh_css_sp_init_stage(struct ia_css_binary *binary,
 	 * Copy the frame infos first, to be overwritten by the frames,
 	 * if these are present.
 	 */
-	sh_css_sp_stage.frames.effective_in_res.width = binary->effective_in_frame_res.width;
-	sh_css_sp_stage.frames.effective_in_res.height = binary->effective_in_frame_res.height;
+	sh_css_sp_stage.frames.effective_in_res.width =
+		binary->effective_in_frame_res.width;
+	sh_css_sp_stage.frames.effective_in_res.height =
+		binary->effective_in_frame_res.height;
 
 	ia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.in.info,
 					   &binary->in_frame_info);
 	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
-		ia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.out[i].info,
-						   &binary->out_frame_info[i]);
+		ia_css_frame_info_to_frame_sp_info(
+			&sh_css_sp_stage.frames.out[i].info,
+			&binary->out_frame_info[i]);
 	}
-	ia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.internal_frame_info,
-					   &binary->internal_frame_info);
-	sh_css_sp_stage.dvs_envelope.width    = binary->dvs_envelope.width;
-	sh_css_sp_stage.dvs_envelope.height   = binary->dvs_envelope.height;
-	sh_css_sp_stage.isp_pipe_version      = (uint8_t)info->pipeline.isp_pipe_version;
-	sh_css_sp_stage.isp_deci_log_factor   = (uint8_t)binary->deci_factor_log2;
-	sh_css_sp_stage.isp_vf_downscale_bits = (uint8_t)binary->vf_downscale_log2;
+	ia_css_frame_info_to_frame_sp_info(
+		&sh_css_sp_stage.frames.internal_frame_info,
+		&binary->internal_frame_info);
+	sh_css_sp_stage.dvs_envelope.width = binary->dvs_envelope.width;
+	sh_css_sp_stage.dvs_envelope.height = binary->dvs_envelope.height;
+	sh_css_sp_stage.isp_pipe_version =
+		(uint8_t)info->pipeline.isp_pipe_version;
+	sh_css_sp_stage.isp_deci_log_factor = (uint8_t)binary->deci_factor_log2;
+	sh_css_sp_stage.isp_vf_downscale_bits =
+		(uint8_t)binary->vf_downscale_log2;
 
 	sh_css_sp_stage.if_config_index = (uint8_t)if_config_index;
 
@@ -956,7 +929,8 @@ sh_css_sp_init_stage(struct ia_css_binary *binary,
 
 	/* Make sure binary name is smaller than allowed string size */
 	assert(strlen(binary_name) < SH_CSS_MAX_BINARY_NAME - 1);
-	strscpy(sh_css_isp_stage.binary_name, binary_name, SH_CSS_MAX_BINARY_NAME);
+	strscpy(sh_css_isp_stage.binary_name, binary_name,
+		SH_CSS_MAX_BINARY_NAME);
 	sh_css_isp_stage.mem_initializers = *isp_mem_if;
 
 	/*
@@ -969,37 +943,44 @@ sh_css_sp_init_stage(struct ia_css_binary *binary,
 	err = sh_css_sp_write_frame_pointers(args);
 	/* TODO: move it to a better place */
 	if (binary->info->sp.enable.s3a) {
-		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_3A_STATISTICS, thread_id,
-					       &queue_id);
-		sh_css_copy_buffer_attr_to_spbuffer(&sh_css_sp_stage.frames.s3a_buf, queue_id,
-						    mmgr_EXCEPTION,
-						    IA_CSS_BUFFER_TYPE_3A_STATISTICS);
+		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_3A_STATISTICS,
+					       thread_id, &queue_id);
+		sh_css_copy_buffer_attr_to_spbuffer(
+			&sh_css_sp_stage.frames.s3a_buf, queue_id,
+			mmgr_EXCEPTION, IA_CSS_BUFFER_TYPE_3A_STATISTICS);
 	}
 	if (binary->info->sp.enable.dis) {
-		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_DIS_STATISTICS, thread_id,
-					       &queue_id);
-		sh_css_copy_buffer_attr_to_spbuffer(&sh_css_sp_stage.frames.dvs_buf, queue_id,
-						    mmgr_EXCEPTION,
-						    IA_CSS_BUFFER_TYPE_DIS_STATISTICS);
+		ia_css_query_internal_queue_id(
+			IA_CSS_BUFFER_TYPE_DIS_STATISTICS, thread_id,
+			&queue_id);
+		sh_css_copy_buffer_attr_to_spbuffer(
+			&sh_css_sp_stage.frames.dvs_buf, queue_id,
+			mmgr_EXCEPTION, IA_CSS_BUFFER_TYPE_DIS_STATISTICS);
 	}
-	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_METADATA, thread_id, &queue_id);
-	sh_css_copy_buffer_attr_to_spbuffer(&sh_css_sp_stage.frames.metadata_buf, queue_id, mmgr_EXCEPTION, IA_CSS_BUFFER_TYPE_METADATA);
+	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_METADATA, thread_id,
+				       &queue_id);
+	sh_css_copy_buffer_attr_to_spbuffer(
+		&sh_css_sp_stage.frames.metadata_buf, queue_id, mmgr_EXCEPTION,
+		IA_CSS_BUFFER_TYPE_METADATA);
 	if (err)
 		return err;
 
 	if (IS_ISP2401) {
-		pipe = find_pipe_by_num(sh_css_sp_group.pipe[thread_id].pipe_num);
+		pipe = find_pipe_by_num(
+			sh_css_sp_group.pipe[thread_id].pipe_num);
 		if (!pipe)
 			return -EINVAL;
 
 		if (args->in_frame)
-			ia_css_get_crop_offsets(pipe, &args->in_frame->frame_info);
+			ia_css_get_crop_offsets(pipe,
+						&args->in_frame->frame_info);
 		else
 			ia_css_get_crop_offsets(pipe, &binary->in_frame_info);
 	}
 
-	err = configure_isp_from_args(&sh_css_sp_group.pipe[thread_id],
-				      binary, args, two_ppc, sh_css_sp_stage.deinterleaved);
+	err = configure_isp_from_args(&sh_css_sp_group.pipe[thread_id], binary,
+				      args, two_ppc,
+				      sh_css_sp_stage.deinterleaved);
 	if (err)
 		return err;
 
@@ -1017,12 +998,12 @@ sh_css_sp_init_stage(struct ia_css_binary *binary,
 		 * TODO: Remove this after preview output decimation is fixed
 		 * by configuring out&vf info fields properly.
 		 */
-		sh_css_sp_stage.frames.out[0].info.padded_width
-		<<= binary->vf_downscale_log2;
-		sh_css_sp_stage.frames.out[0].info.res.width
-		<<= binary->vf_downscale_log2;
-		sh_css_sp_stage.frames.out[0].info.res.height
-		<<= binary->vf_downscale_log2;
+		sh_css_sp_stage.frames.out[0].info.padded_width <<=
+			binary->vf_downscale_log2;
+		sh_css_sp_stage.frames.out[0].info.res.width <<=
+			binary->vf_downscale_log2;
+		sh_css_sp_stage.frames.out[0].info.res.height <<=
+			binary->vf_downscale_log2;
 	}
 	err = copy_isp_mem_if_to_ddr(binary);
 	if (err)
@@ -1031,12 +1012,9 @@ sh_css_sp_init_stage(struct ia_css_binary *binary,
 	return 0;
 }
 
-static int
-sp_init_stage(struct ia_css_pipeline_stage *stage,
-	      unsigned int pipe_num,
-	      bool xnr,
-	      unsigned int if_config_index,
-	      bool two_ppc)
+static int sp_init_stage(struct ia_css_pipeline_stage *stage,
+			 unsigned int pipe_num, bool xnr,
+			 unsigned int if_config_index, bool two_ppc)
 {
 	struct ia_css_binary *binary;
 	const struct ia_css_fw_info *firmware;
@@ -1080,27 +1058,26 @@ sp_init_stage(struct ia_css_pipeline_stage *stage,
 		info = binary->info;
 		binary_name = (const char *)(info->blob->name);
 		blob_info = &info->blob->header.blob;
-		ia_css_init_memory_interface(mem_if, &binary->mem_params, &binary->css_params);
+		ia_css_init_memory_interface(mem_if, &binary->mem_params,
+					     &binary->css_params);
 	} else if (firmware) {
-		const struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {NULL};
+		const struct ia_css_frame_info
+			*out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = { NULL };
 
 		if (args->out_frame[0])
 			out_infos[0] = &args->out_frame[0]->frame_info;
 		info = &firmware->info.isp;
-		ia_css_binary_fill_info(info, false, false,
-					ATOMISP_INPUT_FORMAT_RAW_10,
-					ia_css_frame_get_info(args->in_frame),
-					NULL,
-					out_infos,
-					ia_css_frame_get_info(args->out_vf_frame),
-					&tmp_binary,
-					NULL,
-					-1, true);
+		ia_css_binary_fill_info(
+			info, false, false, ATOMISP_INPUT_FORMAT_RAW_10,
+			ia_css_frame_get_info(args->in_frame), NULL, out_infos,
+			ia_css_frame_get_info(args->out_vf_frame), &tmp_binary,
+			NULL, -1, true);
 		binary = &tmp_binary;
 		binary->info = info;
 		binary_name = IA_CSS_EXT_ISP_PROG_NAME(firmware);
 		blob_info = &firmware->blob;
-		mem_if = (struct ia_css_isp_param_css_segments *)&firmware->mem_initializers;
+		mem_if = (struct ia_css_isp_param_css_segments *)&firmware
+				 ->mem_initializers;
 	} else {
 		/* SP stage */
 		assert(stage->sp_func != IA_CSS_PIPELINE_NO_FUNC);
@@ -1113,42 +1090,33 @@ sp_init_stage(struct ia_css_pipeline_stage *stage,
 		return -EINVAL;
 	}
 
-	err = sh_css_sp_init_stage(binary,
-				   (const char *)binary_name,
-				   blob_info,
-				   args,
-				   pipe_num,
-				   stage_num,
-				   xnr,
-				   mem_if,
-				   if_config_index,
-				   two_ppc);
+	err = sh_css_sp_init_stage(binary, (const char *)binary_name, blob_info,
+				   args, pipe_num, stage_num, xnr, mem_if,
+				   if_config_index, two_ppc);
 	return err;
 }
 
-static void
-sp_init_sp_stage(struct ia_css_pipeline_stage *stage,
-		 unsigned int pipe_num,
-		 bool two_ppc,
-		 enum sh_css_pipe_config_override copy_ovrd,
-		 unsigned int if_config_index)
+static void sp_init_sp_stage(struct ia_css_pipeline_stage *stage,
+			     unsigned int pipe_num, bool two_ppc,
+			     enum sh_css_pipe_config_override copy_ovrd,
+			     unsigned int if_config_index)
 {
 	const struct sh_css_binary_args *args = &stage->args;
 
 	assert(stage);
 	switch (stage->sp_func) {
 	case IA_CSS_PIPELINE_RAW_COPY:
-		sh_css_sp_start_raw_copy(args->out_frame[0],
-					 pipe_num, two_ppc,
-					 stage->max_input_width,
-					 copy_ovrd, if_config_index);
+		sh_css_sp_start_raw_copy(args->out_frame[0], pipe_num, two_ppc,
+					 stage->max_input_width, copy_ovrd,
+					 if_config_index);
 		break;
 	case IA_CSS_PIPELINE_BIN_COPY:
 		assert(false); /* TBI */
 		break;
 	case IA_CSS_PIPELINE_ISYS_COPY:
-		sh_css_sp_start_isys_copy(args->out_frame[0],
-					  pipe_num, stage->max_input_width, if_config_index);
+		sh_css_sp_start_isys_copy(args->out_frame[0], pipe_num,
+					  stage->max_input_width,
+					  if_config_index);
 		break;
 	case IA_CSS_PIPELINE_NO_FUNC:
 		assert(false);
@@ -1156,24 +1124,19 @@ sp_init_sp_stage(struct ia_css_pipeline_stage *stage,
 	}
 }
 
-void
-sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
-			enum ia_css_pipe_id id,
-			u8 pipe_num,
-			bool xnr,
-			bool two_ppc,
-			bool continuous,
-			bool offline,
-			unsigned int required_bds_factor,
-			enum sh_css_pipe_config_override copy_ovrd,
-			enum ia_css_input_mode input_mode,
-			const struct ia_css_metadata_config *md_config,
-			const struct ia_css_metadata_info *md_info,
-			const enum mipi_port_id port_id)
+void sh_css_sp_init_pipeline(struct ia_css_pipeline *me, enum ia_css_pipe_id id,
+			     u8 pipe_num, bool xnr, bool two_ppc,
+			     bool continuous, bool offline,
+			     unsigned int required_bds_factor,
+			     enum sh_css_pipe_config_override copy_ovrd,
+			     enum ia_css_input_mode input_mode,
+			     const struct ia_css_metadata_config *md_config,
+			     const struct ia_css_metadata_info *md_info,
+			     const enum mipi_port_id port_id)
 {
 	/* Get first stage */
-	struct ia_css_pipeline_stage *stage        = NULL;
-	struct ia_css_binary	     *first_binary = NULL;
+	struct ia_css_pipeline_stage *stage = NULL;
+	struct ia_css_binary *first_binary = NULL;
 	struct ia_css_pipe *pipe = NULL;
 	unsigned int num;
 	enum ia_css_pipe_id pipe_id = id;
@@ -1191,9 +1154,10 @@ sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
 	if (input_mode == IA_CSS_INPUT_MODE_SENSOR ||
 	    input_mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
 		assert(port_id < N_MIPI_PORT_ID);
-		if (port_id >= N_MIPI_PORT_ID) /* should not happen but KW does not know */
+		if (port_id >=
+		    N_MIPI_PORT_ID) /* should not happen but KW does not know */
 			return; /* we should be able to return an error */
-		if_config_index  = (uint8_t)(port_id - MIPI_PORT0_ID);
+		if_config_index = (uint8_t)(port_id - MIPI_PORT0_ID);
 	} else if (input_mode == IA_CSS_INPUT_MODE_MEMORY) {
 		if_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;
 	} else {
@@ -1201,7 +1165,8 @@ sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
 	}
 
 	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
-	memset(&sh_css_sp_group.pipe[thread_id], 0, sizeof(struct sh_css_sp_pipeline));
+	memset(&sh_css_sp_group.pipe[thread_id], 0,
+	       sizeof(struct sh_css_sp_pipeline));
 
 	/* Count stages */
 	for (stage = me->stages, num = 0; stage; stage = stage->next, num++) {
@@ -1230,17 +1195,19 @@ sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
 	sh_css_sp_group.pipe[thread_id].pipe_num = pipe_num;
 	sh_css_sp_group.pipe[thread_id].num_execs = me->num_execs;
 	sh_css_sp_group.pipe[thread_id].pipe_qos_config = QOS_INVALID;
-	sh_css_sp_group.pipe[thread_id].required_bds_factor = required_bds_factor;
-	sh_css_sp_group.pipe[thread_id].input_system_mode
-	= (uint32_t)input_mode;
+	sh_css_sp_group.pipe[thread_id].required_bds_factor =
+		required_bds_factor;
+	sh_css_sp_group.pipe[thread_id].input_system_mode =
+		(uint32_t)input_mode;
 	sh_css_sp_group.pipe[thread_id].port_id = port_id;
-	sh_css_sp_group.pipe[thread_id].dvs_frame_delay = (uint32_t)me->dvs_frame_delay;
+	sh_css_sp_group.pipe[thread_id].dvs_frame_delay =
+		(uint32_t)me->dvs_frame_delay;
 
 	/* TODO: next indicates from which queues parameters need to be
 		 sampled, needs checking/improvement */
 	if (ia_css_pipeline_uses_params(me)) {
 		sh_css_sp_group.pipe[thread_id].pipe_config =
-		SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id;
+			SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id;
 	}
 
 	/*
@@ -1250,59 +1217,69 @@ sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
 	if (continuous)
 		sh_css_sp_group.pipe[thread_id].pipe_config = 0;
 
-	sh_css_sp_group.pipe[thread_id].inout_port_config = me->inout_port_config;
+	sh_css_sp_group.pipe[thread_id].inout_port_config =
+		me->inout_port_config;
 
 	pipe = find_pipe_by_num(pipe_num);
 	assert(pipe);
 	if (!pipe)
 		return;
 
-	sh_css_sp_group.pipe[thread_id].scaler_pp_lut = sh_css_pipe_get_pp_gdc_lut(pipe);
+	sh_css_sp_group.pipe[thread_id].scaler_pp_lut =
+		sh_css_pipe_get_pp_gdc_lut(pipe);
 
 	if (md_info && md_info->size > 0) {
-		sh_css_sp_group.pipe[thread_id].metadata.width  = md_info->resolution.width;
-		sh_css_sp_group.pipe[thread_id].metadata.height = md_info->resolution.height;
-		sh_css_sp_group.pipe[thread_id].metadata.stride = md_info->stride;
-		sh_css_sp_group.pipe[thread_id].metadata.size   = md_info->size;
+		sh_css_sp_group.pipe[thread_id].metadata.width =
+			md_info->resolution.width;
+		sh_css_sp_group.pipe[thread_id].metadata.height =
+			md_info->resolution.height;
+		sh_css_sp_group.pipe[thread_id].metadata.stride =
+			md_info->stride;
+		sh_css_sp_group.pipe[thread_id].metadata.size = md_info->size;
 		ia_css_isys_convert_stream_format_to_mipi_format(
-		    md_config->data_type, MIPI_PREDICTOR_NONE,
-		    &sh_css_sp_group.pipe[thread_id].metadata.format);
+			md_config->data_type, MIPI_PREDICTOR_NONE,
+			&sh_css_sp_group.pipe[thread_id].metadata.format);
 	}
 
-	sh_css_sp_group.pipe[thread_id].output_frame_queue_id = (uint32_t)SH_CSS_INVALID_QUEUE_ID;
+	sh_css_sp_group.pipe[thread_id].output_frame_queue_id =
+		(uint32_t)SH_CSS_INVALID_QUEUE_ID;
 	if (pipe_id != IA_CSS_PIPE_ID_COPY) {
-		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, thread_id,
-					       (enum sh_css_queue_id *)(
-						   &sh_css_sp_group.pipe[thread_id].output_frame_queue_id));
+		ia_css_query_internal_queue_id(
+			IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, thread_id,
+			(enum sh_css_queue_id
+				 *)(&sh_css_sp_group.pipe[thread_id]
+					     .output_frame_queue_id));
 	}
 
-	IA_CSS_LOG("pipe_id %d port_config %08x",
-		   pipe_id, sh_css_sp_group.pipe[thread_id].inout_port_config);
+	IA_CSS_LOG("pipe_id %d port_config %08x", pipe_id,
+		   sh_css_sp_group.pipe[thread_id].inout_port_config);
 
 	for (stage = me->stages, num = 0; stage; stage = stage->next, num++) {
 		sh_css_sp_group.pipe[thread_id].num_stages++;
 		if (is_sp_stage(stage)) {
-			sp_init_sp_stage(stage, pipe_num, two_ppc,
-					 copy_ovrd, if_config_index);
+			sp_init_sp_stage(stage, pipe_num, two_ppc, copy_ovrd,
+					 if_config_index);
 		} else {
 			if ((stage->stage_num != 0) ||
-			    SH_CSS_PIPE_PORT_CONFIG_IS_CONTINUOUS(me->inout_port_config))
-				tmp_if_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;
+			    SH_CSS_PIPE_PORT_CONFIG_IS_CONTINUOUS(
+				    me->inout_port_config))
+				tmp_if_config_index =
+					SH_CSS_IF_CONFIG_NOT_NEEDED;
 			else
 				tmp_if_config_index = if_config_index;
-			sp_init_stage(stage, pipe_num,
-				      xnr, tmp_if_config_index, two_ppc);
+			sp_init_stage(stage, pipe_num, xnr, tmp_if_config_index,
+				      two_ppc);
 		}
 
 		store_sp_stage_data(pipe_id, pipe_num, num);
 	}
-	sh_css_sp_group.pipe[thread_id].pipe_config |= (uint32_t)
-		(me->acquire_isp_each_stage << IA_CSS_ACQUIRE_ISP_POS);
+	sh_css_sp_group.pipe[thread_id].pipe_config |=
+		(uint32_t)(me->acquire_isp_each_stage
+			   << IA_CSS_ACQUIRE_ISP_POS);
 	store_sp_group_data();
 }
 
-void
-sh_css_sp_uninit_pipeline(unsigned int pipe_num)
+void sh_css_sp_uninit_pipeline(unsigned int pipe_num)
 {
 	unsigned int thread_id;
 
@@ -1314,28 +1291,31 @@ sh_css_sp_uninit_pipeline(unsigned int pipe_num)
 bool sh_css_write_host2sp_command(enum host2sp_commands host2sp_command)
 {
 	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
-	unsigned int offset = (unsigned int)offsetof(struct host_sp_communication,
-			      host2sp_command)
-			      / sizeof(int);
+	unsigned int offset =
+		(unsigned int)offsetof(struct host_sp_communication,
+				       host2sp_command) /
+		sizeof(int);
 	enum host2sp_commands last_cmd = host2sp_cmd_error;
 	(void)HIVE_ADDR_host_sp_com; /* Suppress warnings in CRUN */
 
 	/* Previous command must be handled by SP (by design) */
 	last_cmd = load_sp_array_uint(host_sp_com, offset);
 	if (last_cmd != host2sp_cmd_ready)
-		IA_CSS_ERROR("last host command not handled by SP(%d)", last_cmd);
+		IA_CSS_ERROR("last host command not handled by SP(%d)",
+			     last_cmd);
 
 	store_sp_array_uint(host_sp_com, offset, host2sp_command);
 
 	return (last_cmd == host2sp_cmd_ready);
 }
 
-enum host2sp_commands
-sh_css_read_host2sp_command(void)
+enum host2sp_commands sh_css_read_host2sp_command(void)
 {
 	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
-	unsigned int offset = (unsigned int)offsetof(struct host_sp_communication, host2sp_command)
-	/ sizeof(int);
+	unsigned int offset =
+		(unsigned int)offsetof(struct host_sp_communication,
+				       host2sp_command) /
+		sizeof(int);
 	(void)HIVE_ADDR_host_sp_com; /* Suppress warnings in CRUN */
 	return (enum host2sp_commands)load_sp_array_uint(host_sp_com, offset);
 }
@@ -1351,8 +1331,7 @@ sh_css_read_host2sp_command(void)
  * sh_css_sp_stage. Even the special cases like accelerator and copy_frame
  * These have a pipeline of just 1 stage.
  */
-void
-sh_css_init_host2sp_frame_data(void)
+void sh_css_init_host2sp_frame_data(void)
 {
 	/* Clean table */
 	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
@@ -1370,11 +1349,9 @@ sh_css_init_host2sp_frame_data(void)
  * @brief Update the offline frame information in host_sp_communication.
  * Refer to "sh_css_sp.h" for more details.
  */
-void
-sh_css_update_host2sp_offline_frame(
-    unsigned int frame_num,
-    struct ia_css_frame *frame,
-    struct ia_css_metadata *metadata)
+void sh_css_update_host2sp_offline_frame(unsigned int frame_num,
+					 struct ia_css_frame *frame,
+					 struct ia_css_metadata *metadata)
 {
 	unsigned int HIVE_ADDR_host_sp_com;
 	unsigned int offset;
@@ -1384,27 +1361,26 @@ sh_css_update_host2sp_offline_frame(
 	/* Write new frame data into SP DMEM */
 	HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
 	offset = (unsigned int)offsetof(struct host_sp_communication,
-					host2sp_offline_frames)
-		 / sizeof(int);
+					host2sp_offline_frames) /
+		 sizeof(int);
 	offset += frame_num;
 	store_sp_array_uint(host_sp_com, offset, frame ? frame->data : 0);
 
 	/* Write metadata buffer into SP DMEM */
 	offset = (unsigned int)offsetof(struct host_sp_communication,
-					host2sp_offline_metadata)
-		 / sizeof(int);
+					host2sp_offline_metadata) /
+		 sizeof(int);
 	offset += frame_num;
-	store_sp_array_uint(host_sp_com, offset, metadata ? metadata->address : 0);
+	store_sp_array_uint(host_sp_com, offset,
+			    metadata ? metadata->address : 0);
 }
 
 /*
  * @brief Update the mipi frame information in host_sp_communication.
  * Refer to "sh_css_sp.h" for more details.
  */
-void
-sh_css_update_host2sp_mipi_frame(
-    unsigned int frame_num,
-    struct ia_css_frame *frame)
+void sh_css_update_host2sp_mipi_frame(unsigned int frame_num,
+				      struct ia_css_frame *frame)
 {
 	unsigned int HIVE_ADDR_host_sp_com;
 	unsigned int offset;
@@ -1415,22 +1391,19 @@ sh_css_update_host2sp_mipi_frame(
 	/* Write new frame data into SP DMEM */
 	HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
 	offset = (unsigned int)offsetof(struct host_sp_communication,
-					host2sp_mipi_frames)
-		 / sizeof(int);
+					host2sp_mipi_frames) /
+		 sizeof(int);
 	offset += frame_num;
 
-	store_sp_array_uint(host_sp_com, offset,
-			    frame ? frame->data : 0);
+	store_sp_array_uint(host_sp_com, offset, frame ? frame->data : 0);
 }
 
 /*
  * @brief Update the mipi metadata information in host_sp_communication.
  * Refer to "sh_css_sp.h" for more details.
  */
-void
-sh_css_update_host2sp_mipi_metadata(
-    unsigned int frame_num,
-    struct ia_css_metadata *metadata)
+void sh_css_update_host2sp_mipi_metadata(unsigned int frame_num,
+					 struct ia_css_metadata *metadata)
 {
 	unsigned int HIVE_ADDR_host_sp_com;
 	unsigned int o;
@@ -1440,15 +1413,13 @@ sh_css_update_host2sp_mipi_metadata(
 
 	/* Write new frame data into SP DMEM */
 	HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
-	o = offsetof(struct host_sp_communication, host2sp_mipi_metadata)
-	    / sizeof(int);
+	o = offsetof(struct host_sp_communication, host2sp_mipi_metadata) /
+	    sizeof(int);
 	o += frame_num;
-	store_sp_array_uint(host_sp_com, o,
-			    metadata ? metadata->address : 0);
+	store_sp_array_uint(host_sp_com, o, metadata ? metadata->address : 0);
 }
 
-void
-sh_css_update_host2sp_num_mipi_frames(unsigned int num_frames)
+void sh_css_update_host2sp_num_mipi_frames(unsigned int num_frames)
 {
 	unsigned int HIVE_ADDR_host_sp_com;
 	unsigned int offset;
@@ -1456,15 +1427,14 @@ sh_css_update_host2sp_num_mipi_frames(unsigned int num_frames)
 	/* Write new frame data into SP DMEM */
 	HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
 	offset = (unsigned int)offsetof(struct host_sp_communication,
-					host2sp_num_mipi_frames)
-		 / sizeof(int);
+					host2sp_num_mipi_frames) /
+		 sizeof(int);
 
 	store_sp_array_uint(host_sp_com, offset, num_frames);
 }
 
-void
-sh_css_update_host2sp_cont_num_raw_frames(unsigned int num_frames,
-	bool set_avail)
+void sh_css_update_host2sp_cont_num_raw_frames(unsigned int num_frames,
+					       bool set_avail)
 {
 	const struct ia_css_fw_info *fw;
 	unsigned int HIVE_ADDR_host_sp_com;
@@ -1475,32 +1445,35 @@ sh_css_update_host2sp_cont_num_raw_frames(unsigned int num_frames,
 	fw = &sh_css_sp_fw;
 	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
 	if (set_avail) {
-		offset = (unsigned int)offsetof(struct host_sp_communication,
-						host2sp_cont_avail_num_raw_frames)
-			 / sizeof(int);
+		offset = (unsigned int)offsetof(
+				 struct host_sp_communication,
+				 host2sp_cont_avail_num_raw_frames) /
+			 sizeof(int);
 		avail_num_frames = load_sp_array_uint(host_sp_com, offset);
 		extra_num_frames = num_frames - avail_num_frames;
-		offset_extra = (unsigned int)offsetof(struct host_sp_communication,
-						      host2sp_cont_extra_num_raw_frames)
-			       / sizeof(int);
-		store_sp_array_uint(host_sp_com, offset_extra, extra_num_frames);
+		offset_extra = (unsigned int)offsetof(
+				       struct host_sp_communication,
+				       host2sp_cont_extra_num_raw_frames) /
+			       sizeof(int);
+		store_sp_array_uint(host_sp_com, offset_extra,
+				    extra_num_frames);
 	} else
-		offset = (unsigned int)offsetof(struct host_sp_communication,
-						host2sp_cont_target_num_raw_frames)
-			 / sizeof(int);
+		offset = (unsigned int)offsetof(
+				 struct host_sp_communication,
+				 host2sp_cont_target_num_raw_frames) /
+			 sizeof(int);
 
 	store_sp_array_uint(host_sp_com, offset, num_frames);
 }
 
-void
-sh_css_event_init_irq_mask(void)
+void sh_css_event_init_irq_mask(void)
 {
 	int i;
 	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
 	unsigned int offset;
 	struct sh_css_event_irq_mask event_irq_mask_init;
 
-	event_irq_mask_init.or_mask  = IA_CSS_EVENT_TYPE_ALL;
+	event_irq_mask_init.or_mask = IA_CSS_EVENT_TYPE_ALL;
 	event_irq_mask_init.and_mask = IA_CSS_EVENT_TYPE_NONE;
 	(void)HIVE_ADDR_host_sp_com; /* Suppress warnings in CRUN */
 
@@ -1511,14 +1484,13 @@ sh_css_event_init_irq_mask(void)
 		assert(offset % HRT_BUS_BYTES == 0);
 		sp_dmem_store(SP0_ID,
 			      (unsigned int)sp_address_of(host_sp_com) + offset,
-			      &event_irq_mask_init, sizeof(event_irq_mask_init));
+			      &event_irq_mask_init,
+			      sizeof(event_irq_mask_init));
 	}
 }
 
-int
-ia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe,
-			 unsigned int or_mask,
-			 unsigned int and_mask)
+int ia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe, unsigned int or_mask,
+			     unsigned int and_mask)
 {
 	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
 	unsigned int offset;
@@ -1540,7 +1512,7 @@ ia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe,
 	(void)HIVE_ADDR_host_sp_com; /* Suppress warnings in CRUN */
 
 	IA_CSS_LOG("or_mask=%x, and_mask=%x", or_mask, and_mask);
-	event_irq_mask.or_mask  = (uint16_t)or_mask;
+	event_irq_mask.or_mask = (uint16_t)or_mask;
 	event_irq_mask.and_mask = (uint16_t)and_mask;
 
 	pipe_num = ia_css_pipe_get_pipe_num(pipe);
@@ -1549,17 +1521,14 @@ ia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe,
 	offset = (unsigned int)offsetof(struct host_sp_communication,
 					host2sp_event_irq_mask[pipe_num]);
 	assert(offset % HRT_BUS_BYTES == 0);
-	sp_dmem_store(SP0_ID,
-		      (unsigned int)sp_address_of(host_sp_com) + offset,
+	sp_dmem_store(SP0_ID, (unsigned int)sp_address_of(host_sp_com) + offset,
 		      &event_irq_mask, sizeof(event_irq_mask));
 
 	return 0;
 }
 
-int
-ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
-			  unsigned int *or_mask,
-			  unsigned int *and_mask)
+int ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
+			      unsigned int *or_mask, unsigned int *and_mask)
 {
 	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
 	unsigned int offset;
@@ -1579,8 +1548,7 @@ ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
 	offset = (unsigned int)offsetof(struct host_sp_communication,
 					host2sp_event_irq_mask[pipe_num]);
 	assert(offset % HRT_BUS_BYTES == 0);
-	sp_dmem_load(SP0_ID,
-		     (unsigned int)sp_address_of(host_sp_com) + offset,
+	sp_dmem_load(SP0_ID, (unsigned int)sp_address_of(host_sp_com) + offset,
 		     &event_irq_mask, sizeof(event_irq_mask));
 
 	if (or_mask)
@@ -1592,20 +1560,17 @@ ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
 	return 0;
 }
 
-void
-sh_css_sp_set_sp_running(bool flag)
+void sh_css_sp_set_sp_running(bool flag)
 {
 	sp_running = flag;
 }
 
-bool
-sh_css_sp_is_running(void)
+bool sh_css_sp_is_running(void)
 {
 	return sp_running;
 }
 
-void
-sh_css_sp_start_isp(void)
+void sh_css_sp_start_isp(void)
 {
 	const struct ia_css_fw_info *fw;
 	unsigned int HIVE_ADDR_sp_sw_state;
@@ -1624,8 +1589,7 @@ sh_css_sp_start_isp(void)
 	store_sp_group_data();
 	store_sp_per_frame_data(fw);
 
-	sp_dmem_store_uint32(SP0_ID,
-			     (unsigned int)sp_address_of(sp_sw_state),
+	sp_dmem_store_uint32(SP0_ID, (unsigned int)sp_address_of(sp_sw_state),
 			     (uint32_t)(IA_CSS_SP_SW_TERMINATED));
 
 	/*
@@ -1652,11 +1616,11 @@ sh_css_sp_start_isp(void)
 	ia_css_spctrl_start(SP0_ID);
 }
 
-bool
-ia_css_isp_has_started(void)
+bool ia_css_isp_has_started(void)
 {
 	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_ia_css_ispctrl_sp_isp_started = fw->info.sp.isp_started;
+	unsigned int HIVE_ADDR_ia_css_ispctrl_sp_isp_started =
+		fw->info.sp.isp_started;
 	(void)HIVE_ADDR_ia_css_ispctrl_sp_isp_started; /* Suppress warnings in CRUN */
 
 	return (bool)load_sp_uint(ia_css_ispctrl_sp_isp_started);
@@ -1666,23 +1630,16 @@ ia_css_isp_has_started(void)
  * @brief Initialize the DMA software-mask in the debug mode.
  * Refer to "sh_css_sp.h" for more details.
  */
-bool
-sh_css_sp_init_dma_sw_reg(int dma_id)
+bool sh_css_sp_init_dma_sw_reg(int dma_id)
 {
 	int i;
 
 	/* enable all the DMA channels */
 	for (i = 0; i < N_DMA_CHANNEL_ID; i++) {
 		/* enable the writing request */
-		sh_css_sp_set_dma_sw_reg(dma_id,
-					 i,
-					 0,
-					 true);
+		sh_css_sp_set_dma_sw_reg(dma_id, i, 0, true);
 		/* enable the reading request */
-		sh_css_sp_set_dma_sw_reg(dma_id,
-					 i,
-					 1,
-					 true);
+		sh_css_sp_set_dma_sw_reg(dma_id, i, 1, true);
 	}
 
 	return true;
@@ -1692,11 +1649,8 @@ sh_css_sp_init_dma_sw_reg(int dma_id)
  * @brief Set the DMA software-mask in the debug mode.
  * Refer to "sh_css_sp.h" for more details.
  */
-bool
-sh_css_sp_set_dma_sw_reg(int dma_id,
-			 int channel_id,
-			 int request_type,
-			 bool enable)
+bool sh_css_sp_set_dma_sw_reg(int dma_id, int channel_id, int request_type,
+			      bool enable)
 {
 	u32 sw_reg;
 	u32 bit_val;
@@ -1709,8 +1663,7 @@ sh_css_sp_set_dma_sw_reg(int dma_id,
 	assert(request_type >= 0);
 
 	/* get the software-mask */
-	sw_reg =
-	    sh_css_sp_group.debug.dma_sw_reg;
+	sw_reg = sh_css_sp_group.debug.dma_sw_reg;
 
 	/* get the offset of the target bit */
 	bit_offset = (8 * request_type) + channel_id;
@@ -1730,8 +1683,7 @@ sh_css_sp_set_dma_sw_reg(int dma_id,
 	return true;
 }
 
-void
-sh_css_sp_reset_global_vars(void)
+void sh_css_sp_reset_global_vars(void)
 {
 	memset(&sh_css_sp_group, 0, sizeof(struct sh_css_sp_group));
 	memset(&sh_css_sp_stage, 0, sizeof(struct sh_css_sp_stage));
diff --git a/drivers/staging/media/atomisp/pci/sh_css_sp.h b/drivers/staging/media/atomisp/pci/sh_css_sp.h
index 78aec5b7e8fa7e9f66085adb43ad8eb406486018..fa357b54ba42f08966ca5dd7486c0c53ed5f06f2 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_sp.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_sp.h
@@ -16,57 +16,42 @@
 #include "ia_css_pipeline.h"
 
 /* Function to initialize the data and bss section descr of the binary */
-void
-sh_css_sp_store_init_dmem(const struct ia_css_fw_info *fw);
+void sh_css_sp_store_init_dmem(const struct ia_css_fw_info *fw);
 
-void
-store_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num,
-		    unsigned int stage);
+void store_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num,
+			 unsigned int stage);
 
-void
-sh_css_stage_write_binary_info(struct ia_css_binary_info *info);
+void sh_css_stage_write_binary_info(struct ia_css_binary_info *info);
 
-void
-store_sp_group_data(void);
+void store_sp_group_data(void);
 
 /* Start binary (jpeg) copy on the SP */
-void
-sh_css_sp_start_binary_copy(unsigned int pipe_num,
-			    struct ia_css_frame *out_frame,
-			    unsigned int two_ppc);
+void sh_css_sp_start_binary_copy(unsigned int pipe_num,
+				 struct ia_css_frame *out_frame,
+				 unsigned int two_ppc);
 
-unsigned int
-sh_css_sp_get_binary_copy_size(void);
+unsigned int sh_css_sp_get_binary_copy_size(void);
 
 /* Return the value of a SW interrupt */
-unsigned int
-sh_css_sp_get_sw_interrupt_value(unsigned int irq);
-
-void
-sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
-			enum ia_css_pipe_id id,
-			u8 pipe_num,
-			bool xnr,
-			bool two_ppc,
-			bool continuous,
-			bool offline,
-			unsigned int required_bds_factor,
-			enum sh_css_pipe_config_override copy_ovrd,
-			enum ia_css_input_mode input_mode,
-			const struct ia_css_metadata_config *md_config,
-			const struct ia_css_metadata_info *md_info,
-			const enum mipi_port_id port_id);
-
-void
-sh_css_sp_uninit_pipeline(unsigned int pipe_num);
+unsigned int sh_css_sp_get_sw_interrupt_value(unsigned int irq);
+
+void sh_css_sp_init_pipeline(struct ia_css_pipeline *me, enum ia_css_pipe_id id,
+			     u8 pipe_num, bool xnr, bool two_ppc,
+			     bool continuous, bool offline,
+			     unsigned int required_bds_factor,
+			     enum sh_css_pipe_config_override copy_ovrd,
+			     enum ia_css_input_mode input_mode,
+			     const struct ia_css_metadata_config *md_config,
+			     const struct ia_css_metadata_info *md_info,
+			     const enum mipi_port_id port_id);
+
+void sh_css_sp_uninit_pipeline(unsigned int pipe_num);
 
 bool sh_css_write_host2sp_command(enum host2sp_commands host2sp_command);
 
-enum host2sp_commands
-sh_css_read_host2sp_command(void);
+enum host2sp_commands sh_css_read_host2sp_command(void);
 
-void
-sh_css_init_host2sp_frame_data(void);
+void sh_css_init_host2sp_frame_data(void);
 
 /**
  * @brief Update the offline frame information in host_sp_communication.
@@ -74,11 +59,9 @@ sh_css_init_host2sp_frame_data(void);
  * @param[in] frame_num The offline frame number.
  * @param[in] frame The pointer to the offline frame.
  */
-void
-sh_css_update_host2sp_offline_frame(
-    unsigned int frame_num,
-    struct ia_css_frame *frame,
-    struct ia_css_metadata *metadata);
+void sh_css_update_host2sp_offline_frame(unsigned int frame_num,
+					 struct ia_css_frame *frame,
+					 struct ia_css_metadata *metadata);
 
 /**
  * @brief Update the mipi frame information in host_sp_communication.
@@ -86,10 +69,8 @@ sh_css_update_host2sp_offline_frame(
  * @param[in] frame_num The mipi frame number.
  * @param[in] frame The pointer to the mipi frame.
  */
-void
-sh_css_update_host2sp_mipi_frame(
-    unsigned int frame_num,
-    struct ia_css_frame *frame);
+void sh_css_update_host2sp_mipi_frame(unsigned int frame_num,
+				      struct ia_css_frame *frame);
 
 /**
  * @brief Update the mipi metadata information in host_sp_communication.
@@ -97,78 +78,57 @@ sh_css_update_host2sp_mipi_frame(
  * @param[in] frame_num The mipi frame number.
  * @param[in] metadata The pointer to the mipi metadata.
  */
-void
-sh_css_update_host2sp_mipi_metadata(
-    unsigned int frame_num,
-    struct ia_css_metadata *metadata);
+void sh_css_update_host2sp_mipi_metadata(unsigned int frame_num,
+					 struct ia_css_metadata *metadata);
 
 /**
  * @brief Update the nr of mipi frames to use in host_sp_communication.
  *
  * @param[in] num_frames The number of mipi frames to use.
  */
-void
-sh_css_update_host2sp_num_mipi_frames(unsigned int num_frames);
+void sh_css_update_host2sp_num_mipi_frames(unsigned int num_frames);
 
 /**
  * @brief Update the nr of offline frames to use in host_sp_communication.
  *
  * @param[in] num_frames The number of raw frames to use.
  */
-void
-sh_css_update_host2sp_cont_num_raw_frames(unsigned int num_frames,
-	bool set_avail);
+void sh_css_update_host2sp_cont_num_raw_frames(unsigned int num_frames,
+					       bool set_avail);
 
-void
-sh_css_event_init_irq_mask(void);
+void sh_css_event_init_irq_mask(void);
 
-void
-sh_css_sp_start_isp(void);
+void sh_css_sp_start_isp(void);
 
-void
-sh_css_sp_set_sp_running(bool flag);
+void sh_css_sp_set_sp_running(bool flag);
 
-bool
-sh_css_sp_is_running(void);
+bool sh_css_sp_is_running(void);
 
 #if SP_DEBUG != SP_DEBUG_NONE
 
-void
-sh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state);
+void sh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state);
 
 #endif
 
-void
-sh_css_sp_set_if_configs(
-    const input_formatter_cfg_t	*config_a,
-    const input_formatter_cfg_t	*config_b,
-    const uint8_t		if_config_index);
+void sh_css_sp_set_if_configs(const input_formatter_cfg_t *config_a,
+			      const input_formatter_cfg_t *config_b,
+			      const uint8_t if_config_index);
 
-void
-sh_css_sp_program_input_circuit(int fmt_type,
-				int ch_id,
-				enum ia_css_input_mode input_mode);
+void sh_css_sp_program_input_circuit(int fmt_type, int ch_id,
+				     enum ia_css_input_mode input_mode);
 
-void
-sh_css_sp_configure_sync_gen(int width,
-			     int height,
-			     int hblank_cycles,
-			     int vblank_cycles);
+void sh_css_sp_configure_sync_gen(int width, int height, int hblank_cycles,
+				  int vblank_cycles);
 
-void
-sh_css_sp_configure_prbs(int seed);
+void sh_css_sp_configure_prbs(int seed);
 
-void
-sh_css_sp_configure_enable_raw_pool_locking(bool lock_all);
+void sh_css_sp_configure_enable_raw_pool_locking(bool lock_all);
 
-void
-sh_css_sp_enable_isys_event_queue(bool enable);
+void sh_css_sp_enable_isys_event_queue(bool enable);
 
-void
-sh_css_sp_set_disable_continuous_viewfinder(bool flag);
+void sh_css_sp_set_disable_continuous_viewfinder(bool flag);
 
-void
-sh_css_sp_reset_global_vars(void);
+void sh_css_sp_reset_global_vars(void);
 
 /**
  * @brief Initialize the DMA software-mask in the debug mode.
@@ -182,8 +142,7 @@ sh_css_sp_reset_global_vars(void);
  *	- true, if it is successful.
  *	- false, otherwise.
  */
-bool
-sh_css_sp_init_dma_sw_reg(int dma_id);
+bool sh_css_sp_init_dma_sw_reg(int dma_id);
 
 /**
  * @brief Set the DMA software-mask in the debug mode.
@@ -207,11 +166,8 @@ sh_css_sp_init_dma_sw_reg(int dma_id);
  *	- true, if it is successful.
  *	- false, otherwise.
  */
-bool
-sh_css_sp_set_dma_sw_reg(int dma_id,
-			 int channel_id,
-			 int request_type,
-			 bool enable);
+bool sh_css_sp_set_dma_sw_reg(int dma_id, int channel_id, int request_type,
+			      bool enable);
 
 extern struct sh_css_sp_group sh_css_sp_group;
 extern struct sh_css_sp_stage sh_css_sp_stage;
diff --git a/drivers/staging/media/atomisp/pci/sh_css_stream_format.c b/drivers/staging/media/atomisp/pci/sh_css_stream_format.c
index 24ec09703d9a5d825fc1be73debcb88758f5f2d8..42934f25fdf5b15f164f6895aa03090a90323f17 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_stream_format.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_stream_format.c
@@ -7,8 +7,8 @@
 #include "sh_css_stream_format.h"
 #include <ia_css_stream_format.h>
 
-unsigned int sh_css_stream_format_2_bits_per_subpixel(
-    enum atomisp_input_format format)
+unsigned int
+sh_css_stream_format_2_bits_per_subpixel(enum atomisp_input_format format)
 {
 	unsigned int rval;
 
diff --git a/drivers/staging/media/atomisp/pci/sh_css_stream_format.h b/drivers/staging/media/atomisp/pci/sh_css_stream_format.h
index 7f5a3be00c6ba16c6799ea299eb35bba7d53872e..6538f430d694cc2129920d0d094bb3ea051981c5 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_stream_format.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_stream_format.h
@@ -9,7 +9,7 @@
 
 #include <ia_css_stream_format.h>
 
-unsigned int sh_css_stream_format_2_bits_per_subpixel(
-    enum atomisp_input_format format);
+unsigned int
+sh_css_stream_format_2_bits_per_subpixel(enum atomisp_input_format format);
 
 #endif /* __SH_CSS_STREAM_FORMAT_H */
diff --git a/drivers/staging/media/atomisp/pci/sh_css_struct.h b/drivers/staging/media/atomisp/pci/sh_css_struct.h
index c51fcb7252089450ae1e531419b67d7ef21df754..4629cfdc4a0c8852ac08a3b730e67d9d57bea167 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_struct.h
+++ b/drivers/staging/media/atomisp/pci/sh_css_struct.h
@@ -24,52 +24,52 @@
 #include "ia_css_irq.h"
 
 struct sh_css {
-	struct ia_css_pipe            *active_pipes[IA_CSS_PIPELINE_NUM_MAX];
+	struct ia_css_pipe *active_pipes[IA_CSS_PIPELINE_NUM_MAX];
 	/* All of the pipes created at any point of time. At this moment there can
 	 * be no more than MAX_SP_THREADS of them because pipe_num is reused as SP
 	 * thread_id to which a pipe's pipeline is associated. At a later point, if
 	 * we support more pipe objects, we should add test code to test that
 	 * possibility. Also, active_pipes[] should be able to hold only
 	 * SH_CSS_MAX_SP_THREADS objects. Anything else is misleading. */
-	struct ia_css_pipe            *all_pipes[IA_CSS_PIPELINE_NUM_MAX];
+	struct ia_css_pipe *all_pipes[IA_CSS_PIPELINE_NUM_MAX];
 	void *(*malloc)(size_t bytes, bool zero_mem);
 	void (*free)(void *ptr);
 	void (*flush)(struct ia_css_acc_fw *fw);
 
-/* ISP2401 */
+	/* ISP2401 */
 	void *(*malloc_ex)(size_t bytes, bool zero_mem, const char *caller_func,
 			   int caller_line);
 	void (*free_ex)(void *ptr, const char *caller_func, int caller_line);
 
-/* ISP2400 */
+	/* ISP2400 */
 	bool stop_copy_preview;
 
-	bool                           check_system_idle;
-	unsigned int                   num_cont_raw_frames;
-	unsigned int                   num_mipi_frames[N_CSI_PORTS];
+	bool check_system_idle;
+	unsigned int num_cont_raw_frames;
+	unsigned int num_mipi_frames[N_CSI_PORTS];
 	struct ia_css_frame
 		*mipi_frames[N_CSI_PORTS][NUM_MIPI_FRAMES_PER_STREAM];
 	struct ia_css_metadata
 		*mipi_metadata[N_CSI_PORTS][NUM_MIPI_FRAMES_PER_STREAM];
-	unsigned int
-	mipi_sizes_for_check[N_CSI_PORTS][IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT];
-	unsigned int                   mipi_frame_size[N_CSI_PORTS];
-	ia_css_ptr                   sp_bin_addr;
-	hrt_data                       page_table_base_index;
+	unsigned int mipi_sizes_for_check
+		[N_CSI_PORTS][IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT];
+	unsigned int mipi_frame_size[N_CSI_PORTS];
+	ia_css_ptr sp_bin_addr;
+	hrt_data page_table_base_index;
 
 	unsigned int
-	size_mem_words; /* \deprecated{Use ia_css_mipi_buffer_config instead.}*/
-	enum ia_css_irq_type           irq_type;
-	unsigned int                   pipe_counter;
+		size_mem_words; /* \deprecated{Use ia_css_mipi_buffer_config instead.}*/
+	enum ia_css_irq_type irq_type;
+	unsigned int pipe_counter;
 
-	unsigned int		type;	/* 2400 or 2401 for now */
+	unsigned int type; /* 2400 or 2401 for now */
 };
 
-#define IPU_2400		1
-#define IPU_2401		2
+#define IPU_2400 1
+#define IPU_2401 2
 
-#define IS_2400()		(my_css.type == IPU_2400)
-#define IS_2401()		(my_css.type == IPU_2401)
+#define IS_2400() (my_css.type == IPU_2400)
+#define IS_2401() (my_css.type == IPU_2401)
 
 extern struct sh_css my_css;
 
diff --git a/drivers/staging/media/atomisp/pci/sh_css_version.c b/drivers/staging/media/atomisp/pci/sh_css_version.c
index ba8660f0cb817419edffc145eb071007e83c17c7..64608b11a6739f1c71ce2a7f606feb80a6906d3d 100644
--- a/drivers/staging/media/atomisp/pci/sh_css_version.c
+++ b/drivers/staging/media/atomisp/pci/sh_css_version.c
@@ -11,8 +11,7 @@
 #include "ia_css_err.h"
 #include "sh_css_firmware.h"
 
-int
-ia_css_get_version(char *version, int max_size)
+int ia_css_get_version(char *version, int max_size)
 {
 	char *css_version;
 
@@ -21,7 +20,8 @@ ia_css_get_version(char *version, int max_size)
 	else
 		css_version = ISP2401_CSS_VERSION_STRING;
 
-	if (max_size <= (int)strlen(css_version) + (int)strlen(sh_css_get_fw_version()) + 5)
+	if (max_size <=
+	    (int)strlen(css_version) + (int)strlen(sh_css_get_fw_version()) + 5)
 		return -EINVAL;
 	strscpy(version, css_version, max_size);
 	strcat(version, "FW:");
diff --git a/drivers/staging/media/atomisp/pci/str2mem_defs.h b/drivers/staging/media/atomisp/pci/str2mem_defs.h
index fc06d4e4589f7a89242c7f5bd30847cff0ac7c61..9fac152c66b638b90a29c97ea40237bccf8459bf 100644
--- a/drivers/staging/media/atomisp/pci/str2mem_defs.h
+++ b/drivers/staging/media/atomisp/pci/str2mem_defs.h
@@ -7,25 +7,25 @@
 #ifndef _ST2MEM_DEFS_H
 #define _ST2MEM_DEFS_H
 
-#define _STR2MEM_CRUN_BIT               0x100000
-#define _STR2MEM_CMD_BITS               0x0F0000
-#define _STR2MEM_COUNT_BITS             0x00FFFF
+#define _STR2MEM_CRUN_BIT 0x100000
+#define _STR2MEM_CMD_BITS 0x0F0000
+#define _STR2MEM_COUNT_BITS 0x00FFFF
 
-#define _STR2MEM_BLOCKS_CMD             0xA0000
-#define _STR2MEM_PACKETS_CMD            0xB0000
-#define _STR2MEM_BYTES_CMD              0xC0000
-#define _STR2MEM_BYTES_FROM_PACKET_CMD  0xD0000
+#define _STR2MEM_BLOCKS_CMD 0xA0000
+#define _STR2MEM_PACKETS_CMD 0xB0000
+#define _STR2MEM_BYTES_CMD 0xC0000
+#define _STR2MEM_BYTES_FROM_PACKET_CMD 0xD0000
 
-#define _STR2MEM_SOFT_RESET_REG_ID                   0
-#define _STR2MEM_INPUT_ENDIANNESS_REG_ID             1
-#define _STR2MEM_OUTPUT_ENDIANNESS_REG_ID            2
-#define _STR2MEM_BIT_SWAPPING_REG_ID                 3
-#define _STR2MEM_BLOCK_SYNC_LEVEL_REG_ID             4
-#define _STR2MEM_PACKET_SYNC_LEVEL_REG_ID            5
-#define _STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ID  6
-#define _STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ID     7
-#define _STR2MEM_EN_STAT_UPDATE_ID                   8
+#define _STR2MEM_SOFT_RESET_REG_ID 0
+#define _STR2MEM_INPUT_ENDIANNESS_REG_ID 1
+#define _STR2MEM_OUTPUT_ENDIANNESS_REG_ID 2
+#define _STR2MEM_BIT_SWAPPING_REG_ID 3
+#define _STR2MEM_BLOCK_SYNC_LEVEL_REG_ID 4
+#define _STR2MEM_PACKET_SYNC_LEVEL_REG_ID 5
+#define _STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ID 6
+#define _STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ID 7
+#define _STR2MEM_EN_STAT_UPDATE_ID 8
 
-#define _STR2MEM_REG_ALIGN      4
+#define _STR2MEM_REG_ALIGN 4
 
 #endif /* _ST2MEM_DEFS_H */
diff --git a/drivers/staging/media/atomisp/pci/streaming_to_mipi_defs.h b/drivers/staging/media/atomisp/pci/streaming_to_mipi_defs.h
index 8efbaa55f7520a9b0a6cc40cb71826e38ab27b24..c90d13186d5744b430fdd50ea6d22b3b0a705bab 100644
--- a/drivers/staging/media/atomisp/pci/streaming_to_mipi_defs.h
+++ b/drivers/staging/media/atomisp/pci/streaming_to_mipi_defs.h
@@ -9,12 +9,12 @@
 
 #define HIVE_STR_TO_MIPI_VALID_A_BIT 0
 #define HIVE_STR_TO_MIPI_VALID_B_BIT 1
-#define HIVE_STR_TO_MIPI_SOL_BIT     2
-#define HIVE_STR_TO_MIPI_EOL_BIT     3
-#define HIVE_STR_TO_MIPI_SOF_BIT     4
-#define HIVE_STR_TO_MIPI_EOF_BIT     5
-#define HIVE_STR_TO_MIPI_CH_ID_LSB   6
+#define HIVE_STR_TO_MIPI_SOL_BIT 2
+#define HIVE_STR_TO_MIPI_EOL_BIT 3
+#define HIVE_STR_TO_MIPI_SOF_BIT 4
+#define HIVE_STR_TO_MIPI_EOF_BIT 5
+#define HIVE_STR_TO_MIPI_CH_ID_LSB 6
 
-#define HIVE_STR_TO_MIPI_DATA_A_LSB  (HIVE_STR_TO_MIPI_VALID_B_BIT + 1)
+#define HIVE_STR_TO_MIPI_DATA_A_LSB (HIVE_STR_TO_MIPI_VALID_B_BIT + 1)
 
 #endif /* _streaming_to_mipi_defs_h */
diff --git a/drivers/staging/media/atomisp/pci/system_global.h b/drivers/staging/media/atomisp/pci/system_global.h
index e8a29f73d67a7f09e3876ea999b001219cc9552f..252ff1753c626f1c62d17633e058ab00df5c1719 100644
--- a/drivers/staging/media/atomisp/pci/system_global.h
+++ b/drivers/staging/media/atomisp/pci/system_global.h
@@ -32,7 +32,7 @@
  * The longest allowed (uninteruptible) bus transfer, does not
  * take stalling into account
  */
-#define HIVE_ISP_MAX_BURST_LENGTH	1024
+#define HIVE_ISP_MAX_BURST_LENGTH 1024
 
 /*
  * Maximum allowed burst length in words for the ISP DMA
@@ -41,8 +41,8 @@
  * 2 lines on Moorefield and Cherrytrail, the input system buffers
  * may overflow if blocked for too long (BZ 2726).
  */
-#define ISP2400_DMA_MAX_BURST_LENGTH	128
-#define ISP2401_DMA_MAX_BURST_LENGTH	2
+#define ISP2400_DMA_MAX_BURST_LENGTH 128
+#define ISP2401_DMA_MAX_BURST_LENGTH 2
 
 #include <hive_isp_css_defs.h>
 #include <type_support.h>
@@ -53,93 +53,56 @@
 /*
  * Semi global. "HRT" is accessible from SP, but the HRT types do not fully apply
  */
-#define HRT_VADDRESS_WIDTH	32
+#define HRT_VADDRESS_WIDTH 32
 
-#define SIZEOF_HRT_REG		(HRT_DATA_WIDTH >> 3)
+#define SIZEOF_HRT_REG (HRT_DATA_WIDTH >> 3)
 #define HIVE_ISP_CTRL_DATA_BYTES (HIVE_ISP_CTRL_DATA_WIDTH / 8)
 
 /* The main bus connecting all devices */
-#define HRT_BUS_WIDTH		HIVE_ISP_CTRL_DATA_WIDTH
-#define HRT_BUS_BYTES		HIVE_ISP_CTRL_DATA_BYTES
+#define HRT_BUS_WIDTH HIVE_ISP_CTRL_DATA_WIDTH
+#define HRT_BUS_BYTES HIVE_ISP_CTRL_DATA_BYTES
 
-typedef u32			hrt_bus_align_t;
+typedef u32 hrt_bus_align_t;
 
 /*
  * Enumerate the devices, device access through the API is by ID,
  * through the DLI by address. The enumerator terminators are used
  * to size the wiring arrays and as an exception value.
  */
-typedef enum {
-	DDR0_ID = 0,
-	N_DDR_ID
-} ddr_ID_t;
+typedef enum { DDR0_ID = 0, N_DDR_ID } ddr_ID_t;
 
-typedef enum {
-	ISP0_ID = 0,
-	N_ISP_ID
-} isp_ID_t;
+typedef enum { ISP0_ID = 0, N_ISP_ID } isp_ID_t;
 
-typedef enum {
-	SP0_ID = 0,
-	N_SP_ID
-} sp_ID_t;
+typedef enum { SP0_ID = 0, N_SP_ID } sp_ID_t;
 
-typedef enum {
-	MMU0_ID = 0,
-	MMU1_ID,
-	N_MMU_ID
-} mmu_ID_t;
+typedef enum { MMU0_ID = 0, MMU1_ID, N_MMU_ID } mmu_ID_t;
 
-typedef enum {
-	DMA0_ID = 0,
-	N_DMA_ID
-} dma_ID_t;
+typedef enum { DMA0_ID = 0, N_DMA_ID } dma_ID_t;
 
-typedef enum {
-	GDC0_ID = 0,
-	GDC1_ID,
-	N_GDC_ID
-} gdc_ID_t;
+typedef enum { GDC0_ID = 0, GDC1_ID, N_GDC_ID } gdc_ID_t;
 
 /* this extra define is needed because we want to use it also
    in the preprocessor, and that doesn't work with enums.
  */
 #define N_GDC_ID_CPP 2
 
-typedef enum {
-	VAMEM0_ID = 0,
-	VAMEM1_ID,
-	VAMEM2_ID,
-	N_VAMEM_ID
-} vamem_ID_t;
+typedef enum { VAMEM0_ID = 0, VAMEM1_ID, VAMEM2_ID, N_VAMEM_ID } vamem_ID_t;
 
-typedef enum {
-	BAMEM0_ID = 0,
-	N_BAMEM_ID
-} bamem_ID_t;
+typedef enum { BAMEM0_ID = 0, N_BAMEM_ID } bamem_ID_t;
 
-typedef enum {
-	HMEM0_ID = 0,
-	N_HMEM_ID
-} hmem_ID_t;
+typedef enum { HMEM0_ID = 0, N_HMEM_ID } hmem_ID_t;
 
 typedef enum {
-	IRQ0_ID = 0,	/* GP IRQ block */
-	IRQ1_ID,	/* Input formatter */
-	IRQ2_ID,	/* input system */
-	IRQ3_ID,	/* input selector */
+	IRQ0_ID = 0, /* GP IRQ block */
+	IRQ1_ID, /* Input formatter */
+	IRQ2_ID, /* input system */
+	IRQ3_ID, /* input selector */
 	N_IRQ_ID
 } irq_ID_t;
 
-typedef enum {
-	FIFO_MONITOR0_ID = 0,
-	N_FIFO_MONITOR_ID
-} fifo_monitor_ID_t;
+typedef enum { FIFO_MONITOR0_ID = 0, N_FIFO_MONITOR_ID } fifo_monitor_ID_t;
 
-typedef enum {
-	GP_DEVICE0_ID = 0,
-	N_GP_DEVICE_ID
-} gp_device_ID_t;
+typedef enum { GP_DEVICE0_ID = 0, N_GP_DEVICE_ID } gp_device_ID_t;
 
 typedef enum {
 	GP_TIMER0_ID = 0,
@@ -153,15 +116,9 @@ typedef enum {
 	N_GP_TIMER_ID
 } gp_timer_ID_t;
 
-typedef enum {
-	GPIO0_ID = 0,
-	N_GPIO_ID
-} gpio_ID_t;
+typedef enum { GPIO0_ID = 0, N_GPIO_ID } gpio_ID_t;
 
-typedef enum {
-	TIMED_CTRL0_ID = 0,
-	N_TIMED_CTRL_ID
-} timed_ctrl_ID_t;
+typedef enum { TIMED_CTRL0_ID = 0, N_TIMED_CTRL_ID } timed_ctrl_ID_t;
 
 typedef enum {
 	INPUT_FORMATTER0_ID = 0,
@@ -172,25 +129,19 @@ typedef enum {
 } input_formatter_ID_t;
 
 /* The IF RST is outside the IF */
-#define INPUT_FORMATTER0_SRST_OFFSET	0x0824
-#define INPUT_FORMATTER1_SRST_OFFSET	0x0624
-#define INPUT_FORMATTER2_SRST_OFFSET	0x0424
-#define INPUT_FORMATTER3_SRST_OFFSET	0x0224
+#define INPUT_FORMATTER0_SRST_OFFSET 0x0824
+#define INPUT_FORMATTER1_SRST_OFFSET 0x0624
+#define INPUT_FORMATTER2_SRST_OFFSET 0x0424
+#define INPUT_FORMATTER3_SRST_OFFSET 0x0224
 
-#define INPUT_FORMATTER0_SRST_MASK		0x0001
-#define INPUT_FORMATTER1_SRST_MASK		0x0002
-#define INPUT_FORMATTER2_SRST_MASK		0x0004
-#define INPUT_FORMATTER3_SRST_MASK		0x0008
+#define INPUT_FORMATTER0_SRST_MASK 0x0001
+#define INPUT_FORMATTER1_SRST_MASK 0x0002
+#define INPUT_FORMATTER2_SRST_MASK 0x0004
+#define INPUT_FORMATTER3_SRST_MASK 0x0008
 
-typedef enum {
-	INPUT_SYSTEM0_ID = 0,
-	N_INPUT_SYSTEM_ID
-} input_system_ID_t;
+typedef enum { INPUT_SYSTEM0_ID = 0, N_INPUT_SYSTEM_ID } input_system_ID_t;
 
-typedef enum {
-	RX0_ID = 0,
-	N_RX_ID
-} rx_ID_t;
+typedef enum { RX0_ID = 0, N_RX_ID } rx_ID_t;
 
 enum mipi_port_id {
 	MIPI_PORT0_ID = 0,
@@ -199,7 +150,7 @@ enum mipi_port_id {
 	N_MIPI_PORT_ID
 };
 
-#define	N_RX_CHANNEL_ID		4
+#define N_RX_CHANNEL_ID 4
 
 typedef enum {
 	CAPTURE_UNIT0_ID = 0,
@@ -214,10 +165,9 @@ typedef enum {
 	N_SUB_SYSTEM_ID
 } sub_system_ID_t;
 
-#define	N_CAPTURE_UNIT_ID		3
-#define	N_ACQUISITION_UNIT_ID		1
-#define	N_CTRL_UNIT_ID			1
-
+#define N_CAPTURE_UNIT_ID 3
+#define N_ACQUISITION_UNIT_ID 1
+#define N_CTRL_UNIT_ID 1
 
 enum ia_css_isp_memories {
 	IA_CSS_ISP_PMEM0 = 0,
@@ -234,7 +184,7 @@ enum ia_css_isp_memories {
 
 #define IA_CSS_NUM_MEMORIES 9
 /* For driver compatibility */
-#define N_IA_CSS_ISP_MEMORIES   IA_CSS_NUM_MEMORIES
+#define N_IA_CSS_ISP_MEMORIES IA_CSS_NUM_MEMORIES
 #define IA_CSS_NUM_ISP_MEMORIES IA_CSS_NUM_MEMORIES
 
 /*
@@ -242,20 +192,19 @@ enum ia_css_isp_memories {
  */
 
 typedef enum {
-	ISYS_IRQ0_ID = 0,	/* port a */
-	ISYS_IRQ1_ID,	/* port b */
-	ISYS_IRQ2_ID,	/* port c */
+	ISYS_IRQ0_ID = 0, /* port a */
+	ISYS_IRQ1_ID, /* port b */
+	ISYS_IRQ2_ID, /* port c */
 	N_ISYS_IRQ_ID
 } isys_irq_ID_t;
 
-
 /*
  * Input-buffer Controller.
  */
 typedef enum {
-	IBUF_CTRL0_ID = 0,	/* map to ISYS2401_IBUF_CNTRL_A */
-	IBUF_CTRL1_ID,		/* map to ISYS2401_IBUF_CNTRL_B */
-	IBUF_CTRL2_ID,		/* map ISYS2401_IBUF_CNTRL_C */
+	IBUF_CTRL0_ID = 0, /* map to ISYS2401_IBUF_CNTRL_A */
+	IBUF_CTRL1_ID, /* map to ISYS2401_IBUF_CNTRL_B */
+	IBUF_CTRL2_ID, /* map ISYS2401_IBUF_CNTRL_C */
 	N_IBUF_CTRL_ID
 } ibuf_ctrl_ID_t;
 /* end of Input-buffer Controller */
@@ -264,9 +213,9 @@ typedef enum {
  * Stream2MMIO.
  */
 typedef enum {
-	STREAM2MMIO0_ID = 0,	/* map to ISYS2401_S2M_A */
-	STREAM2MMIO1_ID,	/* map to ISYS2401_S2M_B */
-	STREAM2MMIO2_ID,	/* map to ISYS2401_S2M_C */
+	STREAM2MMIO0_ID = 0, /* map to ISYS2401_S2M_A */
+	STREAM2MMIO1_ID, /* map to ISYS2401_S2M_B */
+	STREAM2MMIO2_ID, /* map to ISYS2401_S2M_C */
 	N_STREAM2MMIO_ID
 } stream2mmio_ID_t;
 
@@ -297,32 +246,29 @@ typedef enum {
  * Input System 2401: CSI-MIPI recevier.
  */
 typedef enum {
-	CSI_RX_BACKEND0_ID = 0,	/* map to ISYS2401_MIPI_BE_A */
-	CSI_RX_BACKEND1_ID,		/* map to ISYS2401_MIPI_BE_B */
-	CSI_RX_BACKEND2_ID,		/* map to ISYS2401_MIPI_BE_C */
+	CSI_RX_BACKEND0_ID = 0, /* map to ISYS2401_MIPI_BE_A */
+	CSI_RX_BACKEND1_ID, /* map to ISYS2401_MIPI_BE_B */
+	CSI_RX_BACKEND2_ID, /* map to ISYS2401_MIPI_BE_C */
 	N_CSI_RX_BACKEND_ID
 } csi_rx_backend_ID_t;
 
 typedef enum {
-	CSI_RX_FRONTEND0_ID = 0,	/* map to ISYS2401_CSI_RX_A */
-	CSI_RX_FRONTEND1_ID,		/* map to ISYS2401_CSI_RX_B */
-	CSI_RX_FRONTEND2_ID,		/* map to ISYS2401_CSI_RX_C */
+	CSI_RX_FRONTEND0_ID = 0, /* map to ISYS2401_CSI_RX_A */
+	CSI_RX_FRONTEND1_ID, /* map to ISYS2401_CSI_RX_B */
+	CSI_RX_FRONTEND2_ID, /* map to ISYS2401_CSI_RX_C */
 #define N_CSI_RX_FRONTEND_ID (CSI_RX_FRONTEND2_ID + 1)
 } csi_rx_frontend_ID_t;
 
 typedef enum {
-	CSI_RX_DLANE0_ID = 0,		/* map to DLANE0 in CSI RX */
-	CSI_RX_DLANE1_ID,		/* map to DLANE1 in CSI RX */
-	CSI_RX_DLANE2_ID,		/* map to DLANE2 in CSI RX */
-	CSI_RX_DLANE3_ID,		/* map to DLANE3 in CSI RX */
+	CSI_RX_DLANE0_ID = 0, /* map to DLANE0 in CSI RX */
+	CSI_RX_DLANE1_ID, /* map to DLANE1 in CSI RX */
+	CSI_RX_DLANE2_ID, /* map to DLANE2 in CSI RX */
+	CSI_RX_DLANE3_ID, /* map to DLANE3 in CSI RX */
 	N_CSI_RX_DLANE_ID
 } csi_rx_fe_dlane_ID_t;
 /* end of CSI-MIPI receiver */
 
-typedef enum {
-	ISYS2401_DMA0_ID = 0,
-	N_ISYS2401_DMA_ID
-} isys2401_dma_ID_t;
+typedef enum { ISYS2401_DMA0_ID = 0, N_ISYS2401_DMA_ID } isys2401_dma_ID_t;
 
 /**
  * Pixel-generator. ("system_global.h")
@@ -347,7 +293,7 @@ typedef enum {
 	N_INPUT_SYSTEM_INPUT_PORT_ID
 } input_system_input_port_ID_t;
 
-#define N_INPUT_SYSTEM_CSI_PORT	3
+#define N_INPUT_SYSTEM_CSI_PORT 3
 
 typedef enum {
 	ISYS2401_DMA_CHANNEL_0 = 0,
diff --git a/drivers/staging/media/atomisp/pci/system_local.c b/drivers/staging/media/atomisp/pci/system_local.c
index a8a93760d5b10701400c2db7b280bd2117abc07d..88a271208ce7453c1827b48bc0515845d1f9104d 100644
--- a/drivers/staging/media/atomisp/pci/system_local.c
+++ b/drivers/staging/media/atomisp/pci/system_local.c
@@ -7,63 +7,45 @@
 #include "system_local.h"
 
 /* ISP */
-const hrt_address ISP_CTRL_BASE[N_ISP_ID] = {
-	0x0000000000020000ULL
-};
+const hrt_address ISP_CTRL_BASE[N_ISP_ID] = { 0x0000000000020000ULL };
 
-const hrt_address ISP_DMEM_BASE[N_ISP_ID] = {
-	0x0000000000200000ULL
-};
+const hrt_address ISP_DMEM_BASE[N_ISP_ID] = { 0x0000000000200000ULL };
 
-const hrt_address ISP_BAMEM_BASE[N_BAMEM_ID] = {
-	0x0000000000100000ULL
-};
+const hrt_address ISP_BAMEM_BASE[N_BAMEM_ID] = { 0x0000000000100000ULL };
 
 /* SP */
-const hrt_address SP_CTRL_BASE[N_SP_ID] = {
-	0x0000000000010000ULL
-};
+const hrt_address SP_CTRL_BASE[N_SP_ID] = { 0x0000000000010000ULL };
 
-const hrt_address SP_DMEM_BASE[N_SP_ID] = {
-	0x0000000000300000ULL
-};
+const hrt_address SP_DMEM_BASE[N_SP_ID] = { 0x0000000000300000ULL };
 
 /* MMU */
 /*
  * MMU0_ID: The data MMU
  * MMU1_ID: The icache MMU
  */
-const hrt_address MMU_BASE[N_MMU_ID] = {
-	0x0000000000070000ULL,
-	0x00000000000A0000ULL
-};
+const hrt_address MMU_BASE[N_MMU_ID] = { 0x0000000000070000ULL,
+					 0x00000000000A0000ULL };
 
 /* DMA */
-const hrt_address DMA_BASE[N_DMA_ID] = {
-	0x0000000000040000ULL
-};
+const hrt_address DMA_BASE[N_DMA_ID] = { 0x0000000000040000ULL };
 
 const hrt_address ISYS2401_DMA_BASE[N_ISYS2401_DMA_ID] = {
 	0x00000000000CA000ULL
 };
 
 /* IRQ */
-const hrt_address IRQ_BASE[N_IRQ_ID] = {
-	0x0000000000000500ULL,
-	0x0000000000030A00ULL,
-	0x000000000008C000ULL,
-	0x0000000000090200ULL
-};
+const hrt_address IRQ_BASE[N_IRQ_ID] = { 0x0000000000000500ULL,
+					 0x0000000000030A00ULL,
+					 0x000000000008C000ULL,
+					 0x0000000000090200ULL };
 
 /*
 	0x0000000000000500ULL};
  */
 
 /* GDC */
-const hrt_address GDC_BASE[N_GDC_ID] = {
-	0x0000000000050000ULL,
-	0x0000000000060000ULL
-};
+const hrt_address GDC_BASE[N_GDC_ID] = { 0x0000000000050000ULL,
+					 0x0000000000060000ULL };
 
 /* FIFO_MONITOR (not a subset of GP_DEVICE) */
 const hrt_address FIFO_MONITOR_BASE[N_FIFO_MONITOR_ID] = {
@@ -79,31 +61,22 @@ const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
 */
 
 /* GP_DEVICE (single base for all separate GP_REG instances) */
-const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
-	0x0000000000000000ULL
-};
+const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = { 0x0000000000000000ULL };
 
 /*GP TIMER , all timer registers are inter-twined,
  * so, having multiple base addresses for
  * different timers does not help*/
-const hrt_address GP_TIMER_BASE =
-    (hrt_address)0x0000000000000600ULL;
+const hrt_address GP_TIMER_BASE = (hrt_address)0x0000000000000600ULL;
 
 /* GPIO */
-const hrt_address GPIO_BASE[N_GPIO_ID] = {
-	0x0000000000000400ULL
-};
+const hrt_address GPIO_BASE[N_GPIO_ID] = { 0x0000000000000400ULL };
 
 /* TIMED_CTRL */
-const hrt_address TIMED_CTRL_BASE[N_TIMED_CTRL_ID] = {
-	0x0000000000000100ULL
-};
+const hrt_address TIMED_CTRL_BASE[N_TIMED_CTRL_ID] = { 0x0000000000000100ULL };
 
 /* INPUT_FORMATTER */
 const hrt_address INPUT_FORMATTER_BASE[N_INPUT_FORMATTER_ID] = {
-	0x0000000000030000ULL,
-	0x0000000000030200ULL,
-	0x0000000000030400ULL,
+	0x0000000000030000ULL, 0x0000000000030200ULL, 0x0000000000030400ULL,
 	0x0000000000030600ULL
 }; /* memcpy() */
 
@@ -123,48 +96,46 @@ const hrt_address INPUT_SYSTEM_BASE[N_INPUT_SYSTEM_ID] = {
 /*	0x000000000008C000ULL, */ /* IRQ */
 
 /* RX, the MIPI lane control regs start at offset 0 */
-const hrt_address RX_BASE[N_RX_ID] = {
-	0x0000000000080100ULL
-};
+const hrt_address RX_BASE[N_RX_ID] = { 0x0000000000080100ULL };
 
 /* IBUF_CTRL, part of the Input System 2401 */
 const hrt_address IBUF_CTRL_BASE[N_IBUF_CTRL_ID] = {
-	0x00000000000C1800ULL,	/* ibuf controller A */
-	0x00000000000C3800ULL,	/* ibuf controller B */
-	0x00000000000C5800ULL	/* ibuf controller C */
+	0x00000000000C1800ULL, /* ibuf controller A */
+	0x00000000000C3800ULL, /* ibuf controller B */
+	0x00000000000C5800ULL /* ibuf controller C */
 };
 
 /* ISYS IRQ Controllers, part of the Input System 2401 */
 const hrt_address ISYS_IRQ_BASE[N_ISYS_IRQ_ID] = {
-	0x00000000000C1400ULL,	/* port a */
-	0x00000000000C3400ULL,	/* port b */
-	0x00000000000C5400ULL	/* port c */
+	0x00000000000C1400ULL, /* port a */
+	0x00000000000C3400ULL, /* port b */
+	0x00000000000C5400ULL /* port c */
 };
 
 /* CSI FE, part of the Input System 2401 */
 const hrt_address CSI_RX_FE_CTRL_BASE[N_CSI_RX_FRONTEND_ID] = {
-	0x00000000000C0400ULL,	/* csi fe controller A */
-	0x00000000000C2400ULL,	/* csi fe controller B */
-	0x00000000000C4400ULL	/* csi fe controller C */
+	0x00000000000C0400ULL, /* csi fe controller A */
+	0x00000000000C2400ULL, /* csi fe controller B */
+	0x00000000000C4400ULL /* csi fe controller C */
 };
 
 /* CSI BE, part of the Input System 2401 */
 const hrt_address CSI_RX_BE_CTRL_BASE[N_CSI_RX_BACKEND_ID] = {
-	0x00000000000C0800ULL,	/* csi be controller A */
-	0x00000000000C2800ULL,	/* csi be controller B */
-	0x00000000000C4800ULL	/* csi be controller C */
+	0x00000000000C0800ULL, /* csi be controller A */
+	0x00000000000C2800ULL, /* csi be controller B */
+	0x00000000000C4800ULL /* csi be controller C */
 };
 
 /* PIXEL Generator, part of the Input System 2401 */
 const hrt_address PIXELGEN_CTRL_BASE[N_PIXELGEN_ID] = {
-	0x00000000000C1000ULL,	/* pixel gen controller A */
-	0x00000000000C3000ULL,	/* pixel gen controller B */
-	0x00000000000C5000ULL	/* pixel gen controller C */
+	0x00000000000C1000ULL, /* pixel gen controller A */
+	0x00000000000C3000ULL, /* pixel gen controller B */
+	0x00000000000C5000ULL /* pixel gen controller C */
 };
 
 /* Stream2MMIO, part of the Input System 2401 */
 const hrt_address STREAM2MMIO_CTRL_BASE[N_STREAM2MMIO_ID] = {
-	0x00000000000C0C00ULL,	/* stream2mmio controller A */
-	0x00000000000C2C00ULL,	/* stream2mmio controller B */
-	0x00000000000C4C00ULL	/* stream2mmio controller C */
+	0x00000000000C0C00ULL, /* stream2mmio controller A */
+	0x00000000000C2C00ULL, /* stream2mmio controller B */
+	0x00000000000C4C00ULL /* stream2mmio controller C */
 };
diff --git a/drivers/staging/media/atomisp/pci/system_local.h b/drivers/staging/media/atomisp/pci/system_local.h
index 970f4ef990ec9b998e8c1947b8177a187e2339f7..58b9f99bf8bafbbdaa2622e0a2d5665c49fff99e 100644
--- a/drivers/staging/media/atomisp/pci/system_local.h
+++ b/drivers/staging/media/atomisp/pci/system_local.h
@@ -22,7 +22,8 @@
  * Cell specific address maps
  */
 
-#define GP_FIFO_BASE   ((hrt_address)0x0000000000090104)		/* This is NOT a base address */
+#define GP_FIFO_BASE \
+	((hrt_address)0x0000000000090104) /* This is NOT a base address */
 
 /* ISP */
 extern const hrt_address ISP_CTRL_BASE[N_ISP_ID];
diff --git a/drivers/staging/media/atomisp/pci/version.h b/drivers/staging/media/atomisp/pci/version.h
index 90688034c49168b8eb033b98bb4672c90e3583de..2844e8ae7f77cfb267121a7c2d745a7ace8f9b8a 100644
--- a/drivers/staging/media/atomisp/pci/version.h
+++ b/drivers/staging/media/atomisp/pci/version.h
@@ -8,5 +8,5 @@
 #define HRT_VERSION_H
 #define HRT_VERSION_MAJOR 1
 #define HRT_VERSION_MINOR 4
-#define HRT_VERSION 1_4
+#define HRT_VERSION (1_4)
 #endif

---
base-commit: 67a993863163cb88b1b68974c31b0d84ece4293e
change-id: 20250621-bar-573b8b40fb80

Best regards,
-- 
LiangCheng Wang <zaq14760@gmail.com>


